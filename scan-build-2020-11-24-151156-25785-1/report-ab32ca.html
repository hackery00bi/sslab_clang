<!doctype html>
<html>
<head>
<title>../deps/zlib/contrib/optimizations/chunkcopy.h</title>

<style type="text/css">
body { color:#000000; background-color:#ffffff }
body { font-family:Helvetica, sans-serif; font-size:10pt }
h1 { font-size:14pt }
.FileName { margin-top: 5px; margin-bottom: 5px; display: inline; }
.FileNav { margin-left: 5px; margin-right: 5px; display: inline; }
.FileNav a { text-decoration:none; font-size: larger; }
.divider { margin-top: 30px; margin-bottom: 30px; height: 15px; }
.divider { background-color: gray; }
.code { border-collapse:collapse; width:100%; }
.code { font-family: "Monospace", monospace; font-size:10pt }
.code { line-height: 1.2em }
.comment { color: green; font-style: oblique }
.keyword { color: blue }
.string_literal { color: red }
.directive { color: darkmagenta }

/* Macros and variables could have pop-up notes hidden by default.
  - Macro pop-up:    expansion of the macro
  - Variable pop-up: value (table) of the variable */
.macro_popup, .variable_popup { display: none; }

/* Pop-up appears on mouse-hover event. */
.macro:hover .macro_popup, .variable:hover .variable_popup {
  display: block;
  padding: 2px;
  -webkit-border-radius:5px;
  -webkit-box-shadow:1px 1px 7px #000;
  border-radius:5px;
  box-shadow:1px 1px 7px #000;
  position: absolute;
  top: -1em;
  left:10em;
  z-index: 1
}

.macro_popup {
  border: 2px solid red;
  background-color:#FFF0F0;
  font-weight: normal;
}

.variable_popup {
  border: 2px solid blue;
  background-color:#F0F0FF;
  font-weight: bold;
  font-family: Helvetica, sans-serif;
  font-size: 9pt;
}

/* Pop-up notes needs a relative position as a base where they pops up. */
.macro, .variable {
  background-color: PaleGoldenRod;
  position: relative;
}
.macro { color: DarkMagenta; }

#tooltiphint {
  position: fixed;
  width: 50em;
  margin-left: -25em;
  left: 50%;
  padding: 10px;
  border: 1px solid #b0b0b0;
  border-radius: 2px;
  box-shadow: 1px 1px 7px black;
  background-color: #c0c0c0;
  z-index: 2;
}

.num { width:2.5em; padding-right:2ex; background-color:#eeeeee }
.num { text-align:right; font-size:8pt }
.num { color:#444444 }
.line { padding-left: 1ex; border-left: 3px solid #ccc }
.line { white-space: pre }
.msg { -webkit-box-shadow:1px 1px 7px #000 }
.msg { box-shadow:1px 1px 7px #000 }
.msg { -webkit-border-radius:5px }
.msg { border-radius:5px }
.msg { font-family:Helvetica, sans-serif; font-size:8pt }
.msg { float:left }
.msg { padding:0.25em 1ex 0.25em 1ex }
.msg { margin-top:10px; margin-bottom:10px }
.msg { font-weight:bold }
.msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }
.msgT { padding:0x; spacing:0x }
.msgEvent { background-color:#fff8b4; color:#000000 }
.msgControl { background-color:#bbbbbb; color:#000000 }
.msgNote { background-color:#ddeeff; color:#000000 }
.mrange { background-color:#dfddf3 }
.mrange { border-bottom:1px solid #6F9DBE }
.PathIndex { font-weight: bold; padding:0px 5px; margin-right:5px; }
.PathIndex { -webkit-border-radius:8px }
.PathIndex { border-radius:8px }
.PathIndexEvent { background-color:#bfba87 }
.PathIndexControl { background-color:#8c8c8c }
.PathIndexPopUp { background-color: #879abc; }
.PathNav a { text-decoration:none; font-size: larger }
.CodeInsertionHint { font-weight: bold; background-color: #10dd10 }
.CodeRemovalHint { background-color:#de1010 }
.CodeRemovalHint { border-bottom:1px solid #6F9DBE }
.selected{ background-color:orange !important; }

table.simpletable {
  padding: 5px;
  font-size:12pt;
  margin:20px;
  border-collapse: collapse; border-spacing: 0px;
}
td.rowname {
  text-align: right;
  vertical-align: top;
  font-weight: bold;
  color:#444444;
  padding-right:2ex;
}

/* Hidden text. */
input.spoilerhider + label {
  cursor: pointer;
  text-decoration: underline;
  display: block;
}
input.spoilerhider {
 display: none;
}
input.spoilerhider ~ .spoiler {
  overflow: hidden;
  margin: 10px auto 0;
  height: 0;
  opacity: 0;
}
input.spoilerhider:checked + label + .spoiler{
  height: auto;
  opacity: 1;
}
</style>
</head>
<body>
<!-- BUGDESC Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 -->

<!-- BUGTYPE Potential insecure memory buffer bounds restriction in call 'memcpy' -->

<!-- BUGCATEGORY Security -->

<!-- BUGFILE /tmp/sslab_clang/cpp_node/node/out/../deps/zlib/contrib/optimizations/chunkcopy.h -->

<!-- FILENAME chunkcopy.h -->

<!-- FUNCTIONNAME read64le -->

<!-- ISSUEHASHCONTENTOFLINEINCONTEXT ac751d4c383adc71b4d6235d8c2e34f2 -->

<!-- BUGLINE 430 -->

<!-- BUGCOLUMN 5 -->

<!-- BUGPATHLENGTH 1 -->

<!-- BUGMETAEND -->
<!-- REPORTHEADER -->
<h3>Bug Summary</h3>
<table class="simpletable">
<tr><td class="rowname">File:</td><td>/tmp/sslab_clang/cpp_node/node/out/../deps/zlib/contrib/optimizations/chunkcopy.h</td></tr>
<tr><td class="rowname">Warning:</td><td><a href="#EndPath">line 430, column 5</a><br />Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11</td></tr>

</table>
<!-- REPORTSUMMARYEXTRA -->
<h3>Annotated Source Code</h3>
<p>Press <a href="#" onclick="toggleHelp(); return false;">'?'</a>
   to see keyboard shortcuts</p>
<input type="checkbox" class="spoilerhider" id="showinvocation" />
<label for="showinvocation" >Show analyzer invocation</label>
<div class="spoiler">clang -cc1 -cc1 -triple x86_64-unknown-linux-gnu -analyze -disable-free -main-file-name inffast_chunk.c -analyzer-store=region -analyzer-opt-analyze-nested-blocks -analyzer-checker=core -analyzer-checker=apiModeling -analyzer-checker=unix -analyzer-checker=deadcode -analyzer-checker=security.insecureAPI.UncheckedReturn -analyzer-checker=security.insecureAPI.getpw -analyzer-checker=security.insecureAPI.gets -analyzer-checker=security.insecureAPI.mktemp -analyzer-checker=security.insecureAPI.mkstemp -analyzer-checker=security.insecureAPI.vfork -analyzer-checker=nullability.NullPassedToNonnull -analyzer-checker=nullability.NullReturnedFromNonnull -analyzer-output plist -w -setup-static-analyzer -mrelocation-model static -mframe-pointer=all -fmath-errno -fno-rounding-math -mconstructor-aliases -munwind-tables -target-cpu x86-64 -fno-split-dwarf-inlining -debugger-tuning=gdb -resource-dir /llvm-project/build/lib/clang/12.0.0 -D V8_DEPRECATION_WARNINGS -D V8_IMMINENT_DEPRECATION_WARNINGS -D __STDC_FORMAT_MACROS -D OPENSSL_NO_PINSHARED -D OPENSSL_THREADS -D HAVE_HIDDEN -D ADLER32_SIMD_SSSE3 -D INFLATE_CHUNK_SIMD_SSE2 -D CRC32_SIMD_SSE42_PCLMUL -D INFLATE_CHUNK_READ_64LE -I ../deps/zlib -internal-isystem /usr/local/include -internal-isystem /llvm-project/build/lib/clang/12.0.0/include -internal-externc-isystem /usr/include/x86_64-linux-gnu -internal-externc-isystem /include -internal-externc-isystem /usr/include -O3 -Wno-unused-parameter -fdebug-compilation-dir /tmp/sslab_clang/cpp_node/node/out -ferror-limit 19 -fgnuc-version=4.2.1 -vectorize-loops -vectorize-slp -analyzer-checker core -analyzer-checker cplusplus -analyzer-checker nullability -analyzer-checker optin -analyzer-checker security -analyzer-checker unix -analyzer-checker osx -analyzer-checker fuchsia -analyzer-checker webkit -analyzer-output=html -faddrsig -o /tmp/scan-build-2020-11-24-151156-25785-1 -x c ../deps/zlib/contrib/optimizations/inffast_chunk.c
</div>
<div id='tooltiphint' hidden="true">
  <p>Keyboard shortcuts: </p>
  <ul>
    <li>Use 'j/k' keys for keyboard navigation</li>
    <li>Use 'Shift+S' to show/hide relevant lines</li>
    <li>Use '?' to toggle this window</li>
  </ul>
  <a href="#" onclick="toggleHelp(); return false;">Close</a>
</div>
<script type='text/javascript'>
var relevant_lines = {"1662": {"430": 1}};

var filterCounterexample = function (hide) {
  var tables = document.getElementsByClassName("code");
  for (var t=0; t<tables.length; t++) {
    var table = tables[t];
    var file_id = table.getAttribute("data-fileid");
    var lines_in_fid = relevant_lines[file_id];
    if (!lines_in_fid) {
      lines_in_fid = {};
    }
    var lines = table.getElementsByClassName("codeline");
    for (var i=0; i<lines.length; i++) {
        var el = lines[i];
        var lineNo = el.getAttribute("data-linenumber");
        if (!lines_in_fid[lineNo]) {
          if (hide) {
            el.setAttribute("hidden", "");
          } else {
            el.removeAttribute("hidden");
          }
        }
    }
  }
}

window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.key == "S") {
    var checked = document.getElementsByName("showCounterexample")[0].checked;
    filterCounterexample(!checked);
    document.getElementsByName("showCounterexample")[0].checked = !checked;
  } else {
    return;
  }
  event.preventDefault();
}, true);

document.addEventListener("DOMContentLoaded", function() {
    document.querySelector('input[name="showCounterexample"]').onchange=
        function (event) {
      filterCounterexample(this.checked);
    };
});
</script>

<form>
    <input type="checkbox" name="showCounterexample" id="showCounterexample" />
    <label for="showCounterexample">
       Show only relevant lines
    </label>
</form>

<script type='text/javascript'>
var digitMatcher = new RegExp("[0-9]+");

var querySelectorAllArray = function(selector) {
  return Array.prototype.slice.call(
    document.querySelectorAll(selector));
}

document.addEventListener("DOMContentLoaded", function() {
    querySelectorAllArray(".PathNav > a").forEach(
        function(currentValue, currentIndex) {
            var hrefValue = currentValue.getAttribute("href");
            currentValue.onclick = function() {
                scrollTo(document.querySelector(hrefValue));
                return false;
            };
        });
});

var findNum = function() {
    var s = document.querySelector(".selected");
    if (!s || s.id == "EndPath") {
        return 0;
    }
    var out = parseInt(digitMatcher.exec(s.id)[0]);
    return out;
};

var scrollTo = function(el) {
    querySelectorAllArray(".selected").forEach(function(s) {
        s.classList.remove("selected");
    });
    el.classList.add("selected");
    window.scrollBy(0, el.getBoundingClientRect().top -
        (window.innerHeight / 2));
}

var move = function(num, up, numItems) {
  if (num == 1 && up || num == numItems - 1 && !up) {
    return 0;
  } else if (num == 0 && up) {
    return numItems - 1;
  } else if (num == 0 && !up) {
    return 1 % numItems;
  }
  return up ? num - 1 : num + 1;
}

var numToId = function(num) {
  if (num == 0) {
    return document.getElementById("EndPath")
  }
  return document.getElementById("Path" + num);
};

var navigateTo = function(up) {
  var numItems = document.querySelectorAll(
      ".line > .msgEvent, .line > .msgControl").length;
  var currentSelected = findNum();
  var newSelected = move(currentSelected, up, numItems);
  var newEl = numToId(newSelected, numItems);

  // Scroll element into center.
  scrollTo(newEl);
};

window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.key == "j") {
    navigateTo(/*up=*/false);
  } else if (event.key == "k") {
    navigateTo(/*up=*/true);
  } else {
    return;
  }
  event.preventDefault();
}, true);
</script>
  
<script type='text/javascript'>

var toggleHelp = function() {
    var hint = document.querySelector("#tooltiphint");
    var attributeName = "hidden";
    if (hint.hasAttribute(attributeName)) {
      hint.removeAttribute(attributeName);
    } else {
      hint.setAttribute("hidden", "true");
    }
};
window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.key == "?") {
    toggleHelp();
  } else {
    return;
  }
  event.preventDefault();
});
</script>
<table class="code" data-fileid="1662">
<tr class="codeline" data-linenumber="1"><td class="num" id="LN1">1</td><td class="line"><span class='comment'>/* chunkcopy.h -- fast chunk copy and set operations</span></td></tr>
<tr class="codeline" data-linenumber="2"><td class="num" id="LN2">2</td><td class="line"> <span class='comment'>* Copyright (C) 2017 ARM, Inc.</span></td></tr>
<tr class="codeline" data-linenumber="3"><td class="num" id="LN3">3</td><td class="line"> <span class='comment'>* Copyright 2017 The Chromium Authors. All rights reserved.</span></td></tr>
<tr class="codeline" data-linenumber="4"><td class="num" id="LN4">4</td><td class="line"> <span class='comment'>* Use of this source code is governed by a BSD-style license that can be</span></td></tr>
<tr class="codeline" data-linenumber="5"><td class="num" id="LN5">5</td><td class="line"> <span class='comment'>* found in the Chromium source repository LICENSE file.</span></td></tr>
<tr class="codeline" data-linenumber="6"><td class="num" id="LN6">6</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="7"><td class="num" id="LN7">7</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="8"><td class="num" id="LN8">8</td><td class="line"><span class='directive'>#ifndef CHUNKCOPY_H</span></td></tr>
<tr class="codeline" data-linenumber="9"><td class="num" id="LN9">9</td><td class="line"><span class='directive'>#define CHUNKCOPY_H</span></td></tr>
<tr class="codeline" data-linenumber="10"><td class="num" id="LN10">10</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="11"><td class="num" id="LN11">11</td><td class="line"><span class='directive'>#include &lt;stdint.h&gt;</span></td></tr>
<tr class="codeline" data-linenumber="12"><td class="num" id="LN12">12</td><td class="line"><span class='directive'>#include "zutil.h"</span></td></tr>
<tr class="codeline" data-linenumber="13"><td class="num" id="LN13">13</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="14"><td class="num" id="LN14">14</td><td class="line"><span class='directive'>#define Z_STATIC_ASSERT(name, assert) typedef char name[(assert) ? 1 : -1]</span></td></tr>
<tr class="codeline" data-linenumber="15"><td class="num" id="LN15">15</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="16"><td class="num" id="LN16">16</td><td class="line"><span class='directive'>#if <span class='macro'>__STDC_VERSION__<span class='macro_popup'>201710L</span></span> &gt;= 199901L</span></td></tr>
<tr class="codeline" data-linenumber="17"><td class="num" id="LN17">17</td><td class="line"><span class='directive'>#define Z_RESTRICT restrict</span></td></tr>
<tr class="codeline" data-linenumber="18"><td class="num" id="LN18">18</td><td class="line"><span class='directive'>#else</span></td></tr>
<tr class="codeline" data-linenumber="19"><td class="num" id="LN19">19</td><td class="line"><span class='directive'>#define Z_RESTRICT</span></td></tr>
<tr class="codeline" data-linenumber="20"><td class="num" id="LN20">20</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="21"><td class="num" id="LN21">21</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="22"><td class="num" id="LN22">22</td><td class="line"><span class='directive'>#if defined(<span class='macro'>__clang__<span class='macro_popup'>1</span></span>) || defined(<span class='macro'>__GNUC__<span class='macro_popup'>4</span></span>) || defined(<span class='macro'>__llvm__<span class='macro_popup'>1</span></span>)</span></td></tr>
<tr class="codeline" data-linenumber="23"><td class="num" id="LN23">23</td><td class="line"><span class='directive'>#define Z_BUILTIN_MEMCPY __builtin_memcpy</span></td></tr>
<tr class="codeline" data-linenumber="24"><td class="num" id="LN24">24</td><td class="line"><span class='directive'>#else</span></td></tr>
<tr class="codeline" data-linenumber="25"><td class="num" id="LN25">25</td><td class="line"><span class='directive'>#define Z_BUILTIN_MEMCPY <span class='macro'>zmemcpy<span class='macro_popup'>memcpy</span></span></span></td></tr>
<tr class="codeline" data-linenumber="26"><td class="num" id="LN26">26</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="27"><td class="num" id="LN27">27</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="28"><td class="num" id="LN28">28</td><td class="line"><span class='directive'>#if defined(INFLATE_CHUNK_SIMD_NEON)</span></td></tr>
<tr class="codeline" data-linenumber="29"><td class="num" id="LN29">29</td><td class="line"><span class='directive'>#include &lt;arm_neon.h&gt;</span></td></tr>
<tr class="codeline" data-linenumber="30"><td class="num" id="LN30">30</td><td class="line"><span class='keyword'>typedef</span> uint8x16_t z_vec128i_t;</td></tr>
<tr class="codeline" data-linenumber="31"><td class="num" id="LN31">31</td><td class="line"><span class='directive'>#elif defined(<span class='macro'>INFLATE_CHUNK_SIMD_SSE2<span class='macro_popup'>1</span></span>)</span></td></tr>
<tr class="codeline" data-linenumber="32"><td class="num" id="LN32">32</td><td class="line"><span class='directive'>#pragma GCC target ("sse2")</span></td></tr>
<tr class="codeline" data-linenumber="33"><td class="num" id="LN33">33</td><td class="line"><span class='directive'>#include &lt;emmintrin.h&gt;</span></td></tr>
<tr class="codeline" data-linenumber="34"><td class="num" id="LN34">34</td><td class="line"><span class='keyword'>typedef</span> __m128i z_vec128i_t;</td></tr>
<tr class="codeline" data-linenumber="35"><td class="num" id="LN35">35</td><td class="line"><span class='directive'>#else</span></td></tr>
<tr class="codeline" data-linenumber="36"><td class="num" id="LN36">36</td><td class="line"><span class='directive'>#error chunkcopy.h inflate chunk SIMD is not defined for your build target</span></td></tr>
<tr class="codeline" data-linenumber="37"><td class="num" id="LN37">37</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="38"><td class="num" id="LN38">38</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="39"><td class="num" id="LN39">39</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="40"><td class="num" id="LN40">40</td><td class="line"> <span class='comment'>* chunk copy type: the z_vec128i_t type size should be exactly 128-bits</span></td></tr>
<tr class="codeline" data-linenumber="41"><td class="num" id="LN41">41</td><td class="line"> <span class='comment'>* and equal to CHUNKCOPY_CHUNK_SIZE.</span></td></tr>
<tr class="codeline" data-linenumber="42"><td class="num" id="LN42">42</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="43"><td class="num" id="LN43">43</td><td class="line"><span class='directive'>#define <span class='macro'>CHUNKCOPY_CHUNK_SIZE<span class='macro_popup'>sizeof(z_vec128i_t)</span></span> sizeof(z_vec128i_t)</span></td></tr>
<tr class="codeline" data-linenumber="44"><td class="num" id="LN44">44</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="45"><td class="num" id="LN45">45</td><td class="line">Z_STATIC_ASSERT(vector_128_bits_wide,</td></tr>
<tr class="codeline" data-linenumber="46"><td class="num" id="LN46">46</td><td class="line">                <span class='macro'>CHUNKCOPY_CHUNK_SIZE<span class='macro_popup'>sizeof(z_vec128i_t)</span></span> == <span class='keyword'>sizeof</span>(int8_t) * 16);</td></tr>
<tr class="codeline" data-linenumber="47"><td class="num" id="LN47">47</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="48"><td class="num" id="LN48">48</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="49"><td class="num" id="LN49">49</td><td class="line"> <span class='comment'>* Ask the compiler to perform a wide, unaligned load with a machine</span></td></tr>
<tr class="codeline" data-linenumber="50"><td class="num" id="LN50">50</td><td class="line"> <span class='comment'>* instruction appropriate for the z_vec128i_t type.</span></td></tr>
<tr class="codeline" data-linenumber="51"><td class="num" id="LN51">51</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="52"><td class="num" id="LN52">52</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>inline</span> z_vec128i_t loadchunk(</td></tr>
<tr class="codeline" data-linenumber="53"><td class="num" id="LN53">53</td><td class="line">    <span class='keyword'>const</span> <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* s) {</td></tr>
<tr class="codeline" data-linenumber="54"><td class="num" id="LN54">54</td><td class="line">  z_vec128i_t v;</td></tr>
<tr class="codeline" data-linenumber="55"><td class="num" id="LN55">55</td><td class="line">  Z_BUILTIN_MEMCPY(&amp;v, s, <span class='keyword'>sizeof</span>(v));</td></tr>
<tr class="codeline" data-linenumber="56"><td class="num" id="LN56">56</td><td class="line">  <span class='keyword'>return</span> v;</td></tr>
<tr class="codeline" data-linenumber="57"><td class="num" id="LN57">57</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="58"><td class="num" id="LN58">58</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="59"><td class="num" id="LN59">59</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="60"><td class="num" id="LN60">60</td><td class="line"> <span class='comment'>* Ask the compiler to perform a wide, unaligned store with a machine</span></td></tr>
<tr class="codeline" data-linenumber="61"><td class="num" id="LN61">61</td><td class="line"> <span class='comment'>* instruction appropriate for the z_vec128i_t type.</span></td></tr>
<tr class="codeline" data-linenumber="62"><td class="num" id="LN62">62</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="63"><td class="num" id="LN63">63</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>inline</span> <span class='keyword'>void</span> storechunk(</td></tr>
<tr class="codeline" data-linenumber="64"><td class="num" id="LN64">64</td><td class="line">    <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* d,</td></tr>
<tr class="codeline" data-linenumber="65"><td class="num" id="LN65">65</td><td class="line">    <span class='keyword'>const</span> z_vec128i_t v) {</td></tr>
<tr class="codeline" data-linenumber="66"><td class="num" id="LN66">66</td><td class="line">  Z_BUILTIN_MEMCPY(d, &amp;v, <span class='keyword'>sizeof</span>(v));</td></tr>
<tr class="codeline" data-linenumber="67"><td class="num" id="LN67">67</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="68"><td class="num" id="LN68">68</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="69"><td class="num" id="LN69">69</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="70"><td class="num" id="LN70">70</td><td class="line"> <span class='comment'>* Perform a memcpy-like operation, assuming that length is non-zero and that</span></td></tr>
<tr class="codeline" data-linenumber="71"><td class="num" id="LN71">71</td><td class="line"> <span class='comment'>* it's OK to overwrite at least CHUNKCOPY_CHUNK_SIZE bytes of output even if</span></td></tr>
<tr class="codeline" data-linenumber="72"><td class="num" id="LN72">72</td><td class="line"> <span class='comment'>* the length is shorter than this.</span></td></tr>
<tr class="codeline" data-linenumber="73"><td class="num" id="LN73">73</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="74"><td class="num" id="LN74">74</td><td class="line"> <span class='comment'>* It also guarantees that it will properly unroll the data if the distance</span></td></tr>
<tr class="codeline" data-linenumber="75"><td class="num" id="LN75">75</td><td class="line"> <span class='comment'>* between `out` and `from` is at least CHUNKCOPY_CHUNK_SIZE, which we rely on</span></td></tr>
<tr class="codeline" data-linenumber="76"><td class="num" id="LN76">76</td><td class="line"> <span class='comment'>* in chunkcopy_relaxed().</span></td></tr>
<tr class="codeline" data-linenumber="77"><td class="num" id="LN77">77</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="78"><td class="num" id="LN78">78</td><td class="line"> <span class='comment'>* Aside from better memory bus utilisation, this means that short copies</span></td></tr>
<tr class="codeline" data-linenumber="79"><td class="num" id="LN79">79</td><td class="line"> <span class='comment'>* (CHUNKCOPY_CHUNK_SIZE bytes or fewer) will fall straight through the loop</span></td></tr>
<tr class="codeline" data-linenumber="80"><td class="num" id="LN80">80</td><td class="line"> <span class='comment'>* without iteration, which will hopefully make the branch prediction more</span></td></tr>
<tr class="codeline" data-linenumber="81"><td class="num" id="LN81">81</td><td class="line"> <span class='comment'>* reliable.</span></td></tr>
<tr class="codeline" data-linenumber="82"><td class="num" id="LN82">82</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="83"><td class="num" id="LN83">83</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>inline</span> <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* chunkcopy_core(</td></tr>
<tr class="codeline" data-linenumber="84"><td class="num" id="LN84">84</td><td class="line">    <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* out,</td></tr>
<tr class="codeline" data-linenumber="85"><td class="num" id="LN85">85</td><td class="line">    <span class='keyword'>const</span> <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* from,</td></tr>
<tr class="codeline" data-linenumber="86"><td class="num" id="LN86">86</td><td class="line">    <span class='keyword'>unsigned</span> len) {</td></tr>
<tr class="codeline" data-linenumber="87"><td class="num" id="LN87">87</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>int</span> bump = (--len % <span class='macro'>CHUNKCOPY_CHUNK_SIZE<span class='macro_popup'>sizeof(z_vec128i_t)</span></span>) + 1;</td></tr>
<tr class="codeline" data-linenumber="88"><td class="num" id="LN88">88</td><td class="line">  storechunk(out, loadchunk(from));</td></tr>
<tr class="codeline" data-linenumber="89"><td class="num" id="LN89">89</td><td class="line">  out += bump;</td></tr>
<tr class="codeline" data-linenumber="90"><td class="num" id="LN90">90</td><td class="line">  from += bump;</td></tr>
<tr class="codeline" data-linenumber="91"><td class="num" id="LN91">91</td><td class="line">  len /= <span class='macro'>CHUNKCOPY_CHUNK_SIZE<span class='macro_popup'>sizeof(z_vec128i_t)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="92"><td class="num" id="LN92">92</td><td class="line">  <span class='keyword'>while</span> (len-- &gt; 0) {</td></tr>
<tr class="codeline" data-linenumber="93"><td class="num" id="LN93">93</td><td class="line">    storechunk(out, loadchunk(from));</td></tr>
<tr class="codeline" data-linenumber="94"><td class="num" id="LN94">94</td><td class="line">    out += <span class='macro'>CHUNKCOPY_CHUNK_SIZE<span class='macro_popup'>sizeof(z_vec128i_t)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="95"><td class="num" id="LN95">95</td><td class="line">    from += <span class='macro'>CHUNKCOPY_CHUNK_SIZE<span class='macro_popup'>sizeof(z_vec128i_t)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="96"><td class="num" id="LN96">96</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="97"><td class="num" id="LN97">97</td><td class="line">  <span class='keyword'>return</span> out;</td></tr>
<tr class="codeline" data-linenumber="98"><td class="num" id="LN98">98</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="99"><td class="num" id="LN99">99</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="100"><td class="num" id="LN100">100</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="101"><td class="num" id="LN101">101</td><td class="line"> <span class='comment'>* Like chunkcopy_core(), but avoid writing beyond of legal output.</span></td></tr>
<tr class="codeline" data-linenumber="102"><td class="num" id="LN102">102</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="103"><td class="num" id="LN103">103</td><td class="line"> <span class='comment'>* Accepts an additional pointer to the end of safe output.  A generic safe</span></td></tr>
<tr class="codeline" data-linenumber="104"><td class="num" id="LN104">104</td><td class="line"> <span class='comment'>* copy would use (out + len), but it's normally the case that the end of the</span></td></tr>
<tr class="codeline" data-linenumber="105"><td class="num" id="LN105">105</td><td class="line"> <span class='comment'>* output buffer is beyond the end of the current copy, and this can still be</span></td></tr>
<tr class="codeline" data-linenumber="106"><td class="num" id="LN106">106</td><td class="line"> <span class='comment'>* exploited.</span></td></tr>
<tr class="codeline" data-linenumber="107"><td class="num" id="LN107">107</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="108"><td class="num" id="LN108">108</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>inline</span> <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* chunkcopy_core_safe(</td></tr>
<tr class="codeline" data-linenumber="109"><td class="num" id="LN109">109</td><td class="line">    <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* out,</td></tr>
<tr class="codeline" data-linenumber="110"><td class="num" id="LN110">110</td><td class="line">    <span class='keyword'>const</span> <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* from,</td></tr>
<tr class="codeline" data-linenumber="111"><td class="num" id="LN111">111</td><td class="line">    <span class='keyword'>unsigned</span> len,</td></tr>
<tr class="codeline" data-linenumber="112"><td class="num" id="LN112">112</td><td class="line">    <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* limit) {</td></tr>
<tr class="codeline" data-linenumber="113"><td class="num" id="LN113">113</td><td class="line">  Assert(out + len &lt;= limit, <span class='string_literal'>"chunk copy exceeds safety limit"</span>);</td></tr>
<tr class="codeline" data-linenumber="114"><td class="num" id="LN114">114</td><td class="line">  <span class='keyword'>if</span> ((limit - out) &lt; (ptrdiff_t)<span class='macro'>CHUNKCOPY_CHUNK_SIZE<span class='macro_popup'>sizeof(z_vec128i_t)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="115"><td class="num" id="LN115">115</td><td class="line">    <span class='keyword'>const</span> <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* Z_RESTRICT rfrom = from;</td></tr>
<tr class="codeline" data-linenumber="116"><td class="num" id="LN116">116</td><td class="line">    <span class='keyword'>if</span> (len &amp; 8) {</td></tr>
<tr class="codeline" data-linenumber="117"><td class="num" id="LN117">117</td><td class="line">      Z_BUILTIN_MEMCPY(out, rfrom, 8);</td></tr>
<tr class="codeline" data-linenumber="118"><td class="num" id="LN118">118</td><td class="line">      out += 8;</td></tr>
<tr class="codeline" data-linenumber="119"><td class="num" id="LN119">119</td><td class="line">      rfrom += 8;</td></tr>
<tr class="codeline" data-linenumber="120"><td class="num" id="LN120">120</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="121"><td class="num" id="LN121">121</td><td class="line">    <span class='keyword'>if</span> (len &amp; 4) {</td></tr>
<tr class="codeline" data-linenumber="122"><td class="num" id="LN122">122</td><td class="line">      Z_BUILTIN_MEMCPY(out, rfrom, 4);</td></tr>
<tr class="codeline" data-linenumber="123"><td class="num" id="LN123">123</td><td class="line">      out += 4;</td></tr>
<tr class="codeline" data-linenumber="124"><td class="num" id="LN124">124</td><td class="line">      rfrom += 4;</td></tr>
<tr class="codeline" data-linenumber="125"><td class="num" id="LN125">125</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="126"><td class="num" id="LN126">126</td><td class="line">    <span class='keyword'>if</span> (len &amp; 2) {</td></tr>
<tr class="codeline" data-linenumber="127"><td class="num" id="LN127">127</td><td class="line">      Z_BUILTIN_MEMCPY(out, rfrom, 2);</td></tr>
<tr class="codeline" data-linenumber="128"><td class="num" id="LN128">128</td><td class="line">      out += 2;</td></tr>
<tr class="codeline" data-linenumber="129"><td class="num" id="LN129">129</td><td class="line">      rfrom += 2;</td></tr>
<tr class="codeline" data-linenumber="130"><td class="num" id="LN130">130</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="131"><td class="num" id="LN131">131</td><td class="line">    <span class='keyword'>if</span> (len &amp; 1) {</td></tr>
<tr class="codeline" data-linenumber="132"><td class="num" id="LN132">132</td><td class="line">      *out++ = *rfrom++;</td></tr>
<tr class="codeline" data-linenumber="133"><td class="num" id="LN133">133</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="134"><td class="num" id="LN134">134</td><td class="line">    <span class='keyword'>return</span> out;</td></tr>
<tr class="codeline" data-linenumber="135"><td class="num" id="LN135">135</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="136"><td class="num" id="LN136">136</td><td class="line">  <span class='keyword'>return</span> chunkcopy_core(out, from, len);</td></tr>
<tr class="codeline" data-linenumber="137"><td class="num" id="LN137">137</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="138"><td class="num" id="LN138">138</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="139"><td class="num" id="LN139">139</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="140"><td class="num" id="LN140">140</td><td class="line"> <span class='comment'>* Perform short copies until distance can be rewritten as being at least</span></td></tr>
<tr class="codeline" data-linenumber="141"><td class="num" id="LN141">141</td><td class="line"> <span class='comment'>* CHUNKCOPY_CHUNK_SIZE.</span></td></tr>
<tr class="codeline" data-linenumber="142"><td class="num" id="LN142">142</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="143"><td class="num" id="LN143">143</td><td class="line"> <span class='comment'>* Assumes it's OK to overwrite at least the first 2*CHUNKCOPY_CHUNK_SIZE</span></td></tr>
<tr class="codeline" data-linenumber="144"><td class="num" id="LN144">144</td><td class="line"> <span class='comment'>* bytes of output even if the copy is shorter than this.  This assumption</span></td></tr>
<tr class="codeline" data-linenumber="145"><td class="num" id="LN145">145</td><td class="line"> <span class='comment'>* holds within zlib inflate_fast(), which starts every iteration with at</span></td></tr>
<tr class="codeline" data-linenumber="146"><td class="num" id="LN146">146</td><td class="line"> <span class='comment'>* least 258 bytes of output space available (258 being the maximum length</span></td></tr>
<tr class="codeline" data-linenumber="147"><td class="num" id="LN147">147</td><td class="line"> <span class='comment'>* output from a single token; see inffast.c).</span></td></tr>
<tr class="codeline" data-linenumber="148"><td class="num" id="LN148">148</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="149"><td class="num" id="LN149">149</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>inline</span> <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* chunkunroll_relaxed(</td></tr>
<tr class="codeline" data-linenumber="150"><td class="num" id="LN150">150</td><td class="line">    <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* out,</td></tr>
<tr class="codeline" data-linenumber="151"><td class="num" id="LN151">151</td><td class="line">    <span class='keyword'>unsigned</span> FAR* dist,</td></tr>
<tr class="codeline" data-linenumber="152"><td class="num" id="LN152">152</td><td class="line">    <span class='keyword'>unsigned</span> FAR* len) {</td></tr>
<tr class="codeline" data-linenumber="153"><td class="num" id="LN153">153</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* from = out - *dist;</td></tr>
<tr class="codeline" data-linenumber="154"><td class="num" id="LN154">154</td><td class="line">  <span class='keyword'>while</span> (*dist &lt; *len &amp;&amp; *dist &lt; <span class='macro'>CHUNKCOPY_CHUNK_SIZE<span class='macro_popup'>sizeof(z_vec128i_t)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="155"><td class="num" id="LN155">155</td><td class="line">    storechunk(out, loadchunk(from));</td></tr>
<tr class="codeline" data-linenumber="156"><td class="num" id="LN156">156</td><td class="line">    out += *dist;</td></tr>
<tr class="codeline" data-linenumber="157"><td class="num" id="LN157">157</td><td class="line">    *len -= *dist;</td></tr>
<tr class="codeline" data-linenumber="158"><td class="num" id="LN158">158</td><td class="line">    *dist += *dist;</td></tr>
<tr class="codeline" data-linenumber="159"><td class="num" id="LN159">159</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="160"><td class="num" id="LN160">160</td><td class="line">  <span class='keyword'>return</span> out;</td></tr>
<tr class="codeline" data-linenumber="161"><td class="num" id="LN161">161</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="162"><td class="num" id="LN162">162</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="163"><td class="num" id="LN163">163</td><td class="line"><span class='directive'>#if defined(INFLATE_CHUNK_SIMD_NEON)</span></td></tr>
<tr class="codeline" data-linenumber="164"><td class="num" id="LN164">164</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="165"><td class="num" id="LN165">165</td><td class="line"> <span class='comment'>* v_load64_dup(): load *src as an unaligned 64-bit int and duplicate it in</span></td></tr>
<tr class="codeline" data-linenumber="166"><td class="num" id="LN166">166</td><td class="line"> <span class='comment'>* every 64-bit component of the 128-bit result (64-bit int splat).</span></td></tr>
<tr class="codeline" data-linenumber="167"><td class="num" id="LN167">167</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="168"><td class="num" id="LN168">168</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>inline</span> z_vec128i_t v_load64_dup(<span class='keyword'>const</span> <span class='keyword'>void</span>* src) {</td></tr>
<tr class="codeline" data-linenumber="169"><td class="num" id="LN169">169</td><td class="line">  <span class='keyword'>return</span> vcombine_u8(vld1_u8(src), vld1_u8(src));</td></tr>
<tr class="codeline" data-linenumber="170"><td class="num" id="LN170">170</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="171"><td class="num" id="LN171">171</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="172"><td class="num" id="LN172">172</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="173"><td class="num" id="LN173">173</td><td class="line"> <span class='comment'>* v_load32_dup(): load *src as an unaligned 32-bit int and duplicate it in</span></td></tr>
<tr class="codeline" data-linenumber="174"><td class="num" id="LN174">174</td><td class="line"> <span class='comment'>* every 32-bit component of the 128-bit result (32-bit int splat).</span></td></tr>
<tr class="codeline" data-linenumber="175"><td class="num" id="LN175">175</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="176"><td class="num" id="LN176">176</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>inline</span> z_vec128i_t v_load32_dup(<span class='keyword'>const</span> <span class='keyword'>void</span>* src) {</td></tr>
<tr class="codeline" data-linenumber="177"><td class="num" id="LN177">177</td><td class="line">  int32_t i32;</td></tr>
<tr class="codeline" data-linenumber="178"><td class="num" id="LN178">178</td><td class="line">  Z_BUILTIN_MEMCPY(&amp;i32, src, <span class='keyword'>sizeof</span>(i32));</td></tr>
<tr class="codeline" data-linenumber="179"><td class="num" id="LN179">179</td><td class="line">  <span class='keyword'>return</span> vreinterpretq_u8_s32(vdupq_n_s32(i32));</td></tr>
<tr class="codeline" data-linenumber="180"><td class="num" id="LN180">180</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="181"><td class="num" id="LN181">181</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="182"><td class="num" id="LN182">182</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="183"><td class="num" id="LN183">183</td><td class="line"> <span class='comment'>* v_load16_dup(): load *src as an unaligned 16-bit int and duplicate it in</span></td></tr>
<tr class="codeline" data-linenumber="184"><td class="num" id="LN184">184</td><td class="line"> <span class='comment'>* every 16-bit component of the 128-bit result (16-bit int splat).</span></td></tr>
<tr class="codeline" data-linenumber="185"><td class="num" id="LN185">185</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="186"><td class="num" id="LN186">186</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>inline</span> z_vec128i_t v_load16_dup(<span class='keyword'>const</span> <span class='keyword'>void</span>* src) {</td></tr>
<tr class="codeline" data-linenumber="187"><td class="num" id="LN187">187</td><td class="line">  int16_t i16;</td></tr>
<tr class="codeline" data-linenumber="188"><td class="num" id="LN188">188</td><td class="line">  Z_BUILTIN_MEMCPY(&amp;i16, src, <span class='keyword'>sizeof</span>(i16));</td></tr>
<tr class="codeline" data-linenumber="189"><td class="num" id="LN189">189</td><td class="line">  <span class='keyword'>return</span> vreinterpretq_u8_s16(vdupq_n_s16(i16));</td></tr>
<tr class="codeline" data-linenumber="190"><td class="num" id="LN190">190</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="191"><td class="num" id="LN191">191</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="192"><td class="num" id="LN192">192</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="193"><td class="num" id="LN193">193</td><td class="line"> <span class='comment'>* v_load8_dup(): load the 8-bit int *src and duplicate it in every 8-bit</span></td></tr>
<tr class="codeline" data-linenumber="194"><td class="num" id="LN194">194</td><td class="line"> <span class='comment'>* component of the 128-bit result (8-bit int splat).</span></td></tr>
<tr class="codeline" data-linenumber="195"><td class="num" id="LN195">195</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="196"><td class="num" id="LN196">196</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>inline</span> z_vec128i_t v_load8_dup(<span class='keyword'>const</span> <span class='keyword'>void</span>* src) {</td></tr>
<tr class="codeline" data-linenumber="197"><td class="num" id="LN197">197</td><td class="line">  <span class='keyword'>return</span> vld1q_dup_u8((<span class='keyword'>const</span> uint8_t*)src);</td></tr>
<tr class="codeline" data-linenumber="198"><td class="num" id="LN198">198</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="199"><td class="num" id="LN199">199</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="200"><td class="num" id="LN200">200</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="201"><td class="num" id="LN201">201</td><td class="line"> <span class='comment'>* v_store_128(): store the 128-bit vec in a memory destination (that might</span></td></tr>
<tr class="codeline" data-linenumber="202"><td class="num" id="LN202">202</td><td class="line"> <span class='comment'>* not be 16-byte aligned) void* out.</span></td></tr>
<tr class="codeline" data-linenumber="203"><td class="num" id="LN203">203</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="204"><td class="num" id="LN204">204</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>inline</span> <span class='keyword'>void</span> v_store_128(<span class='keyword'>void</span>* out, <span class='keyword'>const</span> z_vec128i_t vec) {</td></tr>
<tr class="codeline" data-linenumber="205"><td class="num" id="LN205">205</td><td class="line">  vst1q_u8(out, vec);</td></tr>
<tr class="codeline" data-linenumber="206"><td class="num" id="LN206">206</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="207"><td class="num" id="LN207">207</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="208"><td class="num" id="LN208">208</td><td class="line"><span class='directive'>#elif defined(<span class='macro'>INFLATE_CHUNK_SIMD_SSE2<span class='macro_popup'>1</span></span>)</span></td></tr>
<tr class="codeline" data-linenumber="209"><td class="num" id="LN209">209</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="210"><td class="num" id="LN210">210</td><td class="line"> <span class='comment'>* v_load64_dup(): load *src as an unaligned 64-bit int and duplicate it in</span></td></tr>
<tr class="codeline" data-linenumber="211"><td class="num" id="LN211">211</td><td class="line"> <span class='comment'>* every 64-bit component of the 128-bit result (64-bit int splat).</span></td></tr>
<tr class="codeline" data-linenumber="212"><td class="num" id="LN212">212</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="213"><td class="num" id="LN213">213</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>inline</span> z_vec128i_t v_load64_dup(<span class='keyword'>const</span> <span class='keyword'>void</span>* src) {</td></tr>
<tr class="codeline" data-linenumber="214"><td class="num" id="LN214">214</td><td class="line">  int64_t i64;</td></tr>
<tr class="codeline" data-linenumber="215"><td class="num" id="LN215">215</td><td class="line">  Z_BUILTIN_MEMCPY(&amp;i64, src, <span class='keyword'>sizeof</span>(i64));</td></tr>
<tr class="codeline" data-linenumber="216"><td class="num" id="LN216">216</td><td class="line">  <span class='keyword'>return</span> _mm_set1_epi64x(i64);</td></tr>
<tr class="codeline" data-linenumber="217"><td class="num" id="LN217">217</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="218"><td class="num" id="LN218">218</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="219"><td class="num" id="LN219">219</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="220"><td class="num" id="LN220">220</td><td class="line"> <span class='comment'>* v_load32_dup(): load *src as an unaligned 32-bit int and duplicate it in</span></td></tr>
<tr class="codeline" data-linenumber="221"><td class="num" id="LN221">221</td><td class="line"> <span class='comment'>* every 32-bit component of the 128-bit result (32-bit int splat).</span></td></tr>
<tr class="codeline" data-linenumber="222"><td class="num" id="LN222">222</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="223"><td class="num" id="LN223">223</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>inline</span> z_vec128i_t v_load32_dup(<span class='keyword'>const</span> <span class='keyword'>void</span>* src) {</td></tr>
<tr class="codeline" data-linenumber="224"><td class="num" id="LN224">224</td><td class="line">  int32_t i32;</td></tr>
<tr class="codeline" data-linenumber="225"><td class="num" id="LN225">225</td><td class="line">  Z_BUILTIN_MEMCPY(&amp;i32, src, <span class='keyword'>sizeof</span>(i32));</td></tr>
<tr class="codeline" data-linenumber="226"><td class="num" id="LN226">226</td><td class="line">  <span class='keyword'>return</span> _mm_set1_epi32(i32);</td></tr>
<tr class="codeline" data-linenumber="227"><td class="num" id="LN227">227</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="228"><td class="num" id="LN228">228</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="229"><td class="num" id="LN229">229</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="230"><td class="num" id="LN230">230</td><td class="line"> <span class='comment'>* v_load16_dup(): load *src as an unaligned 16-bit int and duplicate it in</span></td></tr>
<tr class="codeline" data-linenumber="231"><td class="num" id="LN231">231</td><td class="line"> <span class='comment'>* every 16-bit component of the 128-bit result (16-bit int splat).</span></td></tr>
<tr class="codeline" data-linenumber="232"><td class="num" id="LN232">232</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="233"><td class="num" id="LN233">233</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>inline</span> z_vec128i_t v_load16_dup(<span class='keyword'>const</span> <span class='keyword'>void</span>* src) {</td></tr>
<tr class="codeline" data-linenumber="234"><td class="num" id="LN234">234</td><td class="line">  int16_t i16;</td></tr>
<tr class="codeline" data-linenumber="235"><td class="num" id="LN235">235</td><td class="line">  Z_BUILTIN_MEMCPY(&amp;i16, src, <span class='keyword'>sizeof</span>(i16));</td></tr>
<tr class="codeline" data-linenumber="236"><td class="num" id="LN236">236</td><td class="line">  <span class='keyword'>return</span> _mm_set1_epi16(i16);</td></tr>
<tr class="codeline" data-linenumber="237"><td class="num" id="LN237">237</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="238"><td class="num" id="LN238">238</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="239"><td class="num" id="LN239">239</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="240"><td class="num" id="LN240">240</td><td class="line"> <span class='comment'>* v_load8_dup(): load the 8-bit int *src and duplicate it in every 8-bit</span></td></tr>
<tr class="codeline" data-linenumber="241"><td class="num" id="LN241">241</td><td class="line"> <span class='comment'>* component of the 128-bit result (8-bit int splat).</span></td></tr>
<tr class="codeline" data-linenumber="242"><td class="num" id="LN242">242</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="243"><td class="num" id="LN243">243</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>inline</span> z_vec128i_t v_load8_dup(<span class='keyword'>const</span> <span class='keyword'>void</span>* src) {</td></tr>
<tr class="codeline" data-linenumber="244"><td class="num" id="LN244">244</td><td class="line">  <span class='keyword'>return</span> _mm_set1_epi8(*(<span class='keyword'>const</span> <span class='keyword'>char</span>*)src);</td></tr>
<tr class="codeline" data-linenumber="245"><td class="num" id="LN245">245</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="246"><td class="num" id="LN246">246</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="247"><td class="num" id="LN247">247</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="248"><td class="num" id="LN248">248</td><td class="line"> <span class='comment'>* v_store_128(): store the 128-bit vec in a memory destination (that might</span></td></tr>
<tr class="codeline" data-linenumber="249"><td class="num" id="LN249">249</td><td class="line"> <span class='comment'>* not be 16-byte aligned) void* out.</span></td></tr>
<tr class="codeline" data-linenumber="250"><td class="num" id="LN250">250</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="251"><td class="num" id="LN251">251</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>inline</span> <span class='keyword'>void</span> v_store_128(<span class='keyword'>void</span>* out, <span class='keyword'>const</span> z_vec128i_t vec) {</td></tr>
<tr class="codeline" data-linenumber="252"><td class="num" id="LN252">252</td><td class="line">  _mm_storeu_si128((__m128i*)out, vec);</td></tr>
<tr class="codeline" data-linenumber="253"><td class="num" id="LN253">253</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="254"><td class="num" id="LN254">254</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="255"><td class="num" id="LN255">255</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="256"><td class="num" id="LN256">256</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="257"><td class="num" id="LN257">257</td><td class="line"> <span class='comment'>* Perform an overlapping copy which behaves as a memset() operation, but</span></td></tr>
<tr class="codeline" data-linenumber="258"><td class="num" id="LN258">258</td><td class="line"> <span class='comment'>* supporting periods other than one, and assume that length is non-zero and</span></td></tr>
<tr class="codeline" data-linenumber="259"><td class="num" id="LN259">259</td><td class="line"> <span class='comment'>* that it's OK to overwrite at least CHUNKCOPY_CHUNK_SIZE*3 bytes of output</span></td></tr>
<tr class="codeline" data-linenumber="260"><td class="num" id="LN260">260</td><td class="line"> <span class='comment'>* even if the length is shorter than this.</span></td></tr>
<tr class="codeline" data-linenumber="261"><td class="num" id="LN261">261</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="262"><td class="num" id="LN262">262</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>inline</span> <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* chunkset_core(</td></tr>
<tr class="codeline" data-linenumber="263"><td class="num" id="LN263">263</td><td class="line">    <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* out,</td></tr>
<tr class="codeline" data-linenumber="264"><td class="num" id="LN264">264</td><td class="line">    <span class='keyword'>unsigned</span> period,</td></tr>
<tr class="codeline" data-linenumber="265"><td class="num" id="LN265">265</td><td class="line">    <span class='keyword'>unsigned</span> len) {</td></tr>
<tr class="codeline" data-linenumber="266"><td class="num" id="LN266">266</td><td class="line">  z_vec128i_t v;</td></tr>
<tr class="codeline" data-linenumber="267"><td class="num" id="LN267">267</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>int</span> bump = ((len - 1) % <span class='keyword'>sizeof</span>(v)) + 1;</td></tr>
<tr class="codeline" data-linenumber="268"><td class="num" id="LN268">268</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="269"><td class="num" id="LN269">269</td><td class="line">  <span class='keyword'>switch</span> (period) {</td></tr>
<tr class="codeline" data-linenumber="270"><td class="num" id="LN270">270</td><td class="line">    <span class='keyword'>case</span> 1:</td></tr>
<tr class="codeline" data-linenumber="271"><td class="num" id="LN271">271</td><td class="line">      v = v_load8_dup(out - 1);</td></tr>
<tr class="codeline" data-linenumber="272"><td class="num" id="LN272">272</td><td class="line">      v_store_128(out, v);</td></tr>
<tr class="codeline" data-linenumber="273"><td class="num" id="LN273">273</td><td class="line">      out += bump;</td></tr>
<tr class="codeline" data-linenumber="274"><td class="num" id="LN274">274</td><td class="line">      len -= bump;</td></tr>
<tr class="codeline" data-linenumber="275"><td class="num" id="LN275">275</td><td class="line">      <span class='keyword'>while</span> (len &gt; 0) {</td></tr>
<tr class="codeline" data-linenumber="276"><td class="num" id="LN276">276</td><td class="line">        v_store_128(out, v);</td></tr>
<tr class="codeline" data-linenumber="277"><td class="num" id="LN277">277</td><td class="line">        out += <span class='keyword'>sizeof</span>(v);</td></tr>
<tr class="codeline" data-linenumber="278"><td class="num" id="LN278">278</td><td class="line">        len -= <span class='keyword'>sizeof</span>(v);</td></tr>
<tr class="codeline" data-linenumber="279"><td class="num" id="LN279">279</td><td class="line">      }</td></tr>
<tr class="codeline" data-linenumber="280"><td class="num" id="LN280">280</td><td class="line">      <span class='keyword'>return</span> out;</td></tr>
<tr class="codeline" data-linenumber="281"><td class="num" id="LN281">281</td><td class="line">    <span class='keyword'>case</span> 2:</td></tr>
<tr class="codeline" data-linenumber="282"><td class="num" id="LN282">282</td><td class="line">      v = v_load16_dup(out - 2);</td></tr>
<tr class="codeline" data-linenumber="283"><td class="num" id="LN283">283</td><td class="line">      v_store_128(out, v);</td></tr>
<tr class="codeline" data-linenumber="284"><td class="num" id="LN284">284</td><td class="line">      out += bump;</td></tr>
<tr class="codeline" data-linenumber="285"><td class="num" id="LN285">285</td><td class="line">      len -= bump;</td></tr>
<tr class="codeline" data-linenumber="286"><td class="num" id="LN286">286</td><td class="line">      <span class='keyword'>if</span> (len &gt; 0) {</td></tr>
<tr class="codeline" data-linenumber="287"><td class="num" id="LN287">287</td><td class="line">        v = v_load16_dup(out - 2);</td></tr>
<tr class="codeline" data-linenumber="288"><td class="num" id="LN288">288</td><td class="line">        <span class='keyword'>do</span> {</td></tr>
<tr class="codeline" data-linenumber="289"><td class="num" id="LN289">289</td><td class="line">          v_store_128(out, v);</td></tr>
<tr class="codeline" data-linenumber="290"><td class="num" id="LN290">290</td><td class="line">          out += <span class='keyword'>sizeof</span>(v);</td></tr>
<tr class="codeline" data-linenumber="291"><td class="num" id="LN291">291</td><td class="line">          len -= <span class='keyword'>sizeof</span>(v);</td></tr>
<tr class="codeline" data-linenumber="292"><td class="num" id="LN292">292</td><td class="line">        } <span class='keyword'>while</span> (len &gt; 0);</td></tr>
<tr class="codeline" data-linenumber="293"><td class="num" id="LN293">293</td><td class="line">      }</td></tr>
<tr class="codeline" data-linenumber="294"><td class="num" id="LN294">294</td><td class="line">      <span class='keyword'>return</span> out;</td></tr>
<tr class="codeline" data-linenumber="295"><td class="num" id="LN295">295</td><td class="line">    <span class='keyword'>case</span> 4:</td></tr>
<tr class="codeline" data-linenumber="296"><td class="num" id="LN296">296</td><td class="line">      v = v_load32_dup(out - 4);</td></tr>
<tr class="codeline" data-linenumber="297"><td class="num" id="LN297">297</td><td class="line">      v_store_128(out, v);</td></tr>
<tr class="codeline" data-linenumber="298"><td class="num" id="LN298">298</td><td class="line">      out += bump;</td></tr>
<tr class="codeline" data-linenumber="299"><td class="num" id="LN299">299</td><td class="line">      len -= bump;</td></tr>
<tr class="codeline" data-linenumber="300"><td class="num" id="LN300">300</td><td class="line">      <span class='keyword'>if</span> (len &gt; 0) {</td></tr>
<tr class="codeline" data-linenumber="301"><td class="num" id="LN301">301</td><td class="line">        v = v_load32_dup(out - 4);</td></tr>
<tr class="codeline" data-linenumber="302"><td class="num" id="LN302">302</td><td class="line">        <span class='keyword'>do</span> {</td></tr>
<tr class="codeline" data-linenumber="303"><td class="num" id="LN303">303</td><td class="line">          v_store_128(out, v);</td></tr>
<tr class="codeline" data-linenumber="304"><td class="num" id="LN304">304</td><td class="line">          out += <span class='keyword'>sizeof</span>(v);</td></tr>
<tr class="codeline" data-linenumber="305"><td class="num" id="LN305">305</td><td class="line">          len -= <span class='keyword'>sizeof</span>(v);</td></tr>
<tr class="codeline" data-linenumber="306"><td class="num" id="LN306">306</td><td class="line">        } <span class='keyword'>while</span> (len &gt; 0);</td></tr>
<tr class="codeline" data-linenumber="307"><td class="num" id="LN307">307</td><td class="line">      }</td></tr>
<tr class="codeline" data-linenumber="308"><td class="num" id="LN308">308</td><td class="line">      <span class='keyword'>return</span> out;</td></tr>
<tr class="codeline" data-linenumber="309"><td class="num" id="LN309">309</td><td class="line">    <span class='keyword'>case</span> 8:</td></tr>
<tr class="codeline" data-linenumber="310"><td class="num" id="LN310">310</td><td class="line">      v = v_load64_dup(out - 8);</td></tr>
<tr class="codeline" data-linenumber="311"><td class="num" id="LN311">311</td><td class="line">      v_store_128(out, v);</td></tr>
<tr class="codeline" data-linenumber="312"><td class="num" id="LN312">312</td><td class="line">      out += bump;</td></tr>
<tr class="codeline" data-linenumber="313"><td class="num" id="LN313">313</td><td class="line">      len -= bump;</td></tr>
<tr class="codeline" data-linenumber="314"><td class="num" id="LN314">314</td><td class="line">      <span class='keyword'>if</span> (len &gt; 0) {</td></tr>
<tr class="codeline" data-linenumber="315"><td class="num" id="LN315">315</td><td class="line">        v = v_load64_dup(out - 8);</td></tr>
<tr class="codeline" data-linenumber="316"><td class="num" id="LN316">316</td><td class="line">        <span class='keyword'>do</span> {</td></tr>
<tr class="codeline" data-linenumber="317"><td class="num" id="LN317">317</td><td class="line">          v_store_128(out, v);</td></tr>
<tr class="codeline" data-linenumber="318"><td class="num" id="LN318">318</td><td class="line">          out += <span class='keyword'>sizeof</span>(v);</td></tr>
<tr class="codeline" data-linenumber="319"><td class="num" id="LN319">319</td><td class="line">          len -= <span class='keyword'>sizeof</span>(v);</td></tr>
<tr class="codeline" data-linenumber="320"><td class="num" id="LN320">320</td><td class="line">        } <span class='keyword'>while</span> (len &gt; 0);</td></tr>
<tr class="codeline" data-linenumber="321"><td class="num" id="LN321">321</td><td class="line">      }</td></tr>
<tr class="codeline" data-linenumber="322"><td class="num" id="LN322">322</td><td class="line">      <span class='keyword'>return</span> out;</td></tr>
<tr class="codeline" data-linenumber="323"><td class="num" id="LN323">323</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="324"><td class="num" id="LN324">324</td><td class="line">  out = chunkunroll_relaxed(out, &amp;period, &amp;len);</td></tr>
<tr class="codeline" data-linenumber="325"><td class="num" id="LN325">325</td><td class="line">  <span class='keyword'>return</span> chunkcopy_core(out, out - period, len);</td></tr>
<tr class="codeline" data-linenumber="326"><td class="num" id="LN326">326</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="327"><td class="num" id="LN327">327</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="328"><td class="num" id="LN328">328</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="329"><td class="num" id="LN329">329</td><td class="line"> <span class='comment'>* Perform a memcpy-like operation, but assume that length is non-zero and that</span></td></tr>
<tr class="codeline" data-linenumber="330"><td class="num" id="LN330">330</td><td class="line"> <span class='comment'>* it's OK to overwrite at least CHUNKCOPY_CHUNK_SIZE bytes of output even if</span></td></tr>
<tr class="codeline" data-linenumber="331"><td class="num" id="LN331">331</td><td class="line"> <span class='comment'>* the length is shorter than this.</span></td></tr>
<tr class="codeline" data-linenumber="332"><td class="num" id="LN332">332</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="333"><td class="num" id="LN333">333</td><td class="line"> <span class='comment'>* Unlike chunkcopy_core() above, no guarantee is made regarding the behaviour</span></td></tr>
<tr class="codeline" data-linenumber="334"><td class="num" id="LN334">334</td><td class="line"> <span class='comment'>* of overlapping buffers, regardless of the distance between the pointers.</span></td></tr>
<tr class="codeline" data-linenumber="335"><td class="num" id="LN335">335</td><td class="line"> <span class='comment'>* This is reflected in the `restrict`-qualified pointers, allowing the</span></td></tr>
<tr class="codeline" data-linenumber="336"><td class="num" id="LN336">336</td><td class="line"> <span class='comment'>* compiler to re-order loads and stores.</span></td></tr>
<tr class="codeline" data-linenumber="337"><td class="num" id="LN337">337</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="338"><td class="num" id="LN338">338</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>inline</span> <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* chunkcopy_relaxed(</td></tr>
<tr class="codeline" data-linenumber="339"><td class="num" id="LN339">339</td><td class="line">    <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* Z_RESTRICT out,</td></tr>
<tr class="codeline" data-linenumber="340"><td class="num" id="LN340">340</td><td class="line">    <span class='keyword'>const</span> <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* Z_RESTRICT from,</td></tr>
<tr class="codeline" data-linenumber="341"><td class="num" id="LN341">341</td><td class="line">    <span class='keyword'>unsigned</span> len) {</td></tr>
<tr class="codeline" data-linenumber="342"><td class="num" id="LN342">342</td><td class="line">  <span class='keyword'>return</span> chunkcopy_core(out, from, len);</td></tr>
<tr class="codeline" data-linenumber="343"><td class="num" id="LN343">343</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="344"><td class="num" id="LN344">344</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="345"><td class="num" id="LN345">345</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="346"><td class="num" id="LN346">346</td><td class="line"> <span class='comment'>* Like chunkcopy_relaxed(), but avoid writing beyond of legal output.</span></td></tr>
<tr class="codeline" data-linenumber="347"><td class="num" id="LN347">347</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="348"><td class="num" id="LN348">348</td><td class="line"> <span class='comment'>* Unlike chunkcopy_core_safe() above, no guarantee is made regarding the</span></td></tr>
<tr class="codeline" data-linenumber="349"><td class="num" id="LN349">349</td><td class="line"> <span class='comment'>* behaviour of overlapping buffers, regardless of the distance between the</span></td></tr>
<tr class="codeline" data-linenumber="350"><td class="num" id="LN350">350</td><td class="line"> <span class='comment'>* pointers.  This is reflected in the `restrict`-qualified pointers, allowing</span></td></tr>
<tr class="codeline" data-linenumber="351"><td class="num" id="LN351">351</td><td class="line"> <span class='comment'>* the compiler to re-order loads and stores.</span></td></tr>
<tr class="codeline" data-linenumber="352"><td class="num" id="LN352">352</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="353"><td class="num" id="LN353">353</td><td class="line"> <span class='comment'>* Accepts an additional pointer to the end of safe output.  A generic safe</span></td></tr>
<tr class="codeline" data-linenumber="354"><td class="num" id="LN354">354</td><td class="line"> <span class='comment'>* copy would use (out + len), but it's normally the case that the end of the</span></td></tr>
<tr class="codeline" data-linenumber="355"><td class="num" id="LN355">355</td><td class="line"> <span class='comment'>* output buffer is beyond the end of the current copy, and this can still be</span></td></tr>
<tr class="codeline" data-linenumber="356"><td class="num" id="LN356">356</td><td class="line"> <span class='comment'>* exploited.</span></td></tr>
<tr class="codeline" data-linenumber="357"><td class="num" id="LN357">357</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="358"><td class="num" id="LN358">358</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>inline</span> <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* chunkcopy_safe(</td></tr>
<tr class="codeline" data-linenumber="359"><td class="num" id="LN359">359</td><td class="line">    <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* out,</td></tr>
<tr class="codeline" data-linenumber="360"><td class="num" id="LN360">360</td><td class="line">    <span class='keyword'>const</span> <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* Z_RESTRICT from,</td></tr>
<tr class="codeline" data-linenumber="361"><td class="num" id="LN361">361</td><td class="line">    <span class='keyword'>unsigned</span> len,</td></tr>
<tr class="codeline" data-linenumber="362"><td class="num" id="LN362">362</td><td class="line">    <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* limit) {</td></tr>
<tr class="codeline" data-linenumber="363"><td class="num" id="LN363">363</td><td class="line">  Assert(out + len &lt;= limit, <span class='string_literal'>"chunk copy exceeds safety limit"</span>);</td></tr>
<tr class="codeline" data-linenumber="364"><td class="num" id="LN364">364</td><td class="line">  <span class='keyword'>return</span> chunkcopy_core_safe(out, from, len, limit);</td></tr>
<tr class="codeline" data-linenumber="365"><td class="num" id="LN365">365</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="366"><td class="num" id="LN366">366</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="367"><td class="num" id="LN367">367</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="368"><td class="num" id="LN368">368</td><td class="line"> <span class='comment'>* Perform chunky copy within the same buffer, where the source and destination</span></td></tr>
<tr class="codeline" data-linenumber="369"><td class="num" id="LN369">369</td><td class="line"> <span class='comment'>* may potentially overlap.</span></td></tr>
<tr class="codeline" data-linenumber="370"><td class="num" id="LN370">370</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="371"><td class="num" id="LN371">371</td><td class="line"> <span class='comment'>* Assumes that len &gt; 0 on entry, and that it's safe to write at least</span></td></tr>
<tr class="codeline" data-linenumber="372"><td class="num" id="LN372">372</td><td class="line"> <span class='comment'>* CHUNKCOPY_CHUNK_SIZE*3 bytes to the output.</span></td></tr>
<tr class="codeline" data-linenumber="373"><td class="num" id="LN373">373</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="374"><td class="num" id="LN374">374</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>inline</span> <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* chunkcopy_lapped_relaxed(</td></tr>
<tr class="codeline" data-linenumber="375"><td class="num" id="LN375">375</td><td class="line">    <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* out,</td></tr>
<tr class="codeline" data-linenumber="376"><td class="num" id="LN376">376</td><td class="line">    <span class='keyword'>unsigned</span> dist,</td></tr>
<tr class="codeline" data-linenumber="377"><td class="num" id="LN377">377</td><td class="line">    <span class='keyword'>unsigned</span> len) {</td></tr>
<tr class="codeline" data-linenumber="378"><td class="num" id="LN378">378</td><td class="line">  <span class='keyword'>if</span> (dist &lt; len &amp;&amp; dist &lt; <span class='macro'>CHUNKCOPY_CHUNK_SIZE<span class='macro_popup'>sizeof(z_vec128i_t)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="379"><td class="num" id="LN379">379</td><td class="line">    <span class='keyword'>return</span> chunkset_core(out, dist, len);</td></tr>
<tr class="codeline" data-linenumber="380"><td class="num" id="LN380">380</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="381"><td class="num" id="LN381">381</td><td class="line">  <span class='keyword'>return</span> chunkcopy_core(out, out - dist, len);</td></tr>
<tr class="codeline" data-linenumber="382"><td class="num" id="LN382">382</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="383"><td class="num" id="LN383">383</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="384"><td class="num" id="LN384">384</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="385"><td class="num" id="LN385">385</td><td class="line"> <span class='comment'>* Behave like chunkcopy_lapped_relaxed(), but avoid writing beyond of legal</span></td></tr>
<tr class="codeline" data-linenumber="386"><td class="num" id="LN386">386</td><td class="line"> <span class='comment'>* output.</span></td></tr>
<tr class="codeline" data-linenumber="387"><td class="num" id="LN387">387</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="388"><td class="num" id="LN388">388</td><td class="line"> <span class='comment'>* Accepts an additional pointer to the end of safe output.  A generic safe</span></td></tr>
<tr class="codeline" data-linenumber="389"><td class="num" id="LN389">389</td><td class="line"> <span class='comment'>* copy would use (out + len), but it's normally the case that the end of the</span></td></tr>
<tr class="codeline" data-linenumber="390"><td class="num" id="LN390">390</td><td class="line"> <span class='comment'>* output buffer is beyond the end of the current copy, and this can still be</span></td></tr>
<tr class="codeline" data-linenumber="391"><td class="num" id="LN391">391</td><td class="line"> <span class='comment'>* exploited.</span></td></tr>
<tr class="codeline" data-linenumber="392"><td class="num" id="LN392">392</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="393"><td class="num" id="LN393">393</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>inline</span> <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* chunkcopy_lapped_safe(</td></tr>
<tr class="codeline" data-linenumber="394"><td class="num" id="LN394">394</td><td class="line">    <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* out,</td></tr>
<tr class="codeline" data-linenumber="395"><td class="num" id="LN395">395</td><td class="line">    <span class='keyword'>unsigned</span> dist,</td></tr>
<tr class="codeline" data-linenumber="396"><td class="num" id="LN396">396</td><td class="line">    <span class='keyword'>unsigned</span> len,</td></tr>
<tr class="codeline" data-linenumber="397"><td class="num" id="LN397">397</td><td class="line">    <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR* limit) {</td></tr>
<tr class="codeline" data-linenumber="398"><td class="num" id="LN398">398</td><td class="line">  Assert(out + len &lt;= limit, <span class='string_literal'>"chunk copy exceeds safety limit"</span>);</td></tr>
<tr class="codeline" data-linenumber="399"><td class="num" id="LN399">399</td><td class="line">  <span class='keyword'>if</span> ((limit - out) &lt; (ptrdiff_t)(3 * <span class='macro'>CHUNKCOPY_CHUNK_SIZE<span class='macro_popup'>sizeof(z_vec128i_t)</span></span>)) {</td></tr>
<tr class="codeline" data-linenumber="400"><td class="num" id="LN400">400</td><td class="line">    <span class='comment'>/* TODO(cavalcantii): try harder to optimise this */</span></td></tr>
<tr class="codeline" data-linenumber="401"><td class="num" id="LN401">401</td><td class="line">    <span class='keyword'>while</span> (len-- &gt; 0) {</td></tr>
<tr class="codeline" data-linenumber="402"><td class="num" id="LN402">402</td><td class="line">      *out = *(out - dist);</td></tr>
<tr class="codeline" data-linenumber="403"><td class="num" id="LN403">403</td><td class="line">      out++;</td></tr>
<tr class="codeline" data-linenumber="404"><td class="num" id="LN404">404</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="405"><td class="num" id="LN405">405</td><td class="line">    <span class='keyword'>return</span> out;</td></tr>
<tr class="codeline" data-linenumber="406"><td class="num" id="LN406">406</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="407"><td class="num" id="LN407">407</td><td class="line">  <span class='keyword'>return</span> chunkcopy_lapped_relaxed(out, dist, len);</td></tr>
<tr class="codeline" data-linenumber="408"><td class="num" id="LN408">408</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="409"><td class="num" id="LN409">409</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="410"><td class="num" id="LN410">410</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="411"><td class="num" id="LN411">411</td><td class="line"> <span class='comment'>* The chunk-copy code above deals with writing the decoded DEFLATE data to</span></td></tr>
<tr class="codeline" data-linenumber="412"><td class="num" id="LN412">412</td><td class="line"> <span class='comment'>* the output with SIMD methods to increase decode speed. Reading the input</span></td></tr>
<tr class="codeline" data-linenumber="413"><td class="num" id="LN413">413</td><td class="line"> <span class='comment'>* to the DEFLATE decoder with a wide, SIMD method can also increase decode</span></td></tr>
<tr class="codeline" data-linenumber="414"><td class="num" id="LN414">414</td><td class="line"> <span class='comment'>* speed. This option is supported on little endian machines, and reads the</span></td></tr>
<tr class="codeline" data-linenumber="415"><td class="num" id="LN415">415</td><td class="line"> <span class='comment'>* input data in 64-bit (8 byte) chunks.</span></td></tr>
<tr class="codeline" data-linenumber="416"><td class="num" id="LN416">416</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="417"><td class="num" id="LN417">417</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="418"><td class="num" id="LN418">418</td><td class="line"><span class='directive'>#ifdef <span class='macro'>INFLATE_CHUNK_READ_64LE<span class='macro_popup'>1</span></span></span></td></tr>
<tr class="codeline" data-linenumber="419"><td class="num" id="LN419">419</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="420"><td class="num" id="LN420">420</td><td class="line"> <span class='comment'>* Buffer the input in a uint64_t (8 bytes) in the wide input reading case.</span></td></tr>
<tr class="codeline" data-linenumber="421"><td class="num" id="LN421">421</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="422"><td class="num" id="LN422">422</td><td class="line"><span class='keyword'>typedef</span> uint64_t inflate_holder_t;</td></tr>
<tr class="codeline" data-linenumber="423"><td class="num" id="LN423">423</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="424"><td class="num" id="LN424">424</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="425"><td class="num" id="LN425">425</td><td class="line"> <span class='comment'>* Ask the compiler to perform a wide, unaligned load of a uint64_t using a</span></td></tr>
<tr class="codeline" data-linenumber="426"><td class="num" id="LN426">426</td><td class="line"> <span class='comment'>* machine instruction appropriate for the uint64_t type.</span></td></tr>
<tr class="codeline" data-linenumber="427"><td class="num" id="LN427">427</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="428"><td class="num" id="LN428">428</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>inline</span> inflate_holder_t read64le(<span class='keyword'>const</span> <span class='keyword'>unsigned</span> <span class='keyword'>char</span> FAR *in) {</td></tr>
<tr class="codeline" data-linenumber="429"><td class="num" id="LN429">429</td><td class="line">    inflate_holder_t input;</td></tr>
<tr class="codeline" data-linenumber="430"><td class="num" id="LN430">430</td><td class="line">    <span class="mrange">Z_BUILTIN_MEMCPY</span>(&amp;input, in, <span class='keyword'>sizeof</span>(input));</td></tr>
<tr><td class="num"></td><td class="line"><div id="EndPath" class="msg msgEvent" style="margin-left:5ex; max-width:58em">Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11</div></td></tr>
<tr class="codeline" data-linenumber="431"><td class="num" id="LN431">431</td><td class="line">    <span class='keyword'>return</span> input;</td></tr>
<tr class="codeline" data-linenumber="432"><td class="num" id="LN432">432</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="433"><td class="num" id="LN433">433</td><td class="line"><span class='directive'>#else</span></td></tr>
<tr class="codeline" data-linenumber="434"><td class="num" id="LN434">434</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="435"><td class="num" id="LN435">435</td><td class="line"> <span class='comment'>* Otherwise, buffer the input bits using zlib's default input buffer type.</span></td></tr>
<tr class="codeline" data-linenumber="436"><td class="num" id="LN436">436</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="437"><td class="num" id="LN437">437</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>unsigned</span> <span class='keyword'>long</span> inflate_holder_t;</td></tr>
<tr class="codeline" data-linenumber="438"><td class="num" id="LN438">438</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="439"><td class="num" id="LN439">439</td><td class="line"><span class='directive'>#endif /* INFLATE_CHUNK_READ_64LE */</span></td></tr>
<tr class="codeline" data-linenumber="440"><td class="num" id="LN440">440</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="441"><td class="num" id="LN441">441</td><td class="line"><span class='directive'>#undef Z_STATIC_ASSERT</span></td></tr>
<tr class="codeline" data-linenumber="442"><td class="num" id="LN442">442</td><td class="line"><span class='directive'>#undef Z_RESTRICT</span></td></tr>
<tr class="codeline" data-linenumber="443"><td class="num" id="LN443">443</td><td class="line"><span class='directive'>#undef Z_BUILTIN_MEMCPY</span></td></tr>
<tr class="codeline" data-linenumber="444"><td class="num" id="LN444">444</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="445"><td class="num" id="LN445">445</td><td class="line"><span class='directive'>#endif /* CHUNKCOPY_H */</span></td></tr>
</table></body></html>
