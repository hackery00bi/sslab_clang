
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Cppcheck - HTML report - [project name]</title>
    <link rel="stylesheet" href="style.css">
    <style>
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #ffffff; }
.highlight .c { color: #888888 } /* Comment */
.highlight .err { color: #FF0000; background-color: #FFAAAA } /* Error */
.highlight .k { color: #008800; font-weight: bold } /* Keyword */
.highlight .o { color: #333333 } /* Operator */
.highlight .ch { color: #888888 } /* Comment.Hashbang */
.highlight .cm { color: #888888 } /* Comment.Multiline */
.highlight .cp { color: #557799 } /* Comment.Preproc */
.highlight .cpf { color: #888888 } /* Comment.PreprocFile */
.highlight .c1 { color: #888888 } /* Comment.Single */
.highlight .cs { color: #cc0000; font-weight: bold } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008800; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008800; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008800; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #003388; font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { color: #008800; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #333399; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #6600EE; font-weight: bold } /* Literal.Number */
.highlight .s { background-color: #fff0f0 } /* Literal.String */
.highlight .na { color: #0000CC } /* Name.Attribute */
.highlight .nb { color: #007020 } /* Name.Builtin */
.highlight .nc { color: #BB0066; font-weight: bold } /* Name.Class */
.highlight .no { color: #003366; font-weight: bold } /* Name.Constant */
.highlight .nd { color: #555555; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #880000; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #FF0000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0066BB; font-weight: bold } /* Name.Function */
.highlight .nl { color: #997700; font-weight: bold } /* Name.Label */
.highlight .nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #007700 } /* Name.Tag */
.highlight .nv { color: #996633 } /* Name.Variable */
.highlight .ow { color: #000000; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #6600EE; font-weight: bold } /* Literal.Number.Bin */
.highlight .mf { color: #6600EE; font-weight: bold } /* Literal.Number.Float */
.highlight .mh { color: #005588; font-weight: bold } /* Literal.Number.Hex */
.highlight .mi { color: #0000DD; font-weight: bold } /* Literal.Number.Integer */
.highlight .mo { color: #4400EE; font-weight: bold } /* Literal.Number.Oct */
.highlight .sa { background-color: #fff0f0 } /* Literal.String.Affix */
.highlight .sb { background-color: #fff0f0 } /* Literal.String.Backtick */
.highlight .sc { color: #0044DD } /* Literal.String.Char */
.highlight .dl { background-color: #fff0f0 } /* Literal.String.Delimiter */
.highlight .sd { color: #DD4422 } /* Literal.String.Doc */
.highlight .s2 { background-color: #fff0f0 } /* Literal.String.Double */
.highlight .se { color: #666666; font-weight: bold; background-color: #fff0f0 } /* Literal.String.Escape */
.highlight .sh { background-color: #fff0f0 } /* Literal.String.Heredoc */
.highlight .si { background-color: #eeeeee } /* Literal.String.Interpol */
.highlight .sx { color: #DD2200; background-color: #fff0f0 } /* Literal.String.Other */
.highlight .sr { color: #000000; background-color: #fff0ff } /* Literal.String.Regex */
.highlight .s1 { background-color: #fff0f0 } /* Literal.String.Single */
.highlight .ss { color: #AA6600 } /* Literal.String.Symbol */
.highlight .bp { color: #007020 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #0066BB; font-weight: bold } /* Name.Function.Magic */
.highlight .vc { color: #336699 } /* Name.Variable.Class */
.highlight .vg { color: #dd7700; font-weight: bold } /* Name.Variable.Global */
.highlight .vi { color: #3333BB } /* Name.Variable.Instance */
.highlight .vm { color: #996633 } /* Name.Variable.Magic */
.highlight .il { color: #0000DD; font-weight: bold } /* Literal.Number.Integer.Long */
    </style>
    <script>
      function getStyle(el, styleProp) {
        var y;

        if (el.currentStyle) {
          y = el.currentStyle[styleProp];
        } else if (window.getComputedStyle) {
          y = document.defaultView.getComputedStyle(el, null).getPropertyValue(styleProp);
        }

        return y;
      }

      function toggle() {
        var el = this.expandable_content;
        var mark = this.expandable_marker;

        if (el.style.display === "block") {
          el.style.display = "none";
          mark.textContent = "[+]";
        } else {
          el.style.display = "block";
          mark.textContent = "[-]";
        }
      }

      function initExpandables() {
        var elements = document.querySelectorAll(".expandable");

        for (var i = 0, len = elements.length; i < len; i++) {
          var el = elements[i];
          var clickable = el.querySelector("span");
          var marker = clickable.querySelector(".marker");
          var content = el.querySelector(".content");
          var width = clickable.clientWidth - parseInt(getStyle(content, "padding-left")) - parseInt(getStyle(content, "padding-right"));
          content.style.width = width + "px";
          clickable.expandable_content = content;
          clickable.expandable_marker = marker;
          clickable.addEventListener("click", toggle);
        }
      }

      function toggleDisplay(id) {
        var elements = document.querySelectorAll("." + id);

        for (var i = 0, len = elements.length; i < len; i++) {
          elements[i].classList.toggle("d-none");
        }
      }

      function toggleAll() {
        var elements = document.querySelectorAll("input");

        // starting from 1 since 0 is the "toggle all" input
        for (var i = 1, len = elements.length; i < len; i++) {
          var el = elements[i];

          if (el.checked) {
            el.checked = false;
          } else {
            el.checked = true;
          }

          toggleDisplay(el.id);
        }
      }
      window.addEventListener("load", initExpandables);
    </script>
  </head>
  <body>
    <div id="header" class="header">
      <h1>Cppcheck report - [project name]: /tmp/sslab_clang/c_git/git/compat/regex/regex_internal.h</h1>
    </div>
    <div class="wrapper">
      <div id="menu">
       <p id="filename"><a href="index.html">Defects:</a> regex_internal.h</p>
<a href="116.html#line-697"> syntaxError 697</a>
    </div>
    <div id="content">
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561
562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580
581
582
583
584
585
586
587
588
589
590
591
592
593
594
595
596
597
598
599
600
601
602
603
604
605
606
607
608
609
610
611
612
613
614
615
616
617
618
619
620
621
622
623
624
625
626
627
628
629
630
631
632
633
634
635
636
637
638
639
640
641
642
643
644
645
646
647
648
649
650
651
652
653
654
655
656
657
658
659
660
661
662
663
664
665
666
667
668
669
670
671
672
673
674
675
676
677
678
679
680
681
682
683
684
685
686
687
688
689
690
691
692
693
694
695
696
697
698
699
700
701
702
703
704
705
706
707
708
709
710
711
712
713
714
715
716
717
718
719
720
721
722
723
724
725
726
727
728
729
730
731
732
733
734
735
736
737
738
739
740
741
742
743
744
745
746
747
748
749
750
751
752
753
754
755
756
757
758
759
760
761
762
763
764
765
766
767
768
769
770
771
772
773
774
775
776
777
778
779
780
781
782
783
784
785
786
787
788
789
790
791
792
793
794
795
796
797
798
799
800
801
802
803
804
805
806
807
808</pre></div></td><td class="code"><div class="highlight"><pre><span></span><a name="line-1"></a><span class="cm">/* Extended regular expression matching and search library.</span>
<a name="line-2"></a><span class="cm">   Copyright (C) 2002-2005, 2007, 2008, 2010 Free Software Foundation, Inc.</span>
<a name="line-3"></a><span class="cm">   This file is part of the GNU C Library.</span>
<a name="line-4"></a><span class="cm">   Contributed by Isamu Hasegawa &lt;isamu@yamato.ibm.com&gt;.</span>
<a name="line-5"></a>
<a name="line-6"></a><span class="cm">   The GNU C Library is free software; you can redistribute it and/or</span>
<a name="line-7"></a><span class="cm">   modify it under the terms of the GNU Lesser General Public</span>
<a name="line-8"></a><span class="cm">   License as published by the Free Software Foundation; either</span>
<a name="line-9"></a><span class="cm">   version 2.1 of the License, or (at your option) any later version.</span>
<a name="line-10"></a>
<a name="line-11"></a><span class="cm">   The GNU C Library is distributed in the hope that it will be useful,</span>
<a name="line-12"></a><span class="cm">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="line-13"></a><span class="cm">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="line-14"></a><span class="cm">   Lesser General Public License for more details.</span>
<a name="line-15"></a>
<a name="line-16"></a><span class="cm">   You should have received a copy of the GNU Lesser General Public</span>
<a name="line-17"></a><span class="cm">   License along with the GNU C Library; if not, see</span>
<a name="line-18"></a><span class="cm">   &lt;http://www.gnu.org/licenses/&gt;.  */</span>
<a name="line-19"></a>
<a name="line-20"></a><span class="cp">#ifndef _REGEX_INTERNAL_H</span>
<a name="line-21"></a><span class="cp">#define _REGEX_INTERNAL_H 1</span>
<a name="line-22"></a>
<a name="line-23"></a><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>
<a name="line-24"></a><span class="cp">#include</span> <span class="cpf">&lt;ctype.h&gt;</span><span class="cp"></span>
<a name="line-25"></a><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<a name="line-26"></a><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<a name="line-27"></a>
<a name="line-28"></a><span class="cp">#if defined HAVE_LANGINFO_H || defined HAVE_LANGINFO_CODESET || defined _LIBC</span>
<a name="line-29"></a><span class="cp"># include &lt;langinfo.h&gt;</span>
<a name="line-30"></a><span class="cp">#endif</span>
<a name="line-31"></a><span class="cp">#if defined HAVE_LOCALE_H || defined _LIBC</span>
<a name="line-32"></a><span class="cp"># include &lt;locale.h&gt;</span>
<a name="line-33"></a><span class="cp">#endif</span>
<a name="line-34"></a><span class="cp">#if defined HAVE_WCHAR_H || defined _LIBC</span>
<a name="line-35"></a><span class="cp"># include &lt;wchar.h&gt;</span>
<a name="line-36"></a><span class="cp">#endif </span><span class="cm">/* HAVE_WCHAR_H || _LIBC */</span><span class="cp"></span>
<a name="line-37"></a><span class="cp">#if defined HAVE_WCTYPE_H || defined _LIBC</span>
<a name="line-38"></a><span class="cp"># include &lt;wctype.h&gt;</span>
<a name="line-39"></a><span class="cp">#endif </span><span class="cm">/* HAVE_WCTYPE_H || _LIBC */</span><span class="cp"></span>
<a name="line-40"></a><span class="cp">#if defined HAVE_STDBOOL_H || defined _LIBC</span>
<a name="line-41"></a><span class="cp"># include &lt;stdbool.h&gt;</span>
<a name="line-42"></a><span class="cp">#endif </span><span class="cm">/* HAVE_STDBOOL_H || _LIBC */</span><span class="cp"></span>
<a name="line-43"></a><span class="cp">#if !defined(ZOS_USS)</span>
<a name="line-44"></a><span class="cp">#if defined HAVE_STDINT_H || defined _LIBC</span>
<a name="line-45"></a><span class="cp"># include &lt;stdint.h&gt;</span>
<a name="line-46"></a><span class="cp">#endif </span><span class="cm">/* HAVE_STDINT_H || _LIBC */</span><span class="cp"></span>
<a name="line-47"></a><span class="cp">#endif </span><span class="cm">/* !ZOS_USS */</span><span class="cp"></span>
<a name="line-48"></a><span class="cp">#if defined _LIBC</span>
<a name="line-49"></a><span class="cp"># include &lt;bits/libc-lock.h&gt;</span>
<a name="line-50"></a><span class="cp">#else</span>
<a name="line-51"></a><span class="cp"># define __libc_lock_define(CLASS,NAME)</span>
<a name="line-52"></a><span class="cp"># define __libc_lock_init(NAME) do { } while (0)</span>
<a name="line-53"></a><span class="cp"># define __libc_lock_lock(NAME) do { } while (0)</span>
<a name="line-54"></a><span class="cp"># define __libc_lock_unlock(NAME) do { } while (0)</span>
<a name="line-55"></a><span class="cp">#endif</span>
<a name="line-56"></a>
<a name="line-57"></a><span class="cp">#ifndef GAWK</span>
<a name="line-58"></a><span class="cm">/* In case that the system doesn&#39;t have isblank().  */</span>
<a name="line-59"></a><span class="cp">#if !defined _LIBC &amp;&amp; !defined HAVE_ISBLANK &amp;&amp; !defined isblank</span>
<a name="line-60"></a><span class="cp"># define isblank(ch) ((ch) == &#39; &#39; || (ch) == &#39;\t&#39;)</span>
<a name="line-61"></a><span class="cp">#endif</span>
<a name="line-62"></a><span class="cp">#else </span><span class="cm">/* GAWK */</span><span class="cp"></span>
<a name="line-63"></a><span class="cm">/*</span>
<a name="line-64"></a><span class="cm"> * This is a freaking mess. On glibc systems you have to define</span>
<a name="line-65"></a><span class="cm"> * a magic constant to get isblank() out of &lt;ctype.h&gt;, since it&#39;s</span>
<a name="line-66"></a><span class="cm"> * a C99 function.  To heck with all that and borrow a page from</span>
<a name="line-67"></a><span class="cm"> * dfa.c&#39;s book.</span>
<a name="line-68"></a><span class="cm"> */</span>
<a name="line-69"></a>
<a name="line-70"></a><span class="k">static</span> <span class="kt">int</span>
<a name="line-71"></a><span class="nf">is_blank</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
<a name="line-72"></a><span class="p">{</span>
<a name="line-73"></a>   <span class="k">return</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;\t&#39;</span><span class="p">);</span>
<a name="line-74"></a><span class="p">}</span>
<a name="line-75"></a><span class="cp">#endif </span><span class="cm">/* GAWK */</span><span class="cp"></span>
<a name="line-76"></a>
<a name="line-77"></a><span class="cp">#ifdef _LIBC</span>
<a name="line-78"></a><span class="cp"># ifndef _RE_DEFINE_LOCALE_FUNCTIONS</span>
<a name="line-79"></a><span class="cp">#  define _RE_DEFINE_LOCALE_FUNCTIONS 1</span>
<a name="line-80"></a><span class="cp">#   include &lt;locale/localeinfo.h&gt;</span>
<a name="line-81"></a><span class="cp">#   include &lt;locale/elem-hash.h&gt;</span>
<a name="line-82"></a><span class="cp">#   include &lt;locale/coll-lookup.h&gt;</span>
<a name="line-83"></a><span class="cp"># endif</span>
<a name="line-84"></a><span class="cp">#endif</span>
<a name="line-85"></a>
<a name="line-86"></a><span class="cm">/* This is for other GNU distributions with internationalized messages.  */</span>
<a name="line-87"></a><span class="cp">#if (HAVE_LIBINTL_H &amp;&amp; ENABLE_NLS) || defined _LIBC</span>
<a name="line-88"></a><span class="cp"># include &lt;libintl.h&gt;</span>
<a name="line-89"></a><span class="cp"># ifdef _LIBC</span>
<a name="line-90"></a><span class="cp">#  undef gettext</span>
<a name="line-91"></a><span class="cp">#  define gettext(msgid) \</span>
<a name="line-92"></a><span class="cp">  INTUSE(__dcgettext) (_libc_intl_domainname, msgid, LC_MESSAGES)</span>
<a name="line-93"></a><span class="cp"># endif</span>
<a name="line-94"></a><span class="cp">#else</span>
<a name="line-95"></a><span class="cp"># define gettext(msgid) (msgid)</span>
<a name="line-96"></a><span class="cp">#endif</span>
<a name="line-97"></a>
<a name="line-98"></a><span class="cp">#ifndef gettext_noop</span>
<a name="line-99"></a><span class="cm">/* This define is so xgettext can find the internationalizable</span>
<a name="line-100"></a><span class="cm">   strings.  */</span>
<a name="line-101"></a><span class="cp"># define gettext_noop(String) String</span>
<a name="line-102"></a><span class="cp">#endif</span>
<a name="line-103"></a>
<a name="line-104"></a><span class="cm">/* For loser systems without the definition.  */</span>
<a name="line-105"></a><span class="cp">#ifndef SIZE_MAX</span>
<a name="line-106"></a><span class="cp"># define SIZE_MAX ((size_t) -1)</span>
<a name="line-107"></a><span class="cp">#endif</span>
<a name="line-108"></a>
<a name="line-109"></a><span class="cp">#ifndef NO_MBSUPPORT</span>
<a name="line-110"></a><span class="cp">#include</span> <span class="cpf">&quot;mbsupport.h&quot; /* gawk */</span><span class="cp"></span>
<a name="line-111"></a><span class="cp">#endif</span>
<a name="line-112"></a><span class="cp">#ifndef MB_CUR_MAX</span>
<a name="line-113"></a><span class="cp">#define MB_CUR_MAX 1</span>
<a name="line-114"></a><span class="cp">#endif</span>
<a name="line-115"></a>
<a name="line-116"></a><span class="cp">#if (defined MBS_SUPPORT) || _LIBC</span>
<a name="line-117"></a><span class="cp"># define RE_ENABLE_I18N</span>
<a name="line-118"></a><span class="cp">#endif</span>
<a name="line-119"></a>
<a name="line-120"></a><span class="cp">#if __GNUC__ &gt;= 3</span>
<a name="line-121"></a><span class="cp"># define BE(expr, val) __builtin_expect (expr, val)</span>
<a name="line-122"></a><span class="cp">#else</span>
<a name="line-123"></a><span class="cp"># define BE(expr, val) (expr)</span>
<a name="line-124"></a><span class="cp"># ifdef inline</span>
<a name="line-125"></a><span class="cp"># undef inline</span>
<a name="line-126"></a><span class="cp"># endif</span>
<a name="line-127"></a><span class="cp"># define inline</span>
<a name="line-128"></a><span class="cp">#endif</span>
<a name="line-129"></a>
<a name="line-130"></a><span class="cm">/* Number of single byte character.  */</span>
<a name="line-131"></a><span class="cp">#define SBC_MAX 256</span>
<a name="line-132"></a>
<a name="line-133"></a><span class="cp">#define COLL_ELEM_LEN_MAX 8</span>
<a name="line-134"></a>
<a name="line-135"></a><span class="cm">/* The character which represents newline.  */</span>
<a name="line-136"></a><span class="cp">#define NEWLINE_CHAR &#39;\n&#39;</span>
<a name="line-137"></a><span class="cp">#define WIDE_NEWLINE_CHAR L&#39;\n&#39;</span>
<a name="line-138"></a>
<a name="line-139"></a><span class="cm">/* Rename to standard API for using out of glibc.  */</span>
<a name="line-140"></a><span class="cp">#ifndef _LIBC</span>
<a name="line-141"></a><span class="cp"># ifdef __wctype</span>
<a name="line-142"></a><span class="cp"># undef __wctype</span>
<a name="line-143"></a><span class="cp"># endif</span>
<a name="line-144"></a><span class="cp"># define __wctype wctype</span>
<a name="line-145"></a><span class="cp"># ifdef __iswctype</span>
<a name="line-146"></a><span class="cp"># undef __iswctype</span>
<a name="line-147"></a><span class="cp"># endif</span>
<a name="line-148"></a><span class="cp"># define __iswctype iswctype</span>
<a name="line-149"></a><span class="cp"># define __btowc btowc</span>
<a name="line-150"></a><span class="cp"># define __mbrtowc mbrtowc</span>
<a name="line-151"></a><span class="cp">#undef __mempcpy	</span><span class="cm">/* GAWK */</span><span class="cp"></span>
<a name="line-152"></a><span class="cp"># define __mempcpy mempcpy</span>
<a name="line-153"></a><span class="cp"># define __wcrtomb wcrtomb</span>
<a name="line-154"></a><span class="cp"># define __regfree regfree</span>
<a name="line-155"></a><span class="cp"># define attribute_hidden</span>
<a name="line-156"></a><span class="cp">#endif </span><span class="cm">/* not _LIBC */</span><span class="cp"></span>
<a name="line-157"></a>
<a name="line-158"></a><span class="cp">#ifdef __GNUC__</span>
<a name="line-159"></a><span class="cp"># define __attribute(arg) __attribute__ (arg)</span>
<a name="line-160"></a><span class="cp">#else</span>
<a name="line-161"></a><span class="cp"># define __attribute(arg)</span>
<a name="line-162"></a><span class="cp">#endif</span>
<a name="line-163"></a>
<a name="line-164"></a><span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__re_error_msgid</span><span class="p">[]</span> <span class="n">attribute_hidden</span><span class="p">;</span>
<a name="line-165"></a><span class="k">extern</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">__re_error_msgid_idx</span><span class="p">[]</span> <span class="n">attribute_hidden</span><span class="p">;</span>
<a name="line-166"></a>
<a name="line-167"></a><span class="cm">/* An integer used to represent a set of bits.  It must be unsigned,</span>
<a name="line-168"></a><span class="cm">   and must be at least as wide as unsigned int.  */</span>
<a name="line-169"></a><span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">bitset_word_t</span><span class="p">;</span>
<a name="line-170"></a><span class="cm">/* All bits set in a bitset_word_t.  */</span>
<a name="line-171"></a><span class="cp">#define BITSET_WORD_MAX ULONG_MAX</span>
<a name="line-172"></a><span class="cm">/* Number of bits in a bitset_word_t.  */</span>
<a name="line-173"></a><span class="cp">#define BITSET_WORD_BITS (sizeof (bitset_word_t) * CHAR_BIT)</span>
<a name="line-174"></a><span class="cm">/* Number of bitset_word_t in a bit_set.  */</span>
<a name="line-175"></a><span class="cp">#define BITSET_WORDS (SBC_MAX / BITSET_WORD_BITS)</span>
<a name="line-176"></a><span class="k">typedef</span> <span class="n">bitset_word_t</span> <span class="n">bitset_t</span><span class="p">[</span><span class="n">BITSET_WORDS</span><span class="p">];</span>
<a name="line-177"></a><span class="k">typedef</span> <span class="n">bitset_word_t</span> <span class="o">*</span><span class="n">re_bitset_ptr_t</span><span class="p">;</span>
<a name="line-178"></a><span class="k">typedef</span> <span class="k">const</span> <span class="n">bitset_word_t</span> <span class="o">*</span><span class="n">re_const_bitset_ptr_t</span><span class="p">;</span>
<a name="line-179"></a>
<a name="line-180"></a><span class="cp">#define bitset_set(set,i) \</span>
<a name="line-181"></a><span class="cp">  (set[i / BITSET_WORD_BITS] |= (bitset_word_t) 1 &lt;&lt; i % BITSET_WORD_BITS)</span>
<a name="line-182"></a><span class="cp">#define bitset_clear(set,i) \</span>
<a name="line-183"></a><span class="cp">  (set[i / BITSET_WORD_BITS] &amp;= ~((bitset_word_t) 1 &lt;&lt; i % BITSET_WORD_BITS))</span>
<a name="line-184"></a><span class="cp">#define bitset_contain(set,i) \</span>
<a name="line-185"></a><span class="cp">  (set[i / BITSET_WORD_BITS] &amp; ((bitset_word_t) 1 &lt;&lt; i % BITSET_WORD_BITS))</span>
<a name="line-186"></a><span class="cp">#define bitset_empty(set) memset (set, &#39;\0&#39;, sizeof (bitset_t))</span>
<a name="line-187"></a><span class="cp">#define bitset_set_all(set) memset (set, &#39;\xff&#39;, sizeof (bitset_t))</span>
<a name="line-188"></a><span class="cp">#define bitset_copy(dest,src) memcpy (dest, src, sizeof (bitset_t))</span>
<a name="line-189"></a>
<a name="line-190"></a><span class="cp">#define PREV_WORD_CONSTRAINT 0x0001</span>
<a name="line-191"></a><span class="cp">#define PREV_NOTWORD_CONSTRAINT 0x0002</span>
<a name="line-192"></a><span class="cp">#define NEXT_WORD_CONSTRAINT 0x0004</span>
<a name="line-193"></a><span class="cp">#define NEXT_NOTWORD_CONSTRAINT 0x0008</span>
<a name="line-194"></a><span class="cp">#define PREV_NEWLINE_CONSTRAINT 0x0010</span>
<a name="line-195"></a><span class="cp">#define NEXT_NEWLINE_CONSTRAINT 0x0020</span>
<a name="line-196"></a><span class="cp">#define PREV_BEGBUF_CONSTRAINT 0x0040</span>
<a name="line-197"></a><span class="cp">#define NEXT_ENDBUF_CONSTRAINT 0x0080</span>
<a name="line-198"></a><span class="cp">#define WORD_DELIM_CONSTRAINT 0x0100</span>
<a name="line-199"></a><span class="cp">#define NOT_WORD_DELIM_CONSTRAINT 0x0200</span>
<a name="line-200"></a>
<a name="line-201"></a><span class="k">typedef</span> <span class="k">enum</span>
<a name="line-202"></a><span class="p">{</span>
<a name="line-203"></a>  <span class="n">INSIDE_WORD</span> <span class="o">=</span> <span class="n">PREV_WORD_CONSTRAINT</span> <span class="o">|</span> <span class="n">NEXT_WORD_CONSTRAINT</span><span class="p">,</span>
<a name="line-204"></a>  <span class="n">WORD_FIRST</span> <span class="o">=</span> <span class="n">PREV_NOTWORD_CONSTRAINT</span> <span class="o">|</span> <span class="n">NEXT_WORD_CONSTRAINT</span><span class="p">,</span>
<a name="line-205"></a>  <span class="n">WORD_LAST</span> <span class="o">=</span> <span class="n">PREV_WORD_CONSTRAINT</span> <span class="o">|</span> <span class="n">NEXT_NOTWORD_CONSTRAINT</span><span class="p">,</span>
<a name="line-206"></a>  <span class="n">INSIDE_NOTWORD</span> <span class="o">=</span> <span class="n">PREV_NOTWORD_CONSTRAINT</span> <span class="o">|</span> <span class="n">NEXT_NOTWORD_CONSTRAINT</span><span class="p">,</span>
<a name="line-207"></a>  <span class="n">LINE_FIRST</span> <span class="o">=</span> <span class="n">PREV_NEWLINE_CONSTRAINT</span><span class="p">,</span>
<a name="line-208"></a>  <span class="n">LINE_LAST</span> <span class="o">=</span> <span class="n">NEXT_NEWLINE_CONSTRAINT</span><span class="p">,</span>
<a name="line-209"></a>  <span class="n">BUF_FIRST</span> <span class="o">=</span> <span class="n">PREV_BEGBUF_CONSTRAINT</span><span class="p">,</span>
<a name="line-210"></a>  <span class="n">BUF_LAST</span> <span class="o">=</span> <span class="n">NEXT_ENDBUF_CONSTRAINT</span><span class="p">,</span>
<a name="line-211"></a>  <span class="n">WORD_DELIM</span> <span class="o">=</span> <span class="n">WORD_DELIM_CONSTRAINT</span><span class="p">,</span>
<a name="line-212"></a>  <span class="n">NOT_WORD_DELIM</span> <span class="o">=</span> <span class="n">NOT_WORD_DELIM_CONSTRAINT</span>
<a name="line-213"></a><span class="p">}</span> <span class="n">re_context_type</span><span class="p">;</span>
<a name="line-214"></a>
<a name="line-215"></a><span class="k">typedef</span> <span class="k">struct</span>
<a name="line-216"></a><span class="p">{</span>
<a name="line-217"></a>  <span class="kt">int</span> <span class="n">alloc</span><span class="p">;</span>
<a name="line-218"></a>  <span class="kt">int</span> <span class="n">nelem</span><span class="p">;</span>
<a name="line-219"></a>  <span class="kt">int</span> <span class="o">*</span><span class="n">elems</span><span class="p">;</span>
<a name="line-220"></a><span class="p">}</span> <span class="n">re_node_set</span><span class="p">;</span>
<a name="line-221"></a>
<a name="line-222"></a><span class="k">typedef</span> <span class="k">enum</span>
<a name="line-223"></a><span class="p">{</span>
<a name="line-224"></a>  <span class="n">NON_TYPE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<a name="line-225"></a>
<a name="line-226"></a>  <span class="cm">/* Node type, These are used by token, node, tree.  */</span>
<a name="line-227"></a>  <span class="n">CHARACTER</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<a name="line-228"></a>  <span class="n">END_OF_RE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<a name="line-229"></a>  <span class="n">SIMPLE_BRACKET</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<a name="line-230"></a>  <span class="n">OP_BACK_REF</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<a name="line-231"></a>  <span class="n">OP_PERIOD</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<a name="line-232"></a><span class="cp">#ifdef RE_ENABLE_I18N</span>
<a name="line-233"></a>  <span class="n">COMPLEX_BRACKET</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
<a name="line-234"></a>  <span class="n">OP_UTF8_PERIOD</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
<a name="line-235"></a><span class="cp">#endif </span><span class="cm">/* RE_ENABLE_I18N */</span><span class="cp"></span>
<a name="line-236"></a>
<a name="line-237"></a>  <span class="cm">/* We define EPSILON_BIT as a macro so that OP_OPEN_SUBEXP is used</span>
<a name="line-238"></a><span class="cm">     when the debugger shows values of this enum type.  */</span>
<a name="line-239"></a><span class="cp">#define EPSILON_BIT 8</span>
<a name="line-240"></a>  <span class="n">OP_OPEN_SUBEXP</span> <span class="o">=</span> <span class="n">EPSILON_BIT</span> <span class="o">|</span> <span class="mi">0</span><span class="p">,</span>
<a name="line-241"></a>  <span class="n">OP_CLOSE_SUBEXP</span> <span class="o">=</span> <span class="n">EPSILON_BIT</span> <span class="o">|</span> <span class="mi">1</span><span class="p">,</span>
<a name="line-242"></a>  <span class="n">OP_ALT</span> <span class="o">=</span> <span class="n">EPSILON_BIT</span> <span class="o">|</span> <span class="mi">2</span><span class="p">,</span>
<a name="line-243"></a>  <span class="n">OP_DUP_ASTERISK</span> <span class="o">=</span> <span class="n">EPSILON_BIT</span> <span class="o">|</span> <span class="mi">3</span><span class="p">,</span>
<a name="line-244"></a>  <span class="n">ANCHOR</span> <span class="o">=</span> <span class="n">EPSILON_BIT</span> <span class="o">|</span> <span class="mi">4</span><span class="p">,</span>
<a name="line-245"></a>
<a name="line-246"></a>  <span class="cm">/* Tree type, these are used only by tree. */</span>
<a name="line-247"></a>  <span class="n">CONCAT</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
<a name="line-248"></a>  <span class="n">SUBEXP</span> <span class="o">=</span> <span class="mi">17</span><span class="p">,</span>
<a name="line-249"></a>
<a name="line-250"></a>  <span class="cm">/* Token type, these are used only by token.  */</span>
<a name="line-251"></a>  <span class="n">OP_DUP_PLUS</span> <span class="o">=</span> <span class="mi">18</span><span class="p">,</span>
<a name="line-252"></a>  <span class="n">OP_DUP_QUESTION</span><span class="p">,</span>
<a name="line-253"></a>  <span class="n">OP_OPEN_BRACKET</span><span class="p">,</span>
<a name="line-254"></a>  <span class="n">OP_CLOSE_BRACKET</span><span class="p">,</span>
<a name="line-255"></a>  <span class="n">OP_CHARSET_RANGE</span><span class="p">,</span>
<a name="line-256"></a>  <span class="n">OP_OPEN_DUP_NUM</span><span class="p">,</span>
<a name="line-257"></a>  <span class="n">OP_CLOSE_DUP_NUM</span><span class="p">,</span>
<a name="line-258"></a>  <span class="n">OP_NON_MATCH_LIST</span><span class="p">,</span>
<a name="line-259"></a>  <span class="n">OP_OPEN_COLL_ELEM</span><span class="p">,</span>
<a name="line-260"></a>  <span class="n">OP_CLOSE_COLL_ELEM</span><span class="p">,</span>
<a name="line-261"></a>  <span class="n">OP_OPEN_EQUIV_CLASS</span><span class="p">,</span>
<a name="line-262"></a>  <span class="n">OP_CLOSE_EQUIV_CLASS</span><span class="p">,</span>
<a name="line-263"></a>  <span class="n">OP_OPEN_CHAR_CLASS</span><span class="p">,</span>
<a name="line-264"></a>  <span class="n">OP_CLOSE_CHAR_CLASS</span><span class="p">,</span>
<a name="line-265"></a>  <span class="n">OP_WORD</span><span class="p">,</span>
<a name="line-266"></a>  <span class="n">OP_NOTWORD</span><span class="p">,</span>
<a name="line-267"></a>  <span class="n">OP_SPACE</span><span class="p">,</span>
<a name="line-268"></a>  <span class="n">OP_NOTSPACE</span><span class="p">,</span>
<a name="line-269"></a>  <span class="n">BACK_SLASH</span>
<a name="line-270"></a>
<a name="line-271"></a><span class="p">}</span> <span class="n">re_token_type_t</span><span class="p">;</span>
<a name="line-272"></a>
<a name="line-273"></a><span class="cp">#ifdef RE_ENABLE_I18N</span>
<a name="line-274"></a><span class="k">typedef</span> <span class="k">struct</span>
<a name="line-275"></a><span class="p">{</span>
<a name="line-276"></a>  <span class="cm">/* Multibyte characters.  */</span>
<a name="line-277"></a>  <span class="kt">wchar_t</span> <span class="o">*</span><span class="n">mbchars</span><span class="p">;</span>
<a name="line-278"></a>
<a name="line-279"></a>  <span class="cm">/* Collating symbols.  */</span>
<a name="line-280"></a><span class="cp"># ifdef _LIBC</span>
<a name="line-281"></a>  <span class="kt">int32_t</span> <span class="o">*</span><span class="n">coll_syms</span><span class="p">;</span>
<a name="line-282"></a><span class="cp"># endif</span>
<a name="line-283"></a>
<a name="line-284"></a>  <span class="cm">/* Equivalence classes. */</span>
<a name="line-285"></a><span class="cp"># ifdef _LIBC</span>
<a name="line-286"></a>  <span class="kt">int32_t</span> <span class="o">*</span><span class="n">equiv_classes</span><span class="p">;</span>
<a name="line-287"></a><span class="cp"># endif</span>
<a name="line-288"></a>
<a name="line-289"></a>  <span class="cm">/* Range expressions. */</span>
<a name="line-290"></a><span class="cp"># ifdef _LIBC</span>
<a name="line-291"></a>  <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">range_starts</span><span class="p">;</span>
<a name="line-292"></a>  <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">range_ends</span><span class="p">;</span>
<a name="line-293"></a><span class="cp"># else </span><span class="cm">/* not _LIBC */</span><span class="cp"></span>
<a name="line-294"></a>  <span class="kt">wchar_t</span> <span class="o">*</span><span class="n">range_starts</span><span class="p">;</span>
<a name="line-295"></a>  <span class="kt">wchar_t</span> <span class="o">*</span><span class="n">range_ends</span><span class="p">;</span>
<a name="line-296"></a><span class="cp"># endif </span><span class="cm">/* not _LIBC */</span><span class="cp"></span>
<a name="line-297"></a>
<a name="line-298"></a>  <span class="cm">/* Character classes. */</span>
<a name="line-299"></a>  <span class="kt">wctype_t</span> <span class="o">*</span><span class="n">char_classes</span><span class="p">;</span>
<a name="line-300"></a>
<a name="line-301"></a>  <span class="cm">/* If this character set is the non-matching list.  */</span>
<a name="line-302"></a>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">non_match</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-303"></a>
<a name="line-304"></a>  <span class="cm">/* # of multibyte characters.  */</span>
<a name="line-305"></a>  <span class="kt">int</span> <span class="n">nmbchars</span><span class="p">;</span>
<a name="line-306"></a>
<a name="line-307"></a>  <span class="cm">/* # of collating symbols.  */</span>
<a name="line-308"></a>  <span class="kt">int</span> <span class="n">ncoll_syms</span><span class="p">;</span>
<a name="line-309"></a>
<a name="line-310"></a>  <span class="cm">/* # of equivalence classes. */</span>
<a name="line-311"></a>  <span class="kt">int</span> <span class="n">nequiv_classes</span><span class="p">;</span>
<a name="line-312"></a>
<a name="line-313"></a>  <span class="cm">/* # of range expressions. */</span>
<a name="line-314"></a>  <span class="kt">int</span> <span class="n">nranges</span><span class="p">;</span>
<a name="line-315"></a>
<a name="line-316"></a>  <span class="cm">/* # of character classes. */</span>
<a name="line-317"></a>  <span class="kt">int</span> <span class="n">nchar_classes</span><span class="p">;</span>
<a name="line-318"></a><span class="p">}</span> <span class="n">re_charset_t</span><span class="p">;</span>
<a name="line-319"></a><span class="cp">#endif </span><span class="cm">/* RE_ENABLE_I18N */</span><span class="cp"></span>
<a name="line-320"></a>
<a name="line-321"></a><span class="k">typedef</span> <span class="k">struct</span>
<a name="line-322"></a><span class="p">{</span>
<a name="line-323"></a>  <span class="k">union</span>
<a name="line-324"></a>  <span class="p">{</span>
<a name="line-325"></a>    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>		<span class="cm">/* for CHARACTER */</span>
<a name="line-326"></a>    <span class="n">re_bitset_ptr_t</span> <span class="n">sbcset</span><span class="p">;</span>	<span class="cm">/* for SIMPLE_BRACKET */</span>
<a name="line-327"></a><span class="cp">#ifdef RE_ENABLE_I18N</span>
<a name="line-328"></a>    <span class="n">re_charset_t</span> <span class="o">*</span><span class="n">mbcset</span><span class="p">;</span>	<span class="cm">/* for COMPLEX_BRACKET */</span>
<a name="line-329"></a><span class="cp">#endif </span><span class="cm">/* RE_ENABLE_I18N */</span><span class="cp"></span>
<a name="line-330"></a>    <span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>			<span class="cm">/* for BACK_REF */</span>
<a name="line-331"></a>    <span class="n">re_context_type</span> <span class="n">ctx_type</span><span class="p">;</span>	<span class="cm">/* for ANCHOR */</span>
<a name="line-332"></a>  <span class="p">}</span> <span class="n">opr</span><span class="p">;</span>
<a name="line-333"></a><span class="cp">#if __GNUC__ &gt;= 2</span>
<a name="line-334"></a>  <span class="n">re_token_type_t</span> <span class="nl">type</span> <span class="p">:</span> <span class="mi">8</span><span class="p">;</span>
<a name="line-335"></a><span class="cp">#else</span>
<a name="line-336"></a>  <span class="n">re_token_type_t</span> <span class="n">type</span><span class="p">;</span>
<a name="line-337"></a><span class="cp">#endif</span>
<a name="line-338"></a>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">constraint</span> <span class="p">:</span> <span class="mi">10</span><span class="p">;</span>	<span class="cm">/* context constraint */</span>
<a name="line-339"></a>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">duplicated</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-340"></a>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">opt_subexp</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-341"></a><span class="cp">#ifdef RE_ENABLE_I18N</span>
<a name="line-342"></a>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">accept_mb</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-343"></a>  <span class="cm">/* These 2 bits can be moved into the union if needed (e.g. if running out</span>
<a name="line-344"></a><span class="cm">     of bits; move opr.c to opr.c.c and move the flags to opr.c.flags).  */</span>
<a name="line-345"></a>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">mb_partial</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-346"></a><span class="cp">#endif</span>
<a name="line-347"></a>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">word_char</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-348"></a><span class="p">}</span> <span class="n">re_token_t</span><span class="p">;</span>
<a name="line-349"></a>
<a name="line-350"></a><span class="cp">#define IS_EPSILON_NODE(type) ((type) &amp; EPSILON_BIT)</span>
<a name="line-351"></a>
<a name="line-352"></a><span class="k">struct</span> <span class="n">re_string_t</span>
<a name="line-353"></a><span class="p">{</span>
<a name="line-354"></a>  <span class="cm">/* Indicate the raw buffer which is the original string passed as an</span>
<a name="line-355"></a><span class="cm">     argument of regexec(), re_search(), etc..  */</span>
<a name="line-356"></a>  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">raw_mbs</span><span class="p">;</span>
<a name="line-357"></a>  <span class="cm">/* Store the multibyte string.  In case of &quot;case insensitive mode&quot; like</span>
<a name="line-358"></a><span class="cm">     REG_ICASE, upper cases of the string are stored, otherwise MBS points</span>
<a name="line-359"></a><span class="cm">     the same address that RAW_MBS points.  */</span>
<a name="line-360"></a>  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mbs</span><span class="p">;</span>
<a name="line-361"></a><span class="cp">#ifdef RE_ENABLE_I18N</span>
<a name="line-362"></a>  <span class="cm">/* Store the wide character string which is corresponding to MBS.  */</span>
<a name="line-363"></a>  <span class="kt">wint_t</span> <span class="o">*</span><span class="n">wcs</span><span class="p">;</span>
<a name="line-364"></a>  <span class="kt">int</span> <span class="o">*</span><span class="n">offsets</span><span class="p">;</span>
<a name="line-365"></a>  <span class="kt">mbstate_t</span> <span class="n">cur_state</span><span class="p">;</span>
<a name="line-366"></a><span class="cp">#endif</span>
<a name="line-367"></a>  <span class="cm">/* Index in RAW_MBS.  Each character mbs[i] corresponds to</span>
<a name="line-368"></a><span class="cm">     raw_mbs[raw_mbs_idx + i].  */</span>
<a name="line-369"></a>  <span class="kt">int</span> <span class="n">raw_mbs_idx</span><span class="p">;</span>
<a name="line-370"></a>  <span class="cm">/* The length of the valid characters in the buffers.  */</span>
<a name="line-371"></a>  <span class="kt">int</span> <span class="n">valid_len</span><span class="p">;</span>
<a name="line-372"></a>  <span class="cm">/* The corresponding number of bytes in raw_mbs array.  */</span>
<a name="line-373"></a>  <span class="kt">int</span> <span class="n">valid_raw_len</span><span class="p">;</span>
<a name="line-374"></a>  <span class="cm">/* The length of the buffers MBS and WCS.  */</span>
<a name="line-375"></a>  <span class="kt">int</span> <span class="n">bufs_len</span><span class="p">;</span>
<a name="line-376"></a>  <span class="cm">/* The index in MBS, which is updated by re_string_fetch_byte.  */</span>
<a name="line-377"></a>  <span class="kt">int</span> <span class="n">cur_idx</span><span class="p">;</span>
<a name="line-378"></a>  <span class="cm">/* length of RAW_MBS array.  */</span>
<a name="line-379"></a>  <span class="kt">int</span> <span class="n">raw_len</span><span class="p">;</span>
<a name="line-380"></a>  <span class="cm">/* This is RAW_LEN - RAW_MBS_IDX + VALID_LEN - VALID_RAW_LEN.  */</span>
<a name="line-381"></a>  <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
<a name="line-382"></a>  <span class="cm">/* End of the buffer may be shorter than its length in the cases such</span>
<a name="line-383"></a><span class="cm">     as re_match_2, re_search_2.  Then, we use STOP for end of the buffer</span>
<a name="line-384"></a><span class="cm">     instead of LEN.  */</span>
<a name="line-385"></a>  <span class="kt">int</span> <span class="n">raw_stop</span><span class="p">;</span>
<a name="line-386"></a>  <span class="cm">/* This is RAW_STOP - RAW_MBS_IDX adjusted through OFFSETS.  */</span>
<a name="line-387"></a>  <span class="kt">int</span> <span class="n">stop</span><span class="p">;</span>
<a name="line-388"></a>
<a name="line-389"></a>  <span class="cm">/* The context of mbs[0].  We store the context independently, since</span>
<a name="line-390"></a><span class="cm">     the context of mbs[0] may be different from raw_mbs[0], which is</span>
<a name="line-391"></a><span class="cm">     the beginning of the input string.  */</span>
<a name="line-392"></a>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tip_context</span><span class="p">;</span>
<a name="line-393"></a>  <span class="cm">/* The translation passed as a part of an argument of re_compile_pattern.  */</span>
<a name="line-394"></a>  <span class="n">RE_TRANSLATE_TYPE</span> <span class="n">trans</span><span class="p">;</span>
<a name="line-395"></a>  <span class="cm">/* Copy of re_dfa_t&#39;s word_char.  */</span>
<a name="line-396"></a>  <span class="n">re_const_bitset_ptr_t</span> <span class="n">word_char</span><span class="p">;</span>
<a name="line-397"></a>  <span class="cm">/* 1 if REG_ICASE.  */</span>
<a name="line-398"></a>  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">icase</span><span class="p">;</span>
<a name="line-399"></a>  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">is_utf8</span><span class="p">;</span>
<a name="line-400"></a>  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">map_notascii</span><span class="p">;</span>
<a name="line-401"></a>  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mbs_allocated</span><span class="p">;</span>
<a name="line-402"></a>  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">offsets_needed</span><span class="p">;</span>
<a name="line-403"></a>  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">newline_anchor</span><span class="p">;</span>
<a name="line-404"></a>  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">word_ops_used</span><span class="p">;</span>
<a name="line-405"></a>  <span class="kt">int</span> <span class="n">mb_cur_max</span><span class="p">;</span>
<a name="line-406"></a><span class="p">};</span>
<a name="line-407"></a><span class="k">typedef</span> <span class="k">struct</span> <span class="n">re_string_t</span> <span class="n">re_string_t</span><span class="p">;</span>
<a name="line-408"></a>
<a name="line-409"></a>
<a name="line-410"></a><span class="k">struct</span> <span class="n">re_dfa_t</span><span class="p">;</span>
<a name="line-411"></a><span class="k">typedef</span> <span class="k">struct</span> <span class="n">re_dfa_t</span> <span class="n">re_dfa_t</span><span class="p">;</span>
<a name="line-412"></a>
<a name="line-413"></a><span class="cp">#ifndef _LIBC</span>
<a name="line-414"></a><span class="cp"># ifdef __i386__</span>
<a name="line-415"></a><span class="cp">#  define internal_function   __attribute ((regparm (3), stdcall))</span>
<a name="line-416"></a><span class="cp"># else</span>
<a name="line-417"></a><span class="cp">#  define internal_function</span>
<a name="line-418"></a><span class="cp"># endif</span>
<a name="line-419"></a><span class="cp">#endif</span>
<a name="line-420"></a>
<a name="line-421"></a><span class="cp">#ifndef NOT_IN_libc</span>
<a name="line-422"></a><span class="k">static</span> <span class="n">reg_errcode_t</span> <span class="nf">re_string_realloc_buffers</span> <span class="p">(</span><span class="n">re_string_t</span> <span class="o">*</span><span class="n">pstr</span><span class="p">,</span>
<a name="line-423"></a>						<span class="kt">int</span> <span class="n">new_buf_len</span><span class="p">)</span>
<a name="line-424"></a>     <span class="n">internal_function</span><span class="p">;</span>
<a name="line-425"></a><span class="cp"># ifdef RE_ENABLE_I18N</span>
<a name="line-426"></a><span class="k">static</span> <span class="kt">void</span> <span class="nf">build_wcs_buffer</span> <span class="p">(</span><span class="n">re_string_t</span> <span class="o">*</span><span class="n">pstr</span><span class="p">)</span> <span class="n">internal_function</span><span class="p">;</span>
<a name="line-427"></a><span class="k">static</span> <span class="n">reg_errcode_t</span> <span class="nf">build_wcs_upper_buffer</span> <span class="p">(</span><span class="n">re_string_t</span> <span class="o">*</span><span class="n">pstr</span><span class="p">)</span>
<a name="line-428"></a>  <span class="n">internal_function</span><span class="p">;</span>
<a name="line-429"></a><span class="cp"># endif </span><span class="cm">/* RE_ENABLE_I18N */</span><span class="cp"></span>
<a name="line-430"></a><span class="k">static</span> <span class="kt">void</span> <span class="nf">build_upper_buffer</span> <span class="p">(</span><span class="n">re_string_t</span> <span class="o">*</span><span class="n">pstr</span><span class="p">)</span> <span class="n">internal_function</span><span class="p">;</span>
<a name="line-431"></a><span class="k">static</span> <span class="kt">void</span> <span class="nf">re_string_translate_buffer</span> <span class="p">(</span><span class="n">re_string_t</span> <span class="o">*</span><span class="n">pstr</span><span class="p">)</span> <span class="n">internal_function</span><span class="p">;</span>
<a name="line-432"></a><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">re_string_context_at</span> <span class="p">(</span><span class="k">const</span> <span class="n">re_string_t</span> <span class="o">*</span><span class="n">input</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span>
<a name="line-433"></a>					  <span class="kt">int</span> <span class="n">eflags</span><span class="p">)</span>
<a name="line-434"></a>     <span class="n">internal_function</span> <span class="n">__attribute</span> <span class="p">((</span><span class="n">pure</span><span class="p">));</span>
<a name="line-435"></a><span class="cp">#endif</span>
<a name="line-436"></a><span class="cp">#define re_string_peek_byte(pstr, offset) \</span>
<a name="line-437"></a><span class="cp">  ((pstr)-&gt;mbs[(pstr)-&gt;cur_idx + offset])</span>
<a name="line-438"></a><span class="cp">#define re_string_fetch_byte(pstr) \</span>
<a name="line-439"></a><span class="cp">  ((pstr)-&gt;mbs[(pstr)-&gt;cur_idx++])</span>
<a name="line-440"></a><span class="cp">#define re_string_first_byte(pstr, idx) \</span>
<a name="line-441"></a><span class="cp">  ((idx) == (pstr)-&gt;valid_len || (pstr)-&gt;wcs[idx] != WEOF)</span>
<a name="line-442"></a><span class="cp">#define re_string_is_single_byte_char(pstr, idx) \</span>
<a name="line-443"></a><span class="cp">  ((pstr)-&gt;wcs[idx] != WEOF &amp;&amp; ((pstr)-&gt;valid_len == (idx) + 1 \</span>
<a name="line-444"></a><span class="cp">				|| (pstr)-&gt;wcs[(idx) + 1] != WEOF))</span>
<a name="line-445"></a><span class="cp">#define re_string_eoi(pstr) ((pstr)-&gt;stop &lt;= (pstr)-&gt;cur_idx)</span>
<a name="line-446"></a><span class="cp">#define re_string_cur_idx(pstr) ((pstr)-&gt;cur_idx)</span>
<a name="line-447"></a><span class="cp">#define re_string_get_buffer(pstr) ((pstr)-&gt;mbs)</span>
<a name="line-448"></a><span class="cp">#define re_string_length(pstr) ((pstr)-&gt;len)</span>
<a name="line-449"></a><span class="cp">#define re_string_byte_at(pstr,idx) ((pstr)-&gt;mbs[idx])</span>
<a name="line-450"></a><span class="cp">#define re_string_skip_bytes(pstr,idx) ((pstr)-&gt;cur_idx += (idx))</span>
<a name="line-451"></a><span class="cp">#define re_string_set_index(pstr,idx) ((pstr)-&gt;cur_idx = (idx))</span>
<a name="line-452"></a>
<a name="line-453"></a><span class="cp">#ifndef _LIBC</span>
<a name="line-454"></a><span class="cp"># if HAVE_ALLOCA</span>
<a name="line-455"></a><span class="cp">#  if (_MSC_VER)</span>
<a name="line-456"></a><span class="cp">#   include &lt;malloc.h&gt;</span>
<a name="line-457"></a><span class="cp">#   define __libc_use_alloca(n) 0</span>
<a name="line-458"></a><span class="cp">#  else</span>
<a name="line-459"></a><span class="cp">#   include &lt;alloca.h&gt;</span>
<a name="line-460"></a><span class="cm">/* The OS usually guarantees only one guard page at the bottom of the stack,</span>
<a name="line-461"></a><span class="cm">   and a page size can be as small as 4096 bytes.  So we cannot safely</span>
<a name="line-462"></a><span class="cm">   allocate anything larger than 4096 bytes.  Also care for the possibility</span>
<a name="line-463"></a><span class="cm">   of a few compiler-allocated temporary stack slots.  */</span>
<a name="line-464"></a><span class="cp">#  define __libc_use_alloca(n) ((n) &lt; 4032)</span>
<a name="line-465"></a><span class="cp">#  endif</span>
<a name="line-466"></a><span class="cp"># else</span>
<a name="line-467"></a><span class="cm">/* alloca is implemented with malloc, so just use malloc.  */</span>
<a name="line-468"></a><span class="cp">#  define __libc_use_alloca(n) 0</span>
<a name="line-469"></a><span class="cp"># endif</span>
<a name="line-470"></a><span class="cp">#endif</span>
<a name="line-471"></a>
<a name="line-472"></a><span class="cp">#define re_malloc(t,n) ((t *) malloc ((n) * sizeof (t)))</span>
<a name="line-473"></a><span class="cm">/* SunOS 4.1.x realloc doesn&#39;t accept null pointers: pre-Standard C. Sigh. */</span>
<a name="line-474"></a><span class="cp">#define re_realloc(p,t,n) ((p != NULL) ? (t *) realloc (p,(n)*sizeof(t)) : (t *) calloc(n,sizeof(t)))</span>
<a name="line-475"></a><span class="cp">#define re_free(p) free (p)</span>
<a name="line-476"></a>
<a name="line-477"></a><span class="k">struct</span> <span class="n">bin_tree_t</span>
<a name="line-478"></a><span class="p">{</span>
<a name="line-479"></a>  <span class="k">struct</span> <span class="n">bin_tree_t</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
<a name="line-480"></a>  <span class="k">struct</span> <span class="n">bin_tree_t</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
<a name="line-481"></a>  <span class="k">struct</span> <span class="n">bin_tree_t</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
<a name="line-482"></a>  <span class="k">struct</span> <span class="n">bin_tree_t</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
<a name="line-483"></a>  <span class="k">struct</span> <span class="n">bin_tree_t</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<a name="line-484"></a>
<a name="line-485"></a>  <span class="n">re_token_t</span> <span class="n">token</span><span class="p">;</span>
<a name="line-486"></a>
<a name="line-487"></a>  <span class="cm">/* `node_idx&#39; is the index in dfa-&gt;nodes, if `type&#39; == 0.</span>
<a name="line-488"></a><span class="cm">     Otherwise `type&#39; indicate the type of this node.  */</span>
<a name="line-489"></a>  <span class="kt">int</span> <span class="n">node_idx</span><span class="p">;</span>
<a name="line-490"></a><span class="p">};</span>
<a name="line-491"></a><span class="k">typedef</span> <span class="k">struct</span> <span class="n">bin_tree_t</span> <span class="n">bin_tree_t</span><span class="p">;</span>
<a name="line-492"></a>
<a name="line-493"></a><span class="cp">#define BIN_TREE_STORAGE_SIZE \</span>
<a name="line-494"></a><span class="cp">  ((1024 - sizeof (void *)) / sizeof (bin_tree_t))</span>
<a name="line-495"></a>
<a name="line-496"></a><span class="k">struct</span> <span class="n">bin_tree_storage_t</span>
<a name="line-497"></a><span class="p">{</span>
<a name="line-498"></a>  <span class="k">struct</span> <span class="n">bin_tree_storage_t</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<a name="line-499"></a>  <span class="n">bin_tree_t</span> <span class="n">data</span><span class="p">[</span><span class="n">BIN_TREE_STORAGE_SIZE</span><span class="p">];</span>
<a name="line-500"></a><span class="p">};</span>
<a name="line-501"></a><span class="k">typedef</span> <span class="k">struct</span> <span class="n">bin_tree_storage_t</span> <span class="n">bin_tree_storage_t</span><span class="p">;</span>
<a name="line-502"></a>
<a name="line-503"></a><span class="cp">#define CONTEXT_WORD 1</span>
<a name="line-504"></a><span class="cp">#define CONTEXT_NEWLINE (CONTEXT_WORD &lt;&lt; 1)</span>
<a name="line-505"></a><span class="cp">#define CONTEXT_BEGBUF (CONTEXT_NEWLINE &lt;&lt; 1)</span>
<a name="line-506"></a><span class="cp">#define CONTEXT_ENDBUF (CONTEXT_BEGBUF &lt;&lt; 1)</span>
<a name="line-507"></a>
<a name="line-508"></a><span class="cp">#define IS_WORD_CONTEXT(c) ((c) &amp; CONTEXT_WORD)</span>
<a name="line-509"></a><span class="cp">#define IS_NEWLINE_CONTEXT(c) ((c) &amp; CONTEXT_NEWLINE)</span>
<a name="line-510"></a><span class="cp">#define IS_BEGBUF_CONTEXT(c) ((c) &amp; CONTEXT_BEGBUF)</span>
<a name="line-511"></a><span class="cp">#define IS_ENDBUF_CONTEXT(c) ((c) &amp; CONTEXT_ENDBUF)</span>
<a name="line-512"></a><span class="cp">#define IS_ORDINARY_CONTEXT(c) ((c) == 0)</span>
<a name="line-513"></a>
<a name="line-514"></a><span class="cp">#define IS_WORD_CHAR(ch) (isalnum (ch) || (ch) == &#39;_&#39;)</span>
<a name="line-515"></a><span class="cp">#define IS_NEWLINE(ch) ((ch) == NEWLINE_CHAR)</span>
<a name="line-516"></a><span class="cp">#define IS_WIDE_WORD_CHAR(ch) (iswalnum (ch) || (ch) == L&#39;_&#39;)</span>
<a name="line-517"></a><span class="cp">#define IS_WIDE_NEWLINE(ch) ((ch) == WIDE_NEWLINE_CHAR)</span>
<a name="line-518"></a>
<a name="line-519"></a><span class="cp">#define NOT_SATISFY_PREV_CONSTRAINT(constraint,context) \</span>
<a name="line-520"></a><span class="cp"> ((((constraint) &amp; PREV_WORD_CONSTRAINT) &amp;&amp; !IS_WORD_CONTEXT (context)) \</span>
<a name="line-521"></a><span class="cp">  || ((constraint &amp; PREV_NOTWORD_CONSTRAINT) &amp;&amp; IS_WORD_CONTEXT (context)) \</span>
<a name="line-522"></a><span class="cp">  || ((constraint &amp; PREV_NEWLINE_CONSTRAINT) &amp;&amp; !IS_NEWLINE_CONTEXT (context))\</span>
<a name="line-523"></a><span class="cp">  || ((constraint &amp; PREV_BEGBUF_CONSTRAINT) &amp;&amp; !IS_BEGBUF_CONTEXT (context)))</span>
<a name="line-524"></a>
<a name="line-525"></a><span class="cp">#define NOT_SATISFY_NEXT_CONSTRAINT(constraint,context) \</span>
<a name="line-526"></a><span class="cp"> ((((constraint) &amp; NEXT_WORD_CONSTRAINT) &amp;&amp; !IS_WORD_CONTEXT (context)) \</span>
<a name="line-527"></a><span class="cp">  || (((constraint) &amp; NEXT_NOTWORD_CONSTRAINT) &amp;&amp; IS_WORD_CONTEXT (context)) \</span>
<a name="line-528"></a><span class="cp">  || (((constraint) &amp; NEXT_NEWLINE_CONSTRAINT) &amp;&amp; !IS_NEWLINE_CONTEXT (context)) \</span>
<a name="line-529"></a><span class="cp">  || (((constraint) &amp; NEXT_ENDBUF_CONSTRAINT) &amp;&amp; !IS_ENDBUF_CONTEXT (context)))</span>
<a name="line-530"></a>
<a name="line-531"></a><span class="k">struct</span> <span class="n">re_dfastate_t</span>
<a name="line-532"></a><span class="p">{</span>
<a name="line-533"></a>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">;</span>
<a name="line-534"></a>  <span class="n">re_node_set</span> <span class="n">nodes</span><span class="p">;</span>
<a name="line-535"></a>  <span class="n">re_node_set</span> <span class="n">non_eps_nodes</span><span class="p">;</span>
<a name="line-536"></a>  <span class="n">re_node_set</span> <span class="n">inveclosure</span><span class="p">;</span>
<a name="line-537"></a>  <span class="n">re_node_set</span> <span class="o">*</span><span class="n">entrance_nodes</span><span class="p">;</span>
<a name="line-538"></a>  <span class="k">struct</span> <span class="n">re_dfastate_t</span> <span class="o">**</span><span class="n">trtable</span><span class="p">,</span> <span class="o">**</span><span class="n">word_trtable</span><span class="p">;</span>
<a name="line-539"></a>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">context</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>
<a name="line-540"></a>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">halt</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-541"></a>  <span class="cm">/* If this state can accept `multi byte&#39;.</span>
<a name="line-542"></a><span class="cm">     Note that we refer to multibyte characters, and multi character</span>
<a name="line-543"></a><span class="cm">     collating elements as `multi byte&#39;.  */</span>
<a name="line-544"></a>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">accept_mb</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-545"></a>  <span class="cm">/* If this state has backreference node(s).  */</span>
<a name="line-546"></a>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">has_backref</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-547"></a>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">has_constraint</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-548"></a><span class="p">};</span>
<a name="line-549"></a><span class="k">typedef</span> <span class="k">struct</span> <span class="n">re_dfastate_t</span> <span class="n">re_dfastate_t</span><span class="p">;</span>
<a name="line-550"></a>
<a name="line-551"></a><span class="k">struct</span> <span class="n">re_state_table_entry</span>
<a name="line-552"></a><span class="p">{</span>
<a name="line-553"></a>  <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
<a name="line-554"></a>  <span class="kt">int</span> <span class="n">alloc</span><span class="p">;</span>
<a name="line-555"></a>  <span class="n">re_dfastate_t</span> <span class="o">**</span><span class="n">array</span><span class="p">;</span>
<a name="line-556"></a><span class="p">};</span>
<a name="line-557"></a>
<a name="line-558"></a><span class="cm">/* Array type used in re_sub_match_last_t and re_sub_match_top_t.  */</span>
<a name="line-559"></a>
<a name="line-560"></a><span class="k">typedef</span> <span class="k">struct</span>
<a name="line-561"></a><span class="p">{</span>
<a name="line-562"></a>  <span class="kt">int</span> <span class="n">next_idx</span><span class="p">;</span>
<a name="line-563"></a>  <span class="kt">int</span> <span class="n">alloc</span><span class="p">;</span>
<a name="line-564"></a>  <span class="n">re_dfastate_t</span> <span class="o">**</span><span class="n">array</span><span class="p">;</span>
<a name="line-565"></a><span class="p">}</span> <span class="n">state_array_t</span><span class="p">;</span>
<a name="line-566"></a>
<a name="line-567"></a><span class="cm">/* Store information about the node NODE whose type is OP_CLOSE_SUBEXP.  */</span>
<a name="line-568"></a>
<a name="line-569"></a><span class="k">typedef</span> <span class="k">struct</span>
<a name="line-570"></a><span class="p">{</span>
<a name="line-571"></a>  <span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
<a name="line-572"></a>  <span class="kt">int</span> <span class="n">str_idx</span><span class="p">;</span> <span class="cm">/* The position NODE match at.  */</span>
<a name="line-573"></a>  <span class="n">state_array_t</span> <span class="n">path</span><span class="p">;</span>
<a name="line-574"></a><span class="p">}</span> <span class="n">re_sub_match_last_t</span><span class="p">;</span>
<a name="line-575"></a>
<a name="line-576"></a><span class="cm">/* Store information about the node NODE whose type is OP_OPEN_SUBEXP.</span>
<a name="line-577"></a><span class="cm">   And information about the node, whose type is OP_CLOSE_SUBEXP,</span>
<a name="line-578"></a><span class="cm">   corresponding to NODE is stored in LASTS.  */</span>
<a name="line-579"></a>
<a name="line-580"></a><span class="k">typedef</span> <span class="k">struct</span>
<a name="line-581"></a><span class="p">{</span>
<a name="line-582"></a>  <span class="kt">int</span> <span class="n">str_idx</span><span class="p">;</span>
<a name="line-583"></a>  <span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
<a name="line-584"></a>  <span class="n">state_array_t</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
<a name="line-585"></a>  <span class="kt">int</span> <span class="n">alasts</span><span class="p">;</span> <span class="cm">/* Allocation size of LASTS.  */</span>
<a name="line-586"></a>  <span class="kt">int</span> <span class="n">nlasts</span><span class="p">;</span> <span class="cm">/* The number of LASTS.  */</span>
<a name="line-587"></a>  <span class="n">re_sub_match_last_t</span> <span class="o">**</span><span class="n">lasts</span><span class="p">;</span>
<a name="line-588"></a><span class="p">}</span> <span class="n">re_sub_match_top_t</span><span class="p">;</span>
<a name="line-589"></a>
<a name="line-590"></a><span class="k">struct</span> <span class="n">re_backref_cache_entry</span>
<a name="line-591"></a><span class="p">{</span>
<a name="line-592"></a>  <span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
<a name="line-593"></a>  <span class="kt">int</span> <span class="n">str_idx</span><span class="p">;</span>
<a name="line-594"></a>  <span class="kt">int</span> <span class="n">subexp_from</span><span class="p">;</span>
<a name="line-595"></a>  <span class="kt">int</span> <span class="n">subexp_to</span><span class="p">;</span>
<a name="line-596"></a>  <span class="kt">char</span> <span class="n">more</span><span class="p">;</span>
<a name="line-597"></a>  <span class="kt">char</span> <span class="n">unused</span><span class="p">;</span>
<a name="line-598"></a>  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="kt">int</span> <span class="n">eps_reachable_subexps_map</span><span class="p">;</span>
<a name="line-599"></a><span class="p">};</span>
<a name="line-600"></a>
<a name="line-601"></a><span class="k">typedef</span> <span class="k">struct</span>
<a name="line-602"></a><span class="p">{</span>
<a name="line-603"></a>  <span class="cm">/* The string object corresponding to the input string.  */</span>
<a name="line-604"></a>  <span class="n">re_string_t</span> <span class="n">input</span><span class="p">;</span>
<a name="line-605"></a><span class="cp">#if defined _LIBC || (defined __STDC_VERSION__ &amp;&amp; __STDC_VERSION__ &gt;= 199901L)</span>
<a name="line-606"></a>  <span class="k">const</span> <span class="n">re_dfa_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">dfa</span><span class="p">;</span>
<a name="line-607"></a><span class="cp">#else</span>
<a name="line-608"></a>  <span class="k">const</span> <span class="n">re_dfa_t</span> <span class="o">*</span><span class="n">dfa</span><span class="p">;</span>
<a name="line-609"></a><span class="cp">#endif</span>
<a name="line-610"></a>  <span class="cm">/* EFLAGS of the argument of regexec.  */</span>
<a name="line-611"></a>  <span class="kt">int</span> <span class="n">eflags</span><span class="p">;</span>
<a name="line-612"></a>  <span class="cm">/* Where the matching ends.  */</span>
<a name="line-613"></a>  <span class="kt">int</span> <span class="n">match_last</span><span class="p">;</span>
<a name="line-614"></a>  <span class="kt">int</span> <span class="n">last_node</span><span class="p">;</span>
<a name="line-615"></a>  <span class="cm">/* The state log used by the matcher.  */</span>
<a name="line-616"></a>  <span class="n">re_dfastate_t</span> <span class="o">**</span><span class="n">state_log</span><span class="p">;</span>
<a name="line-617"></a>  <span class="kt">int</span> <span class="n">state_log_top</span><span class="p">;</span>
<a name="line-618"></a>  <span class="cm">/* Back reference cache.  */</span>
<a name="line-619"></a>  <span class="kt">int</span> <span class="n">nbkref_ents</span><span class="p">;</span>
<a name="line-620"></a>  <span class="kt">int</span> <span class="n">abkref_ents</span><span class="p">;</span>
<a name="line-621"></a>  <span class="k">struct</span> <span class="n">re_backref_cache_entry</span> <span class="o">*</span><span class="n">bkref_ents</span><span class="p">;</span>
<a name="line-622"></a>  <span class="kt">int</span> <span class="n">max_mb_elem_len</span><span class="p">;</span>
<a name="line-623"></a>  <span class="kt">int</span> <span class="n">nsub_tops</span><span class="p">;</span>
<a name="line-624"></a>  <span class="kt">int</span> <span class="n">asub_tops</span><span class="p">;</span>
<a name="line-625"></a>  <span class="n">re_sub_match_top_t</span> <span class="o">**</span><span class="n">sub_tops</span><span class="p">;</span>
<a name="line-626"></a><span class="p">}</span> <span class="n">re_match_context_t</span><span class="p">;</span>
<a name="line-627"></a>
<a name="line-628"></a><span class="k">typedef</span> <span class="k">struct</span>
<a name="line-629"></a><span class="p">{</span>
<a name="line-630"></a>  <span class="n">re_dfastate_t</span> <span class="o">**</span><span class="n">sifted_states</span><span class="p">;</span>
<a name="line-631"></a>  <span class="n">re_dfastate_t</span> <span class="o">**</span><span class="n">limited_states</span><span class="p">;</span>
<a name="line-632"></a>  <span class="kt">int</span> <span class="n">last_node</span><span class="p">;</span>
<a name="line-633"></a>  <span class="kt">int</span> <span class="n">last_str_idx</span><span class="p">;</span>
<a name="line-634"></a>  <span class="n">re_node_set</span> <span class="n">limits</span><span class="p">;</span>
<a name="line-635"></a><span class="p">}</span> <span class="n">re_sift_context_t</span><span class="p">;</span>
<a name="line-636"></a>
<a name="line-637"></a><span class="k">struct</span> <span class="n">re_fail_stack_ent_t</span>
<a name="line-638"></a><span class="p">{</span>
<a name="line-639"></a>  <span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
<a name="line-640"></a>  <span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
<a name="line-641"></a>  <span class="n">regmatch_t</span> <span class="o">*</span><span class="n">regs</span><span class="p">;</span>
<a name="line-642"></a>  <span class="n">re_node_set</span> <span class="n">eps_via_nodes</span><span class="p">;</span>
<a name="line-643"></a><span class="p">};</span>
<a name="line-644"></a>
<a name="line-645"></a><span class="k">struct</span> <span class="n">re_fail_stack_t</span>
<a name="line-646"></a><span class="p">{</span>
<a name="line-647"></a>  <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
<a name="line-648"></a>  <span class="kt">int</span> <span class="n">alloc</span><span class="p">;</span>
<a name="line-649"></a>  <span class="k">struct</span> <span class="n">re_fail_stack_ent_t</span> <span class="o">*</span><span class="n">stack</span><span class="p">;</span>
<a name="line-650"></a><span class="p">};</span>
<a name="line-651"></a>
<a name="line-652"></a><span class="k">struct</span> <span class="n">re_dfa_t</span>
<a name="line-653"></a><span class="p">{</span>
<a name="line-654"></a>  <span class="n">re_token_t</span> <span class="o">*</span><span class="n">nodes</span><span class="p">;</span>
<a name="line-655"></a>  <span class="kt">size_t</span> <span class="n">nodes_alloc</span><span class="p">;</span>
<a name="line-656"></a>  <span class="kt">size_t</span> <span class="n">nodes_len</span><span class="p">;</span>
<a name="line-657"></a>  <span class="kt">int</span> <span class="o">*</span><span class="n">nexts</span><span class="p">;</span>
<a name="line-658"></a>  <span class="kt">int</span> <span class="o">*</span><span class="n">org_indices</span><span class="p">;</span>
<a name="line-659"></a>  <span class="n">re_node_set</span> <span class="o">*</span><span class="n">edests</span><span class="p">;</span>
<a name="line-660"></a>  <span class="n">re_node_set</span> <span class="o">*</span><span class="n">eclosures</span><span class="p">;</span>
<a name="line-661"></a>  <span class="n">re_node_set</span> <span class="o">*</span><span class="n">inveclosures</span><span class="p">;</span>
<a name="line-662"></a>  <span class="k">struct</span> <span class="n">re_state_table_entry</span> <span class="o">*</span><span class="n">state_table</span><span class="p">;</span>
<a name="line-663"></a>  <span class="n">re_dfastate_t</span> <span class="o">*</span><span class="n">init_state</span><span class="p">;</span>
<a name="line-664"></a>  <span class="n">re_dfastate_t</span> <span class="o">*</span><span class="n">init_state_word</span><span class="p">;</span>
<a name="line-665"></a>  <span class="n">re_dfastate_t</span> <span class="o">*</span><span class="n">init_state_nl</span><span class="p">;</span>
<a name="line-666"></a>  <span class="n">re_dfastate_t</span> <span class="o">*</span><span class="n">init_state_begbuf</span><span class="p">;</span>
<a name="line-667"></a>  <span class="n">bin_tree_t</span> <span class="o">*</span><span class="n">str_tree</span><span class="p">;</span>
<a name="line-668"></a>  <span class="n">bin_tree_storage_t</span> <span class="o">*</span><span class="n">str_tree_storage</span><span class="p">;</span>
<a name="line-669"></a>  <span class="n">re_bitset_ptr_t</span> <span class="n">sb_char</span><span class="p">;</span>
<a name="line-670"></a>  <span class="kt">int</span> <span class="n">str_tree_storage_idx</span><span class="p">;</span>
<a name="line-671"></a>
<a name="line-672"></a>  <span class="cm">/* number of subexpressions `re_nsub&#39; is in regex_t.  */</span>
<a name="line-673"></a>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">state_hash_mask</span><span class="p">;</span>
<a name="line-674"></a>  <span class="kt">int</span> <span class="n">init_node</span><span class="p">;</span>
<a name="line-675"></a>  <span class="kt">int</span> <span class="n">nbackref</span><span class="p">;</span> <span class="cm">/* The number of backreference in this dfa.  */</span>
<a name="line-676"></a>
<a name="line-677"></a>  <span class="cm">/* Bitmap expressing which backreference is used.  */</span>
<a name="line-678"></a>  <span class="n">bitset_word_t</span> <span class="n">used_bkref_map</span><span class="p">;</span>
<a name="line-679"></a>  <span class="n">bitset_word_t</span> <span class="n">completed_bkref_map</span><span class="p">;</span>
<a name="line-680"></a>
<a name="line-681"></a>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">has_plural_match</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-682"></a>  <span class="cm">/* If this dfa has &quot;multibyte node&quot;, which is a backreference or</span>
<a name="line-683"></a><span class="cm">     a node which can accept multibyte character or multi character</span>
<a name="line-684"></a><span class="cm">     collating element.  */</span>
<a name="line-685"></a>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">has_mb_node</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-686"></a>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">is_utf8</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-687"></a>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">map_notascii</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-688"></a>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">word_ops_used</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-689"></a>  <span class="kt">int</span> <span class="n">mb_cur_max</span><span class="p">;</span>
<a name="line-690"></a>  <span class="n">bitset_t</span> <span class="n">word_char</span><span class="p">;</span>
<a name="line-691"></a>  <span class="n">reg_syntax_t</span> <span class="n">syntax</span><span class="p">;</span>
<a name="line-692"></a>  <span class="kt">int</span> <span class="o">*</span><span class="n">subexp_map</span><span class="p">;</span>
<a name="line-693"></a><span class="cp">#ifdef DEBUG</span>
<a name="line-694"></a>  <span class="kt">char</span><span class="o">*</span> <span class="n">re_str</span><span class="p">;</span>
<a name="line-695"></a><span class="cp">#endif</span>
<a name="line-696"></a><span class="cp">#if defined _LIBC</span>
<a name="line-697"></a><span class="hll">  <span class="n">__libc_lock_define</span> <span class="p">(,</span> <span class="n">lock</span><span class="p">)</span><span class="error2">&lt;--- syntax error</span>
</span><a name="line-698"></a><span class="cp">#endif</span>
<a name="line-699"></a><span class="p">};</span>
<a name="line-700"></a>
<a name="line-701"></a><span class="cp">#define re_node_set_init_empty(set) memset (set, &#39;\0&#39;, sizeof (re_node_set))</span>
<a name="line-702"></a><span class="cp">#define re_node_set_remove(set,id) \</span>
<a name="line-703"></a><span class="cp">  (re_node_set_remove_at (set, re_node_set_contains (set, id) - 1))</span>
<a name="line-704"></a><span class="cp">#define re_node_set_empty(p) ((p)-&gt;nelem = 0)</span>
<a name="line-705"></a><span class="cp">#define re_node_set_free(set) re_free ((set)-&gt;elems)</span>
<a name="line-706"></a>
<a name="line-707"></a>
<a name="line-708"></a><span class="k">typedef</span> <span class="k">enum</span>
<a name="line-709"></a><span class="p">{</span>
<a name="line-710"></a>  <span class="n">SB_CHAR</span><span class="p">,</span>
<a name="line-711"></a>  <span class="n">MB_CHAR</span><span class="p">,</span>
<a name="line-712"></a>  <span class="n">EQUIV_CLASS</span><span class="p">,</span>
<a name="line-713"></a>  <span class="n">COLL_SYM</span><span class="p">,</span>
<a name="line-714"></a>  <span class="n">CHAR_CLASS</span>
<a name="line-715"></a><span class="p">}</span> <span class="n">bracket_elem_type</span><span class="p">;</span>
<a name="line-716"></a>
<a name="line-717"></a><span class="k">typedef</span> <span class="k">struct</span>
<a name="line-718"></a><span class="p">{</span>
<a name="line-719"></a>  <span class="n">bracket_elem_type</span> <span class="n">type</span><span class="p">;</span>
<a name="line-720"></a>  <span class="k">union</span>
<a name="line-721"></a>  <span class="p">{</span>
<a name="line-722"></a>    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
<a name="line-723"></a>    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<a name="line-724"></a>    <span class="kt">wchar_t</span> <span class="n">wch</span><span class="p">;</span>
<a name="line-725"></a>  <span class="p">}</span> <span class="n">opr</span><span class="p">;</span>
<a name="line-726"></a><span class="p">}</span> <span class="n">bracket_elem_t</span><span class="p">;</span>
<a name="line-727"></a>
<a name="line-728"></a>
<a name="line-729"></a><span class="cm">/* Inline functions for bitset operation.  */</span>
<a name="line-730"></a><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<a name="line-731"></a><span class="nf">bitset_not</span> <span class="p">(</span><span class="n">bitset_t</span> <span class="n">set</span><span class="p">)</span>
<a name="line-732"></a><span class="p">{</span>
<a name="line-733"></a>  <span class="kt">int</span> <span class="n">bitset_i</span><span class="p">;</span>
<a name="line-734"></a>  <span class="k">for</span> <span class="p">(</span><span class="n">bitset_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bitset_i</span> <span class="o">&lt;</span> <span class="n">BITSET_WORDS</span><span class="p">;</span> <span class="o">++</span><span class="n">bitset_i</span><span class="p">)</span>
<a name="line-735"></a>    <span class="n">set</span><span class="p">[</span><span class="n">bitset_i</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">set</span><span class="p">[</span><span class="n">bitset_i</span><span class="p">];</span>
<a name="line-736"></a><span class="p">}</span>
<a name="line-737"></a>
<a name="line-738"></a><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<a name="line-739"></a><span class="nf">bitset_merge</span> <span class="p">(</span><span class="n">bitset_t</span> <span class="n">dest</span><span class="p">,</span> <span class="k">const</span> <span class="n">bitset_t</span> <span class="n">src</span><span class="p">)</span>
<a name="line-740"></a><span class="p">{</span>
<a name="line-741"></a>  <span class="kt">int</span> <span class="n">bitset_i</span><span class="p">;</span>
<a name="line-742"></a>  <span class="k">for</span> <span class="p">(</span><span class="n">bitset_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bitset_i</span> <span class="o">&lt;</span> <span class="n">BITSET_WORDS</span><span class="p">;</span> <span class="o">++</span><span class="n">bitset_i</span><span class="p">)</span>
<a name="line-743"></a>    <span class="n">dest</span><span class="p">[</span><span class="n">bitset_i</span><span class="p">]</span> <span class="o">|=</span> <span class="n">src</span><span class="p">[</span><span class="n">bitset_i</span><span class="p">];</span>
<a name="line-744"></a><span class="p">}</span>
<a name="line-745"></a>
<a name="line-746"></a><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<a name="line-747"></a><span class="nf">bitset_mask</span> <span class="p">(</span><span class="n">bitset_t</span> <span class="n">dest</span><span class="p">,</span> <span class="k">const</span> <span class="n">bitset_t</span> <span class="n">src</span><span class="p">)</span>
<a name="line-748"></a><span class="p">{</span>
<a name="line-749"></a>  <span class="kt">int</span> <span class="n">bitset_i</span><span class="p">;</span>
<a name="line-750"></a>  <span class="k">for</span> <span class="p">(</span><span class="n">bitset_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bitset_i</span> <span class="o">&lt;</span> <span class="n">BITSET_WORDS</span><span class="p">;</span> <span class="o">++</span><span class="n">bitset_i</span><span class="p">)</span>
<a name="line-751"></a>    <span class="n">dest</span><span class="p">[</span><span class="n">bitset_i</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">src</span><span class="p">[</span><span class="n">bitset_i</span><span class="p">];</span>
<a name="line-752"></a><span class="p">}</span>
<a name="line-753"></a>
<a name="line-754"></a><span class="cp">#ifdef RE_ENABLE_I18N</span>
<a name="line-755"></a><span class="cm">/* Inline functions for re_string.  */</span>
<a name="line-756"></a><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<a name="line-757"></a><span class="n">internal_function</span> <span class="nf">__attribute</span> <span class="p">((</span><span class="n">pure</span><span class="p">))</span>
<a name="line-758"></a><span class="n">re_string_char_size_at</span> <span class="p">(</span><span class="k">const</span> <span class="n">re_string_t</span> <span class="o">*</span><span class="n">pstr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<a name="line-759"></a><span class="p">{</span>
<a name="line-760"></a>  <span class="kt">int</span> <span class="n">byte_idx</span><span class="p">;</span>
<a name="line-761"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">pstr</span><span class="o">-&gt;</span><span class="n">mb_cur_max</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<a name="line-762"></a>    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-763"></a>  <span class="k">for</span> <span class="p">(</span><span class="n">byte_idx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">byte_idx</span> <span class="o">&lt;</span> <span class="n">pstr</span><span class="o">-&gt;</span><span class="n">valid_len</span><span class="p">;</span> <span class="o">++</span><span class="n">byte_idx</span><span class="p">)</span>
<a name="line-764"></a>    <span class="k">if</span> <span class="p">(</span><span class="n">pstr</span><span class="o">-&gt;</span><span class="n">wcs</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="n">byte_idx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">WEOF</span><span class="p">)</span>
<a name="line-765"></a>      <span class="k">break</span><span class="p">;</span>
<a name="line-766"></a>  <span class="k">return</span> <span class="n">byte_idx</span><span class="p">;</span>
<a name="line-767"></a><span class="p">}</span>
<a name="line-768"></a>
<a name="line-769"></a><span class="k">static</span> <span class="kr">inline</span> <span class="kt">wint_t</span>
<a name="line-770"></a><span class="n">internal_function</span> <span class="nf">__attribute</span> <span class="p">((</span><span class="n">pure</span><span class="p">))</span>
<a name="line-771"></a><span class="n">re_string_wchar_at</span> <span class="p">(</span><span class="k">const</span> <span class="n">re_string_t</span> <span class="o">*</span><span class="n">pstr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<a name="line-772"></a><span class="p">{</span>
<a name="line-773"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">pstr</span><span class="o">-&gt;</span><span class="n">mb_cur_max</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<a name="line-774"></a>    <span class="k">return</span> <span class="p">(</span><span class="kt">wint_t</span><span class="p">)</span> <span class="n">pstr</span><span class="o">-&gt;</span><span class="n">mbs</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
<a name="line-775"></a>  <span class="k">return</span> <span class="p">(</span><span class="kt">wint_t</span><span class="p">)</span> <span class="n">pstr</span><span class="o">-&gt;</span><span class="n">wcs</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
<a name="line-776"></a><span class="p">}</span>
<a name="line-777"></a>
<a name="line-778"></a><span class="cp"># ifndef NOT_IN_libc</span>
<a name="line-779"></a><span class="k">static</span> <span class="kt">int</span>
<a name="line-780"></a><span class="n">internal_function</span> <span class="nf">__attribute</span> <span class="p">((</span><span class="n">pure</span><span class="p">))</span>
<a name="line-781"></a><span class="n">re_string_elem_size_at</span> <span class="p">(</span><span class="k">const</span> <span class="n">re_string_t</span> <span class="o">*</span><span class="n">pstr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<a name="line-782"></a><span class="p">{</span>
<a name="line-783"></a><span class="cp">#  ifdef _LIBC</span>
<a name="line-784"></a>  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">extra</span><span class="p">;</span>
<a name="line-785"></a>  <span class="k">const</span> <span class="kt">int32_t</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="o">*</span><span class="n">indirect</span><span class="p">;</span>
<a name="line-786"></a>  <span class="kt">int32_t</span> <span class="n">tmp</span><span class="p">;</span>
<a name="line-787"></a><span class="cp">#   include &lt;locale/weight.h&gt;</span>
<a name="line-788"></a>  <span class="kt">uint_fast32_t</span> <span class="n">nrules</span> <span class="o">=</span> <span class="n">_NL_CURRENT_WORD</span> <span class="p">(</span><span class="n">LC_COLLATE</span><span class="p">,</span> <span class="n">_NL_COLLATE_NRULES</span><span class="p">);</span>
<a name="line-789"></a>
<a name="line-790"></a>  <span class="k">if</span> <span class="p">(</span><span class="n">nrules</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<a name="line-791"></a>    <span class="p">{</span>
<a name="line-792"></a>      <span class="n">table</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">_NL_CURRENT</span> <span class="p">(</span><span class="n">LC_COLLATE</span><span class="p">,</span> <span class="n">_NL_COLLATE_TABLEMB</span><span class="p">);</span>
<a name="line-793"></a>      <span class="n">extra</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span>
<a name="line-794"></a>	<span class="n">_NL_CURRENT</span> <span class="p">(</span><span class="n">LC_COLLATE</span><span class="p">,</span> <span class="n">_NL_COLLATE_EXTRAMB</span><span class="p">);</span>
<a name="line-795"></a>      <span class="n">indirect</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">_NL_CURRENT</span> <span class="p">(</span><span class="n">LC_COLLATE</span><span class="p">,</span>
<a name="line-796"></a>						<span class="n">_NL_COLLATE_INDIRECTMB</span><span class="p">);</span>
<a name="line-797"></a>      <span class="n">p</span> <span class="o">=</span> <span class="n">pstr</span><span class="o">-&gt;</span><span class="n">mbs</span> <span class="o">+</span> <span class="n">idx</span><span class="p">;</span>
<a name="line-798"></a>      <span class="n">tmp</span> <span class="o">=</span> <span class="n">findidx</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
<a name="line-799"></a>      <span class="k">return</span> <span class="n">p</span> <span class="o">-</span> <span class="n">pstr</span><span class="o">-&gt;</span><span class="n">mbs</span> <span class="o">-</span> <span class="n">idx</span><span class="p">;</span>
<a name="line-800"></a>    <span class="p">}</span>
<a name="line-801"></a>  <span class="k">else</span>
<a name="line-802"></a><span class="cp">#  endif </span><span class="cm">/* _LIBC */</span><span class="cp"></span>
<a name="line-803"></a>    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-804"></a><span class="p">}</span>
<a name="line-805"></a><span class="cp"># endif</span>
<a name="line-806"></a><span class="cp">#endif </span><span class="cm">/* RE_ENABLE_I18N */</span><span class="cp"></span>
<a name="line-807"></a>
<a name="line-808"></a><span class="cp">#endif </span><span class="cm">/*  _REGEX_INTERNAL_H */</span><span class="cp"></span>
</pre></div>
</td></tr></table>
      </div> <!-- /.wrapper -->
    </div>
    <div id="footer" class="footer">
      <p>
        Cppcheck 2.2 - a tool for static C/C++ code analysis<br>
        <br>
        Internet: <a href="http://cppcheck.net">http://cppcheck.net</a><br>
        IRC: <a href="irc://irc.freenode.net/cppcheck">irc://irc.freenode.net/cppcheck</a><br>
      </p>
    </div>
  </body>
</html>
