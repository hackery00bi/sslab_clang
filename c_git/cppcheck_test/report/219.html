
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Cppcheck - HTML report - [project name]</title>
    <link rel="stylesheet" href="style.css">
    <style>
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #ffffff; }
.highlight .c { color: #888888 } /* Comment */
.highlight .err { color: #FF0000; background-color: #FFAAAA } /* Error */
.highlight .k { color: #008800; font-weight: bold } /* Keyword */
.highlight .o { color: #333333 } /* Operator */
.highlight .ch { color: #888888 } /* Comment.Hashbang */
.highlight .cm { color: #888888 } /* Comment.Multiline */
.highlight .cp { color: #557799 } /* Comment.Preproc */
.highlight .cpf { color: #888888 } /* Comment.PreprocFile */
.highlight .c1 { color: #888888 } /* Comment.Single */
.highlight .cs { color: #cc0000; font-weight: bold } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008800; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008800; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008800; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #003388; font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { color: #008800; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #333399; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #6600EE; font-weight: bold } /* Literal.Number */
.highlight .s { background-color: #fff0f0 } /* Literal.String */
.highlight .na { color: #0000CC } /* Name.Attribute */
.highlight .nb { color: #007020 } /* Name.Builtin */
.highlight .nc { color: #BB0066; font-weight: bold } /* Name.Class */
.highlight .no { color: #003366; font-weight: bold } /* Name.Constant */
.highlight .nd { color: #555555; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #880000; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #FF0000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0066BB; font-weight: bold } /* Name.Function */
.highlight .nl { color: #997700; font-weight: bold } /* Name.Label */
.highlight .nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #007700 } /* Name.Tag */
.highlight .nv { color: #996633 } /* Name.Variable */
.highlight .ow { color: #000000; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #6600EE; font-weight: bold } /* Literal.Number.Bin */
.highlight .mf { color: #6600EE; font-weight: bold } /* Literal.Number.Float */
.highlight .mh { color: #005588; font-weight: bold } /* Literal.Number.Hex */
.highlight .mi { color: #0000DD; font-weight: bold } /* Literal.Number.Integer */
.highlight .mo { color: #4400EE; font-weight: bold } /* Literal.Number.Oct */
.highlight .sa { background-color: #fff0f0 } /* Literal.String.Affix */
.highlight .sb { background-color: #fff0f0 } /* Literal.String.Backtick */
.highlight .sc { color: #0044DD } /* Literal.String.Char */
.highlight .dl { background-color: #fff0f0 } /* Literal.String.Delimiter */
.highlight .sd { color: #DD4422 } /* Literal.String.Doc */
.highlight .s2 { background-color: #fff0f0 } /* Literal.String.Double */
.highlight .se { color: #666666; font-weight: bold; background-color: #fff0f0 } /* Literal.String.Escape */
.highlight .sh { background-color: #fff0f0 } /* Literal.String.Heredoc */
.highlight .si { background-color: #eeeeee } /* Literal.String.Interpol */
.highlight .sx { color: #DD2200; background-color: #fff0f0 } /* Literal.String.Other */
.highlight .sr { color: #000000; background-color: #fff0ff } /* Literal.String.Regex */
.highlight .s1 { background-color: #fff0f0 } /* Literal.String.Single */
.highlight .ss { color: #AA6600 } /* Literal.String.Symbol */
.highlight .bp { color: #007020 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #0066BB; font-weight: bold } /* Name.Function.Magic */
.highlight .vc { color: #336699 } /* Name.Variable.Class */
.highlight .vg { color: #dd7700; font-weight: bold } /* Name.Variable.Global */
.highlight .vi { color: #3333BB } /* Name.Variable.Instance */
.highlight .vm { color: #996633 } /* Name.Variable.Magic */
.highlight .il { color: #0000DD; font-weight: bold } /* Literal.Number.Integer.Long */
    </style>
    <script>
      function getStyle(el, styleProp) {
        var y;

        if (el.currentStyle) {
          y = el.currentStyle[styleProp];
        } else if (window.getComputedStyle) {
          y = document.defaultView.getComputedStyle(el, null).getPropertyValue(styleProp);
        }

        return y;
      }

      function toggle() {
        var el = this.expandable_content;
        var mark = this.expandable_marker;

        if (el.style.display === "block") {
          el.style.display = "none";
          mark.textContent = "[+]";
        } else {
          el.style.display = "block";
          mark.textContent = "[-]";
        }
      }

      function initExpandables() {
        var elements = document.querySelectorAll(".expandable");

        for (var i = 0, len = elements.length; i < len; i++) {
          var el = elements[i];
          var clickable = el.querySelector("span");
          var marker = clickable.querySelector(".marker");
          var content = el.querySelector(".content");
          var width = clickable.clientWidth - parseInt(getStyle(content, "padding-left")) - parseInt(getStyle(content, "padding-right"));
          content.style.width = width + "px";
          clickable.expandable_content = content;
          clickable.expandable_marker = marker;
          clickable.addEventListener("click", toggle);
        }
      }

      function toggleDisplay(id) {
        var elements = document.querySelectorAll("." + id);

        for (var i = 0, len = elements.length; i < len; i++) {
          elements[i].classList.toggle("d-none");
        }
      }

      function toggleAll() {
        var elements = document.querySelectorAll("input");

        // starting from 1 since 0 is the "toggle all" input
        for (var i = 1, len = elements.length; i < len; i++) {
          var el = elements[i];

          if (el.checked) {
            el.checked = false;
          } else {
            el.checked = true;
          }

          toggleDisplay(el.id);
        }
      }
      window.addEventListener("load", initExpandables);
    </script>
  </head>
  <body>
    <div id="header" class="header">
      <h1>Cppcheck report - [project name]: /tmp/sslab_clang/c_git/git/refs.h</h1>
    </div>
    <div class="wrapper">
      <div id="menu">
       <p id="filename"><a href="index.html">Defects:</a> refs.h</p>
<a href="219.html#line-385"> nullPointerRedundantCheck 385</a><a href="219.html#line-385"> ctunullpointer 385</a>
    </div>
    <div id="content">
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561
562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580
581
582
583
584
585
586
587
588
589
590
591
592
593
594
595
596
597
598
599
600
601
602
603
604
605
606
607
608
609
610
611
612
613
614
615
616
617
618
619
620
621
622
623
624
625
626
627
628
629
630
631
632
633
634
635
636
637
638
639
640
641
642
643
644
645
646
647
648
649
650
651
652
653
654
655
656
657
658
659
660
661
662
663
664
665
666
667
668
669
670
671
672
673
674
675
676
677
678
679
680
681
682
683
684
685
686
687
688
689
690
691
692
693
694
695
696
697
698
699
700
701
702
703
704
705
706
707
708
709
710
711
712
713
714
715
716
717
718
719
720
721
722
723
724
725
726
727
728
729
730
731
732
733
734
735
736
737
738
739
740
741
742
743
744
745
746
747
748
749
750
751
752
753
754
755
756
757
758
759
760
761
762
763
764
765
766
767
768
769
770
771
772
773
774
775
776
777
778
779
780
781
782
783
784
785
786
787
788
789
790
791
792
793
794
795
796
797
798
799
800
801
802
803
804
805
806
807
808
809
810
811
812
813
814
815
816
817
818
819
820
821
822
823
824
825
826
827
828
829
830
831
832
833
834
835
836
837
838
839
840
841
842
843
844
845
846
847
848
849
850
851
852
853
854
855
856
857
858
859
860
861
862
863
864
865
866
867
868
869
870
871
872
873
874
875
876
877
878
879
880
881</pre></div></td><td class="code"><div class="highlight"><pre><span></span><a name="line-1"></a><span class="cp">#ifndef REFS_H</span>
<a name="line-2"></a><span class="cp">#define REFS_H</span>
<a name="line-3"></a>
<a name="line-4"></a><span class="cp">#include</span> <span class="cpf">&quot;cache.h&quot;</span><span class="cp"></span>
<a name="line-5"></a>
<a name="line-6"></a><span class="k">struct</span> <span class="n">object_id</span><span class="p">;</span>
<a name="line-7"></a><span class="k">struct</span> <span class="n">ref_store</span><span class="p">;</span>
<a name="line-8"></a><span class="k">struct</span> <span class="n">repository</span><span class="p">;</span>
<a name="line-9"></a><span class="k">struct</span> <span class="n">strbuf</span><span class="p">;</span>
<a name="line-10"></a><span class="k">struct</span> <span class="n">string_list</span><span class="p">;</span>
<a name="line-11"></a><span class="k">struct</span> <span class="n">string_list_item</span><span class="p">;</span>
<a name="line-12"></a><span class="k">struct</span> <span class="n">worktree</span><span class="p">;</span>
<a name="line-13"></a>
<a name="line-14"></a><span class="cm">/*</span>
<a name="line-15"></a><span class="cm"> * Resolve a reference, recursively following symbolic refererences.</span>
<a name="line-16"></a><span class="cm"> *</span>
<a name="line-17"></a><span class="cm"> * Return the name of the non-symbolic reference that ultimately pointed</span>
<a name="line-18"></a><span class="cm"> * at the resolved object name.  The return value, if not NULL, is a</span>
<a name="line-19"></a><span class="cm"> * pointer into either a static buffer or the input ref.</span>
<a name="line-20"></a><span class="cm"> *</span>
<a name="line-21"></a><span class="cm"> * If oid is non-NULL, store the referred-to object&#39;s name in it.</span>
<a name="line-22"></a><span class="cm"> *</span>
<a name="line-23"></a><span class="cm"> * If the reference cannot be resolved to an object, the behavior</span>
<a name="line-24"></a><span class="cm"> * depends on the RESOLVE_REF_READING flag:</span>
<a name="line-25"></a><span class="cm"> *</span>
<a name="line-26"></a><span class="cm"> * - If RESOLVE_REF_READING is set, return NULL.</span>
<a name="line-27"></a><span class="cm"> *</span>
<a name="line-28"></a><span class="cm"> * - If RESOLVE_REF_READING is not set, clear oid and return the name of</span>
<a name="line-29"></a><span class="cm"> *   the last reference name in the chain, which will either be a non-symbolic</span>
<a name="line-30"></a><span class="cm"> *   reference or an undefined reference.  If this is a prelude to</span>
<a name="line-31"></a><span class="cm"> *   &quot;writing&quot; to the ref, the return value is the name of the ref</span>
<a name="line-32"></a><span class="cm"> *   that will actually be created or changed.</span>
<a name="line-33"></a><span class="cm"> *</span>
<a name="line-34"></a><span class="cm"> * If the RESOLVE_REF_NO_RECURSE flag is passed, only resolves one</span>
<a name="line-35"></a><span class="cm"> * level of symbolic reference.  The value stored in oid for a symbolic</span>
<a name="line-36"></a><span class="cm"> * reference will always be null_oid in this case, and the return</span>
<a name="line-37"></a><span class="cm"> * value is the reference that the symref refers to directly.</span>
<a name="line-38"></a><span class="cm"> *</span>
<a name="line-39"></a><span class="cm"> * If flags is non-NULL, set the value that it points to the</span>
<a name="line-40"></a><span class="cm"> * combination of REF_ISPACKED (if the reference was found among the</span>
<a name="line-41"></a><span class="cm"> * packed references), REF_ISSYMREF (if the initial reference was a</span>
<a name="line-42"></a><span class="cm"> * symbolic reference), REF_BAD_NAME (if the reference name is ill</span>
<a name="line-43"></a><span class="cm"> * formed --- see RESOLVE_REF_ALLOW_BAD_NAME below), and REF_ISBROKEN</span>
<a name="line-44"></a><span class="cm"> * (if the ref is malformed or has a bad name). See refs.h for more detail</span>
<a name="line-45"></a><span class="cm"> * on each flag.</span>
<a name="line-46"></a><span class="cm"> *</span>
<a name="line-47"></a><span class="cm"> * If ref is not a properly-formatted, normalized reference, return</span>
<a name="line-48"></a><span class="cm"> * NULL.  If more than MAXDEPTH recursive symbolic lookups are needed,</span>
<a name="line-49"></a><span class="cm"> * give up and return NULL.</span>
<a name="line-50"></a><span class="cm"> *</span>
<a name="line-51"></a><span class="cm"> * RESOLVE_REF_ALLOW_BAD_NAME allows resolving refs even when their</span>
<a name="line-52"></a><span class="cm"> * name is invalid according to git-check-ref-format(1).  If the name</span>
<a name="line-53"></a><span class="cm"> * is bad then the value stored in oid will be null_oid and the two</span>
<a name="line-54"></a><span class="cm"> * flags REF_ISBROKEN and REF_BAD_NAME will be set.</span>
<a name="line-55"></a><span class="cm"> *</span>
<a name="line-56"></a><span class="cm"> * Even with RESOLVE_REF_ALLOW_BAD_NAME, names that escape the refs/</span>
<a name="line-57"></a><span class="cm"> * directory and do not consist of all caps and underscores cannot be</span>
<a name="line-58"></a><span class="cm"> * resolved. The function returns NULL for such ref names.</span>
<a name="line-59"></a><span class="cm"> * Caps and underscores refers to the special refs, such as HEAD,</span>
<a name="line-60"></a><span class="cm"> * FETCH_HEAD and friends, that all live outside of the refs/ directory.</span>
<a name="line-61"></a><span class="cm"> */</span>
<a name="line-62"></a><span class="cp">#define RESOLVE_REF_READING 0x01</span>
<a name="line-63"></a><span class="cp">#define RESOLVE_REF_NO_RECURSE 0x02</span>
<a name="line-64"></a><span class="cp">#define RESOLVE_REF_ALLOW_BAD_NAME 0x04</span>
<a name="line-65"></a>
<a name="line-66"></a><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">refs_resolve_ref_unsafe</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span>
<a name="line-67"></a>				    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span>
<a name="line-68"></a>				    <span class="kt">int</span> <span class="n">resolve_flags</span><span class="p">,</span>
<a name="line-69"></a>				    <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span>
<a name="line-70"></a>				    <span class="kt">int</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
<a name="line-71"></a><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">resolve_ref_unsafe</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">resolve_flags</span><span class="p">,</span>
<a name="line-72"></a>			       <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
<a name="line-73"></a>
<a name="line-74"></a><span class="kt">char</span> <span class="o">*</span><span class="nf">refs_resolve_refdup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span>
<a name="line-75"></a>			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">resolve_flags</span><span class="p">,</span>
<a name="line-76"></a>			  <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
<a name="line-77"></a><span class="kt">char</span> <span class="o">*</span><span class="nf">resolve_refdup</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">resolve_flags</span><span class="p">,</span>
<a name="line-78"></a>		     <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
<a name="line-79"></a>
<a name="line-80"></a><span class="kt">int</span> <span class="nf">refs_read_ref_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span>
<a name="line-81"></a>		       <span class="kt">int</span> <span class="n">resolve_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
<a name="line-82"></a><span class="kt">int</span> <span class="nf">read_ref_full</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">resolve_flags</span><span class="p">,</span>
<a name="line-83"></a>		  <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
<a name="line-84"></a><span class="kt">int</span> <span class="nf">read_ref</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span> <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">oid</span><span class="p">);</span>
<a name="line-85"></a>
<a name="line-86"></a><span class="cm">/*</span>
<a name="line-87"></a><span class="cm"> * Return 0 if a reference named refname could be created without</span>
<a name="line-88"></a><span class="cm"> * conflicting with the name of an existing reference. Otherwise,</span>
<a name="line-89"></a><span class="cm"> * return a negative value and write an explanation to err. If extras</span>
<a name="line-90"></a><span class="cm"> * is non-NULL, it is a list of additional refnames with which refname</span>
<a name="line-91"></a><span class="cm"> * is not allowed to conflict. If skip is non-NULL, ignore potential</span>
<a name="line-92"></a><span class="cm"> * conflicts with refs in skip (e.g., because they are scheduled for</span>
<a name="line-93"></a><span class="cm"> * deletion in the same operation). Behavior is undefined if the same</span>
<a name="line-94"></a><span class="cm"> * name is listed in both extras and skip.</span>
<a name="line-95"></a><span class="cm"> *</span>
<a name="line-96"></a><span class="cm"> * Two reference names conflict if one of them exactly matches the</span>
<a name="line-97"></a><span class="cm"> * leading components of the other; e.g., &quot;foo/bar&quot; conflicts with</span>
<a name="line-98"></a><span class="cm"> * both &quot;foo&quot; and with &quot;foo/bar/baz&quot; but not with &quot;foo/bar&quot; or</span>
<a name="line-99"></a><span class="cm"> * &quot;foo/barbados&quot;.</span>
<a name="line-100"></a><span class="cm"> *</span>
<a name="line-101"></a><span class="cm"> * extras and skip must be sorted.</span>
<a name="line-102"></a><span class="cm"> */</span>
<a name="line-103"></a>
<a name="line-104"></a><span class="kt">int</span> <span class="nf">refs_verify_refname_available</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span>
<a name="line-105"></a>				  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span>
<a name="line-106"></a>				  <span class="k">const</span> <span class="k">struct</span> <span class="n">string_list</span> <span class="o">*</span><span class="n">extras</span><span class="p">,</span>
<a name="line-107"></a>				  <span class="k">const</span> <span class="k">struct</span> <span class="n">string_list</span> <span class="o">*</span><span class="n">skip</span><span class="p">,</span>
<a name="line-108"></a>				  <span class="k">struct</span> <span class="n">strbuf</span> <span class="o">*</span><span class="n">err</span><span class="p">);</span>
<a name="line-109"></a>
<a name="line-110"></a><span class="kt">int</span> <span class="nf">refs_ref_exists</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">);</span>
<a name="line-111"></a>
<a name="line-112"></a><span class="kt">int</span> <span class="nf">ref_exists</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">);</span>
<a name="line-113"></a>
<a name="line-114"></a><span class="kt">int</span> <span class="nf">should_autocreate_reflog</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">);</span>
<a name="line-115"></a>
<a name="line-116"></a><span class="kt">int</span> <span class="nf">is_branch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">);</span>
<a name="line-117"></a>
<a name="line-118"></a><span class="kt">int</span> <span class="nf">refs_init_db</span><span class="p">(</span><span class="k">struct</span> <span class="n">strbuf</span> <span class="o">*</span><span class="n">err</span><span class="p">);</span>
<a name="line-119"></a>
<a name="line-120"></a><span class="cm">/*</span>
<a name="line-121"></a><span class="cm"> * If refname is a non-symbolic reference that refers to a tag object,</span>
<a name="line-122"></a><span class="cm"> * and the tag can be (recursively) dereferenced to a non-tag object,</span>
<a name="line-123"></a><span class="cm"> * store the object ID of the referred-to object to oid and return 0.</span>
<a name="line-124"></a><span class="cm"> * If any of these conditions are not met, return a non-zero value.</span>
<a name="line-125"></a><span class="cm"> * Symbolic references are considered unpeelable, even if they</span>
<a name="line-126"></a><span class="cm"> * ultimately resolve to a peelable tag.</span>
<a name="line-127"></a><span class="cm"> */</span>
<a name="line-128"></a><span class="kt">int</span> <span class="nf">refs_peel_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span>
<a name="line-129"></a>		  <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">oid</span><span class="p">);</span>
<a name="line-130"></a><span class="kt">int</span> <span class="nf">peel_ref</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span> <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">oid</span><span class="p">);</span>
<a name="line-131"></a>
<a name="line-132"></a><span class="cm">/**</span>
<a name="line-133"></a><span class="cm"> * Resolve refname in the nested &quot;gitlink&quot; repository in the specified</span>
<a name="line-134"></a><span class="cm"> * submodule (which must be non-NULL). If the resolution is</span>
<a name="line-135"></a><span class="cm"> * successful, return 0 and set oid to the name of the object;</span>
<a name="line-136"></a><span class="cm"> * otherwise, return a non-zero value.</span>
<a name="line-137"></a><span class="cm"> */</span>
<a name="line-138"></a><span class="kt">int</span> <span class="nf">resolve_gitlink_ref</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">submodule</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span>
<a name="line-139"></a>			<span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">oid</span><span class="p">);</span>
<a name="line-140"></a>
<a name="line-141"></a><span class="cm">/*</span>
<a name="line-142"></a><span class="cm"> * Return true iff abbrev_name is a possible abbreviation for</span>
<a name="line-143"></a><span class="cm"> * full_name according to the rules defined by ref_rev_parse_rules in</span>
<a name="line-144"></a><span class="cm"> * refs.c.</span>
<a name="line-145"></a><span class="cm"> */</span>
<a name="line-146"></a><span class="kt">int</span> <span class="nf">refname_match</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">abbrev_name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">full_name</span><span class="p">);</span>
<a name="line-147"></a>
<a name="line-148"></a><span class="cm">/*</span>
<a name="line-149"></a><span class="cm"> * Given a &#39;prefix&#39; expand it by the rules in &#39;ref_rev_parse_rules&#39; and add</span>
<a name="line-150"></a><span class="cm"> * the results to &#39;prefixes&#39;</span>
<a name="line-151"></a><span class="cm"> */</span>
<a name="line-152"></a><span class="k">struct</span> <span class="n">strvec</span><span class="p">;</span>
<a name="line-153"></a><span class="kt">void</span> <span class="nf">expand_ref_prefix</span><span class="p">(</span><span class="k">struct</span> <span class="n">strvec</span> <span class="o">*</span><span class="n">prefixes</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">);</span>
<a name="line-154"></a>
<a name="line-155"></a><span class="kt">int</span> <span class="nf">expand_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">repository</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">ref</span><span class="p">);</span>
<a name="line-156"></a><span class="kt">int</span> <span class="nf">repo_dwim_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">repository</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
<a name="line-157"></a>		  <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">ref</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonfatal_dangling_mark</span><span class="p">);</span>
<a name="line-158"></a><span class="kt">int</span> <span class="nf">repo_dwim_log</span><span class="p">(</span><span class="k">struct</span> <span class="n">repository</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">ref</span><span class="p">);</span>
<a name="line-159"></a><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dwim_ref</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span>
<a name="line-160"></a>			   <span class="kt">char</span> <span class="o">**</span><span class="n">ref</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonfatal_dangling_mark</span><span class="p">)</span>
<a name="line-161"></a><span class="p">{</span>
<a name="line-162"></a>	<span class="k">return</span> <span class="n">repo_dwim_ref</span><span class="p">(</span><span class="n">the_repository</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">oid</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span>
<a name="line-163"></a>			     <span class="n">nonfatal_dangling_mark</span><span class="p">);</span>
<a name="line-164"></a><span class="p">}</span>
<a name="line-165"></a><span class="kt">int</span> <span class="nf">dwim_log</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">ref</span><span class="p">);</span>
<a name="line-166"></a>
<a name="line-167"></a><span class="cm">/*</span>
<a name="line-168"></a><span class="cm"> * Retrieves the default branch name for newly-initialized repositories.</span>
<a name="line-169"></a><span class="cm"> *</span>
<a name="line-170"></a><span class="cm"> * The return value of `repo_default_branch_name()` is an allocated string. The</span>
<a name="line-171"></a><span class="cm"> * return value of `git_default_branch_name()` is a singleton.</span>
<a name="line-172"></a><span class="cm"> */</span>
<a name="line-173"></a><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">git_default_branch_name</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<a name="line-174"></a><span class="kt">char</span> <span class="o">*</span><span class="nf">repo_default_branch_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">repository</span> <span class="o">*</span><span class="n">r</span><span class="p">);</span>
<a name="line-175"></a>
<a name="line-176"></a><span class="cm">/*</span>
<a name="line-177"></a><span class="cm"> * A ref_transaction represents a collection of reference updates that</span>
<a name="line-178"></a><span class="cm"> * should succeed or fail together.</span>
<a name="line-179"></a><span class="cm"> *</span>
<a name="line-180"></a><span class="cm"> * Calling sequence</span>
<a name="line-181"></a><span class="cm"> * ----------------</span>
<a name="line-182"></a><span class="cm"> *</span>
<a name="line-183"></a><span class="cm"> * - Allocate and initialize a `struct ref_transaction` by calling</span>
<a name="line-184"></a><span class="cm"> *   `ref_transaction_begin()`.</span>
<a name="line-185"></a><span class="cm"> *</span>
<a name="line-186"></a><span class="cm"> * - Specify the intended ref updates by calling one or more of the</span>
<a name="line-187"></a><span class="cm"> *   following functions:</span>
<a name="line-188"></a><span class="cm"> *   - `ref_transaction_update()`</span>
<a name="line-189"></a><span class="cm"> *   - `ref_transaction_create()`</span>
<a name="line-190"></a><span class="cm"> *   - `ref_transaction_delete()`</span>
<a name="line-191"></a><span class="cm"> *   - `ref_transaction_verify()`</span>
<a name="line-192"></a><span class="cm"> *</span>
<a name="line-193"></a><span class="cm"> * - Then either:</span>
<a name="line-194"></a><span class="cm"> *</span>
<a name="line-195"></a><span class="cm"> *   - Optionally call `ref_transaction_prepare()` to prepare the</span>
<a name="line-196"></a><span class="cm"> *     transaction. This locks all references, checks preconditions,</span>
<a name="line-197"></a><span class="cm"> *     etc. but doesn&#39;t finalize anything. If this step fails, the</span>
<a name="line-198"></a><span class="cm"> *     transaction has been closed and can only be freed. If this step</span>
<a name="line-199"></a><span class="cm"> *     succeeds, then `ref_transaction_commit()` is almost certain to</span>
<a name="line-200"></a><span class="cm"> *     succeed. However, you can still call `ref_transaction_abort()`</span>
<a name="line-201"></a><span class="cm"> *     if you decide not to commit the transaction after all.</span>
<a name="line-202"></a><span class="cm"> *</span>
<a name="line-203"></a><span class="cm"> *   - Call `ref_transaction_commit()` to execute the transaction,</span>
<a name="line-204"></a><span class="cm"> *     make the changes permanent, and release all locks. If you</span>
<a name="line-205"></a><span class="cm"> *     haven&#39;t already called `ref_transaction_prepare()`, then</span>
<a name="line-206"></a><span class="cm"> *     `ref_transaction_commit()` calls it for you.</span>
<a name="line-207"></a><span class="cm"> *</span>
<a name="line-208"></a><span class="cm"> *   Or</span>
<a name="line-209"></a><span class="cm"> *</span>
<a name="line-210"></a><span class="cm"> *   - Call `initial_ref_transaction_commit()` if the ref database is</span>
<a name="line-211"></a><span class="cm"> *     known to be empty and have no other writers (e.g. during</span>
<a name="line-212"></a><span class="cm"> *     clone). This is likely to be much faster than</span>
<a name="line-213"></a><span class="cm"> *     `ref_transaction_commit()`. `ref_transaction_prepare()` should</span>
<a name="line-214"></a><span class="cm"> *     *not* be called before `initial_ref_transaction_commit()`.</span>
<a name="line-215"></a><span class="cm"> *</span>
<a name="line-216"></a><span class="cm"> * - Then finally, call `ref_transaction_free()` to free the</span>
<a name="line-217"></a><span class="cm"> *   `ref_transaction` data structure.</span>
<a name="line-218"></a><span class="cm"> *</span>
<a name="line-219"></a><span class="cm"> * At any time before calling `ref_transaction_commit()`, you can call</span>
<a name="line-220"></a><span class="cm"> * `ref_transaction_abort()` to abort the transaction, rollback any</span>
<a name="line-221"></a><span class="cm"> * locks, and free any associated resources (including the</span>
<a name="line-222"></a><span class="cm"> * `ref_transaction` data structure).</span>
<a name="line-223"></a><span class="cm"> *</span>
<a name="line-224"></a><span class="cm"> * Putting it all together, a complete reference update looks like</span>
<a name="line-225"></a><span class="cm"> *</span>
<a name="line-226"></a><span class="cm"> *         struct ref_transaction *transaction;</span>
<a name="line-227"></a><span class="cm"> *         struct strbuf err = STRBUF_INIT;</span>
<a name="line-228"></a><span class="cm"> *         int ret = 0;</span>
<a name="line-229"></a><span class="cm"> *</span>
<a name="line-230"></a><span class="cm"> *         transaction = ref_store_transaction_begin(refs, &amp;err);</span>
<a name="line-231"></a><span class="cm"> *         if (!transaction ||</span>
<a name="line-232"></a><span class="cm"> *             ref_transaction_update(...) ||</span>
<a name="line-233"></a><span class="cm"> *             ref_transaction_create(...) ||</span>
<a name="line-234"></a><span class="cm"> *             ...etc... ||</span>
<a name="line-235"></a><span class="cm"> *             ref_transaction_commit(transaction, &amp;err)) {</span>
<a name="line-236"></a><span class="cm"> *                 error(&quot;%s&quot;, err.buf);</span>
<a name="line-237"></a><span class="cm"> *                 ret = -1;</span>
<a name="line-238"></a><span class="cm"> *         }</span>
<a name="line-239"></a><span class="cm"> *         ref_transaction_free(transaction);</span>
<a name="line-240"></a><span class="cm"> *         strbuf_release(&amp;err);</span>
<a name="line-241"></a><span class="cm"> *         return ret;</span>
<a name="line-242"></a><span class="cm"> *</span>
<a name="line-243"></a><span class="cm"> * Error handling</span>
<a name="line-244"></a><span class="cm"> * --------------</span>
<a name="line-245"></a><span class="cm"> *</span>
<a name="line-246"></a><span class="cm"> * On error, transaction functions append a message about what</span>
<a name="line-247"></a><span class="cm"> * went wrong to the &#39;err&#39; argument.  The message mentions what</span>
<a name="line-248"></a><span class="cm"> * ref was being updated (if any) when the error occurred so it</span>
<a name="line-249"></a><span class="cm"> * can be passed to &#39;die&#39; or &#39;error&#39; as-is.</span>
<a name="line-250"></a><span class="cm"> *</span>
<a name="line-251"></a><span class="cm"> * The message is appended to err without first clearing err.</span>
<a name="line-252"></a><span class="cm"> * err will not be &#39;\n&#39; terminated.</span>
<a name="line-253"></a><span class="cm"> *</span>
<a name="line-254"></a><span class="cm"> * Caveats</span>
<a name="line-255"></a><span class="cm"> * -------</span>
<a name="line-256"></a><span class="cm"> *</span>
<a name="line-257"></a><span class="cm"> * Note that no locks are taken, and no refs are read, until</span>
<a name="line-258"></a><span class="cm"> * `ref_transaction_prepare()` or `ref_transaction_commit()` is</span>
<a name="line-259"></a><span class="cm"> * called. So, for example, `ref_transaction_verify()` won&#39;t report a</span>
<a name="line-260"></a><span class="cm"> * verification failure until the commit is attempted.</span>
<a name="line-261"></a><span class="cm"> */</span>
<a name="line-262"></a><span class="k">struct</span> <span class="n">ref_transaction</span><span class="p">;</span>
<a name="line-263"></a>
<a name="line-264"></a><span class="cm">/*</span>
<a name="line-265"></a><span class="cm"> * Bit values set in the flags argument passed to each_ref_fn() and</span>
<a name="line-266"></a><span class="cm"> * stored in ref_iterator::flags. Other bits are for internal use</span>
<a name="line-267"></a><span class="cm"> * only:</span>
<a name="line-268"></a><span class="cm"> */</span>
<a name="line-269"></a>
<a name="line-270"></a><span class="cm">/* Reference is a symbolic reference. */</span>
<a name="line-271"></a><span class="cp">#define REF_ISSYMREF 0x01</span>
<a name="line-272"></a>
<a name="line-273"></a><span class="cm">/* Reference is a packed reference. */</span>
<a name="line-274"></a><span class="cp">#define REF_ISPACKED 0x02</span>
<a name="line-275"></a>
<a name="line-276"></a><span class="cm">/*</span>
<a name="line-277"></a><span class="cm"> * Reference cannot be resolved to an object name: dangling symbolic</span>
<a name="line-278"></a><span class="cm"> * reference (directly or indirectly), corrupt reference file,</span>
<a name="line-279"></a><span class="cm"> * reference exists but name is bad, or symbolic reference refers to</span>
<a name="line-280"></a><span class="cm"> * ill-formatted reference name.</span>
<a name="line-281"></a><span class="cm"> */</span>
<a name="line-282"></a><span class="cp">#define REF_ISBROKEN 0x04</span>
<a name="line-283"></a>
<a name="line-284"></a><span class="cm">/*</span>
<a name="line-285"></a><span class="cm"> * Reference name is not well formed.</span>
<a name="line-286"></a><span class="cm"> *</span>
<a name="line-287"></a><span class="cm"> * See git-check-ref-format(1) for the definition of well formed ref names.</span>
<a name="line-288"></a><span class="cm"> */</span>
<a name="line-289"></a><span class="cp">#define REF_BAD_NAME 0x08</span>
<a name="line-290"></a>
<a name="line-291"></a><span class="cm">/*</span>
<a name="line-292"></a><span class="cm"> * The signature for the callback function for the for_each_*()</span>
<a name="line-293"></a><span class="cm"> * functions below.  The memory pointed to by the refname and oid</span>
<a name="line-294"></a><span class="cm"> * arguments is only guaranteed to be valid for the duration of a</span>
<a name="line-295"></a><span class="cm"> * single callback invocation.</span>
<a name="line-296"></a><span class="cm"> */</span>
<a name="line-297"></a><span class="k">typedef</span> <span class="kt">int</span> <span class="nf">each_ref_fn</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span>
<a name="line-298"></a>			<span class="k">const</span> <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-299"></a>
<a name="line-300"></a><span class="cm">/*</span>
<a name="line-301"></a><span class="cm"> * The same as each_ref_fn, but also with a repository argument that</span>
<a name="line-302"></a><span class="cm"> * contains the repository associated with the callback.</span>
<a name="line-303"></a><span class="cm"> */</span>
<a name="line-304"></a><span class="k">typedef</span> <span class="kt">int</span> <span class="nf">each_repo_ref_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">repository</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span>
<a name="line-305"></a>			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span>
<a name="line-306"></a>			     <span class="k">const</span> <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span>
<a name="line-307"></a>			     <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
<a name="line-308"></a>			     <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-309"></a>
<a name="line-310"></a><span class="cm">/*</span>
<a name="line-311"></a><span class="cm"> * The following functions invoke the specified callback function for</span>
<a name="line-312"></a><span class="cm"> * each reference indicated.  If the function ever returns a nonzero</span>
<a name="line-313"></a><span class="cm"> * value, stop the iteration and return that value.  Please note that</span>
<a name="line-314"></a><span class="cm"> * it is not safe to modify references while an iteration is in</span>
<a name="line-315"></a><span class="cm"> * progress, unless the same callback function invocation that</span>
<a name="line-316"></a><span class="cm"> * modifies the reference also returns a nonzero value to immediately</span>
<a name="line-317"></a><span class="cm"> * stop the iteration. Returned references are sorted.</span>
<a name="line-318"></a><span class="cm"> */</span>
<a name="line-319"></a><span class="kt">int</span> <span class="nf">refs_head_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span>
<a name="line-320"></a>		  <span class="n">each_ref_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-321"></a><span class="kt">int</span> <span class="nf">refs_for_each_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span>
<a name="line-322"></a>		      <span class="n">each_ref_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-323"></a><span class="kt">int</span> <span class="nf">refs_for_each_ref_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">,</span>
<a name="line-324"></a>			 <span class="n">each_ref_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-325"></a><span class="kt">int</span> <span class="nf">refs_for_each_tag_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span>
<a name="line-326"></a>			  <span class="n">each_ref_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-327"></a><span class="kt">int</span> <span class="nf">refs_for_each_branch_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span>
<a name="line-328"></a>			     <span class="n">each_ref_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-329"></a><span class="kt">int</span> <span class="nf">refs_for_each_remote_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span>
<a name="line-330"></a>			     <span class="n">each_ref_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-331"></a>
<a name="line-332"></a><span class="cm">/* just iterates the head ref. */</span>
<a name="line-333"></a><span class="kt">int</span> <span class="nf">head_ref</span><span class="p">(</span><span class="n">each_ref_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-334"></a>
<a name="line-335"></a><span class="cm">/* iterates all refs. */</span>
<a name="line-336"></a><span class="kt">int</span> <span class="nf">for_each_ref</span><span class="p">(</span><span class="n">each_ref_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-337"></a>
<a name="line-338"></a><span class="cm">/**</span>
<a name="line-339"></a><span class="cm"> * iterates all refs which have a defined prefix and strips that prefix from</span>
<a name="line-340"></a><span class="cm"> * the passed variable refname.</span>
<a name="line-341"></a><span class="cm"> */</span>
<a name="line-342"></a><span class="kt">int</span> <span class="nf">for_each_ref_in</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">,</span> <span class="n">each_ref_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-343"></a>
<a name="line-344"></a><span class="kt">int</span> <span class="nf">refs_for_each_fullref_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">,</span>
<a name="line-345"></a>			     <span class="n">each_ref_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">,</span>
<a name="line-346"></a>			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">broken</span><span class="p">);</span>
<a name="line-347"></a><span class="kt">int</span> <span class="nf">for_each_fullref_in</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">,</span> <span class="n">each_ref_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">,</span>
<a name="line-348"></a>			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">broken</span><span class="p">);</span>
<a name="line-349"></a>
<a name="line-350"></a><span class="cm">/**</span>
<a name="line-351"></a><span class="cm"> * iterate refs from the respective area.</span>
<a name="line-352"></a><span class="cm"> */</span>
<a name="line-353"></a><span class="kt">int</span> <span class="nf">for_each_tag_ref</span><span class="p">(</span><span class="n">each_ref_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-354"></a><span class="kt">int</span> <span class="nf">for_each_branch_ref</span><span class="p">(</span><span class="n">each_ref_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-355"></a><span class="kt">int</span> <span class="nf">for_each_remote_ref</span><span class="p">(</span><span class="n">each_ref_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-356"></a><span class="kt">int</span> <span class="nf">for_each_replace_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">repository</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="n">each_repo_ref_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-357"></a>
<a name="line-358"></a><span class="cm">/* iterates all refs that match the specified glob pattern. */</span>
<a name="line-359"></a><span class="kt">int</span> <span class="nf">for_each_glob_ref</span><span class="p">(</span><span class="n">each_ref_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pattern</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-360"></a>
<a name="line-361"></a><span class="kt">int</span> <span class="nf">for_each_glob_ref_in</span><span class="p">(</span><span class="n">each_ref_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pattern</span><span class="p">,</span>
<a name="line-362"></a>			 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-363"></a>
<a name="line-364"></a><span class="kt">int</span> <span class="nf">head_ref_namespaced</span><span class="p">(</span><span class="n">each_ref_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-365"></a><span class="kt">int</span> <span class="nf">for_each_namespaced_ref</span><span class="p">(</span><span class="n">each_ref_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-366"></a>
<a name="line-367"></a><span class="cm">/* can be used to learn about broken ref and symref */</span>
<a name="line-368"></a><span class="kt">int</span> <span class="nf">refs_for_each_rawref</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span> <span class="n">each_ref_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-369"></a><span class="kt">int</span> <span class="nf">for_each_rawref</span><span class="p">(</span><span class="n">each_ref_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-370"></a>
<a name="line-371"></a><span class="cm">/*</span>
<a name="line-372"></a><span class="cm"> * Normalizes partial refs to their fully qualified form.</span>
<a name="line-373"></a><span class="cm"> * Will prepend &lt;prefix&gt; to the &lt;pattern&gt; if it doesn&#39;t start with &#39;refs/&#39;.</span>
<a name="line-374"></a><span class="cm"> * &lt;prefix&gt; will default to &#39;refs/&#39; if NULL.</span>
<a name="line-375"></a><span class="cm"> *</span>
<a name="line-376"></a><span class="cm"> * item.string will be set to the result.</span>
<a name="line-377"></a><span class="cm"> * item.util will be set to NULL if &lt;pattern&gt; contains glob characters, or</span>
<a name="line-378"></a><span class="cm"> * non-NULL if it doesn&#39;t.</span>
<a name="line-379"></a><span class="cm"> */</span>
<a name="line-380"></a><span class="kt">void</span> <span class="nf">normalize_glob_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">string_list_item</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">,</span>
<a name="line-381"></a>			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pattern</span><span class="p">);</span>
<a name="line-382"></a>
<a name="line-383"></a><span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">has_glob_specials</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pattern</span><span class="p">)</span>
<a name="line-384"></a><span class="p">{</span>
<a name="line-385"></a><span class="hll">	<span class="k">return</span> <span class="n">strpbrk</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="s">&quot;?*[&quot;</span><span class="p">);</span><span class="error2">&lt;--- Null pointer dereference</span><span class="error2">&lt;--- Dereferencing argument pattern that is null</span>
</span><a name="line-386"></a><span class="p">}</span>
<a name="line-387"></a>
<a name="line-388"></a><span class="kt">void</span> <span class="nf">warn_dangling_symref</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg_fmt</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">);</span>
<a name="line-389"></a><span class="kt">void</span> <span class="nf">warn_dangling_symrefs</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg_fmt</span><span class="p">,</span>
<a name="line-390"></a>			   <span class="k">const</span> <span class="k">struct</span> <span class="n">string_list</span> <span class="o">*</span><span class="n">refnames</span><span class="p">);</span>
<a name="line-391"></a>
<a name="line-392"></a><span class="cm">/*</span>
<a name="line-393"></a><span class="cm"> * Flags for controlling behaviour of pack_refs()</span>
<a name="line-394"></a><span class="cm"> * PACK_REFS_PRUNE: Prune loose refs after packing</span>
<a name="line-395"></a><span class="cm"> * PACK_REFS_ALL:   Pack _all_ refs, not just tags and already packed refs</span>
<a name="line-396"></a><span class="cm"> */</span>
<a name="line-397"></a><span class="cp">#define PACK_REFS_PRUNE 0x0001</span>
<a name="line-398"></a><span class="cp">#define PACK_REFS_ALL   0x0002</span>
<a name="line-399"></a>
<a name="line-400"></a><span class="cm">/*</span>
<a name="line-401"></a><span class="cm"> * Write a packed-refs file for the current repository.</span>
<a name="line-402"></a><span class="cm"> * flags: Combination of the above PACK_REFS_* flags.</span>
<a name="line-403"></a><span class="cm"> */</span>
<a name="line-404"></a><span class="kt">int</span> <span class="nf">refs_pack_refs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<a name="line-405"></a>
<a name="line-406"></a><span class="cm">/*</span>
<a name="line-407"></a><span class="cm"> * Setup reflog before using. Fill in err and return -1 on failure.</span>
<a name="line-408"></a><span class="cm"> */</span>
<a name="line-409"></a><span class="kt">int</span> <span class="nf">refs_create_reflog</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span>
<a name="line-410"></a>		       <span class="kt">int</span> <span class="n">force_create</span><span class="p">,</span> <span class="k">struct</span> <span class="n">strbuf</span> <span class="o">*</span><span class="n">err</span><span class="p">);</span>
<a name="line-411"></a><span class="kt">int</span> <span class="nf">safe_create_reflog</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force_create</span><span class="p">,</span> <span class="k">struct</span> <span class="n">strbuf</span> <span class="o">*</span><span class="n">err</span><span class="p">);</span>
<a name="line-412"></a>
<a name="line-413"></a><span class="cm">/** Reads log for the value of ref during at_time. **/</span>
<a name="line-414"></a><span class="kt">int</span> <span class="nf">read_ref_at</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span>
<a name="line-415"></a>		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
<a name="line-416"></a>		<span class="n">timestamp_t</span> <span class="n">at_time</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">,</span>
<a name="line-417"></a>		<span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">msg</span><span class="p">,</span>
<a name="line-418"></a>		<span class="n">timestamp_t</span> <span class="o">*</span><span class="n">cutoff_time</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">cutoff_tz</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">cutoff_cnt</span><span class="p">);</span>
<a name="line-419"></a>
<a name="line-420"></a><span class="cm">/** Check if a particular reflog exists */</span>
<a name="line-421"></a><span class="kt">int</span> <span class="nf">refs_reflog_exists</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">);</span>
<a name="line-422"></a><span class="kt">int</span> <span class="nf">reflog_exists</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">);</span>
<a name="line-423"></a>
<a name="line-424"></a><span class="cm">/*</span>
<a name="line-425"></a><span class="cm"> * Delete the specified reference. If old_oid is non-NULL, then</span>
<a name="line-426"></a><span class="cm"> * verify that the current value of the reference is old_oid before</span>
<a name="line-427"></a><span class="cm"> * deleting it. If old_oid is NULL, delete the reference if it</span>
<a name="line-428"></a><span class="cm"> * exists, regardless of its old value. It is an error for old_oid to</span>
<a name="line-429"></a><span class="cm"> * be null_oid. msg and flags are passed through to</span>
<a name="line-430"></a><span class="cm"> * ref_transaction_delete().</span>
<a name="line-431"></a><span class="cm"> */</span>
<a name="line-432"></a><span class="kt">int</span> <span class="nf">refs_delete_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
<a name="line-433"></a>		    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span>
<a name="line-434"></a>		    <span class="k">const</span> <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">old_oid</span><span class="p">,</span>
<a name="line-435"></a>		    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<a name="line-436"></a><span class="kt">int</span> <span class="nf">delete_ref</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span>
<a name="line-437"></a>	       <span class="k">const</span> <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">old_oid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<a name="line-438"></a>
<a name="line-439"></a><span class="cm">/*</span>
<a name="line-440"></a><span class="cm"> * Delete the specified references. If there are any problems, emit</span>
<a name="line-441"></a><span class="cm"> * errors but attempt to keep going (i.e., the deletes are not done in</span>
<a name="line-442"></a><span class="cm"> * an all-or-nothing transaction). msg and flags are passed through to</span>
<a name="line-443"></a><span class="cm"> * ref_transaction_delete().</span>
<a name="line-444"></a><span class="cm"> */</span>
<a name="line-445"></a><span class="kt">int</span> <span class="nf">refs_delete_refs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
<a name="line-446"></a>		     <span class="k">struct</span> <span class="n">string_list</span> <span class="o">*</span><span class="n">refnames</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<a name="line-447"></a><span class="kt">int</span> <span class="nf">delete_refs</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">string_list</span> <span class="o">*</span><span class="n">refnames</span><span class="p">,</span>
<a name="line-448"></a>		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<a name="line-449"></a>
<a name="line-450"></a><span class="cm">/** Delete a reflog */</span>
<a name="line-451"></a><span class="kt">int</span> <span class="nf">refs_delete_reflog</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">);</span>
<a name="line-452"></a><span class="kt">int</span> <span class="nf">delete_reflog</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">);</span>
<a name="line-453"></a>
<a name="line-454"></a><span class="cm">/*</span>
<a name="line-455"></a><span class="cm"> * Callback to process a reflog entry found by the iteration functions (see</span>
<a name="line-456"></a><span class="cm"> * below)</span>
<a name="line-457"></a><span class="cm"> */</span>
<a name="line-458"></a><span class="k">typedef</span> <span class="kt">int</span> <span class="nf">each_reflog_ent_fn</span><span class="p">(</span>
<a name="line-459"></a>		<span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">old_oid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">new_oid</span><span class="p">,</span>
<a name="line-460"></a>		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">committer</span><span class="p">,</span> <span class="n">timestamp_t</span> <span class="n">timestamp</span><span class="p">,</span>
<a name="line-461"></a>		<span class="kt">int</span> <span class="n">tz</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-462"></a>
<a name="line-463"></a><span class="cm">/* Iterate over reflog entries in the log for `refname`. */</span>
<a name="line-464"></a>
<a name="line-465"></a><span class="cm">/* oldest entry first */</span>
<a name="line-466"></a><span class="kt">int</span> <span class="nf">refs_for_each_reflog_ent</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span>
<a name="line-467"></a>			     <span class="n">each_reflog_ent_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-468"></a>
<a name="line-469"></a><span class="cm">/* youngest entry first */</span>
<a name="line-470"></a><span class="kt">int</span> <span class="nf">refs_for_each_reflog_ent_reverse</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span>
<a name="line-471"></a>				     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span>
<a name="line-472"></a>				     <span class="n">each_reflog_ent_fn</span> <span class="n">fn</span><span class="p">,</span>
<a name="line-473"></a>				     <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-474"></a>
<a name="line-475"></a><span class="cm">/*</span>
<a name="line-476"></a><span class="cm"> * Iterate over reflog entries in the log for `refname` in the main ref store.</span>
<a name="line-477"></a><span class="cm"> */</span>
<a name="line-478"></a>
<a name="line-479"></a><span class="cm">/* oldest entry first */</span>
<a name="line-480"></a><span class="kt">int</span> <span class="nf">for_each_reflog_ent</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span> <span class="n">each_reflog_ent_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-481"></a>
<a name="line-482"></a><span class="cm">/* youngest entry first */</span>
<a name="line-483"></a><span class="kt">int</span> <span class="nf">for_each_reflog_ent_reverse</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span> <span class="n">each_reflog_ent_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-484"></a>
<a name="line-485"></a><span class="cm">/*</span>
<a name="line-486"></a><span class="cm"> * Calls the specified function for each reflog file until it returns nonzero,</span>
<a name="line-487"></a><span class="cm"> * and returns the value. Reflog file order is unspecified.</span>
<a name="line-488"></a><span class="cm"> */</span>
<a name="line-489"></a><span class="kt">int</span> <span class="nf">refs_for_each_reflog</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span> <span class="n">each_ref_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-490"></a><span class="kt">int</span> <span class="nf">for_each_reflog</span><span class="p">(</span><span class="n">each_ref_fn</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-491"></a>
<a name="line-492"></a><span class="cp">#define REFNAME_ALLOW_ONELEVEL 1</span>
<a name="line-493"></a><span class="cp">#define REFNAME_REFSPEC_PATTERN 2</span>
<a name="line-494"></a>
<a name="line-495"></a><span class="cm">/*</span>
<a name="line-496"></a><span class="cm"> * Return 0 iff refname has the correct format for a refname according</span>
<a name="line-497"></a><span class="cm"> * to the rules described in Documentation/git-check-ref-format.txt.</span>
<a name="line-498"></a><span class="cm"> * If REFNAME_ALLOW_ONELEVEL is set in flags, then accept one-level</span>
<a name="line-499"></a><span class="cm"> * reference names.  If REFNAME_REFSPEC_PATTERN is set in flags, then</span>
<a name="line-500"></a><span class="cm"> * allow a single &quot;*&quot; wildcard character in the refspec. No leading or</span>
<a name="line-501"></a><span class="cm"> * repeated slashes are accepted.</span>
<a name="line-502"></a><span class="cm"> */</span>
<a name="line-503"></a><span class="kt">int</span> <span class="nf">check_refname_format</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<a name="line-504"></a>
<a name="line-505"></a><span class="cm">/*</span>
<a name="line-506"></a><span class="cm"> * Apply the rules from check_refname_format, but mutate the result until it</span>
<a name="line-507"></a><span class="cm"> * is acceptable, and place the result in &quot;out&quot;.</span>
<a name="line-508"></a><span class="cm"> */</span>
<a name="line-509"></a><span class="kt">void</span> <span class="nf">sanitize_refname_component</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span> <span class="k">struct</span> <span class="n">strbuf</span> <span class="o">*</span><span class="n">out</span><span class="p">);</span>
<a name="line-510"></a>
<a name="line-511"></a><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">prettify_refname</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">);</span>
<a name="line-512"></a>
<a name="line-513"></a><span class="kt">char</span> <span class="o">*</span><span class="nf">refs_shorten_unambiguous_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span>
<a name="line-514"></a>				   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">strict</span><span class="p">);</span>
<a name="line-515"></a><span class="kt">char</span> <span class="o">*</span><span class="nf">shorten_unambiguous_ref</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">strict</span><span class="p">);</span>
<a name="line-516"></a>
<a name="line-517"></a><span class="cm">/** rename ref, return 0 on success **/</span>
<a name="line-518"></a><span class="kt">int</span> <span class="nf">refs_rename_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">oldref</span><span class="p">,</span>
<a name="line-519"></a>		    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">newref</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">logmsg</span><span class="p">);</span>
<a name="line-520"></a><span class="kt">int</span> <span class="nf">rename_ref</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">oldref</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">newref</span><span class="p">,</span>
<a name="line-521"></a>			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">logmsg</span><span class="p">);</span>
<a name="line-522"></a>
<a name="line-523"></a><span class="cm">/** copy ref, return 0 on success **/</span>
<a name="line-524"></a><span class="kt">int</span> <span class="nf">refs_copy_existing_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">oldref</span><span class="p">,</span>
<a name="line-525"></a>		    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">newref</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">logmsg</span><span class="p">);</span>
<a name="line-526"></a><span class="kt">int</span> <span class="nf">copy_existing_ref</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">oldref</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">newref</span><span class="p">,</span>
<a name="line-527"></a>			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">logmsg</span><span class="p">);</span>
<a name="line-528"></a>
<a name="line-529"></a><span class="kt">int</span> <span class="nf">refs_create_symref</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span>
<a name="line-530"></a>		       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">logmsg</span><span class="p">);</span>
<a name="line-531"></a><span class="kt">int</span> <span class="nf">create_symref</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">logmsg</span><span class="p">);</span>
<a name="line-532"></a>
<a name="line-533"></a><span class="k">enum</span> <span class="n">action_on_err</span> <span class="p">{</span>
<a name="line-534"></a>	<span class="n">UPDATE_REFS_MSG_ON_ERR</span><span class="p">,</span>
<a name="line-535"></a>	<span class="n">UPDATE_REFS_DIE_ON_ERR</span><span class="p">,</span>
<a name="line-536"></a>	<span class="n">UPDATE_REFS_QUIET_ON_ERR</span>
<a name="line-537"></a><span class="p">};</span>
<a name="line-538"></a>
<a name="line-539"></a><span class="cm">/*</span>
<a name="line-540"></a><span class="cm"> * Begin a reference transaction.  The reference transaction must</span>
<a name="line-541"></a><span class="cm"> * be freed by calling ref_transaction_free().</span>
<a name="line-542"></a><span class="cm"> */</span>
<a name="line-543"></a><span class="k">struct</span> <span class="n">ref_transaction</span> <span class="o">*</span><span class="nf">ref_store_transaction_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span>
<a name="line-544"></a>						    <span class="k">struct</span> <span class="n">strbuf</span> <span class="o">*</span><span class="n">err</span><span class="p">);</span>
<a name="line-545"></a><span class="k">struct</span> <span class="n">ref_transaction</span> <span class="o">*</span><span class="nf">ref_transaction_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">strbuf</span> <span class="o">*</span><span class="n">err</span><span class="p">);</span>
<a name="line-546"></a>
<a name="line-547"></a><span class="cm">/*</span>
<a name="line-548"></a><span class="cm"> * Reference transaction updates</span>
<a name="line-549"></a><span class="cm"> *</span>
<a name="line-550"></a><span class="cm"> * The following four functions add a reference check or update to a</span>
<a name="line-551"></a><span class="cm"> * ref_transaction.  They have some common similar parameters:</span>
<a name="line-552"></a><span class="cm"> *</span>
<a name="line-553"></a><span class="cm"> *     transaction -- a pointer to an open ref_transaction, obtained</span>
<a name="line-554"></a><span class="cm"> *         from ref_transaction_begin().</span>
<a name="line-555"></a><span class="cm"> *</span>
<a name="line-556"></a><span class="cm"> *     refname -- the name of the reference to be affected.</span>
<a name="line-557"></a><span class="cm"> *</span>
<a name="line-558"></a><span class="cm"> *     new_oid -- the object ID that should be set to be the new value</span>
<a name="line-559"></a><span class="cm"> *         of the reference. Some functions allow this parameter to be</span>
<a name="line-560"></a><span class="cm"> *         NULL, meaning that the reference is not changed, or</span>
<a name="line-561"></a><span class="cm"> *         null_oid, meaning that the reference should be deleted. A</span>
<a name="line-562"></a><span class="cm"> *         copy of this value is made in the transaction.</span>
<a name="line-563"></a><span class="cm"> *</span>
<a name="line-564"></a><span class="cm"> *     old_oid -- the object ID that the reference must have before</span>
<a name="line-565"></a><span class="cm"> *         the update. Some functions allow this parameter to be NULL,</span>
<a name="line-566"></a><span class="cm"> *         meaning that the old value of the reference is not checked,</span>
<a name="line-567"></a><span class="cm"> *         or null_oid, meaning that the reference must not exist</span>
<a name="line-568"></a><span class="cm"> *         before the update. A copy of this value is made in the</span>
<a name="line-569"></a><span class="cm"> *         transaction.</span>
<a name="line-570"></a><span class="cm"> *</span>
<a name="line-571"></a><span class="cm"> *     flags -- flags affecting the update, passed to</span>
<a name="line-572"></a><span class="cm"> *         update_ref_lock(). Possible flags: REF_NO_DEREF,</span>
<a name="line-573"></a><span class="cm"> *         REF_FORCE_CREATE_REFLOG. See those constants for more</span>
<a name="line-574"></a><span class="cm"> *         information.</span>
<a name="line-575"></a><span class="cm"> *</span>
<a name="line-576"></a><span class="cm"> *     msg -- a message describing the change (for the reflog).</span>
<a name="line-577"></a><span class="cm"> *</span>
<a name="line-578"></a><span class="cm"> *     err -- a strbuf for receiving a description of any error that</span>
<a name="line-579"></a><span class="cm"> *         might have occurred.</span>
<a name="line-580"></a><span class="cm"> *</span>
<a name="line-581"></a><span class="cm"> * The functions make internal copies of refname and msg, so the</span>
<a name="line-582"></a><span class="cm"> * caller retains ownership of these parameters.</span>
<a name="line-583"></a><span class="cm"> *</span>
<a name="line-584"></a><span class="cm"> * The functions return 0 on success and non-zero on failure. A</span>
<a name="line-585"></a><span class="cm"> * failure means that the transaction as a whole has failed and needs</span>
<a name="line-586"></a><span class="cm"> * to be rolled back.</span>
<a name="line-587"></a><span class="cm"> */</span>
<a name="line-588"></a>
<a name="line-589"></a><span class="cm">/*</span>
<a name="line-590"></a><span class="cm"> * The following flags can be passed to ref_transaction_update() etc.</span>
<a name="line-591"></a><span class="cm"> * Internally, they are stored in `ref_update::flags`, along with some</span>
<a name="line-592"></a><span class="cm"> * internal flags.</span>
<a name="line-593"></a><span class="cm"> */</span>
<a name="line-594"></a>
<a name="line-595"></a><span class="cm">/*</span>
<a name="line-596"></a><span class="cm"> * Act on the ref directly; i.e., without dereferencing symbolic refs.</span>
<a name="line-597"></a><span class="cm"> * If this flag is not specified, then symbolic references are</span>
<a name="line-598"></a><span class="cm"> * dereferenced and the update is applied to the referent.</span>
<a name="line-599"></a><span class="cm"> */</span>
<a name="line-600"></a><span class="cp">#define REF_NO_DEREF (1 &lt;&lt; 0)</span>
<a name="line-601"></a>
<a name="line-602"></a><span class="cm">/*</span>
<a name="line-603"></a><span class="cm"> * Force the creation of a reflog for this reference, even if it</span>
<a name="line-604"></a><span class="cm"> * didn&#39;t previously have a reflog.</span>
<a name="line-605"></a><span class="cm"> */</span>
<a name="line-606"></a><span class="cp">#define REF_FORCE_CREATE_REFLOG (1 &lt;&lt; 1)</span>
<a name="line-607"></a>
<a name="line-608"></a><span class="cm">/*</span>
<a name="line-609"></a><span class="cm"> * Bitmask of all of the flags that are allowed to be passed in to</span>
<a name="line-610"></a><span class="cm"> * ref_transaction_update() and friends:</span>
<a name="line-611"></a><span class="cm"> */</span>
<a name="line-612"></a><span class="cp">#define REF_TRANSACTION_UPDATE_ALLOWED_FLAGS \</span>
<a name="line-613"></a><span class="cp">	(REF_NO_DEREF | REF_FORCE_CREATE_REFLOG)</span>
<a name="line-614"></a>
<a name="line-615"></a><span class="cm">/*</span>
<a name="line-616"></a><span class="cm"> * Add a reference update to transaction. `new_oid` is the value that</span>
<a name="line-617"></a><span class="cm"> * the reference should have after the update, or `null_oid` if it</span>
<a name="line-618"></a><span class="cm"> * should be deleted. If `new_oid` is NULL, then the reference is not</span>
<a name="line-619"></a><span class="cm"> * changed at all. `old_oid` is the value that the reference must have</span>
<a name="line-620"></a><span class="cm"> * before the update, or `null_oid` if it must not have existed</span>
<a name="line-621"></a><span class="cm"> * beforehand. The old value is checked after the lock is taken to</span>
<a name="line-622"></a><span class="cm"> * prevent races. If the old value doesn&#39;t agree with old_oid, the</span>
<a name="line-623"></a><span class="cm"> * whole transaction fails. If old_oid is NULL, then the previous</span>
<a name="line-624"></a><span class="cm"> * value is not checked.</span>
<a name="line-625"></a><span class="cm"> *</span>
<a name="line-626"></a><span class="cm"> * See the above comment &quot;Reference transaction updates&quot; for more</span>
<a name="line-627"></a><span class="cm"> * information.</span>
<a name="line-628"></a><span class="cm"> */</span>
<a name="line-629"></a><span class="kt">int</span> <span class="nf">ref_transaction_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_transaction</span> <span class="o">*</span><span class="n">transaction</span><span class="p">,</span>
<a name="line-630"></a>			   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span>
<a name="line-631"></a>			   <span class="k">const</span> <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">new_oid</span><span class="p">,</span>
<a name="line-632"></a>			   <span class="k">const</span> <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">old_oid</span><span class="p">,</span>
<a name="line-633"></a>			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
<a name="line-634"></a>			   <span class="k">struct</span> <span class="n">strbuf</span> <span class="o">*</span><span class="n">err</span><span class="p">);</span>
<a name="line-635"></a>
<a name="line-636"></a><span class="cm">/*</span>
<a name="line-637"></a><span class="cm"> * Add a reference creation to transaction. new_oid is the value that</span>
<a name="line-638"></a><span class="cm"> * the reference should have after the update; it must not be</span>
<a name="line-639"></a><span class="cm"> * null_oid. It is verified that the reference does not exist</span>
<a name="line-640"></a><span class="cm"> * already.</span>
<a name="line-641"></a><span class="cm"> *</span>
<a name="line-642"></a><span class="cm"> * See the above comment &quot;Reference transaction updates&quot; for more</span>
<a name="line-643"></a><span class="cm"> * information.</span>
<a name="line-644"></a><span class="cm"> */</span>
<a name="line-645"></a><span class="kt">int</span> <span class="nf">ref_transaction_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_transaction</span> <span class="o">*</span><span class="n">transaction</span><span class="p">,</span>
<a name="line-646"></a>			   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span>
<a name="line-647"></a>			   <span class="k">const</span> <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">new_oid</span><span class="p">,</span>
<a name="line-648"></a>			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
<a name="line-649"></a>			   <span class="k">struct</span> <span class="n">strbuf</span> <span class="o">*</span><span class="n">err</span><span class="p">);</span>
<a name="line-650"></a>
<a name="line-651"></a><span class="cm">/*</span>
<a name="line-652"></a><span class="cm"> * Add a reference deletion to transaction. If old_oid is non-NULL,</span>
<a name="line-653"></a><span class="cm"> * then it holds the value that the reference should have had before</span>
<a name="line-654"></a><span class="cm"> * the update (which must not be null_oid).</span>
<a name="line-655"></a><span class="cm"> *</span>
<a name="line-656"></a><span class="cm"> * See the above comment &quot;Reference transaction updates&quot; for more</span>
<a name="line-657"></a><span class="cm"> * information.</span>
<a name="line-658"></a><span class="cm"> */</span>
<a name="line-659"></a><span class="kt">int</span> <span class="nf">ref_transaction_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_transaction</span> <span class="o">*</span><span class="n">transaction</span><span class="p">,</span>
<a name="line-660"></a>			   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span>
<a name="line-661"></a>			   <span class="k">const</span> <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">old_oid</span><span class="p">,</span>
<a name="line-662"></a>			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
<a name="line-663"></a>			   <span class="k">struct</span> <span class="n">strbuf</span> <span class="o">*</span><span class="n">err</span><span class="p">);</span>
<a name="line-664"></a>
<a name="line-665"></a><span class="cm">/*</span>
<a name="line-666"></a><span class="cm"> * Verify, within a transaction, that refname has the value old_oid,</span>
<a name="line-667"></a><span class="cm"> * or, if old_oid is null_oid, then verify that the reference</span>
<a name="line-668"></a><span class="cm"> * doesn&#39;t exist. old_oid must be non-NULL.</span>
<a name="line-669"></a><span class="cm"> *</span>
<a name="line-670"></a><span class="cm"> * See the above comment &quot;Reference transaction updates&quot; for more</span>
<a name="line-671"></a><span class="cm"> * information.</span>
<a name="line-672"></a><span class="cm"> */</span>
<a name="line-673"></a><span class="kt">int</span> <span class="nf">ref_transaction_verify</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_transaction</span> <span class="o">*</span><span class="n">transaction</span><span class="p">,</span>
<a name="line-674"></a>			   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span>
<a name="line-675"></a>			   <span class="k">const</span> <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">old_oid</span><span class="p">,</span>
<a name="line-676"></a>			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
<a name="line-677"></a>			   <span class="k">struct</span> <span class="n">strbuf</span> <span class="o">*</span><span class="n">err</span><span class="p">);</span>
<a name="line-678"></a>
<a name="line-679"></a><span class="cm">/* Naming conflict (for example, the ref names A and A/B conflict). */</span>
<a name="line-680"></a><span class="cp">#define TRANSACTION_NAME_CONFLICT -1</span>
<a name="line-681"></a><span class="cm">/* All other errors. */</span>
<a name="line-682"></a><span class="cp">#define TRANSACTION_GENERIC_ERROR -2</span>
<a name="line-683"></a>
<a name="line-684"></a><span class="cm">/*</span>
<a name="line-685"></a><span class="cm"> * Perform the preparatory stages of committing `transaction`. Acquire</span>
<a name="line-686"></a><span class="cm"> * any needed locks, check preconditions, etc.; basically, do as much</span>
<a name="line-687"></a><span class="cm"> * as possible to ensure that the transaction will be able to go</span>
<a name="line-688"></a><span class="cm"> * through, stopping just short of making any irrevocable or</span>
<a name="line-689"></a><span class="cm"> * user-visible changes. The updates that this function prepares can</span>
<a name="line-690"></a><span class="cm"> * be finished up by calling `ref_transaction_commit()` or rolled back</span>
<a name="line-691"></a><span class="cm"> * by calling `ref_transaction_abort()`.</span>
<a name="line-692"></a><span class="cm"> *</span>
<a name="line-693"></a><span class="cm"> * On success, return 0 and leave the transaction in &quot;prepared&quot; state.</span>
<a name="line-694"></a><span class="cm"> * On failure, abort the transaction, write an error message to `err`,</span>
<a name="line-695"></a><span class="cm"> * and return one of the `TRANSACTION_*` constants.</span>
<a name="line-696"></a><span class="cm"> *</span>
<a name="line-697"></a><span class="cm"> * Callers who don&#39;t need such fine-grained control over committing</span>
<a name="line-698"></a><span class="cm"> * reference transactions should just call `ref_transaction_commit()`.</span>
<a name="line-699"></a><span class="cm"> */</span>
<a name="line-700"></a><span class="kt">int</span> <span class="nf">ref_transaction_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_transaction</span> <span class="o">*</span><span class="n">transaction</span><span class="p">,</span>
<a name="line-701"></a>			    <span class="k">struct</span> <span class="n">strbuf</span> <span class="o">*</span><span class="n">err</span><span class="p">);</span>
<a name="line-702"></a>
<a name="line-703"></a><span class="cm">/*</span>
<a name="line-704"></a><span class="cm"> * Commit all of the changes that have been queued in transaction, as</span>
<a name="line-705"></a><span class="cm"> * atomically as possible. On success, return 0 and leave the</span>
<a name="line-706"></a><span class="cm"> * transaction in &quot;closed&quot; state. On failure, roll back the</span>
<a name="line-707"></a><span class="cm"> * transaction, write an error message to `err`, and return one of the</span>
<a name="line-708"></a><span class="cm"> * `TRANSACTION_*` constants</span>
<a name="line-709"></a><span class="cm"> */</span>
<a name="line-710"></a><span class="kt">int</span> <span class="nf">ref_transaction_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_transaction</span> <span class="o">*</span><span class="n">transaction</span><span class="p">,</span>
<a name="line-711"></a>			   <span class="k">struct</span> <span class="n">strbuf</span> <span class="o">*</span><span class="n">err</span><span class="p">);</span>
<a name="line-712"></a>
<a name="line-713"></a><span class="cm">/*</span>
<a name="line-714"></a><span class="cm"> * Abort `transaction`, which has been begun and possibly prepared,</span>
<a name="line-715"></a><span class="cm"> * but not yet committed.</span>
<a name="line-716"></a><span class="cm"> */</span>
<a name="line-717"></a><span class="kt">int</span> <span class="nf">ref_transaction_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_transaction</span> <span class="o">*</span><span class="n">transaction</span><span class="p">,</span>
<a name="line-718"></a>			  <span class="k">struct</span> <span class="n">strbuf</span> <span class="o">*</span><span class="n">err</span><span class="p">);</span>
<a name="line-719"></a>
<a name="line-720"></a><span class="cm">/*</span>
<a name="line-721"></a><span class="cm"> * Like ref_transaction_commit(), but optimized for creating</span>
<a name="line-722"></a><span class="cm"> * references when originally initializing a repository (e.g., by &quot;git</span>
<a name="line-723"></a><span class="cm"> * clone&quot;). It writes the new references directly to packed-refs</span>
<a name="line-724"></a><span class="cm"> * without locking the individual references.</span>
<a name="line-725"></a><span class="cm"> *</span>
<a name="line-726"></a><span class="cm"> * It is a bug to call this function when there might be other</span>
<a name="line-727"></a><span class="cm"> * processes accessing the repository or if there are existing</span>
<a name="line-728"></a><span class="cm"> * references that might conflict with the ones being created. All</span>
<a name="line-729"></a><span class="cm"> * old_oid values must either be absent or null_oid.</span>
<a name="line-730"></a><span class="cm"> */</span>
<a name="line-731"></a><span class="kt">int</span> <span class="nf">initial_ref_transaction_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_transaction</span> <span class="o">*</span><span class="n">transaction</span><span class="p">,</span>
<a name="line-732"></a>				   <span class="k">struct</span> <span class="n">strbuf</span> <span class="o">*</span><span class="n">err</span><span class="p">);</span>
<a name="line-733"></a>
<a name="line-734"></a><span class="cm">/*</span>
<a name="line-735"></a><span class="cm"> * Free `*transaction` and all associated data.</span>
<a name="line-736"></a><span class="cm"> */</span>
<a name="line-737"></a><span class="kt">void</span> <span class="nf">ref_transaction_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_transaction</span> <span class="o">*</span><span class="n">transaction</span><span class="p">);</span>
<a name="line-738"></a>
<a name="line-739"></a><span class="cm">/**</span>
<a name="line-740"></a><span class="cm"> * Lock, update, and unlock a single reference. This function</span>
<a name="line-741"></a><span class="cm"> * basically does a transaction containing a single call to</span>
<a name="line-742"></a><span class="cm"> * ref_transaction_update(). The parameters to this function have the</span>
<a name="line-743"></a><span class="cm"> * same meaning as the corresponding parameters to</span>
<a name="line-744"></a><span class="cm"> * ref_transaction_update(). Handle errors as requested by the `onerr`</span>
<a name="line-745"></a><span class="cm"> * argument.</span>
<a name="line-746"></a><span class="cm"> */</span>
<a name="line-747"></a><span class="kt">int</span> <span class="nf">refs_update_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span>
<a name="line-748"></a>		    <span class="k">const</span> <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">new_oid</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">old_oid</span><span class="p">,</span>
<a name="line-749"></a>		    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">enum</span> <span class="n">action_on_err</span> <span class="n">onerr</span><span class="p">);</span>
<a name="line-750"></a><span class="kt">int</span> <span class="nf">update_ref</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span>
<a name="line-751"></a>	       <span class="k">const</span> <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">new_oid</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">old_oid</span><span class="p">,</span>
<a name="line-752"></a>	       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">enum</span> <span class="n">action_on_err</span> <span class="n">onerr</span><span class="p">);</span>
<a name="line-753"></a>
<a name="line-754"></a><span class="kt">int</span> <span class="nf">parse_hide_refs_config</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">var</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<a name="line-755"></a>
<a name="line-756"></a><span class="cm">/*</span>
<a name="line-757"></a><span class="cm"> * Check whether a ref is hidden. If no namespace is set, both the first and</span>
<a name="line-758"></a><span class="cm"> * the second parameter point to the full ref name. If a namespace is set and</span>
<a name="line-759"></a><span class="cm"> * the ref is inside that namespace, the first parameter is a pointer to the</span>
<a name="line-760"></a><span class="cm"> * name of the ref with the namespace prefix removed. If a namespace is set and</span>
<a name="line-761"></a><span class="cm"> * the ref is outside that namespace, the first parameter is NULL. The second</span>
<a name="line-762"></a><span class="cm"> * parameter always points to the full ref name.</span>
<a name="line-763"></a><span class="cm"> */</span>
<a name="line-764"></a><span class="kt">int</span> <span class="nf">ref_is_hidden</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<a name="line-765"></a>
<a name="line-766"></a><span class="k">enum</span> <span class="n">ref_type</span> <span class="p">{</span>
<a name="line-767"></a>	<span class="n">REF_TYPE_PER_WORKTREE</span><span class="p">,</span>	  <span class="cm">/* refs inside refs/ but not shared       */</span>
<a name="line-768"></a>	<span class="n">REF_TYPE_PSEUDOREF</span><span class="p">,</span>	  <span class="cm">/* refs outside refs/ in current worktree */</span>
<a name="line-769"></a>	<span class="n">REF_TYPE_MAIN_PSEUDOREF</span><span class="p">,</span>  <span class="cm">/* pseudo refs from the main worktree     */</span>
<a name="line-770"></a>	<span class="n">REF_TYPE_OTHER_PSEUDOREF</span><span class="p">,</span> <span class="cm">/* pseudo refs from other worktrees       */</span>
<a name="line-771"></a>	<span class="n">REF_TYPE_NORMAL</span><span class="p">,</span>	  <span class="cm">/* normal/shared refs inside refs/        */</span>
<a name="line-772"></a><span class="p">};</span>
<a name="line-773"></a>
<a name="line-774"></a><span class="k">enum</span> <span class="n">ref_type</span> <span class="nf">ref_type</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">);</span>
<a name="line-775"></a>
<a name="line-776"></a><span class="k">enum</span> <span class="n">expire_reflog_flags</span> <span class="p">{</span>
<a name="line-777"></a>	<span class="n">EXPIRE_REFLOGS_DRY_RUN</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
<a name="line-778"></a>	<span class="n">EXPIRE_REFLOGS_UPDATE_REF</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
<a name="line-779"></a>	<span class="n">EXPIRE_REFLOGS_VERBOSE</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>
<a name="line-780"></a>	<span class="n">EXPIRE_REFLOGS_REWRITE</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span>
<a name="line-781"></a><span class="p">};</span>
<a name="line-782"></a>
<a name="line-783"></a><span class="cm">/*</span>
<a name="line-784"></a><span class="cm"> * The following interface is used for reflog expiration. The caller</span>
<a name="line-785"></a><span class="cm"> * calls reflog_expire(), supplying it with three callback functions,</span>
<a name="line-786"></a><span class="cm"> * of the following types. The callback functions define the</span>
<a name="line-787"></a><span class="cm"> * expiration policy that is desired.</span>
<a name="line-788"></a><span class="cm"> *</span>
<a name="line-789"></a><span class="cm"> * reflog_expiry_prepare_fn -- Called once after the reference is</span>
<a name="line-790"></a><span class="cm"> *     locked.</span>
<a name="line-791"></a><span class="cm"> *</span>
<a name="line-792"></a><span class="cm"> * reflog_expiry_should_prune_fn -- Called once for each entry in the</span>
<a name="line-793"></a><span class="cm"> *     existing reflog. It should return true iff that entry should be</span>
<a name="line-794"></a><span class="cm"> *     pruned.</span>
<a name="line-795"></a><span class="cm"> *</span>
<a name="line-796"></a><span class="cm"> * reflog_expiry_cleanup_fn -- Called once before the reference is</span>
<a name="line-797"></a><span class="cm"> *     unlocked again.</span>
<a name="line-798"></a><span class="cm"> */</span>
<a name="line-799"></a><span class="k">typedef</span> <span class="kt">void</span> <span class="nf">reflog_expiry_prepare_fn</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span>
<a name="line-800"></a>				      <span class="k">const</span> <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span>
<a name="line-801"></a>				      <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-802"></a><span class="k">typedef</span> <span class="kt">int</span> <span class="nf">reflog_expiry_should_prune_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">ooid</span><span class="p">,</span>
<a name="line-803"></a>					  <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">noid</span><span class="p">,</span>
<a name="line-804"></a>					  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">email</span><span class="p">,</span>
<a name="line-805"></a>					  <span class="n">timestamp_t</span> <span class="n">timestamp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tz</span><span class="p">,</span>
<a name="line-806"></a>					  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-807"></a><span class="k">typedef</span> <span class="kt">void</span> <span class="nf">reflog_expiry_cleanup_fn</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">);</span>
<a name="line-808"></a>
<a name="line-809"></a><span class="cm">/*</span>
<a name="line-810"></a><span class="cm"> * Expire reflog entries for the specified reference. oid is the old</span>
<a name="line-811"></a><span class="cm"> * value of the reference. flags is a combination of the constants in</span>
<a name="line-812"></a><span class="cm"> * enum expire_reflog_flags. The three function pointers are described</span>
<a name="line-813"></a><span class="cm"> * above. On success, return zero.</span>
<a name="line-814"></a><span class="cm"> */</span>
<a name="line-815"></a><span class="kt">int</span> <span class="nf">refs_reflog_expire</span><span class="p">(</span><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span>
<a name="line-816"></a>		       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span>
<a name="line-817"></a>		       <span class="k">const</span> <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span>
<a name="line-818"></a>		       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
<a name="line-819"></a>		       <span class="n">reflog_expiry_prepare_fn</span> <span class="n">prepare_fn</span><span class="p">,</span>
<a name="line-820"></a>		       <span class="n">reflog_expiry_should_prune_fn</span> <span class="n">should_prune_fn</span><span class="p">,</span>
<a name="line-821"></a>		       <span class="n">reflog_expiry_cleanup_fn</span> <span class="n">cleanup_fn</span><span class="p">,</span>
<a name="line-822"></a>		       <span class="kt">void</span> <span class="o">*</span><span class="n">policy_cb_data</span><span class="p">);</span>
<a name="line-823"></a><span class="kt">int</span> <span class="nf">reflog_expire</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">refname</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">object_id</span> <span class="o">*</span><span class="n">oid</span><span class="p">,</span>
<a name="line-824"></a>		  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
<a name="line-825"></a>		  <span class="n">reflog_expiry_prepare_fn</span> <span class="n">prepare_fn</span><span class="p">,</span>
<a name="line-826"></a>		  <span class="n">reflog_expiry_should_prune_fn</span> <span class="n">should_prune_fn</span><span class="p">,</span>
<a name="line-827"></a>		  <span class="n">reflog_expiry_cleanup_fn</span> <span class="n">cleanup_fn</span><span class="p">,</span>
<a name="line-828"></a>		  <span class="kt">void</span> <span class="o">*</span><span class="n">policy_cb_data</span><span class="p">);</span>
<a name="line-829"></a>
<a name="line-830"></a><span class="kt">int</span> <span class="nf">ref_storage_backend_exists</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<a name="line-831"></a>
<a name="line-832"></a><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="nf">get_main_ref_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">repository</span> <span class="o">*</span><span class="n">r</span><span class="p">);</span>
<a name="line-833"></a>
<a name="line-834"></a><span class="cm">/**</span>
<a name="line-835"></a><span class="cm"> * Submodules</span>
<a name="line-836"></a><span class="cm"> * ----------</span>
<a name="line-837"></a><span class="cm"> *</span>
<a name="line-838"></a><span class="cm"> * If you want to iterate the refs of a submodule you first need to add the</span>
<a name="line-839"></a><span class="cm"> * submodules object database. You can do this by a code-snippet like</span>
<a name="line-840"></a><span class="cm"> * this:</span>
<a name="line-841"></a><span class="cm"> *</span>
<a name="line-842"></a><span class="cm"> * 	const char *path = &quot;path/to/submodule&quot;</span>
<a name="line-843"></a><span class="cm"> * 	if (add_submodule_odb(path))</span>
<a name="line-844"></a><span class="cm"> * 		die(&quot;Error submodule &#39;%s&#39; not populated.&quot;, path);</span>
<a name="line-845"></a><span class="cm"> *</span>
<a name="line-846"></a><span class="cm"> * `add_submodule_odb()` will return zero on success. If you</span>
<a name="line-847"></a><span class="cm"> * do not do this you will get an error for each ref that it does not point</span>
<a name="line-848"></a><span class="cm"> * to a valid object.</span>
<a name="line-849"></a><span class="cm"> *</span>
<a name="line-850"></a><span class="cm"> * Note: As a side-effect of this you cannot safely assume that all</span>
<a name="line-851"></a><span class="cm"> * objects you lookup are available in superproject. All submodule objects</span>
<a name="line-852"></a><span class="cm"> * will be available the same way as the superprojects objects.</span>
<a name="line-853"></a><span class="cm"> *</span>
<a name="line-854"></a><span class="cm"> * Example:</span>
<a name="line-855"></a><span class="cm"> * --------</span>
<a name="line-856"></a><span class="cm"> *</span>
<a name="line-857"></a><span class="cm"> * ----</span>
<a name="line-858"></a><span class="cm"> * static int handle_remote_ref(const char *refname,</span>
<a name="line-859"></a><span class="cm"> * 		const unsigned char *sha1, int flags, void *cb_data)</span>
<a name="line-860"></a><span class="cm"> * {</span>
<a name="line-861"></a><span class="cm"> * 	struct strbuf *output = cb_data;</span>
<a name="line-862"></a><span class="cm"> * 	strbuf_addf(output, &quot;%s\n&quot;, refname);</span>
<a name="line-863"></a><span class="cm"> * 	return 0;</span>
<a name="line-864"></a><span class="cm"> * }</span>
<a name="line-865"></a><span class="cm"> *</span>
<a name="line-866"></a><span class="cm"> */</span>
<a name="line-867"></a>
<a name="line-868"></a><span class="cm">/*</span>
<a name="line-869"></a><span class="cm"> * Return the ref_store instance for the specified submodule. For the</span>
<a name="line-870"></a><span class="cm"> * main repository, use submodule==NULL; such a call cannot fail. For</span>
<a name="line-871"></a><span class="cm"> * a submodule, the submodule must exist and be a nonbare repository,</span>
<a name="line-872"></a><span class="cm"> * otherwise return NULL. If the requested reference store has not yet</span>
<a name="line-873"></a><span class="cm"> * been initialized, initialize it first.</span>
<a name="line-874"></a><span class="cm"> *</span>
<a name="line-875"></a><span class="cm"> * For backwards compatibility, submodule==&quot;&quot; is treated the same as</span>
<a name="line-876"></a><span class="cm"> * submodule==NULL.</span>
<a name="line-877"></a><span class="cm"> */</span>
<a name="line-878"></a><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="nf">get_submodule_ref_store</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">submodule</span><span class="p">);</span>
<a name="line-879"></a><span class="k">struct</span> <span class="n">ref_store</span> <span class="o">*</span><span class="nf">get_worktree_ref_store</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">worktree</span> <span class="o">*</span><span class="n">wt</span><span class="p">);</span>
<a name="line-880"></a>
<a name="line-881"></a><span class="cp">#endif </span><span class="cm">/* REFS_H */</span><span class="cp"></span>
</pre></div>
</td></tr></table>
      </div> <!-- /.wrapper -->
    </div>
    <div id="footer" class="footer">
      <p>
        Cppcheck 2.2 - a tool for static C/C++ code analysis<br>
        <br>
        Internet: <a href="http://cppcheck.net">http://cppcheck.net</a><br>
        IRC: <a href="irc://irc.freenode.net/cppcheck">irc://irc.freenode.net/cppcheck</a><br>
      </p>
    </div>
  </body>
</html>
