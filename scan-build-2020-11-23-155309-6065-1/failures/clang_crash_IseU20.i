# 1 "buffer.c"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 341 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "buffer.c" 2
# 28 "buffer.c"
# 1 "./vim.h" 1
# 12 "./vim.h"
# 1 "./protodef.h" 1
# 13 "./vim.h" 2
# 27 "./vim.h"
# 1 "./auto/config.h" 1
# 28 "./vim.h" 2
# 50 "./vim.h"
# 1 "/llvm-project/build/lib/clang/12.0.0/include/limits.h" 1 3
# 21 "/llvm-project/build/lib/clang/12.0.0/include/limits.h" 3
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 402 "/usr/include/features.h" 3 4
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 403 "/usr/include/features.h" 2 3 4
# 424 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 427 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 428 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 429 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 425 "/usr/include/features.h" 2 3 4
# 448 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 449 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 183 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 160 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 184 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 188 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 1 3 4
# 64 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uio_lim.h" 1 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 2 3 4
# 192 "/usr/include/limits.h" 2 3 4
# 22 "/llvm-project/build/lib/clang/12.0.0/include/limits.h" 2 3
# 51 "./vim.h" 2
# 151 "./vim.h"
# 1 "./feature.h" 1
# 152 "./vim.h" 2
# 228 "./vim.h"
# 1 "./os_unix.h" 1
# 21 "./os_unix.h"
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/llvm-project/build/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 46 "/llvm-project/build/lib/clang/12.0.0/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 130 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 131 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 36 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 37 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 38 "/usr/include/stdio.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/libio.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 3 4
# 1 "/llvm-project/build/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 22 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 2 3 4




typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 36 "/usr/include/x86_64-linux-gnu/bits/libio.h" 2 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
# 1 "/llvm-project/build/lib/clang/12.0.0/include/stdarg.h" 1 3 4
# 14 "/llvm-project/build/lib/clang/12.0.0/include/stdarg.h" 3 4
typedef __builtin_va_list va_list;
# 32 "/llvm-project/build/lib/clang/12.0.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 54 "/usr/include/x86_64-linux-gnu/bits/libio.h" 2 3 4
# 149 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;




typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 177 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 245 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 293 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
  __off64_t _offset;







  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;

  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 337 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);
# 389 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 433 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__ ));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__ ));

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__ ));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__ ));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__ ));
# 462 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__ ));
# 42 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 57 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;
# 71 "/usr/include/stdio.h" 3 4
typedef __ssize_t ssize_t;






typedef _G_fpos_t fpos_t;
# 131 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 132 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ ));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ ));



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ ));







extern FILE *tmpfile (void) __attribute__ ((__warn_unused_result__));
# 173 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));
# 190 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 232 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) __attribute__ ((__warn_unused_result__));




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
# 265 "/usr/include/stdio.h" 3 4
extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));
# 278 "/usr/include/stdio.h" 3 4
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ ));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ ));
# 312 "/usr/include/stdio.h" 3 4
extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));
# 365 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));




extern int scanf (const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ ));
# 395 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf") __attribute__ ((__warn_unused_result__));


extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf") __attribute__ ((__warn_unused_result__));

extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ ));
# 420 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__warn_unused_result__));





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) __attribute__ ((__warn_unused_result__));


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ )) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 443 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__warn_unused_result__));
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) __attribute__ ((__warn_unused_result__));
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ ))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 477 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);
# 495 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 517 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 545 "/usr/include/stdio.h" 3 4
extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);
# 564 "/usr/include/stdio.h" 3 4
extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__warn_unused_result__));
# 603 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 684 "/usr/include/stdio.h" 3 4
extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) __attribute__ ((__warn_unused_result__));




extern void rewind (FILE *__stream);
# 707 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) __attribute__ ((__warn_unused_result__));
# 731 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 757 "/usr/include/stdio.h" 3 4
extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ ));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));
# 775 "/usr/include/stdio.h" 3 4
extern void perror (const char *__s);






# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 782 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));
# 800 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) __attribute__ ((__warn_unused_result__));





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ ));
# 840 "/usr/include/stdio.h" 3 4
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ ));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ ));
# 859 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 1 3 4
# 43 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return _IO_getc (stdin);
}
# 62 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return _IO_putc (__c, stdout);
}
# 97 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}
# 860 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 3 4
extern int __sprintf_chk (char *__restrict __s, int __flag, size_t __slen,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ ));
extern int __vsprintf_chk (char *__restrict __s, int __flag, size_t __slen,
      const char *__restrict __format,
      __gnuc_va_list __ap) __attribute__ ((__nothrow__ ));
# 42 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) vsprintf (char *__restrict __s, const char *__restrict __fmt, __gnuc_va_list __ap)

{
  return __builtin___vsprintf_chk (__s, 1 - 1,
       __builtin_object_size (__s, 1 > 1), __fmt, __ap);
}



extern int __snprintf_chk (char *__restrict __s, size_t __n, int __flag,
      size_t __slen, const char *__restrict __format,
      ...) __attribute__ ((__nothrow__ ));
extern int __vsnprintf_chk (char *__restrict __s, size_t __n, int __flag,
       size_t __slen, const char *__restrict __format,
       __gnuc_va_list __ap) __attribute__ ((__nothrow__ ));
# 73 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) vsnprintf (char *__restrict __s, size_t __n, const char *__restrict __fmt, __gnuc_va_list __ap)

{
  return __builtin___vsnprintf_chk (__s, __n, 1 - 1,
        __builtin_object_size (__s, 1 > 1), __fmt, __ap);
}
# 240 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 3 4
extern char *__fgets_chk (char *__restrict __s, size_t __size, int __n,
     FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern char *__fgets_alias (char *__restrict __s, int __n, FILE *__restrict __stream) __asm__ ("" "fgets") __attribute__ ((__warn_unused_result__));


extern char *__fgets_chk_warn (char *__restrict __s, size_t __size, int __n, FILE *__restrict __stream) __asm__ ("" "__fgets_chk")


     __attribute__ ((__warn_unused_result__)) ;


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__warn_unused_result__)) char *
fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
{
  if (__builtin_object_size (__s, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n) || __n <= 0)
 return __fgets_chk (__s, __builtin_object_size (__s, 1 > 1), __n, __stream);

      if ((size_t) __n > __builtin_object_size (__s, 1 > 1))
 return __fgets_chk_warn (__s, __builtin_object_size (__s, 1 > 1), __n, __stream);
    }
  return __fgets_alias (__s, __n, __stream);
}

extern size_t __fread_chk (void *__restrict __ptr, size_t __ptrlen,
      size_t __size, size_t __n,
      FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t __fread_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread") __attribute__ ((__warn_unused_result__));



extern size_t __fread_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_chk")




     __attribute__ ((__warn_unused_result__)) ;


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__warn_unused_result__)) size_t
fread (void *__restrict __ptr, size_t __size, size_t __n,
       FILE *__restrict __stream)
{
  if (__builtin_object_size (__ptr, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size)
   || !__builtin_constant_p (__n)
   || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
 return __fread_chk (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);

      if (__size * __n > __builtin_object_size (__ptr, 0))
 return __fread_chk_warn (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);
    }
  return __fread_alias (__ptr, __size, __n, __stream);
}
# 863 "/usr/include/stdio.h" 2 3 4
# 22 "./os_unix.h" 2
# 1 "/usr/include/ctype.h" 1 3 4
# 39 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 40 "/usr/include/ctype.h" 2 3 4






enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) __attribute__ ((__nothrow__ ));
extern int isalpha (int) __attribute__ ((__nothrow__ ));
extern int iscntrl (int) __attribute__ ((__nothrow__ ));
extern int isdigit (int) __attribute__ ((__nothrow__ ));
extern int islower (int) __attribute__ ((__nothrow__ ));
extern int isgraph (int) __attribute__ ((__nothrow__ ));
extern int isprint (int) __attribute__ ((__nothrow__ ));
extern int ispunct (int) __attribute__ ((__nothrow__ ));
extern int isspace (int) __attribute__ ((__nothrow__ ));
extern int isupper (int) __attribute__ ((__nothrow__ ));
extern int isxdigit (int) __attribute__ ((__nothrow__ ));



extern int tolower (int __c) __attribute__ ((__nothrow__ ));


extern int toupper (int __c) __attribute__ ((__nothrow__ ));




extern int isblank (int) __attribute__ ((__nothrow__ ));
# 142 "/usr/include/ctype.h" 3 4
extern int isascii (int __c) __attribute__ ((__nothrow__ ));



extern int toascii (int __c) __attribute__ ((__nothrow__ ));



extern int _toupper (int) __attribute__ ((__nothrow__ ));
extern int _tolower (int) __attribute__ ((__nothrow__ ));
# 206 "/usr/include/ctype.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) tolower (int __c)
{
  return __c >= -128 && __c < 256 ? (*__ctype_tolower_loc ())[__c] : __c;
}

extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) toupper (int __c)
{
  return __c >= -128 && __c < 256 ? (*__ctype_toupper_loc ())[__c] : __c;
}
# 237 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 238 "/usr/include/ctype.h" 2 3 4
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isalpha_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int iscntrl_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isdigit_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int islower_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isgraph_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isprint_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int ispunct_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isspace_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isupper_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isxdigit_l (int, locale_t) __attribute__ ((__nothrow__ ));

extern int isblank_l (int, locale_t) __attribute__ ((__nothrow__ ));



extern int __tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ ));
extern int tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ ));


extern int __toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ ));
extern int toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ ));
# 23 "./os_unix.h" 2





# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __loff_t loff_t;



typedef __ino_t ino_t;
# 60 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 98 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 122 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __key_t key_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 128 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4






typedef __time_t time_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 132 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;






# 1 "/llvm-project/build/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 146 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 156 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 157 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 178 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 212 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 254 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 77 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 99 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
};
# 78 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 118 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
struct __pthread_mutex_s
{
  int __lock ;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;





  short __spins; short __elision;
  __pthread_list_t __list;
# 146 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
};




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 255 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 29 "./os_unix.h" 2
# 1 "/usr/include/x86_64-linux-gnu/sys/stat.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4







struct timespec
{
  __time_t tv_sec;
  __syscall_slong_t tv_nsec;
};
# 31 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 101 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
# 91 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 106 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];
# 115 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
  };
# 102 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 205 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat (const char *__restrict __file,
   struct stat *__restrict __buf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern int fstat (int __fd, struct stat *__buf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));
# 234 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fstatat (int __fd, const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));
# 259 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int lstat (const char *__restrict __file,
    struct stat *__restrict __buf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
# 280 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int chmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 293 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fchmod (int __fd, __mode_t __mode) __attribute__ ((__nothrow__ ));





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));






extern __mode_t umask (__mode_t __mask) __attribute__ ((__nothrow__ ));
# 317 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int mkdir (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));





extern int mkfifo (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));





extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));




extern int futimens (int __fd, const struct timespec __times[2]) __attribute__ ((__nothrow__ ));
# 395 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, const char *__filename,
      struct stat *__stat_buf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, const char *__filename,
       struct stat *__stat_buf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, const char *__filename,
         struct stat *__stat_buf, int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4)));
# 438 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __xmknod (int __ver, const char *__path, __mode_t __mode,
       __dev_t *__dev) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, const char *__path,
         __mode_t __mode, __dev_t *__dev)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 5)));




extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) stat (const char *__path, struct stat *__statbuf)
{
  return __xstat (1, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) lstat (const char *__path, struct stat *__statbuf)
{
  return __lxstat (1, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) fstat (int __fd, struct stat *__statbuf)
{
  return __fxstat (1, __fd, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) fstatat (int __fd, const char *__filename, struct stat *__statbuf, int __flag)

{
  return __fxstatat (1, __fd, __filename, __statbuf, __flag);
}
# 486 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) mknodat (int __fd, const char *__path, __mode_t __mode, __dev_t __dev)

{
  return __xmknodat (0, __fd, __path, __mode, &__dev);
}
# 30 "./os_unix.h" 2



# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/llvm-project/build/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 74 "/llvm-project/build/lib/clang/12.0.0/include/stddef.h" 3 4
typedef int wchar_t;
# 32 "/usr/include/stdlib.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 40 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 55 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 207 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef float _Float32;
# 244 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float64;
# 261 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float32x;
# 278 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef long double _Float64x;
# 121 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 56 "/usr/include/stdlib.h" 2 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));



extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 199 "/usr/include/stdlib.h" 3 4
__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 360 "/usr/include/stdlib.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) atoi (const char *__nptr)
{
  return (int) strtol (__nptr, (char **) ((void*)0), 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
__attribute__ ((__nothrow__ )) atol (const char *__nptr)
{
  return strtol (__nptr, (char **) ((void*)0), 10);
}


__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
__attribute__ ((__nothrow__ )) atoll (const char *__nptr)
{
  return strtoll (__nptr, (char **) ((void*)0), 10);
}
# 385 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 401 "/usr/include/stdlib.h" 3 4
extern long int random (void) __attribute__ ((__nothrow__ ));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ ));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 453 "/usr/include/stdlib.h" 3 4
extern int rand (void) __attribute__ ((__nothrow__ ));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ ));



extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ ));







extern double drand48 (void) __attribute__ ((__nothrow__ ));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ ));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ ));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ ));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 539 "/usr/include/stdlib.h" 3 4
extern void *malloc (size_t __size) __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));






extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));
# 563 "/usr/include/stdlib.h" 3 4
extern void free (void *__ptr) __attribute__ ((__nothrow__ ));
# 577 "/usr/include/stdlib.h" 3 4
extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));



extern void abort (void) __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 614 "/usr/include/stdlib.h" 3 4
extern void exit (int __status) __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));





extern void _Exit (int __status) __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 644 "/usr/include/stdlib.h" 3 4
extern int putenv (char *__string) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 685 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 728 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 781 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) __attribute__ ((__warn_unused_result__));
# 797 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));






typedef int (*__compar_fn_t) (const void *, const void *);
# 817 "/usr/include/stdlib.h" 3 4
extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) __attribute__ ((__warn_unused_result__));



# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) void *
bsearch (const void *__key, const void *__base, size_t __nmemb, size_t __size,
  __compar_fn_t __compar)
{
  size_t __l, __u, __idx;
  const void *__p;
  int __comparison;

  __l = 0;
  __u = __nmemb;
  while (__l < __u)
    {
      __idx = (__l + __u) / 2;
      __p = (void *) (((const char *) __base) + (__idx * __size));
      __comparison = (*__compar) (__key, __p);
      if (__comparison < 0)
 __u = __idx;
      else if (__comparison > 0)
 __l = __idx + 1;
      else
 return (void *) __p;
    }

  return ((void*)0);
}
# 823 "/usr/include/stdlib.h" 2 3 4




extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
# 837 "/usr/include/stdlib.h" 3 4
extern int abs (int __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
extern long int labs (long int __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));


__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));






extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
# 919 "/usr/include/stdlib.h" 3 4
extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ ));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ ));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ ));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ ));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ ));
# 954 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2, 3))) __attribute__ ((__warn_unused_result__));





extern void setkey (const char *__key) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) __attribute__ ((__warn_unused_result__));







extern int grantpt (int __fd) __attribute__ ((__nothrow__ ));



extern int unlockpt (int __fd) __attribute__ ((__nothrow__ ));




extern char *ptsname (int __fd) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));
# 1016 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) double
__attribute__ ((__nothrow__ )) atof (const char *__nptr)
{
  return strtod (__nptr, (char **) ((void*)0));
}
# 1017 "/usr/include/stdlib.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h" 3 4
extern char *__realpath_chk (const char *__restrict __name,
        char *__restrict __resolved,
        size_t __resolvedlen) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));
extern char *__realpath_alias (const char *__restrict __name, char *__restrict __resolved) __asm__ ("" "realpath") __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));


extern char *__realpath_chk_warn (const char *__restrict __name, char *__restrict __resolved, size_t __resolvedlen) __asm__ ("" "__realpath_chk") __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__))




                                      ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__warn_unused_result__)) char *
__attribute__ ((__nothrow__ )) realpath (const char *__restrict __name, char *__restrict __resolved)
{
  if (__builtin_object_size (__resolved, 1 > 1) != (size_t) -1)
    {

      if (__builtin_object_size (__resolved, 1 > 1) < 4096)
 return __realpath_chk_warn (__name, __resolved, __builtin_object_size (__resolved, 1 > 1));

      return __realpath_chk (__name, __resolved, __builtin_object_size (__resolved, 1 > 1));
    }

  return __realpath_alias (__name, __resolved);
}


extern int __ptsname_r_chk (int __fd, char *__buf, size_t __buflen,
       size_t __nreal) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));
extern int __ptsname_r_alias (int __fd, char *__buf, size_t __buflen) __asm__ ("" "ptsname_r") __attribute__ ((__nothrow__ ))

     __attribute__ ((__nonnull__ (2)));
extern int __ptsname_r_chk_warn (int __fd, char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__ptsname_r_chk") __attribute__ ((__nothrow__ ))


     __attribute__ ((__nonnull__ (2))) ;


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) ptsname_r (int __fd, char *__buf, size_t __buflen)
{
  if (__builtin_object_size (__buf, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __ptsname_r_chk (__fd, __buf, __buflen, __builtin_object_size (__buf, 1 > 1));
      if (__buflen > __builtin_object_size (__buf, 1 > 1))
 return __ptsname_r_chk_warn (__fd, __buf, __buflen, __builtin_object_size (__buf, 1 > 1));
    }
  return __ptsname_r_alias (__fd, __buf, __buflen);
}


extern int __wctomb_chk (char *__s, wchar_t __wchar, size_t __buflen)
  __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));
extern int __wctomb_alias (char *__s, wchar_t __wchar) __asm__ ("" "wctomb") __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__warn_unused_result__)) int
__attribute__ ((__nothrow__ )) wctomb (char *__s, wchar_t __wchar)
{







  if (__builtin_object_size (__s, 1 > 1) != (size_t) -1 && 16 > __builtin_object_size (__s, 1 > 1))
    return __wctomb_chk (__s, __wchar, __builtin_object_size (__s, 1 > 1));
  return __wctomb_alias (__s, __wchar);
}


extern size_t __mbstowcs_chk (wchar_t *__restrict __dst,
         const char *__restrict __src,
         size_t __len, size_t __dstlen) __attribute__ ((__nothrow__ ));
extern size_t __mbstowcs_alias (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len) __asm__ ("" "mbstowcs") __attribute__ ((__nothrow__ ));



extern size_t __mbstowcs_chk_warn (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len, size_t __dstlen) __asm__ ("" "__mbstowcs_chk") __attribute__ ((__nothrow__ ))




                        ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) size_t
__attribute__ ((__nothrow__ )) mbstowcs (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len)

{
  if (__builtin_object_size (__dst, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __mbstowcs_chk (__dst, __src, __len,
          __builtin_object_size (__dst, 1 > 1) / sizeof (wchar_t));

      if (__len > __builtin_object_size (__dst, 1 > 1) / sizeof (wchar_t))
 return __mbstowcs_chk_warn (__dst, __src, __len,
         __builtin_object_size (__dst, 1 > 1) / sizeof (wchar_t));
    }
  return __mbstowcs_alias (__dst, __src, __len);
}


extern size_t __wcstombs_chk (char *__restrict __dst,
         const wchar_t *__restrict __src,
         size_t __len, size_t __dstlen) __attribute__ ((__nothrow__ ));
extern size_t __wcstombs_alias (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len) __asm__ ("" "wcstombs") __attribute__ ((__nothrow__ ));



extern size_t __wcstombs_chk_warn (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len, size_t __dstlen) __asm__ ("" "__wcstombs_chk") __attribute__ ((__nothrow__ ))



                                                                    ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) size_t
__attribute__ ((__nothrow__ )) wcstombs (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len)

{
  if (__builtin_object_size (__dst, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __wcstombs_chk (__dst, __src, __len, __builtin_object_size (__dst, 1 > 1));
      if (__len > __builtin_object_size (__dst, 1 > 1))
 return __wcstombs_chk_warn (__dst, __src, __len, __builtin_object_size (__dst, 1 > 1));
    }
  return __wcstombs_alias (__dst, __src, __len);
}
# 1021 "/usr/include/stdlib.h" 2 3 4
# 34 "./os_unix.h" 2
# 52 "./os_unix.h"
# 1 "/usr/include/unistd.h" 1 3 4
# 205 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 206 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 210 "/usr/include/unistd.h" 2 3 4
# 229 "/usr/include/unistd.h" 3 4
# 1 "/llvm-project/build/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 230 "/usr/include/unistd.h" 2 3 4
# 270 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 290 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 307 "/usr/include/unistd.h" 3 4
extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));
# 337 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__ ));
# 356 "/usr/include/unistd.h" 3 4
extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) __attribute__ ((__warn_unused_result__));





extern ssize_t write (int __fd, const void *__buf, size_t __n) __attribute__ ((__warn_unused_result__));
# 379 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) __attribute__ ((__warn_unused_result__));






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) __attribute__ ((__warn_unused_result__));
# 420 "/usr/include/unistd.h" 3 4
extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));
# 435 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ ));
# 447 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);
# 472 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));



extern int chdir (const char *__path) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern int fchdir (int __fd) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));
# 514 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));
# 534 "/usr/include/unistd.h" 3 4
extern int dup (int __fd) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ ));
# 546 "/usr/include/unistd.h" 3 4
extern char **__environ;







extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
# 601 "/usr/include/unistd.h" 3 4
extern int nice (int __inc) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));




extern void _exit (int __status) __attribute__ ((__noreturn__));






# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 613 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ ));


extern long int sysconf (int __name) __attribute__ ((__nothrow__ ));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ ));




extern __pid_t getpid (void) __attribute__ ((__nothrow__ ));


extern __pid_t getppid (void) __attribute__ ((__nothrow__ ));


extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ ));


extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ ));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ ));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ ));
# 663 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__ ));






extern __pid_t setsid (void) __attribute__ ((__nothrow__ ));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ ));



extern __uid_t getuid (void) __attribute__ ((__nothrow__ ));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__ ));


extern __gid_t getgid (void) __attribute__ ((__nothrow__ ));


extern __gid_t getegid (void) __attribute__ ((__nothrow__ ));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));
# 703 "/usr/include/unistd.h" 3 4
extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));
# 759 "/usr/include/unistd.h" 3 4
extern __pid_t fork (void) __attribute__ ((__nothrow__));
# 773 "/usr/include/unistd.h" 3 4
extern char *ttyname (int __fd) __attribute__ ((__nothrow__ ));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));



extern int isatty (int __fd) __attribute__ ((__nothrow__ ));
# 792 "/usr/include/unistd.h" 3 4
extern int link (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 4))) __attribute__ ((__warn_unused_result__));




extern int symlink (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 3))) __attribute__ ((__warn_unused_result__));


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__));



extern int unlink (const char *__name) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ ));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ ));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));
# 872 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern char *optarg;
# 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 91 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 2 3 4
# 873 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 957 "/usr/include/unistd.h" 3 4
extern int fsync (int __fd);
# 970 "/usr/include/unistd.h" 3 4
extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__ ));
# 994 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 1017 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));
# 1082 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) __attribute__ ((__warn_unused_result__));
# 1118 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);







extern char *crypt (const char *__key, const char *__salt)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__glibc_block, int __edflag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));






extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
# 1172 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/unistd.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/unistd.h" 3 4
extern ssize_t __read_chk (int __fd, void *__buf, size_t __nbytes,
      size_t __buflen) __attribute__ ((__warn_unused_result__));
extern ssize_t __read_alias (int __fd, void *__buf, size_t __nbytes) __asm__ ("" "read") __attribute__ ((__warn_unused_result__));

extern ssize_t __read_chk_warn (int __fd, void *__buf, size_t __nbytes, size_t __buflen) __asm__ ("" "__read_chk")


     __attribute__ ((__warn_unused_result__)) ;


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__warn_unused_result__)) ssize_t
read (int __fd, void *__buf, size_t __nbytes)
{
  if (__builtin_object_size (__buf, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__nbytes))
 return __read_chk (__fd, __buf, __nbytes, __builtin_object_size (__buf, 0));

      if (__nbytes > __builtin_object_size (__buf, 0))
 return __read_chk_warn (__fd, __buf, __nbytes, __builtin_object_size (__buf, 0));
    }
  return __read_alias (__fd, __buf, __nbytes);
}


extern ssize_t __pread_chk (int __fd, void *__buf, size_t __nbytes,
       __off_t __offset, size_t __bufsize) __attribute__ ((__warn_unused_result__));
extern ssize_t __pread64_chk (int __fd, void *__buf, size_t __nbytes,
         __off64_t __offset, size_t __bufsize) __attribute__ ((__warn_unused_result__));
extern ssize_t __pread_alias (int __fd, void *__buf, size_t __nbytes, __off_t __offset) __asm__ ("" "pread") __attribute__ ((__warn_unused_result__));


extern ssize_t __pread64_alias (int __fd, void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pread64") __attribute__ ((__warn_unused_result__));


extern ssize_t __pread_chk_warn (int __fd, void *__buf, size_t __nbytes, __off_t __offset, size_t __bufsize) __asm__ ("" "__pread_chk")


     __attribute__ ((__warn_unused_result__)) ;

extern ssize_t __pread64_chk_warn (int __fd, void *__buf, size_t __nbytes, __off64_t __offset, size_t __bufsize) __asm__ ("" "__pread64_chk")



     __attribute__ ((__warn_unused_result__)) ;



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__warn_unused_result__)) ssize_t
pread (int __fd, void *__buf, size_t __nbytes, __off_t __offset)
{
  if (__builtin_object_size (__buf, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__nbytes))
 return __pread_chk (__fd, __buf, __nbytes, __offset, __builtin_object_size (__buf, 0));

      if ( __nbytes > __builtin_object_size (__buf, 0))
 return __pread_chk_warn (__fd, __buf, __nbytes, __offset,
     __builtin_object_size (__buf, 0));
    }
  return __pread_alias (__fd, __buf, __nbytes, __offset);
}
# 123 "/usr/include/x86_64-linux-gnu/bits/unistd.h" 3 4
extern ssize_t __readlink_chk (const char *__restrict __path,
          char *__restrict __buf, size_t __len,
          size_t __buflen)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));
extern ssize_t __readlink_alias (const char *__restrict __path, char *__restrict __buf, size_t __len) __asm__ ("" "readlink") __attribute__ ((__nothrow__ ))


     __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));
extern ssize_t __readlink_chk_warn (const char *__restrict __path, char *__restrict __buf, size_t __len, size_t __buflen) __asm__ ("" "__readlink_chk") __attribute__ ((__nothrow__ ))



     __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__)) ;


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__)) ssize_t
__attribute__ ((__nothrow__ )) readlink (const char *__restrict __path, char *__restrict __buf, size_t __len)

{
  if (__builtin_object_size (__buf, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __readlink_chk (__path, __buf, __len, __builtin_object_size (__buf, 1 > 1));

      if ( __len > __builtin_object_size (__buf, 1 > 1))
 return __readlink_chk_warn (__path, __buf, __len, __builtin_object_size (__buf, 1 > 1));
    }
  return __readlink_alias (__path, __buf, __len);
}



extern ssize_t __readlinkat_chk (int __fd, const char *__restrict __path,
     char *__restrict __buf, size_t __len,
     size_t __buflen)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__));
extern ssize_t __readlinkat_alias (int __fd, const char *__restrict __path, char *__restrict __buf, size_t __len) __asm__ ("" "readlinkat") __attribute__ ((__nothrow__ ))



     __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__));
extern ssize_t __readlinkat_chk_warn (int __fd, const char *__restrict __path, char *__restrict __buf, size_t __len, size_t __buflen) __asm__ ("" "__readlinkat_chk") __attribute__ ((__nothrow__ ))



     __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__)) ;



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__)) ssize_t
__attribute__ ((__nothrow__ )) readlinkat (int __fd, const char *__restrict __path, char *__restrict __buf, size_t __len)

{
  if (__builtin_object_size (__buf, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __readlinkat_chk (__fd, __path, __buf, __len, __builtin_object_size (__buf, 1 > 1));

      if (__len > __builtin_object_size (__buf, 1 > 1))
 return __readlinkat_chk_warn (__fd, __path, __buf, __len,
          __builtin_object_size (__buf, 1 > 1));
    }
  return __readlinkat_alias (__fd, __path, __buf, __len);
}


extern char *__getcwd_chk (char *__buf, size_t __size, size_t __buflen)
     __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));
extern char *__getcwd_alias (char *__buf, size_t __size) __asm__ ("" "getcwd") __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));

extern char *__getcwd_chk_warn (char *__buf, size_t __size, size_t __buflen) __asm__ ("" "__getcwd_chk") __attribute__ ((__nothrow__ ))


     __attribute__ ((__warn_unused_result__)) ;


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__warn_unused_result__)) char *
__attribute__ ((__nothrow__ )) getcwd (char *__buf, size_t __size)
{
  if (__builtin_object_size (__buf, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size))
 return __getcwd_chk (__buf, __size, __builtin_object_size (__buf, 1 > 1));

      if (__size > __builtin_object_size (__buf, 1 > 1))
 return __getcwd_chk_warn (__buf, __size, __builtin_object_size (__buf, 1 > 1));
    }
  return __getcwd_alias (__buf, __size);
}


extern char *__getwd_chk (char *__buf, size_t buflen)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern char *__getwd_warn (char *__buf) __asm__ ("" "getwd") __attribute__ ((__nothrow__ ))
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__)) ;


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) __attribute__ ((__warn_unused_result__)) char *
__attribute__ ((__nothrow__ )) getwd (char *__buf)
{
  if (__builtin_object_size (__buf, 1 > 1) != (size_t) -1)
    return __getwd_chk (__buf, __builtin_object_size (__buf, 1 > 1));
  return __getwd_warn (__buf);
}


extern size_t __confstr_chk (int __name, char *__buf, size_t __len,
        size_t __buflen) __attribute__ ((__nothrow__ ));
extern size_t __confstr_alias (int __name, char *__buf, size_t __len) __asm__ ("" "confstr") __attribute__ ((__nothrow__ ));

extern size_t __confstr_chk_warn (int __name, char *__buf, size_t __len, size_t __buflen) __asm__ ("" "__confstr_chk") __attribute__ ((__nothrow__ ))



            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) size_t
__attribute__ ((__nothrow__ )) confstr (int __name, char *__buf, size_t __len)
{
  if (__builtin_object_size (__buf, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __confstr_chk (__name, __buf, __len, __builtin_object_size (__buf, 1 > 1));

      if (__builtin_object_size (__buf, 1 > 1) < __len)
 return __confstr_chk_warn (__name, __buf, __len, __builtin_object_size (__buf, 1 > 1));
    }
  return __confstr_alias (__name, __buf, __len);
}


extern int __getgroups_chk (int __size, __gid_t __list[], size_t __listlen)
     __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));
extern int __getgroups_alias (int __size, __gid_t __list[]) __asm__ ("" "getgroups") __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));

extern int __getgroups_chk_warn (int __size, __gid_t __list[], size_t __listlen) __asm__ ("" "__getgroups_chk") __attribute__ ((__nothrow__ ))


     __attribute__ ((__warn_unused_result__)) ;


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) getgroups (int __size, __gid_t __list[])
{
  if (__builtin_object_size (__list, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size) || __size < 0)
 return __getgroups_chk (__size, __list, __builtin_object_size (__list, 1 > 1));

      if (__size * sizeof (__gid_t) > __builtin_object_size (__list, 1 > 1))
 return __getgroups_chk_warn (__size, __list, __builtin_object_size (__list, 1 > 1));
    }
  return __getgroups_alias (__size, __list);
}


extern int __ttyname_r_chk (int __fd, char *__buf, size_t __buflen,
       size_t __nreal) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));
extern int __ttyname_r_alias (int __fd, char *__buf, size_t __buflen) __asm__ ("" "ttyname_r") __attribute__ ((__nothrow__ ))

     __attribute__ ((__nonnull__ (2)));
extern int __ttyname_r_chk_warn (int __fd, char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__ttyname_r_chk") __attribute__ ((__nothrow__ ))


     __attribute__ ((__nonnull__ (2))) ;


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) ttyname_r (int __fd, char *__buf, size_t __buflen)
{
  if (__builtin_object_size (__buf, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __ttyname_r_chk (__fd, __buf, __buflen, __builtin_object_size (__buf, 1 > 1));

      if (__buflen > __builtin_object_size (__buf, 1 > 1))
 return __ttyname_r_chk_warn (__fd, __buf, __buflen, __builtin_object_size (__buf, 1 > 1));
    }
  return __ttyname_r_alias (__fd, __buf, __buflen);
}



extern int __getlogin_r_chk (char *__buf, size_t __buflen, size_t __nreal)
     __attribute__ ((__nonnull__ (1)));
extern int __getlogin_r_alias (char *__buf, size_t __buflen) __asm__ ("" "getlogin_r") __attribute__ ((__nonnull__ (1)));

extern int __getlogin_r_chk_warn (char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__getlogin_r_chk")


     __attribute__ ((__nonnull__ (1))) ;


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) int
getlogin_r (char *__buf, size_t __buflen)
{
  if (__builtin_object_size (__buf, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __getlogin_r_chk (__buf, __buflen, __builtin_object_size (__buf, 1 > 1));

      if (__buflen > __builtin_object_size (__buf, 1 > 1))
 return __getlogin_r_chk_warn (__buf, __buflen, __builtin_object_size (__buf, 1 > 1));
    }
  return __getlogin_r_alias (__buf, __buflen);
}




extern int __gethostname_chk (char *__buf, size_t __buflen, size_t __nreal)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
extern int __gethostname_alias (char *__buf, size_t __buflen) __asm__ ("" "gethostname") __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

extern int __gethostname_chk_warn (char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__gethostname_chk") __attribute__ ((__nothrow__ ))


     __attribute__ ((__nonnull__ (1))) ;


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) gethostname (char *__buf, size_t __buflen)
{
  if (__builtin_object_size (__buf, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __gethostname_chk (__buf, __buflen, __builtin_object_size (__buf, 1 > 1));

      if (__buflen > __builtin_object_size (__buf, 1 > 1))
 return __gethostname_chk_warn (__buf, __buflen, __builtin_object_size (__buf, 1 > 1));
    }
  return __gethostname_alias (__buf, __buflen);
}
# 1173 "/usr/include/unistd.h" 2 3 4
# 53 "./os_unix.h" 2







# 1 "/usr/include/x86_64-linux-gnu/sys/param.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/sys/param.h" 3 4
# 1 "/llvm-project/build/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4




# 1 "/usr/include/signal.h" 1 3 4
# 30 "/usr/include/signal.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/signum.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/signum.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/signum-generic.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/signum.h" 2 3 4
# 31 "/usr/include/signal.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/sig_atomic_t.h" 1 3 4







typedef __sig_atomic_t sig_atomic_t;
# 33 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 36 "/usr/include/signal.h" 2 3 4
# 57 "/usr/include/signal.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 5 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h" 3 4
union sigval
{
  int sival_int;
  void *sival_ptr;
};

typedef union sigval __sigval_t;
# 7 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 2 3 4
# 16 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo-arch.h" 1 3 4
# 17 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 2 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 3 4
typedef struct
  {
    int si_signo;

    int si_errno;

    int si_code;





    int __pad0;


    union
      {
 int _pad[((128 / sizeof (int)) - 4)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     __sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     __sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __clock_t si_utime;
     __clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;

     short int si_addr_lsb;
     union
       {

  struct
    {
      void *_lower;
      void *_upper;
    } _addr_bnd;

  __uint32_t _pkey;
       } _bounds;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;



 struct
   {
     void *_call_addr;
     int _syscall;
     unsigned int _arch;
   } _sigsys;

      } _sifields;
  } siginfo_t ;
# 58 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 3 4
enum
{
  SI_ASYNCNL = -60,
  SI_TKILL = -6,
  SI_SIGIO,

  SI_ASYNCIO,
  SI_MESGQ,
  SI_TIMER,





  SI_QUEUE,
  SI_USER,
  SI_KERNEL = 0x80
# 63 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 3 4
};




enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR,

  SEGV_BNDERR,

  SEGV_PKUERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR,

  BUS_MCEERR_AR,

  BUS_MCEERR_AO

};




enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE

};




enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};
# 59 "/usr/include/signal.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 2 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 3 4
typedef struct sigevent
  {
    __sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 4)];



 __pid_t _tid;

 struct
   {
     void (*_function) (__sigval_t);
     pthread_attr_t *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;
# 67 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h" 3 4
enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4


};
# 68 "/usr/include/signal.h" 2 3 4




typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ ));
# 93 "/usr/include/signal.h" 3 4
extern __sighandler_t signal (int __sig, __sighandler_t __handler) __asm__ ("" "__sysv_signal") __attribute__ ((__nothrow__ ));
# 112 "/usr/include/signal.h" 3 4
extern int kill (__pid_t __pid, int __sig) __attribute__ ((__nothrow__ ));






extern int killpg (__pid_t __pgrp, int __sig) __attribute__ ((__nothrow__ ));



extern int raise (int __sig) __attribute__ ((__nothrow__ ));
# 134 "/usr/include/signal.h" 3 4
extern void psignal (int __sig, const char *__s);


extern void psiginfo (const siginfo_t *__pinfo, const char *__s);
# 151 "/usr/include/signal.h" 3 4
extern int sigpause (int __sig) __asm__ ("__xpg_sigpause");
# 196 "/usr/include/signal.h" 3 4
extern int sigemptyset (sigset_t *__set) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int sigismember (const sigset_t *__set, int __signo)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 226 "/usr/include/signal.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sigaction.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h" 3 4
struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };
# 227 "/usr/include/signal.h" 2 3 4


extern int sigprocmask (int __how, const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) __attribute__ ((__nothrow__ ));






extern int sigsuspend (const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) __attribute__ ((__nothrow__ ));


extern int sigpending (sigset_t *__set) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));







extern int sigwait (const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));







extern int sigwaitinfo (const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));






extern int sigtimedwait (const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));



extern int sigqueue (__pid_t __pid, int __sig, const union sigval __val)
     __attribute__ ((__nothrow__ ));
# 301 "/usr/include/signal.h" 3 4
# 1 "/llvm-project/build/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 302 "/usr/include/signal.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h" 3 4
# 1 "/llvm-project/build/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h" 2 3 4


typedef struct
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 304 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 1 3 4
# 37 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3 4
__extension__ typedef long long int greg_t;
# 46 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3 4
typedef greg_t gregset_t[23];
# 101 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3 4
struct _libc_fpxreg
{
  unsigned short int __significand[4];
  unsigned short int __exponent;
  unsigned short int __glibc_reserved1[3];
};

struct _libc_xmmreg
{
  __uint32_t __element[4];
};

struct _libc_fpstate
{

  __uint16_t __cwd;
  __uint16_t __swd;
  __uint16_t __ftw;
  __uint16_t __fop;
  __uint64_t __rip;
  __uint64_t __rdp;
  __uint32_t __mxcsr;
  __uint32_t __mxcr_mask;
  struct _libc_fpxreg _st[8];
  struct _libc_xmmreg _xmm[16];
  __uint32_t __glibc_reserved1[24];
};


typedef struct _libc_fpstate *fpregset_t;


typedef struct
  {
    gregset_t __gregs;

    fpregset_t __fpregs;
    __extension__ unsigned long long __reserved1 [8];
} mcontext_t;


typedef struct ucontext_t
  {
    unsigned long int __uc_flags;
    struct ucontext_t *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
  } ucontext_t;
# 307 "/usr/include/signal.h" 2 3 4







extern int siginterrupt (int __sig, int __interrupt) __attribute__ ((__nothrow__ ));


# 1 "/usr/include/x86_64-linux-gnu/bits/sigstack.h" 1 3 4
# 317 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h" 3 4
enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
# 318 "/usr/include/signal.h" 2 3 4



extern int sigaltstack (const stack_t *__restrict __ss,
   stack_t *__restrict __oss) __attribute__ ((__nothrow__ ));
# 343 "/usr/include/signal.h" 3 4
extern int sighold (int __sig) __attribute__ ((__nothrow__ ));


extern int sigrelse (int __sig) __attribute__ ((__nothrow__ ));


extern int sigignore (int __sig) __attribute__ ((__nothrow__ ));


extern __sighandler_t sigset (int __sig, __sighandler_t __disp) __attribute__ ((__nothrow__ ));







# 1 "/usr/include/x86_64-linux-gnu/bits/sigthread.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
       const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)__attribute__ ((__nothrow__ ));


extern int pthread_kill (pthread_t __threadid, int __signo) __attribute__ ((__nothrow__ ));
# 360 "/usr/include/signal.h" 2 3 4






extern int __libc_current_sigrtmin (void) __attribute__ ((__nothrow__ ));

extern int __libc_current_sigrtmax (void) __attribute__ ((__nothrow__ ));
# 29 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/param.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/param.h" 3 4
# 1 "/usr/include/linux/param.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/asm/param.h" 1 3 4
# 1 "/usr/include/asm-generic/param.h" 1 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/param.h" 2 3 4
# 6 "/usr/include/linux/param.h" 2 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/param.h" 2 3 4
# 32 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4
# 61 "./os_unix.h" 2
# 112 "./os_unix.h"
# 1 "/usr/include/dirent.h" 1 3 4
# 61 "/usr/include/dirent.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/dirent.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h" 3 4
struct dirent
  {

    __ino_t d_ino;
    __off_t d_off;




    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256];
  };
# 62 "/usr/include/dirent.h" 2 3 4
# 127 "/usr/include/dirent.h" 3 4
typedef struct __dirstream DIR;






extern DIR *opendir (const char *__name) __attribute__ ((__nonnull__ (1)));






extern DIR *fdopendir (int __fd);







extern int closedir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
# 162 "/usr/include/dirent.h" 3 4
extern struct dirent *readdir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
# 183 "/usr/include/dirent.h" 3 4
extern int readdir_r (DIR *__restrict __dirp,
        struct dirent *__restrict __entry,
        struct dirent **__restrict __result)
     __attribute__ ((__nonnull__ (1, 2, 3))) __attribute__ ((__deprecated__));
# 209 "/usr/include/dirent.h" 3 4
extern void rewinddir (DIR *__dirp) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern void seekdir (DIR *__dirp, long int __pos) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern long int telldir (DIR *__dirp) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int dirfd (DIR *__dirp) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 245 "/usr/include/dirent.h" 3 4
# 1 "/llvm-project/build/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 246 "/usr/include/dirent.h" 2 3 4
# 255 "/usr/include/dirent.h" 3 4
extern int scandir (const char *__restrict __dir,
      struct dirent ***__restrict __namelist,
      int (*__selector) (const struct dirent *),
      int (*__cmp) (const struct dirent **,
      const struct dirent **))
     __attribute__ ((__nonnull__ (1, 2)));
# 325 "/usr/include/dirent.h" 3 4
extern int alphasort (const struct dirent **__e1,
        const struct dirent **__e2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 113 "./os_unix.h" 2
# 132 "./os_unix.h"
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/llvm-project/build/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 34 "/usr/include/time.h" 2 3 4





# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;





  long int __tm_gmtoff;
  const char *__tm_zone;

};
# 40 "/usr/include/time.h" 2 3 4








# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 72 "/usr/include/time.h" 3 4
extern clock_t clock (void) __attribute__ ((__nothrow__ ));


extern time_t time (time_t *__timer) __attribute__ ((__nothrow__ ));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__ ));





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ ));




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     __attribute__ ((__nothrow__ ));






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) __attribute__ ((__nothrow__ ));
# 119 "/usr/include/time.h" 3 4
extern struct tm *gmtime (const time_t *__timer) __attribute__ ((__nothrow__ ));



extern struct tm *localtime (const time_t *__timer) __attribute__ ((__nothrow__ ));




extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__ ));



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__ ));




extern char *asctime (const struct tm *__tp) __attribute__ ((__nothrow__ ));


extern char *ctime (const time_t *__timer) __attribute__ ((__nothrow__ ));






extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__ ));


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__ ));




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__ ));



extern int daylight;
extern long int timezone;
# 211 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__ ));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__ ));


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     __attribute__ ((__nothrow__ ));






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__ ));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__ ));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__ ));


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__ ));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__ ));


extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__ ));





extern int timespec_get (struct timespec *__ts, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 280 "/usr/include/time.h" 3 4
extern int getdate_err;
# 289 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 133 "./os_unix.h" 2


# 1 "/usr/include/x86_64-linux-gnu/sys/time.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 26 "/usr/include/x86_64-linux-gnu/sys/time.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;
# 101 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);






# 1 "/usr/include/x86_64-linux-gnu/bits/select2.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/select2.h" 3 4
extern long int __fdelt_chk (long int __d);
extern long int __fdelt_warn (long int __d)
                                               ;
# 124 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 33 "/usr/include/x86_64-linux-gnu/sys/time.h" 2 3 4
# 60 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
typedef void *__restrict __timezone_ptr_t;







extern int gettimeofday (struct timeval *__restrict __tv,
    __timezone_ptr_t __tz) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 88 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };






typedef int __itimer_which_t;




extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) __attribute__ ((__nothrow__ ));




extern int setitimer (__itimer_which_t __which,
        const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) __attribute__ ((__nothrow__ ));




extern int utimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 136 "./os_unix.h" 2
# 163 "./os_unix.h"
# 1 "/usr/include/pwd.h" 1 3 4
# 32 "/usr/include/pwd.h" 3 4
# 1 "/llvm-project/build/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 33 "/usr/include/pwd.h" 2 3 4
# 49 "/usr/include/pwd.h" 3 4
struct passwd
{
  char *pw_name;
  char *pw_passwd;
  __uid_t pw_uid;
  __gid_t pw_gid;
  char *pw_gecos;
  char *pw_dir;
  char *pw_shell;
};
# 71 "/usr/include/pwd.h" 3 4
extern void setpwent (void);





extern void endpwent (void);





extern struct passwd *getpwent (void);
# 109 "/usr/include/pwd.h" 3 4
extern struct passwd *getpwuid (__uid_t __uid);





extern struct passwd *getpwnam (const char *__name) __attribute__ ((__nonnull__ (1)));
# 144 "/usr/include/pwd.h" 3 4
extern int getpwuid_r (__uid_t __uid,
         struct passwd *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct passwd **__restrict __result)
         __attribute__ ((__nonnull__ (2, 3, 5)));

extern int getpwnam_r (const char *__restrict __name,
         struct passwd *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct passwd **__restrict __result)
         __attribute__ ((__nonnull__ (1, 2, 3, 5)));
# 164 "./os_unix.h" 2
# 208 "./os_unix.h"
# 1 "/usr/include/x86_64-linux-gnu/sys/file.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/file.h" 3 4
# 1 "/usr/include/fcntl.h" 1 3 4
# 35 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;

    __off_t l_start;
    __off_t l_len;




    __pid_t l_pid;
  };
# 61 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 1 3 4
# 62 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 2 3 4
# 36 "/usr/include/fcntl.h" 2 3 4
# 78 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 79 "/usr/include/fcntl.h" 2 3 4
# 147 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 157 "/usr/include/fcntl.h" 3 4
extern int open (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 181 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 203 "/usr/include/fcntl.h" 3 4
extern int creat (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 249 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, off_t __offset, off_t __len,
     int __advise) __attribute__ ((__nothrow__ ));
# 271 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, off_t __offset, off_t __len);
# 25 "/usr/include/x86_64-linux-gnu/sys/file.h" 2 3 4
# 51 "/usr/include/x86_64-linux-gnu/sys/file.h" 3 4
extern int flock (int __fd, int __operation) __attribute__ ((__nothrow__ ));
# 209 "./os_unix.h" 2
# 473 "./os_unix.h"
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4






# 1 "/llvm-project/build/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4








extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 90 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 121 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));






extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 225 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 252 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 272 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 302 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 329 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));
# 384 "/usr/include/string.h" 3 4
extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) __attribute__ ((__nothrow__ ));
# 409 "/usr/include/string.h" 3 4
extern int strerror_r (int __errnum, char *__buf, size_t __buflen) __asm__ ("" "__xpg_strerror_r") __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));
# 427 "/usr/include/string.h" 3 4
extern char *strerror_l (int __errnum, locale_t __l) __attribute__ ((__nothrow__ ));
# 446 "/usr/include/string.h" 3 4
extern char *strsignal (int __sig) __attribute__ ((__nothrow__ ));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
# 494 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 3 4
extern void __warn_memset_zero_len (void);



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) void *
__attribute__ ((__nothrow__ )) memcpy (void *__restrict __dest, const void *__restrict __src, size_t __len)

{
  return __builtin___memcpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) void *
__attribute__ ((__nothrow__ )) memmove (void *__dest, const void *__src, size_t __len)
{
  return __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}
# 58 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) void *
__attribute__ ((__nothrow__ )) memset (void *__dest, int __ch, size_t __len)
{



  if (__builtin_constant_p (__len) && __len == 0
      && (!__builtin_constant_p (__ch) || __ch != 0))
    {
      __warn_memset_zero_len ();
      return __dest;
    }

  return __builtin___memset_chk (__dest, __ch, __len, __builtin_object_size (__dest, 0));
}
# 87 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
__attribute__ ((__nothrow__ )) strcpy (char *__restrict __dest, const char *__restrict __src)
{
  return __builtin___strcpy_chk (__dest, __src, __builtin_object_size (__dest, 1 > 1));
}
# 102 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
__attribute__ ((__nothrow__ )) strncpy (char *__restrict __dest, const char *__restrict __src, size_t __len)

{
  return __builtin___strncpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 1 > 1));
}


extern char *__stpncpy_chk (char *__dest, const char *__src, size_t __n,
       size_t __destlen) __attribute__ ((__nothrow__ ));
extern char *__stpncpy_alias (char *__dest, const char *__src, size_t __n) __asm__ ("" "stpncpy") __attribute__ ((__nothrow__ ));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
__attribute__ ((__nothrow__ )) stpncpy (char *__dest, const char *__src, size_t __n)
{
  if (__builtin_object_size (__dest, 1 > 1) != (size_t) -1
      && (!__builtin_constant_p (__n) || __n > __builtin_object_size (__dest, 1 > 1)))
    return __stpncpy_chk (__dest, __src, __n, __builtin_object_size (__dest, 1 > 1));
  return __stpncpy_alias (__dest, __src, __n);
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
__attribute__ ((__nothrow__ )) strcat (char *__restrict __dest, const char *__restrict __src)
{
  return __builtin___strcat_chk (__dest, __src, __builtin_object_size (__dest, 1 > 1));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
__attribute__ ((__nothrow__ )) strncat (char *__restrict __dest, const char *__restrict __src, size_t __len)

{
  return __builtin___strncat_chk (__dest, __src, __len, __builtin_object_size (__dest, 1 > 1));
}
# 495 "/usr/include/string.h" 2 3 4
# 474 "./os_unix.h" 2


# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/llvm-project/build/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4
# 104 "/usr/include/strings.h" 3 4
extern int ffs (int __i) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
# 116 "/usr/include/strings.h" 3 4
extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));
# 477 "./os_unix.h" 2



# 1 "/usr/include/setjmp.h" 1 3 4
# 29 "/usr/include/setjmp.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 30 "/usr/include/setjmp.h" 2 3 4



struct __jmp_buf_tag
  {




    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    __sigset_t __saved_mask;
  };


typedef struct __jmp_buf_tag jmp_buf[1];



extern int setjmp (jmp_buf __env) __attribute__ ((__nothrow__));




extern int __sigsetjmp (struct __jmp_buf_tag __env[1], int __savemask) __attribute__ ((__nothrow__));



extern int _setjmp (struct __jmp_buf_tag __env[1]) __attribute__ ((__nothrow__));
# 67 "/usr/include/setjmp.h" 3 4
extern void longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));





extern void _longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







typedef struct __jmp_buf_tag sigjmp_buf[1];
# 93 "/usr/include/setjmp.h" 3 4
extern void siglongjmp (sigjmp_buf __env, int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));






# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp2.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/setjmp2.h" 3 4
extern void longjmp (struct __jmp_buf_tag __env[1], int __val) __asm__ ("" "__longjmp_chk") __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));


extern void _longjmp (struct __jmp_buf_tag __env[1], int __val) __asm__ ("" "__longjmp_chk") __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));


extern void siglongjmp (struct __jmp_buf_tag __env[1], int __val) __asm__ ("" "__longjmp_chk") __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
# 101 "/usr/include/setjmp.h" 2 3 4
# 481 "./os_unix.h" 2
# 229 "./vim.h" 2
# 254 "./vim.h"
# 1 "./auto/osdef.h" 1
# 74 "./auto/osdef.h"
extern void (*sigset(int, void (*func) (int))) (int);
# 255 "./vim.h" 2
# 277 "./vim.h"
# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/llvm-project/build/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4
# 51 "/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 118 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) __attribute__ ((__nothrow__ ));


extern struct lconv *localeconv (void) __attribute__ ((__nothrow__ ));
# 141 "/usr/include/locale.h" 3 4
extern locale_t newlocale (int __category_mask, const char *__locale,
      locale_t __base) __attribute__ ((__nothrow__ ));
# 176 "/usr/include/locale.h" 3 4
extern locale_t duplocale (locale_t __dataset) __attribute__ ((__nothrow__ ));



extern void freelocale (locale_t __dataset) __attribute__ ((__nothrow__ ));






extern locale_t uselocale (locale_t __dataset) __attribute__ ((__nothrow__ ));
# 278 "./vim.h" 2
# 324 "./vim.h"
typedef unsigned char char_u;
typedef unsigned short short_u;
typedef unsigned int int_u;
# 345 "./vim.h"
typedef unsigned long long_u;
typedef long long_i;
# 384 "./vim.h"
typedef off_t off_T;
# 400 "./vim.h"
typedef char_u schar_T;
typedef unsigned short sattr_T;






typedef unsigned int u8char_T;







# 1 "./ascii.h" 1
# 416 "./vim.h" 2
# 1 "./keymap.h" 1
# 151 "./keymap.h"
enum key_extra
{
    KE_NAME = 3

    , KE_S_UP = 4
    , KE_S_DOWN = 5

    , KE_S_F1 = 6
    , KE_S_F2 = 7
    , KE_S_F3 = 8
    , KE_S_F4 = 9
    , KE_S_F5 = 10
    , KE_S_F6 = 11
    , KE_S_F7 = 12
    , KE_S_F8 = 13
    , KE_S_F9 = 14
    , KE_S_F10 = 15

    , KE_S_F11 = 16
    , KE_S_F12 = 17
    , KE_S_F13 = 18
    , KE_S_F14 = 19
    , KE_S_F15 = 20
    , KE_S_F16 = 21
    , KE_S_F17 = 22
    , KE_S_F18 = 23
    , KE_S_F19 = 24
    , KE_S_F20 = 25

    , KE_S_F21 = 26
    , KE_S_F22 = 27
    , KE_S_F23 = 28
    , KE_S_F24 = 29
    , KE_S_F25 = 30
    , KE_S_F26 = 31
    , KE_S_F27 = 32
    , KE_S_F28 = 33
    , KE_S_F29 = 34
    , KE_S_F30 = 35

    , KE_S_F31 = 36
    , KE_S_F32 = 37
    , KE_S_F33 = 38
    , KE_S_F34 = 39
    , KE_S_F35 = 40
    , KE_S_F36 = 41
    , KE_S_F37 = 42

    , KE_MOUSE = 43





    , KE_LEFTMOUSE = 44
    , KE_LEFTDRAG = 45
    , KE_LEFTRELEASE = 46
    , KE_MIDDLEMOUSE = 47
    , KE_MIDDLEDRAG = 48
    , KE_MIDDLERELEASE = 49
    , KE_RIGHTMOUSE = 50
    , KE_RIGHTDRAG = 51
    , KE_RIGHTRELEASE = 52

    , KE_IGNORE = 53

    , KE_TAB = 54
    , KE_S_TAB_OLD = 55

    , KE_SNIFF_UNUSED = 56
    , KE_XF1 = 57
    , KE_XF2 = 58
    , KE_XF3 = 59
    , KE_XF4 = 60
    , KE_XEND = 61
    , KE_ZEND = 62
    , KE_XHOME = 63
    , KE_ZHOME = 64
    , KE_XUP = 65
    , KE_XDOWN = 66
    , KE_XLEFT = 67
    , KE_XRIGHT = 68

    , KE_LEFTMOUSE_NM = 69
    , KE_LEFTRELEASE_NM = 70

    , KE_S_XF1 = 71
    , KE_S_XF2 = 72
    , KE_S_XF3 = 73
    , KE_S_XF4 = 74




    , KE_MOUSEDOWN = 75
    , KE_MOUSEUP = 76
    , KE_MOUSELEFT = 77
    , KE_MOUSERIGHT = 78

    , KE_KINS = 79
    , KE_KDEL = 80

    , KE_CSI = 81
    , KE_SNR = 82
    , KE_PLUG = 83
    , KE_CMDWIN = 84

    , KE_C_LEFT = 85
    , KE_C_RIGHT = 86
    , KE_C_HOME = 87
    , KE_C_END = 88

    , KE_X1MOUSE = 89
    , KE_X1DRAG = 90
    , KE_X1RELEASE = 91
    , KE_X2MOUSE = 92
    , KE_X2DRAG = 93
    , KE_X2RELEASE = 94

    , KE_DROP = 95
    , KE_CURSORHOLD = 96
    , KE_NOP = 97
    , KE_FOCUSGAINED = 98
    , KE_FOCUSLOST = 99
    , KE_MOUSEMOVE = 100
    , KE_CANCEL = 101
    , KE_COMMAND = 102
};
# 417 "./vim.h" 2
# 1 "./term.h" 1
# 26 "./term.h"
enum SpecialKey
{
    KS_NAME = 0,
    KS_CE,
    KS_AL,
    KS_CAL,
    KS_DL,
    KS_CDL,
    KS_CS,
    KS_CL,
    KS_CD,
    KS_UT,
    KS_DA,
    KS_DB,
    KS_VI,
    KS_VE,
    KS_VS,
    KS_CVS,
    KS_CSH,
    KS_CRC,
    KS_CRS,
    KS_ME,
    KS_MR,
    KS_MD,
    KS_SE,
    KS_SO,
    KS_CZH,
    KS_CZR,
    KS_UE,
    KS_US,
    KS_UCE,
    KS_UCS,
    KS_STE,
    KS_STS,
    KS_MS,
    KS_CM,
    KS_SR,
    KS_CRI,
    KS_VB,
    KS_KS,
    KS_KE,
    KS_TI,
    KS_CTI,
    KS_TE,
    KS_CTE,
    KS_BC,
    KS_CCS,
    KS_CCO,
    KS_CSF,
    KS_CSB,
    KS_XS,
    KS_XN,
    KS_MB,
    KS_CAF,
    KS_CAB,
    KS_CAU,
    KS_LE,
    KS_ND,
    KS_CIS,
    KS_CIE,
    KS_CSC,
    KS_CEC,
    KS_TS,
    KS_FS,
    KS_CWP,
    KS_CGP,
    KS_CWS,
    KS_CRV,
    KS_RFG,
    KS_RBG,
    KS_CSI,
    KS_CEI,
    KS_CSR,
    KS_CSV,
    KS_OP,
    KS_U7,
    KS_8F,
    KS_8B,
    KS_8U,
    KS_CBE,
    KS_CBD,
    KS_CPS,
    KS_CPE,
    KS_CST,
    KS_CRT,
    KS_SSI,
    KS_SRI
};
# 125 "./term.h"
extern char_u *(term_strings[]);
# 216 "./term.h"
typedef enum {
    TMODE_COOK,
    TMODE_SLEEP,
    TMODE_RAW,
    TMODE_UNKNOWN
} tmode_T;
# 418 "./vim.h" 2
# 1 "./macros.h" 1
# 277 "./macros.h"
# 1 "/llvm-project/build/lib/clang/12.0.0/include/float.h" 1 3
# 278 "./macros.h" 2


# 1 "/usr/include/math.h" 1 3 4
# 27 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/math.h" 2 3 4
# 40 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libm-simd-decl-stubs.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 2 3 4
# 41 "/usr/include/math.h" 2 3 4
# 138 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/flt-eval-method.h" 1 3 4
# 139 "/usr/include/math.h" 2 3 4
# 149 "/usr/include/math.h" 3 4
typedef float float_t;
typedef double double_t;
# 190 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-logb.h" 1 3 4
# 191 "/usr/include/math.h" 2 3 4
# 233 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-fast.h" 1 3 4
# 234 "/usr/include/math.h" 2 3 4
# 289 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassify (double __value) __attribute__ ((__nothrow__ ))
     __attribute__ ((__const__));


extern int __signbit (double __value) __attribute__ ((__nothrow__ ))
     __attribute__ ((__const__));



extern int __isinf (double __value) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern int __finite (double __value) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern int __isnan (double __value) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern int __iseqsig (double __x, double __y) __attribute__ ((__nothrow__ ));


extern int __issignaling (double __value) __attribute__ ((__nothrow__ ))
     __attribute__ ((__const__));
# 290 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double acos (double __x) __attribute__ ((__nothrow__ )); extern double __acos (double __x) __attribute__ ((__nothrow__ ));

extern double asin (double __x) __attribute__ ((__nothrow__ )); extern double __asin (double __x) __attribute__ ((__nothrow__ ));

extern double atan (double __x) __attribute__ ((__nothrow__ )); extern double __atan (double __x) __attribute__ ((__nothrow__ ));

extern double atan2 (double __y, double __x) __attribute__ ((__nothrow__ )); extern double __atan2 (double __y, double __x) __attribute__ ((__nothrow__ ));


 extern double cos (double __x) __attribute__ ((__nothrow__ )); extern double __cos (double __x) __attribute__ ((__nothrow__ ));

 extern double sin (double __x) __attribute__ ((__nothrow__ )); extern double __sin (double __x) __attribute__ ((__nothrow__ ));

extern double tan (double __x) __attribute__ ((__nothrow__ )); extern double __tan (double __x) __attribute__ ((__nothrow__ ));




extern double cosh (double __x) __attribute__ ((__nothrow__ )); extern double __cosh (double __x) __attribute__ ((__nothrow__ ));

extern double sinh (double __x) __attribute__ ((__nothrow__ )); extern double __sinh (double __x) __attribute__ ((__nothrow__ ));

extern double tanh (double __x) __attribute__ ((__nothrow__ )); extern double __tanh (double __x) __attribute__ ((__nothrow__ ));
# 85 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double acosh (double __x) __attribute__ ((__nothrow__ )); extern double __acosh (double __x) __attribute__ ((__nothrow__ ));

extern double asinh (double __x) __attribute__ ((__nothrow__ )); extern double __asinh (double __x) __attribute__ ((__nothrow__ ));

extern double atanh (double __x) __attribute__ ((__nothrow__ )); extern double __atanh (double __x) __attribute__ ((__nothrow__ ));





 extern double exp (double __x) __attribute__ ((__nothrow__ )); extern double __exp (double __x) __attribute__ ((__nothrow__ ));


extern double frexp (double __x, int *__exponent) __attribute__ ((__nothrow__ )); extern double __frexp (double __x, int *__exponent) __attribute__ ((__nothrow__ ));


extern double ldexp (double __x, int __exponent) __attribute__ ((__nothrow__ )); extern double __ldexp (double __x, int __exponent) __attribute__ ((__nothrow__ ));


 extern double log (double __x) __attribute__ ((__nothrow__ )); extern double __log (double __x) __attribute__ ((__nothrow__ ));


extern double log10 (double __x) __attribute__ ((__nothrow__ )); extern double __log10 (double __x) __attribute__ ((__nothrow__ ));


extern double modf (double __x, double *__iptr) __attribute__ ((__nothrow__ )); extern double __modf (double __x, double *__iptr) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));
# 119 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double expm1 (double __x) __attribute__ ((__nothrow__ )); extern double __expm1 (double __x) __attribute__ ((__nothrow__ ));


extern double log1p (double __x) __attribute__ ((__nothrow__ )); extern double __log1p (double __x) __attribute__ ((__nothrow__ ));


extern double logb (double __x) __attribute__ ((__nothrow__ )); extern double __logb (double __x) __attribute__ ((__nothrow__ ));




extern double exp2 (double __x) __attribute__ ((__nothrow__ )); extern double __exp2 (double __x) __attribute__ ((__nothrow__ ));


extern double log2 (double __x) __attribute__ ((__nothrow__ )); extern double __log2 (double __x) __attribute__ ((__nothrow__ ));






 extern double pow (double __x, double __y) __attribute__ ((__nothrow__ )); extern double __pow (double __x, double __y) __attribute__ ((__nothrow__ ));


extern double sqrt (double __x) __attribute__ ((__nothrow__ )); extern double __sqrt (double __x) __attribute__ ((__nothrow__ ));



extern double hypot (double __x, double __y) __attribute__ ((__nothrow__ )); extern double __hypot (double __x, double __y) __attribute__ ((__nothrow__ ));




extern double cbrt (double __x) __attribute__ ((__nothrow__ )); extern double __cbrt (double __x) __attribute__ ((__nothrow__ ));






extern double ceil (double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern double __ceil (double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern double fabs (double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern double __fabs (double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern double floor (double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern double __floor (double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern double fmod (double __x, double __y) __attribute__ ((__nothrow__ )); extern double __fmod (double __x, double __y) __attribute__ ((__nothrow__ ));
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double copysign (double __x, double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern double __copysign (double __x, double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern double nan (const char *__tagb) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern double __nan (const char *__tagb) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double j0 (double) __attribute__ ((__nothrow__ )); extern double __j0 (double) __attribute__ ((__nothrow__ ));
extern double j1 (double) __attribute__ ((__nothrow__ )); extern double __j1 (double) __attribute__ ((__nothrow__ ));
extern double jn (int, double) __attribute__ ((__nothrow__ )); extern double __jn (int, double) __attribute__ ((__nothrow__ ));
extern double y0 (double) __attribute__ ((__nothrow__ )); extern double __y0 (double) __attribute__ ((__nothrow__ ));
extern double y1 (double) __attribute__ ((__nothrow__ )); extern double __y1 (double) __attribute__ ((__nothrow__ ));
extern double yn (int, double) __attribute__ ((__nothrow__ )); extern double __yn (int, double) __attribute__ ((__nothrow__ ));





extern double erf (double) __attribute__ ((__nothrow__ )); extern double __erf (double) __attribute__ ((__nothrow__ ));
extern double erfc (double) __attribute__ ((__nothrow__ )); extern double __erfc (double) __attribute__ ((__nothrow__ ));
extern double lgamma (double) __attribute__ ((__nothrow__ )); extern double __lgamma (double) __attribute__ ((__nothrow__ ));




extern double tgamma (double) __attribute__ ((__nothrow__ )); extern double __tgamma (double) __attribute__ ((__nothrow__ ));
# 256 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double rint (double __x) __attribute__ ((__nothrow__ )); extern double __rint (double __x) __attribute__ ((__nothrow__ ));


extern double nextafter (double __x, double __y) __attribute__ ((__nothrow__ )); extern double __nextafter (double __x, double __y) __attribute__ ((__nothrow__ ));

extern double nexttoward (double __x, long double __y) __attribute__ ((__nothrow__ )); extern double __nexttoward (double __x, long double __y) __attribute__ ((__nothrow__ ));
# 272 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double remainder (double __x, double __y) __attribute__ ((__nothrow__ )); extern double __remainder (double __x, double __y) __attribute__ ((__nothrow__ ));



extern double scalbn (double __x, int __n) __attribute__ ((__nothrow__ )); extern double __scalbn (double __x, int __n) __attribute__ ((__nothrow__ ));



extern int ilogb (double __x) __attribute__ ((__nothrow__ )); extern int __ilogb (double __x) __attribute__ ((__nothrow__ ));
# 290 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double scalbln (double __x, long int __n) __attribute__ ((__nothrow__ )); extern double __scalbln (double __x, long int __n) __attribute__ ((__nothrow__ ));



extern double nearbyint (double __x) __attribute__ ((__nothrow__ )); extern double __nearbyint (double __x) __attribute__ ((__nothrow__ ));



extern double round (double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern double __round (double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern double trunc (double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern double __trunc (double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__ )); extern double __remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__ ));






extern long int lrint (double __x) __attribute__ ((__nothrow__ )); extern long int __lrint (double __x) __attribute__ ((__nothrow__ ));
__extension__
extern long long int llrint (double __x) __attribute__ ((__nothrow__ )); extern long long int __llrint (double __x) __attribute__ ((__nothrow__ ));



extern long int lround (double __x) __attribute__ ((__nothrow__ )); extern long int __lround (double __x) __attribute__ ((__nothrow__ ));
__extension__
extern long long int llround (double __x) __attribute__ ((__nothrow__ )); extern long long int __llround (double __x) __attribute__ ((__nothrow__ ));



extern double fdim (double __x, double __y) __attribute__ ((__nothrow__ )); extern double __fdim (double __x, double __y) __attribute__ ((__nothrow__ ));


extern double fmax (double __x, double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern double __fmax (double __x, double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern double fmin (double __x, double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern double __fmin (double __x, double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern double fma (double __x, double __y, double __z) __attribute__ ((__nothrow__ )); extern double __fma (double __x, double __y, double __z) __attribute__ ((__nothrow__ ));
# 291 "/usr/include/math.h" 2 3 4
# 306 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf (float __value) __attribute__ ((__nothrow__ ))
     __attribute__ ((__const__));


extern int __signbitf (float __value) __attribute__ ((__nothrow__ ))
     __attribute__ ((__const__));



extern int __isinff (float __value) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern int __finitef (float __value) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern int __isnanf (float __value) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern int __iseqsigf (float __x, float __y) __attribute__ ((__nothrow__ ));


extern int __issignalingf (float __value) __attribute__ ((__nothrow__ ))
     __attribute__ ((__const__));
# 307 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float acosf (float __x) __attribute__ ((__nothrow__ )); extern float __acosf (float __x) __attribute__ ((__nothrow__ ));

extern float asinf (float __x) __attribute__ ((__nothrow__ )); extern float __asinf (float __x) __attribute__ ((__nothrow__ ));

extern float atanf (float __x) __attribute__ ((__nothrow__ )); extern float __atanf (float __x) __attribute__ ((__nothrow__ ));

extern float atan2f (float __y, float __x) __attribute__ ((__nothrow__ )); extern float __atan2f (float __y, float __x) __attribute__ ((__nothrow__ ));


 extern float cosf (float __x) __attribute__ ((__nothrow__ )); extern float __cosf (float __x) __attribute__ ((__nothrow__ ));

 extern float sinf (float __x) __attribute__ ((__nothrow__ )); extern float __sinf (float __x) __attribute__ ((__nothrow__ ));

extern float tanf (float __x) __attribute__ ((__nothrow__ )); extern float __tanf (float __x) __attribute__ ((__nothrow__ ));




extern float coshf (float __x) __attribute__ ((__nothrow__ )); extern float __coshf (float __x) __attribute__ ((__nothrow__ ));

extern float sinhf (float __x) __attribute__ ((__nothrow__ )); extern float __sinhf (float __x) __attribute__ ((__nothrow__ ));

extern float tanhf (float __x) __attribute__ ((__nothrow__ )); extern float __tanhf (float __x) __attribute__ ((__nothrow__ ));
# 85 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float acoshf (float __x) __attribute__ ((__nothrow__ )); extern float __acoshf (float __x) __attribute__ ((__nothrow__ ));

extern float asinhf (float __x) __attribute__ ((__nothrow__ )); extern float __asinhf (float __x) __attribute__ ((__nothrow__ ));

extern float atanhf (float __x) __attribute__ ((__nothrow__ )); extern float __atanhf (float __x) __attribute__ ((__nothrow__ ));





 extern float expf (float __x) __attribute__ ((__nothrow__ )); extern float __expf (float __x) __attribute__ ((__nothrow__ ));


extern float frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__ )); extern float __frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__ ));


extern float ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__ )); extern float __ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__ ));


 extern float logf (float __x) __attribute__ ((__nothrow__ )); extern float __logf (float __x) __attribute__ ((__nothrow__ ));


extern float log10f (float __x) __attribute__ ((__nothrow__ )); extern float __log10f (float __x) __attribute__ ((__nothrow__ ));


extern float modff (float __x, float *__iptr) __attribute__ ((__nothrow__ )); extern float __modff (float __x, float *__iptr) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));
# 119 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float expm1f (float __x) __attribute__ ((__nothrow__ )); extern float __expm1f (float __x) __attribute__ ((__nothrow__ ));


extern float log1pf (float __x) __attribute__ ((__nothrow__ )); extern float __log1pf (float __x) __attribute__ ((__nothrow__ ));


extern float logbf (float __x) __attribute__ ((__nothrow__ )); extern float __logbf (float __x) __attribute__ ((__nothrow__ ));




extern float exp2f (float __x) __attribute__ ((__nothrow__ )); extern float __exp2f (float __x) __attribute__ ((__nothrow__ ));


extern float log2f (float __x) __attribute__ ((__nothrow__ )); extern float __log2f (float __x) __attribute__ ((__nothrow__ ));






 extern float powf (float __x, float __y) __attribute__ ((__nothrow__ )); extern float __powf (float __x, float __y) __attribute__ ((__nothrow__ ));


extern float sqrtf (float __x) __attribute__ ((__nothrow__ )); extern float __sqrtf (float __x) __attribute__ ((__nothrow__ ));



extern float hypotf (float __x, float __y) __attribute__ ((__nothrow__ )); extern float __hypotf (float __x, float __y) __attribute__ ((__nothrow__ ));




extern float cbrtf (float __x) __attribute__ ((__nothrow__ )); extern float __cbrtf (float __x) __attribute__ ((__nothrow__ ));






extern float ceilf (float __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern float __ceilf (float __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern float fabsf (float __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern float __fabsf (float __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern float floorf (float __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern float __floorf (float __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern float fmodf (float __x, float __y) __attribute__ ((__nothrow__ )); extern float __fmodf (float __x, float __y) __attribute__ ((__nothrow__ ));
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float copysignf (float __x, float __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern float nanf (const char *__tagb) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern float __nanf (const char *__tagb) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
# 228 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float erff (float) __attribute__ ((__nothrow__ )); extern float __erff (float) __attribute__ ((__nothrow__ ));
extern float erfcf (float) __attribute__ ((__nothrow__ )); extern float __erfcf (float) __attribute__ ((__nothrow__ ));
extern float lgammaf (float) __attribute__ ((__nothrow__ )); extern float __lgammaf (float) __attribute__ ((__nothrow__ ));




extern float tgammaf (float) __attribute__ ((__nothrow__ )); extern float __tgammaf (float) __attribute__ ((__nothrow__ ));
# 256 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float rintf (float __x) __attribute__ ((__nothrow__ )); extern float __rintf (float __x) __attribute__ ((__nothrow__ ));


extern float nextafterf (float __x, float __y) __attribute__ ((__nothrow__ )); extern float __nextafterf (float __x, float __y) __attribute__ ((__nothrow__ ));

extern float nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__ )); extern float __nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__ ));
# 272 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float remainderf (float __x, float __y) __attribute__ ((__nothrow__ )); extern float __remainderf (float __x, float __y) __attribute__ ((__nothrow__ ));



extern float scalbnf (float __x, int __n) __attribute__ ((__nothrow__ )); extern float __scalbnf (float __x, int __n) __attribute__ ((__nothrow__ ));



extern int ilogbf (float __x) __attribute__ ((__nothrow__ )); extern int __ilogbf (float __x) __attribute__ ((__nothrow__ ));
# 290 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float scalblnf (float __x, long int __n) __attribute__ ((__nothrow__ )); extern float __scalblnf (float __x, long int __n) __attribute__ ((__nothrow__ ));



extern float nearbyintf (float __x) __attribute__ ((__nothrow__ )); extern float __nearbyintf (float __x) __attribute__ ((__nothrow__ ));



extern float roundf (float __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern float __roundf (float __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern float truncf (float __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern float __truncf (float __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__ )); extern float __remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__ ));






extern long int lrintf (float __x) __attribute__ ((__nothrow__ )); extern long int __lrintf (float __x) __attribute__ ((__nothrow__ ));
__extension__
extern long long int llrintf (float __x) __attribute__ ((__nothrow__ )); extern long long int __llrintf (float __x) __attribute__ ((__nothrow__ ));



extern long int lroundf (float __x) __attribute__ ((__nothrow__ )); extern long int __lroundf (float __x) __attribute__ ((__nothrow__ ));
__extension__
extern long long int llroundf (float __x) __attribute__ ((__nothrow__ )); extern long long int __llroundf (float __x) __attribute__ ((__nothrow__ ));



extern float fdimf (float __x, float __y) __attribute__ ((__nothrow__ )); extern float __fdimf (float __x, float __y) __attribute__ ((__nothrow__ ));


extern float fmaxf (float __x, float __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern float fminf (float __x, float __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern float __fminf (float __x, float __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern float fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__ )); extern float __fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__ ));
# 308 "/usr/include/math.h" 2 3 4
# 349 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyl (long double __value) __attribute__ ((__nothrow__ ))
     __attribute__ ((__const__));


extern int __signbitl (long double __value) __attribute__ ((__nothrow__ ))
     __attribute__ ((__const__));



extern int __isinfl (long double __value) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern int __finitel (long double __value) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern int __isnanl (long double __value) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern int __iseqsigl (long double __x, long double __y) __attribute__ ((__nothrow__ ));


extern int __issignalingl (long double __value) __attribute__ ((__nothrow__ ))
     __attribute__ ((__const__));
# 350 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double acosl (long double __x) __attribute__ ((__nothrow__ )); extern long double __acosl (long double __x) __attribute__ ((__nothrow__ ));

extern long double asinl (long double __x) __attribute__ ((__nothrow__ )); extern long double __asinl (long double __x) __attribute__ ((__nothrow__ ));

extern long double atanl (long double __x) __attribute__ ((__nothrow__ )); extern long double __atanl (long double __x) __attribute__ ((__nothrow__ ));

extern long double atan2l (long double __y, long double __x) __attribute__ ((__nothrow__ )); extern long double __atan2l (long double __y, long double __x) __attribute__ ((__nothrow__ ));


 extern long double cosl (long double __x) __attribute__ ((__nothrow__ )); extern long double __cosl (long double __x) __attribute__ ((__nothrow__ ));

 extern long double sinl (long double __x) __attribute__ ((__nothrow__ )); extern long double __sinl (long double __x) __attribute__ ((__nothrow__ ));

extern long double tanl (long double __x) __attribute__ ((__nothrow__ )); extern long double __tanl (long double __x) __attribute__ ((__nothrow__ ));




extern long double coshl (long double __x) __attribute__ ((__nothrow__ )); extern long double __coshl (long double __x) __attribute__ ((__nothrow__ ));

extern long double sinhl (long double __x) __attribute__ ((__nothrow__ )); extern long double __sinhl (long double __x) __attribute__ ((__nothrow__ ));

extern long double tanhl (long double __x) __attribute__ ((__nothrow__ )); extern long double __tanhl (long double __x) __attribute__ ((__nothrow__ ));
# 85 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double acoshl (long double __x) __attribute__ ((__nothrow__ )); extern long double __acoshl (long double __x) __attribute__ ((__nothrow__ ));

extern long double asinhl (long double __x) __attribute__ ((__nothrow__ )); extern long double __asinhl (long double __x) __attribute__ ((__nothrow__ ));

extern long double atanhl (long double __x) __attribute__ ((__nothrow__ )); extern long double __atanhl (long double __x) __attribute__ ((__nothrow__ ));





 extern long double expl (long double __x) __attribute__ ((__nothrow__ )); extern long double __expl (long double __x) __attribute__ ((__nothrow__ ));


extern long double frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__ )); extern long double __frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__ ));


extern long double ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__ )); extern long double __ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__ ));


 extern long double logl (long double __x) __attribute__ ((__nothrow__ )); extern long double __logl (long double __x) __attribute__ ((__nothrow__ ));


extern long double log10l (long double __x) __attribute__ ((__nothrow__ )); extern long double __log10l (long double __x) __attribute__ ((__nothrow__ ));


extern long double modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__ )); extern long double __modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));
# 119 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double expm1l (long double __x) __attribute__ ((__nothrow__ )); extern long double __expm1l (long double __x) __attribute__ ((__nothrow__ ));


extern long double log1pl (long double __x) __attribute__ ((__nothrow__ )); extern long double __log1pl (long double __x) __attribute__ ((__nothrow__ ));


extern long double logbl (long double __x) __attribute__ ((__nothrow__ )); extern long double __logbl (long double __x) __attribute__ ((__nothrow__ ));




extern long double exp2l (long double __x) __attribute__ ((__nothrow__ )); extern long double __exp2l (long double __x) __attribute__ ((__nothrow__ ));


extern long double log2l (long double __x) __attribute__ ((__nothrow__ )); extern long double __log2l (long double __x) __attribute__ ((__nothrow__ ));






 extern long double powl (long double __x, long double __y) __attribute__ ((__nothrow__ )); extern long double __powl (long double __x, long double __y) __attribute__ ((__nothrow__ ));


extern long double sqrtl (long double __x) __attribute__ ((__nothrow__ )); extern long double __sqrtl (long double __x) __attribute__ ((__nothrow__ ));



extern long double hypotl (long double __x, long double __y) __attribute__ ((__nothrow__ )); extern long double __hypotl (long double __x, long double __y) __attribute__ ((__nothrow__ ));




extern long double cbrtl (long double __x) __attribute__ ((__nothrow__ )); extern long double __cbrtl (long double __x) __attribute__ ((__nothrow__ ));






extern long double ceill (long double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern long double __ceill (long double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern long double fabsl (long double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern long double __fabsl (long double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern long double floorl (long double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern long double __floorl (long double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) __attribute__ ((__nothrow__ )); extern long double __fmodl (long double __x, long double __y) __attribute__ ((__nothrow__ ));
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double copysignl (long double __x, long double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern long double nanl (const char *__tagb) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern long double __nanl (const char *__tagb) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
# 228 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double erfl (long double) __attribute__ ((__nothrow__ )); extern long double __erfl (long double) __attribute__ ((__nothrow__ ));
extern long double erfcl (long double) __attribute__ ((__nothrow__ )); extern long double __erfcl (long double) __attribute__ ((__nothrow__ ));
extern long double lgammal (long double) __attribute__ ((__nothrow__ )); extern long double __lgammal (long double) __attribute__ ((__nothrow__ ));




extern long double tgammal (long double) __attribute__ ((__nothrow__ )); extern long double __tgammal (long double) __attribute__ ((__nothrow__ ));
# 256 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double rintl (long double __x) __attribute__ ((__nothrow__ )); extern long double __rintl (long double __x) __attribute__ ((__nothrow__ ));


extern long double nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__ )); extern long double __nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__ ));

extern long double nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__ )); extern long double __nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__ ));
# 272 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double remainderl (long double __x, long double __y) __attribute__ ((__nothrow__ )); extern long double __remainderl (long double __x, long double __y) __attribute__ ((__nothrow__ ));



extern long double scalbnl (long double __x, int __n) __attribute__ ((__nothrow__ )); extern long double __scalbnl (long double __x, int __n) __attribute__ ((__nothrow__ ));



extern int ilogbl (long double __x) __attribute__ ((__nothrow__ )); extern int __ilogbl (long double __x) __attribute__ ((__nothrow__ ));
# 290 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__ )); extern long double __scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__ ));



extern long double nearbyintl (long double __x) __attribute__ ((__nothrow__ )); extern long double __nearbyintl (long double __x) __attribute__ ((__nothrow__ ));



extern long double roundl (long double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern long double __roundl (long double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern long double truncl (long double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern long double __truncl (long double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__ )); extern long double __remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__ ));






extern long int lrintl (long double __x) __attribute__ ((__nothrow__ )); extern long int __lrintl (long double __x) __attribute__ ((__nothrow__ ));
__extension__
extern long long int llrintl (long double __x) __attribute__ ((__nothrow__ )); extern long long int __llrintl (long double __x) __attribute__ ((__nothrow__ ));



extern long int lroundl (long double __x) __attribute__ ((__nothrow__ )); extern long int __lroundl (long double __x) __attribute__ ((__nothrow__ ));
__extension__
extern long long int llroundl (long double __x) __attribute__ ((__nothrow__ )); extern long long int __llroundl (long double __x) __attribute__ ((__nothrow__ ));



extern long double fdiml (long double __x, long double __y) __attribute__ ((__nothrow__ )); extern long double __fdiml (long double __x, long double __y) __attribute__ ((__nothrow__ ));


extern long double fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern long double fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ )); extern long double __fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ ));
# 351 "/usr/include/math.h" 2 3 4
# 489 "/usr/include/math.h" 3 4
extern int signgam;
# 569 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 952 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathinline.h" 1 3 4
# 953 "/usr/include/math.h" 2 3 4
# 281 "./macros.h" 2
# 419 "./vim.h" 2
# 432 "./vim.h"
# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4




# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 2 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4








extern int *__errno_location (void) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
# 433 "./vim.h" 2
# 456 "./vim.h"
# 1 "/usr/include/assert.h" 1 3 4
# 69 "/usr/include/assert.h" 3 4
extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));
# 457 "./vim.h" 2


# 1 "/llvm-project/build/lib/clang/12.0.0/include/stdint.h" 1 3
# 52 "/llvm-project/build/lib/clang/12.0.0/include/stdint.h" 3
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
# 68 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 81 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 100 "/usr/include/stdint.h" 3 4
typedef unsigned long int uintptr_t;
# 111 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 53 "/llvm-project/build/lib/clang/12.0.0/include/stdint.h" 2 3
# 460 "./vim.h" 2


# 1 "/llvm-project/build/lib/clang/12.0.0/include/inttypes.h" 1 3
# 21 "/llvm-project/build/lib/clang/12.0.0/include/inttypes.h" 3
# 1 "/usr/include/inttypes.h" 1 3 4
# 34 "/usr/include/inttypes.h" 3 4
typedef int __gwchar_t;
# 271 "/usr/include/inttypes.h" 3 4
typedef struct
  {
    long int quot;
    long int rem;
  } imaxdiv_t;
# 290 "/usr/include/inttypes.h" 3 4
extern intmax_t imaxabs (intmax_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern intmax_t strtoimax (const char *__restrict __nptr,
      char **__restrict __endptr, int __base) __attribute__ ((__nothrow__ ));


extern uintmax_t strtoumax (const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) __attribute__ ((__nothrow__ ));


extern intmax_t wcstoimax (const __gwchar_t *__restrict __nptr,
      __gwchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ ));


extern uintmax_t wcstoumax (const __gwchar_t *__restrict __nptr,
       __gwchar_t ** __restrict __endptr, int __base)
     __attribute__ ((__nothrow__ ));





extern long int __strtol_internal (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, int __group)
  __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern __inline __attribute__ ((__gnu_inline__)) intmax_t
__attribute__ ((__nothrow__ )) strtoimax (const char *__restrict nptr, char **__restrict endptr, int base)

{
  return __strtol_internal (nptr, endptr, base, 0);
}

extern unsigned long int __strtoul_internal (const char *__restrict __nptr,
          char ** __restrict __endptr,
          int __base, int __group)
  __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern __inline __attribute__ ((__gnu_inline__)) uintmax_t
__attribute__ ((__nothrow__ )) strtoumax (const char *__restrict nptr, char **__restrict endptr, int base)

{
  return __strtoul_internal (nptr, endptr, base, 0);
}

extern long int __wcstol_internal (const __gwchar_t * __restrict __nptr,
       __gwchar_t **__restrict __endptr,
       int __base, int __group)
  __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern __inline __attribute__ ((__gnu_inline__)) intmax_t
__attribute__ ((__nothrow__ )) wcstoimax (const __gwchar_t *__restrict nptr, __gwchar_t **__restrict endptr, int base)

{
  return __wcstol_internal (nptr, endptr, base, 0);
}

extern unsigned long int __wcstoul_internal (const __gwchar_t *
          __restrict __nptr,
          __gwchar_t **
          __restrict __endptr,
          int __base, int __group)
  __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern __inline __attribute__ ((__gnu_inline__)) uintmax_t
__attribute__ ((__nothrow__ )) wcstoumax (const __gwchar_t *__restrict nptr, __gwchar_t **__restrict endptr, int base)

{
  return __wcstoul_internal (nptr, endptr, base, 0);
}
# 22 "/llvm-project/build/lib/clang/12.0.0/include/inttypes.h" 2 3
# 463 "./vim.h" 2


# 1 "/usr/include/wctype.h" 1 3 4
# 28 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 3 4
typedef unsigned int wint_t;
# 29 "/usr/include/wctype.h" 2 3 4
# 38 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
typedef unsigned long int wctype_t;
# 56 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};
# 95 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
extern int iswalnum (wint_t __wc) __attribute__ ((__nothrow__ ));





extern int iswalpha (wint_t __wc) __attribute__ ((__nothrow__ ));


extern int iswcntrl (wint_t __wc) __attribute__ ((__nothrow__ ));



extern int iswdigit (wint_t __wc) __attribute__ ((__nothrow__ ));



extern int iswgraph (wint_t __wc) __attribute__ ((__nothrow__ ));




extern int iswlower (wint_t __wc) __attribute__ ((__nothrow__ ));


extern int iswprint (wint_t __wc) __attribute__ ((__nothrow__ ));




extern int iswpunct (wint_t __wc) __attribute__ ((__nothrow__ ));




extern int iswspace (wint_t __wc) __attribute__ ((__nothrow__ ));




extern int iswupper (wint_t __wc) __attribute__ ((__nothrow__ ));




extern int iswxdigit (wint_t __wc) __attribute__ ((__nothrow__ ));





extern int iswblank (wint_t __wc) __attribute__ ((__nothrow__ ));
# 155 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
extern wctype_t wctype (const char *__property) __attribute__ ((__nothrow__ ));



extern int iswctype (wint_t __wc, wctype_t __desc) __attribute__ ((__nothrow__ ));






extern wint_t towlower (wint_t __wc) __attribute__ ((__nothrow__ ));


extern wint_t towupper (wint_t __wc) __attribute__ ((__nothrow__ ));
# 39 "/usr/include/wctype.h" 2 3 4
# 48 "/usr/include/wctype.h" 3 4
typedef const __int32_t *wctrans_t;



extern wctrans_t wctrans (const char *__property) __attribute__ ((__nothrow__ ));


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) __attribute__ ((__nothrow__ ));







extern int iswalnum_l (wint_t __wc, locale_t __locale) __attribute__ ((__nothrow__ ));





extern int iswalpha_l (wint_t __wc, locale_t __locale) __attribute__ ((__nothrow__ ));


extern int iswcntrl_l (wint_t __wc, locale_t __locale) __attribute__ ((__nothrow__ ));



extern int iswdigit_l (wint_t __wc, locale_t __locale) __attribute__ ((__nothrow__ ));



extern int iswgraph_l (wint_t __wc, locale_t __locale) __attribute__ ((__nothrow__ ));




extern int iswlower_l (wint_t __wc, locale_t __locale) __attribute__ ((__nothrow__ ));


extern int iswprint_l (wint_t __wc, locale_t __locale) __attribute__ ((__nothrow__ ));




extern int iswpunct_l (wint_t __wc, locale_t __locale) __attribute__ ((__nothrow__ ));




extern int iswspace_l (wint_t __wc, locale_t __locale) __attribute__ ((__nothrow__ ));




extern int iswupper_l (wint_t __wc, locale_t __locale) __attribute__ ((__nothrow__ ));




extern int iswxdigit_l (wint_t __wc, locale_t __locale) __attribute__ ((__nothrow__ ));




extern int iswblank_l (wint_t __wc, locale_t __locale) __attribute__ ((__nothrow__ ));



extern wctype_t wctype_l (const char *__property, locale_t __locale)
     __attribute__ ((__nothrow__ ));



extern int iswctype_l (wint_t __wc, wctype_t __desc, locale_t __locale)
     __attribute__ ((__nothrow__ ));






extern wint_t towlower_l (wint_t __wc, locale_t __locale) __attribute__ ((__nothrow__ ));


extern wint_t towupper_l (wint_t __wc, locale_t __locale) __attribute__ ((__nothrow__ ));



extern wctrans_t wctrans_l (const char *__property, locale_t __locale)
     __attribute__ ((__nothrow__ ));


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      locale_t __locale) __attribute__ ((__nothrow__ ));
# 466 "./vim.h" 2




# 1 "/llvm-project/build/lib/clang/12.0.0/include/stddef.h" 1 3
# 35 "/llvm-project/build/lib/clang/12.0.0/include/stddef.h" 3
typedef long int ptrdiff_t;
# 102 "/llvm-project/build/lib/clang/12.0.0/include/stddef.h" 3
# 1 "/llvm-project/build/lib/clang/12.0.0/include/__stddef_max_align_t.h" 1 3
# 19 "/llvm-project/build/lib/clang/12.0.0/include/__stddef_max_align_t.h" 3
typedef struct {
  long long __clang_max_align_nonce1
      __attribute__((__aligned__(__alignof__(long long))));
  long double __clang_max_align_nonce2
      __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 103 "/llvm-project/build/lib/clang/12.0.0/include/stddef.h" 2 3
# 471 "./vim.h" 2
# 538 "./vim.h"
# 1 "/usr/include/libintl.h" 1 3 4
# 39 "/usr/include/libintl.h" 3 4
extern char *gettext (const char *__msgid)
     __attribute__ ((__nothrow__ )) __attribute__ ((__format_arg__ (1)));



extern char *dgettext (const char *__domainname, const char *__msgid)
     __attribute__ ((__nothrow__ )) __attribute__ ((__format_arg__ (2)));
extern char *__dgettext (const char *__domainname, const char *__msgid)
     __attribute__ ((__nothrow__ )) __attribute__ ((__format_arg__ (2)));



extern char *dcgettext (const char *__domainname,
   const char *__msgid, int __category)
     __attribute__ ((__nothrow__ )) __attribute__ ((__format_arg__ (2)));
extern char *__dcgettext (const char *__domainname,
     const char *__msgid, int __category)
     __attribute__ ((__nothrow__ )) __attribute__ ((__format_arg__ (2)));




extern char *ngettext (const char *__msgid1, const char *__msgid2,
         unsigned long int __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__format_arg__ (1))) __attribute__ ((__format_arg__ (2)));



extern char *dngettext (const char *__domainname, const char *__msgid1,
   const char *__msgid2, unsigned long int __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));



extern char *dcngettext (const char *__domainname, const char *__msgid1,
    const char *__msgid2, unsigned long int __n,
    int __category)
     __attribute__ ((__nothrow__ )) __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));





extern char *textdomain (const char *__domainname) __attribute__ ((__nothrow__ ));



extern char *bindtextdomain (const char *__domainname,
        const char *__dirname) __attribute__ ((__nothrow__ ));



extern char *bind_textdomain_codeset (const char *__domainname,
          const char *__codeset) __attribute__ ((__nothrow__ ));








# 1 "/llvm-project/build/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 101 "/usr/include/libintl.h" 2 3 4
# 539 "./vim.h" 2
# 1238 "./vim.h"
enum auto_event
{
    EVENT_BUFADD = 0,
    EVENT_BUFDELETE,
    EVENT_BUFENTER,
    EVENT_BUFFILEPOST,
    EVENT_BUFFILEPRE,
    EVENT_BUFHIDDEN,
    EVENT_BUFLEAVE,
    EVENT_BUFNEW,
    EVENT_BUFNEWFILE,
    EVENT_BUFREADCMD,
    EVENT_BUFREADPOST,
    EVENT_BUFREADPRE,
    EVENT_BUFUNLOAD,
    EVENT_BUFWINENTER,
    EVENT_BUFWINLEAVE,
    EVENT_BUFWIPEOUT,
    EVENT_BUFWRITECMD,
    EVENT_BUFWRITEPOST,
    EVENT_BUFWRITEPRE,
    EVENT_CMDLINECHANGED,
    EVENT_CMDLINEENTER,
    EVENT_CMDLINELEAVE,
    EVENT_CMDUNDEFINED,
    EVENT_CMDWINENTER,
    EVENT_CMDWINLEAVE,
    EVENT_COLORSCHEME,
    EVENT_COLORSCHEMEPRE,
    EVENT_COMPLETECHANGED,
    EVENT_COMPLETEDONE,
    EVENT_COMPLETEDONEPRE,
    EVENT_CURSORHOLD,
    EVENT_CURSORHOLDI,
    EVENT_CURSORMOVED,
    EVENT_CURSORMOVEDI,
    EVENT_DIFFUPDATED,
    EVENT_DIRCHANGED,
    EVENT_ENCODINGCHANGED,
    EVENT_EXITPRE,
    EVENT_FILEAPPENDCMD,
    EVENT_FILEAPPENDPOST,
    EVENT_FILEAPPENDPRE,
    EVENT_FILECHANGEDRO,
    EVENT_FILECHANGEDSHELL,
    EVENT_FILECHANGEDSHELLPOST,
    EVENT_FILEREADCMD,
    EVENT_FILEREADPOST,
    EVENT_FILEREADPRE,
    EVENT_FILETYPE,
    EVENT_FILEWRITECMD,
    EVENT_FILEWRITEPOST,
    EVENT_FILEWRITEPRE,
    EVENT_FILTERREADPOST,
    EVENT_FILTERREADPRE,
    EVENT_FILTERWRITEPOST,
    EVENT_FILTERWRITEPRE,
    EVENT_FOCUSGAINED,
    EVENT_FOCUSLOST,
    EVENT_FUNCUNDEFINED,
    EVENT_GUIENTER,
    EVENT_GUIFAILED,
    EVENT_INSERTCHANGE,
    EVENT_INSERTCHARPRE,
    EVENT_INSERTENTER,
    EVENT_INSERTLEAVEPRE,
    EVENT_INSERTLEAVE,
    EVENT_MENUPOPUP,
    EVENT_OPTIONSET,
    EVENT_QUICKFIXCMDPOST,
    EVENT_QUICKFIXCMDPRE,
    EVENT_QUITPRE,
    EVENT_REMOTEREPLY,
    EVENT_SAFESTATE,
    EVENT_SAFESTATEAGAIN,
    EVENT_SESSIONLOADPOST,
    EVENT_SHELLCMDPOST,
    EVENT_SHELLFILTERPOST,
    EVENT_SIGUSR1,
    EVENT_SOURCECMD,
    EVENT_SOURCEPRE,
    EVENT_SOURCEPOST,
    EVENT_SPELLFILEMISSING,
    EVENT_STDINREADPOST,
    EVENT_STDINREADPRE,
    EVENT_SWAPEXISTS,
    EVENT_SYNTAX,
    EVENT_TABCLOSED,
    EVENT_TABENTER,
    EVENT_TABLEAVE,
    EVENT_TABNEW,
    EVENT_TERMCHANGED,
    EVENT_TERMINALOPEN,
    EVENT_TERMINALWINOPEN,

    EVENT_TERMRESPONSE,
    EVENT_TEXTCHANGED,
    EVENT_TEXTCHANGEDI,
    EVENT_TEXTCHANGEDP,
    EVENT_TEXTYANKPOST,
    EVENT_USER,
    EVENT_VIMENTER,
    EVENT_VIMLEAVE,
    EVENT_VIMLEAVEPRE,
    EVENT_VIMRESIZED,
    EVENT_WINENTER,
    EVENT_WINLEAVE,
    EVENT_WINNEW,

    NUM_EVENTS
};

typedef enum auto_event event_T;






typedef enum
{
    HLF_8 = 0

    , HLF_EOB
    , HLF_AT

    , HLF_D
    , HLF_E
    , HLF_H
    , HLF_I
    , HLF_L
    , HLF_M
    , HLF_CM
    , HLF_N
    , HLF_LNA
    , HLF_LNB
    , HLF_CLN
    , HLF_R
    , HLF_S
    , HLF_SNC
    , HLF_C
    , HLF_T
    , HLF_V
    , HLF_VNC
    , HLF_W
    , HLF_WM
    , HLF_FL
    , HLF_FC
    , HLF_ADD
    , HLF_CHD
    , HLF_DED
    , HLF_TXD
    , HLF_CONCEAL
    , HLF_SC
    , HLF_SPB
    , HLF_SPC
    , HLF_SPR
    , HLF_SPL
    , HLF_PNI
    , HLF_PSI
    , HLF_PSB
    , HLF_PST
    , HLF_TP
    , HLF_TPS
    , HLF_TPF
    , HLF_CUC
    , HLF_CUL
    , HLF_MC
    , HLF_QFL
    , HLF_ST
    , HLF_STNC
    , HLF_COUNT
} hlf_T;
# 1432 "./vim.h"
typedef uint32_t UINT32_T;
# 1681 "./vim.h"
typedef long linenr_T;
typedef int colnr_T;
typedef unsigned short disptick_T;
# 1704 "./vim.h"
typedef void *vim_acl_T;
# 1780 "./vim.h"
typedef struct timeval proftime_T;
# 1797 "./vim.h"
typedef time_t time_T;






typedef int sock_T;





# 1 "./option.h" 1
# 369 "./option.h"
extern long p_aleph;

extern char_u *p_ambw;

extern int p_acd;

extern int p_ai;
extern int p_bin;
extern int p_bomb;
extern int p_bl;

extern int p_cin;
extern char_u *p_cink;


extern char_u *p_cinw;


extern char_u *p_cfu;
extern char_u *p_ofu;

extern int p_ci;



extern int p_ar;
extern int p_aw;
extern int p_awa;
extern char_u *p_bs;
extern char_u *p_bg;
extern int p_bk;
extern char_u *p_bkc;
extern unsigned bkc_flags;





extern char_u *p_bdir;
extern char_u *p_bex;
extern char_u *p_bo;
extern unsigned bo_flags;
# 434 "./option.h"
extern char_u *p_bsk;


extern char_u *p_cm;





extern long p_bdlay;

extern char_u *p_bexpr;


extern int p_bevalterm;






extern char_u *p_breakat;

extern char_u *p_bh;
extern char_u *p_bt;
extern char_u *p_cmp;
extern unsigned cmp_flags;


extern char_u *p_enc;
extern int p_deco;

extern char_u *p_ccv;

extern char_u *p_cino;

extern char_u *p_cedit;
extern long p_cwh;


extern char_u *p_cb;

extern long p_ch;

extern char_u *p_cms;

extern char_u *p_cpt;

extern int p_confirm;

extern int p_cp;
extern char_u *p_cot;



extern long p_ph;
extern long p_pw;
extern char_u *p_com;
extern char_u *p_cpo;

extern char_u *p_csprg;
extern int p_csre;

extern char_u *p_csqf;



extern int p_cst;
extern long p_csto;
extern long p_cspc;
extern int p_csverbose;

extern char_u *p_debug;

extern char_u *p_def;
extern char_u *p_inc;


extern char_u *p_dip;

extern char_u *p_dex;


extern char_u *p_dict;

extern int p_dg;

extern char_u *p_dir;
extern char_u *p_dy;
extern unsigned dy_flags;



extern int p_ed;
extern char_u *p_ead;
extern char_u *p_emoji;
extern int p_ea;
extern char_u *p_ep;
extern int p_eb;

extern char_u *p_ef;
extern char_u *p_efm;
extern char_u *p_gefm;
extern char_u *p_gp;

extern int p_eol;
extern int p_ek;
extern char_u *p_ei;
extern int p_et;
extern int p_exrc;
extern char_u *p_fenc;
extern char_u *p_fencs;
extern char_u *p_ff;
extern char_u *p_ffs;
extern long p_fic;
extern char_u *p_ft;
extern char_u *p_fcs;
extern int p_fixeol;

extern char_u *p_fcl;
extern long p_fdls;
extern char_u *p_fdo;
extern unsigned fdo_flags;
# 570 "./option.h"
extern char_u *p_fex;

extern char_u *p_flp;
extern char_u *p_fo;
extern char_u *p_fp;

extern int p_fs;

extern int p_gd;


extern char_u *p_cpp;

extern char_u *p_pvp;


extern char_u *p_pdev;

extern char_u *p_penc;
extern char_u *p_pexpr;
extern char_u *p_pmfn;
extern char_u *p_pmcs;

extern char_u *p_pfn;
extern char_u *p_popt;
extern char_u *p_header;

extern int p_prompt;
# 610 "./option.h"
extern char_u *p_guicursor;
# 622 "./option.h"
extern char_u *p_hf;
extern long p_hh;

extern char_u *p_hlg;

extern int p_hid;
extern char_u *p_hl;
extern int p_hls;
extern long p_hi;

extern int p_hkmap;
extern int p_hkmapp;

extern int p_arshape;



extern int p_icon;
extern char_u *p_iconstring;

extern int p_ic;







extern char_u *p_imaf;
extern char_u *p_imsf;

extern int p_imcmdline;
extern int p_imdisable;
extern long p_iminsert;
extern long p_imsearch;
extern int p_inf;

extern char_u *p_inex;

extern int p_is;

extern char_u *p_inde;
extern char_u *p_indk;

extern int p_im;
extern char_u *p_isf;
extern char_u *p_isi;
extern char_u *p_isk;
extern char_u *p_isp;
extern int p_js;

extern char_u *p_key;


extern char_u *p_keymap;

extern char_u *p_kp;
extern char_u *p_km;

extern char_u *p_langmap;
extern int p_lnr;
extern int p_lrm;


extern char_u *p_lm;





extern int p_lisp;
extern char_u *p_lispwords;

extern long p_ls;
extern long p_stal;
extern char_u *p_lcs;

extern int p_lz;
extern int p_lpl;



extern int p_magic;
extern char_u *p_menc;

extern char_u *p_mef;
extern char_u *p_mp;

extern char_u *p_mps;

extern char_u *p_scl;


extern char_u *p_cc;
extern int p_cc_cols[256];

extern long p_mat;
extern long p_mco;

extern long p_mfd;

extern long p_mmd;
extern long p_mm;
extern long p_mmp;
extern long p_mmt;

extern long p_mis;


extern char_u *p_msm;

extern int p_ml;
extern long p_mle;
extern long p_mls;
extern int p_ma;
extern int p_mod;
extern char_u *p_mouse;




extern char_u *p_mousem;
extern long p_mouset;
extern int p_more;







extern char_u *p_nf;



extern char_u *p_opfunc;
extern char_u *p_para;
extern int p_paste;
extern char_u *p_pt;

extern char_u *p_pex;

extern char_u *p_pm;
extern char_u *p_path;

extern char_u *p_cdpath;




extern int p_pi;
# 789 "./option.h"
extern char_u *p_qe;

extern int p_ro;

extern long p_rdt;

extern int p_remap;
extern long p_re;



extern long p_report;

extern long p_pvh;





extern int p_ari;
extern int p_ri;





extern int p_ru;


extern char_u *p_ruf;

extern char_u *p_pp;
extern char_u *p_qftf;
extern char_u *p_rtp;
extern long p_sj;



extern long p_so;
extern char_u *p_sbo;
extern char_u *p_sections;
extern int p_secure;
extern char_u *p_sel;
extern char_u *p_slm;

extern char_u *p_ssop;
extern unsigned ssop_flags;
# 854 "./option.h"
extern char_u *p_sh;
extern char_u *p_shcf;

extern char_u *p_sp;

extern char_u *p_shq;
extern char_u *p_sxq;
extern char_u *p_sxe;
extern char_u *p_srr;



extern int p_stmp;




extern char_u *p_stl;

extern int p_sr;
extern long p_sw;
extern char_u *p_shm;
extern int p_sn;

extern char_u *p_sbr;


extern int p_sc;

extern int p_sft;
extern int p_sm;
extern int p_smd;
extern long p_ss;
extern long p_siso;
extern int p_scs;

extern int p_si;

extern int p_sta;
extern long p_sts;
extern int p_sb;

extern char_u *p_sua;

extern int p_swf;

extern long p_smc;

extern long p_tpm;

extern char_u *p_tal;


extern char_u *p_tfu;


extern char_u *p_spc;
extern char_u *p_spf;
extern char_u *p_spl;
extern char_u *p_spo;
extern char_u *p_sps;

extern int p_spr;
extern int p_sol;
extern char_u *p_su;
extern char_u *p_sws;
extern char_u *p_swb;
extern unsigned swb_flags;







extern char_u *p_syn;
extern long p_ts;
extern int p_tbs;
extern char_u *p_tc;
extern unsigned tc_flags;





extern long p_tl;
extern int p_tr;
extern char_u *p_tags;
extern int p_tgst;




extern int p_tbidi;

extern char_u *p_tenc;

extern int p_tgc;


extern long p_twsl;




extern int p_terse;
extern int p_ta;
extern int p_tx;
extern long p_tw;
extern int p_to;
extern int p_timeout;
extern long p_tm;

extern int p_title;
extern long p_titlelen;
extern char_u *p_titleold;
extern char_u *p_titlestring;

extern char_u *p_tsr;
extern int p_ttimeout;
extern long p_ttm;
extern int p_tbi;
extern int p_tf;
# 995 "./option.h"
extern long p_ttyscroll;

extern char_u *p_ttym;
extern unsigned ttym_flags;
# 1008 "./option.h"
extern char_u *p_udir;

extern int p_udf;

extern long p_ul;
extern long p_ur;
extern long p_uc;
extern long p_ut;

extern char_u *p_vsts;
extern char_u *p_vts;


extern char_u *p_viminfo;
extern char_u *p_viminfofile;


extern char_u *p_vdir;
extern char_u *p_vop;
extern unsigned vop_flags;

extern int p_vb;
extern char_u *p_ve;
extern unsigned ve_flags;




extern long p_verbose;



extern char_u *p_vfile;

extern int p_warn;
extern char_u *p_wop;
extern long p_window;






extern char_u *p_wig;

extern int p_wiv;
extern char_u *p_ww;
extern long p_wc;
extern long p_wcm;
extern long p_wic;
extern char_u *p_wim;

extern int p_wmnu;

extern long p_wh;
extern long p_wmh;
extern long p_wmw;
extern long p_wiw;



extern long p_wm;
extern int p_ws;
extern int p_write;
extern int p_wa;
extern int p_wb;
extern long p_wd;






enum
{
    BV_AI = 0
    , BV_AR
    , BV_BH
    , BV_BKC
    , BV_BT

    , BV_EFM
    , BV_GP
    , BV_MP

    , BV_BIN
    , BV_BL
    , BV_BOMB
    , BV_CI

    , BV_CIN
    , BV_CINK
    , BV_CINO


    , BV_CINW

    , BV_CM

    , BV_CMS

    , BV_COM
    , BV_CPT
    , BV_DICT
    , BV_TSR




    , BV_CFU


    , BV_DEF
    , BV_INC

    , BV_EOL
    , BV_FIXEOL
    , BV_EP
    , BV_ET
    , BV_FENC
    , BV_FP

    , BV_BEXPR
    , BV_FEX

    , BV_FF
    , BV_FLP
    , BV_FO
    , BV_FT
    , BV_IMI
    , BV_IMS

    , BV_INDE
    , BV_INDK


    , BV_INEX

    , BV_INF
    , BV_ISK

    , BV_KEY


    , BV_KMAP

    , BV_KP

    , BV_LISP
    , BV_LW

    , BV_MENC
    , BV_MA
    , BV_ML
    , BV_MOD
    , BV_MPS
    , BV_NF

    , BV_OFU

    , BV_PATH
    , BV_PI

    , BV_QE

    , BV_RO

    , BV_SI

    , BV_SN

    , BV_SMC
    , BV_SYN


    , BV_SPC
    , BV_SPF
    , BV_SPL
    , BV_SPO

    , BV_STS

    , BV_SUA

    , BV_SW
    , BV_SWF

    , BV_TFU

    , BV_TAGS
    , BV_TC
    , BV_TS
    , BV_TW
    , BV_TX
    , BV_UDF
    , BV_UL
    , BV_WM

    , BV_TWSL


    , BV_VSTS
    , BV_VTS

    , BV_COUNT
};






enum
{
    WV_LIST = 0

    , WV_ARAB


    , WV_COCU
    , WV_COLE


    , WV_TWK
    , WV_TWS

    , WV_CRBIND

    , WV_BRI
    , WV_BRIOPT

    , WV_WCR

    , WV_DIFF


    , WV_FDC
    , WV_FEN
    , WV_FDI
    , WV_FDL
    , WV_FDM
    , WV_FML
    , WV_FDN

    , WV_FDE
    , WV_FDT

    , WV_FMR


    , WV_LBR

    , WV_NU
    , WV_RNU

    , WV_NUW


    , WV_PVW


    , WV_RL
    , WV_RLC

    , WV_SCBIND
    , WV_SCROLL
    , WV_SISO
    , WV_SO

    , WV_SPELL


    , WV_CUC
    , WV_CUL
    , WV_CULOPT
    , WV_CC


    , WV_SBR


    , WV_STL

    , WV_WFH
    , WV_WFW
    , WV_WRAP

    , WV_SCL

    , WV_COUNT
};
# 1810 "./vim.h" 2

# 1 "./beval.h" 1
# 25 "./beval.h"
typedef enum
{
    ShS_NEUTRAL,
    ShS_PENDING,
    ShS_UPDATE_PENDING,
    ShS_SHOWING
} BeState;

typedef struct BalloonEvalStruct
{
# 74 "./beval.h"
    int ts;

    int *vts;

    char_u *msg;







} BalloonEval;
# 1812 "./vim.h" 2



# 1 "./structs.h" 1
# 26 "./structs.h"
typedef struct
{
    linenr_T lnum;
    colnr_T col;
    colnr_T coladd;
} pos_T;





typedef struct
{
    linenr_T lnum;
    colnr_T col;
} lpos_T;






typedef struct growarray
{
    int ga_len;
    int ga_maxlen;
    int ga_itemsize;
    int ga_growsize;
    void *ga_data;
} garray_T;



typedef struct window_S win_T;
typedef struct wininfo_S wininfo_T;
typedef struct frame_S frame_T;
typedef int scid_T;
typedef struct file_buffer buf_T;
typedef struct terminal_S term_T;


typedef struct VimMenu vimmenu_T;
# 85 "./structs.h"
typedef struct {
    scid_T sc_sid;
    int sc_seq;
    linenr_T sc_lnum;
    int sc_version;
} sctx_T;





typedef struct {
    buf_T *br_buf;
    int br_fnum;
    int br_buf_free_count;
} bufref_T;





# 1 "./regexp.h" 1
# 42 "./regexp.h"
typedef struct regengine regengine_T;






typedef struct regprog
{
    regengine_T *engine;
    unsigned regflags;
    unsigned re_engine;
    unsigned re_flags;
    int re_in_use;
} regprog_T;






typedef struct
{

    regengine_T *engine;
    unsigned regflags;
    unsigned re_engine;
    unsigned re_flags;
    int re_in_use;

    int regstart;
    char_u reganch;
    char_u *regmust;
    int regmlen;

    char_u reghasz;

    char_u program[1];
} bt_regprog_T;





typedef struct nfa_state nfa_state_T;
struct nfa_state
{
    int c;
    nfa_state_T *out;
    nfa_state_T *out1;
    int id;
    int lastlist[2];
    int val;
};




typedef struct
{

    regengine_T *engine;
    unsigned regflags;
    unsigned re_engine;
    unsigned re_flags;
    int re_in_use;

    nfa_state_T *start;

    int reganch;
    int regstart;
    char_u *match_text;

    int has_zend;
    int has_backref;

    int reghasz;

    char_u *pattern;
    int nsubexp;
    int nstate;
    nfa_state_T state[1];
} nfa_regprog_T;






typedef struct
{
    regprog_T *regprog;
    char_u *startp[10];
    char_u *endp[10];
    int rm_ic;
} regmatch_T;
# 147 "./regexp.h"
typedef struct
{
    regprog_T *regprog;
    lpos_T startpos[10];
    lpos_T endpos[10];
    int rmm_ic;
    colnr_T rmm_maxcol;
} regmmatch_T;






typedef struct
{
    short refcnt;
    char_u *matches[10];
} reg_extmatch_T;

struct regengine
{
    regprog_T *(*regcomp)(char_u*, int);
    void (*regfree)(regprog_T *);
    int (*regexec_nl)(regmatch_T *, char_u *, colnr_T, int);
    long (*regexec_multi)(regmmatch_T *, win_T *, buf_T *, linenr_T, colnr_T, proftime_T *, int *);
    char_u *expr;
};
# 106 "./structs.h" 2
# 115 "./structs.h"
# 1 "/usr/include/X11/Intrinsic.h" 1 3 4
# 53 "/usr/include/X11/Intrinsic.h" 3 4
# 1 "/usr/include/X11/Xlib.h" 1 3 4
# 44 "/usr/include/X11/Xlib.h" 3 4
# 1 "/usr/include/X11/X.h" 1 3 4
# 66 "/usr/include/X11/X.h" 3 4
typedef unsigned long XID;



typedef unsigned long Mask;



typedef unsigned long Atom;

typedef unsigned long VisualID;
typedef unsigned long Time;
# 96 "/usr/include/X11/X.h" 3 4
typedef XID Window;
typedef XID Drawable;


typedef XID Font;

typedef XID Pixmap;
typedef XID Cursor;
typedef XID Colormap;
typedef XID GContext;
typedef XID KeySym;

typedef unsigned char KeyCode;
# 45 "/usr/include/X11/Xlib.h" 2 3 4


# 1 "/usr/include/X11/Xfuncproto.h" 1 3 4
# 48 "/usr/include/X11/Xlib.h" 2 3 4
# 1 "/usr/include/X11/Xosdefs.h" 1 3 4
# 49 "/usr/include/X11/Xlib.h" 2 3 4


# 1 "/llvm-project/build/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 52 "/usr/include/X11/Xlib.h" 2 3 4
# 62 "/usr/include/X11/Xlib.h" 3 4
extern int
_Xmblen(
    char *str,
    int len
    );
# 76 "/usr/include/X11/Xlib.h" 3 4
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wpadded"


typedef char *XPointer;
# 148 "/usr/include/X11/Xlib.h" 3 4
typedef struct _XExtData {
 int number;
 struct _XExtData *next;
 int (*free_private)(
 struct _XExtData *extension
 );
 XPointer private_data;
} XExtData;




typedef struct {
 int extension;
 int major_opcode;
 int first_event;
 int first_error;
} XExtCodes;





typedef struct {
    int depth;
    int bits_per_pixel;
    int scanline_pad;
} XPixmapFormatValues;





typedef struct {
 int function;
 unsigned long plane_mask;
 unsigned long foreground;
 unsigned long background;
 int line_width;
 int line_style;
 int cap_style;

 int join_style;
 int fill_style;

 int fill_rule;
 int arc_mode;
 Pixmap tile;
 Pixmap stipple;
 int ts_x_origin;
 int ts_y_origin;
        Font font;
 int subwindow_mode;
 int graphics_exposures;
 int clip_x_origin;
 int clip_y_origin;
 Pixmap clip_mask;
 int dash_offset;
 char dashes;
} XGCValues;






typedef struct _XGC







*GC;




typedef struct {
 XExtData *ext_data;
 VisualID visualid;



 int class;

 unsigned long red_mask, green_mask, blue_mask;
 int bits_per_rgb;
 int map_entries;
} Visual;




typedef struct {
 int depth;
 int nvisuals;
 Visual *visuals;
} Depth;







struct _XDisplay;

typedef struct {
 XExtData *ext_data;
 struct _XDisplay *display;
 Window root;
 int width, height;
 int mwidth, mheight;
 int ndepths;
 Depth *depths;
 int root_depth;
 Visual *root_visual;
 GC default_gc;
 Colormap cmap;
 unsigned long white_pixel;
 unsigned long black_pixel;
 int max_maps, min_maps;
 int backing_store;
 int save_unders;
 long root_input_mask;
} Screen;




typedef struct {
 XExtData *ext_data;
 int depth;
 int bits_per_pixel;
 int scanline_pad;
} ScreenFormat;




typedef struct {
    Pixmap background_pixmap;
    unsigned long background_pixel;
    Pixmap border_pixmap;
    unsigned long border_pixel;
    int bit_gravity;
    int win_gravity;
    int backing_store;
    unsigned long backing_planes;
    unsigned long backing_pixel;
    int save_under;
    long event_mask;
    long do_not_propagate_mask;
    int override_redirect;
    Colormap colormap;
    Cursor cursor;
} XSetWindowAttributes;

typedef struct {
    int x, y;
    int width, height;
    int border_width;
    int depth;
    Visual *visual;
    Window root;



    int class;

    int bit_gravity;
    int win_gravity;
    int backing_store;
    unsigned long backing_planes;
    unsigned long backing_pixel;
    int save_under;
    Colormap colormap;
    int map_installed;
    int map_state;
    long all_event_masks;
    long your_event_mask;
    long do_not_propagate_mask;
    int override_redirect;
    Screen *screen;
} XWindowAttributes;






typedef struct {
 int family;
 int length;
 char *address;
} XHostAddress;




typedef struct {
 int typelength;
 int valuelength;
 char *type;
 char *value;
} XServerInterpretedAddress;




typedef struct _XImage {
    int width, height;
    int xoffset;
    int format;
    char *data;
    int byte_order;
    int bitmap_unit;
    int bitmap_bit_order;
    int bitmap_pad;
    int depth;
    int bytes_per_line;
    int bits_per_pixel;
    unsigned long red_mask;
    unsigned long green_mask;
    unsigned long blue_mask;
    XPointer obdata;
    struct funcs {
 struct _XImage *(*create_image)(
  struct _XDisplay* ,
  Visual* ,
  unsigned int ,
  int ,
  int ,
  char* ,
  unsigned int ,
  unsigned int ,
  int ,
  int );
 int (*destroy_image) (struct _XImage *);
 unsigned long (*get_pixel) (struct _XImage *, int, int);
 int (*put_pixel) (struct _XImage *, int, int, unsigned long);
 struct _XImage *(*sub_image)(struct _XImage *, int, int, unsigned int, unsigned int);
 int (*add_pixel) (struct _XImage *, long);
 } f;
} XImage;




typedef struct {
    int x, y;
    int width, height;
    int border_width;
    Window sibling;
    int stack_mode;
} XWindowChanges;




typedef struct {
 unsigned long pixel;
 unsigned short red, green, blue;
 char flags;
 char pad;
} XColor;






typedef struct {
    short x1, y1, x2, y2;
} XSegment;

typedef struct {
    short x, y;
} XPoint;

typedef struct {
    short x, y;
    unsigned short width, height;
} XRectangle;

typedef struct {
    short x, y;
    unsigned short width, height;
    short angle1, angle2;
} XArc;




typedef struct {
        int key_click_percent;
        int bell_percent;
        int bell_pitch;
        int bell_duration;
        int led;
        int led_mode;
        int key;
        int auto_repeat_mode;
} XKeyboardControl;



typedef struct {
        int key_click_percent;
 int bell_percent;
 unsigned int bell_pitch, bell_duration;
 unsigned long led_mask;
 int global_auto_repeat;
 char auto_repeats[32];
} XKeyboardState;



typedef struct {
        Time time;
 short x, y;
} XTimeCoord;



typedef struct {
  int max_keypermod;
  KeyCode *modifiermap;
} XModifierKeymap;
# 487 "/usr/include/X11/Xlib.h" 3 4
typedef struct _XDisplay Display;


struct _XPrivate;
struct _XrmHashBucketRec;

typedef struct



{
 XExtData *ext_data;
 struct _XPrivate *private1;
 int fd;
 int private2;
 int proto_major_version;
 int proto_minor_version;
 char *vendor;
        XID private3;
 XID private4;
 XID private5;
 int private6;
 XID (*resource_alloc)(
  struct _XDisplay*
 );
 int byte_order;
 int bitmap_unit;
 int bitmap_pad;
 int bitmap_bit_order;
 int nformats;
 ScreenFormat *pixmap_format;
 int private8;
 int release;
 struct _XPrivate *private9, *private10;
 int qlen;
 unsigned long last_request_read;
 unsigned long request;
 XPointer private11;
 XPointer private12;
 XPointer private13;
 XPointer private14;
 unsigned max_request_size;
 struct _XrmHashBucketRec *db;
 int (*private15)(
  struct _XDisplay*
  );
 char *display_name;
 int default_screen;
 int nscreens;
 Screen *screens;
 unsigned long motion_buffer;
 unsigned long private16;
 int min_keycode;
 int max_keycode;
 XPointer private17;
 XPointer private18;
 int private19;
 char *xdefaults;

}



*_XPrivDisplay;






typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 Window root;
 Window subwindow;
 Time time;
 int x, y;
 int x_root, y_root;
 unsigned int state;
 unsigned int keycode;
 int same_screen;
} XKeyEvent;
typedef XKeyEvent XKeyPressedEvent;
typedef XKeyEvent XKeyReleasedEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 Window root;
 Window subwindow;
 Time time;
 int x, y;
 int x_root, y_root;
 unsigned int state;
 unsigned int button;
 int same_screen;
} XButtonEvent;
typedef XButtonEvent XButtonPressedEvent;
typedef XButtonEvent XButtonReleasedEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 Window root;
 Window subwindow;
 Time time;
 int x, y;
 int x_root, y_root;
 unsigned int state;
 char is_hint;
 int same_screen;
} XMotionEvent;
typedef XMotionEvent XPointerMovedEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 Window root;
 Window subwindow;
 Time time;
 int x, y;
 int x_root, y_root;
 int mode;
 int detail;




 int same_screen;
 int focus;
 unsigned int state;
} XCrossingEvent;
typedef XCrossingEvent XEnterWindowEvent;
typedef XCrossingEvent XLeaveWindowEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 int mode;

 int detail;





} XFocusChangeEvent;
typedef XFocusChangeEvent XFocusInEvent;
typedef XFocusChangeEvent XFocusOutEvent;


typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 char key_vector[32];
} XKeymapEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 int x, y;
 int width, height;
 int count;
} XExposeEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Drawable drawable;
 int x, y;
 int width, height;
 int count;
 int major_code;
 int minor_code;
} XGraphicsExposeEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Drawable drawable;
 int major_code;
 int minor_code;
} XNoExposeEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 int state;
} XVisibilityEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window parent;
 Window window;
 int x, y;
 int width, height;
 int border_width;
 int override_redirect;
} XCreateWindowEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window event;
 Window window;
} XDestroyWindowEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window event;
 Window window;
 int from_configure;
} XUnmapEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window event;
 Window window;
 int override_redirect;
} XMapEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window parent;
 Window window;
} XMapRequestEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window event;
 Window window;
 Window parent;
 int x, y;
 int override_redirect;
} XReparentEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window event;
 Window window;
 int x, y;
 int width, height;
 int border_width;
 Window above;
 int override_redirect;
} XConfigureEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window event;
 Window window;
 int x, y;
} XGravityEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 int width, height;
} XResizeRequestEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window parent;
 Window window;
 int x, y;
 int width, height;
 int border_width;
 Window above;
 int detail;
 unsigned long value_mask;
} XConfigureRequestEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window event;
 Window window;
 int place;
} XCirculateEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window parent;
 Window window;
 int place;
} XCirculateRequestEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 Atom atom;
 Time time;
 int state;
} XPropertyEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 Atom selection;
 Time time;
} XSelectionClearEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window owner;
 Window requestor;
 Atom selection;
 Atom target;
 Atom property;
 Time time;
} XSelectionRequestEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window requestor;
 Atom selection;
 Atom target;
 Atom property;
 Time time;
} XSelectionEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 Colormap colormap;



 int new;

 int state;
} XColormapEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 Atom message_type;
 int format;
 union {
  char b[20];
  short s[10];
  long l[5];
  } data;
} XClientMessageEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
 int request;

 int first_keycode;
 int count;
} XMappingEvent;

typedef struct {
 int type;
 Display *display;
 XID resourceid;
 unsigned long serial;
 unsigned char error_code;
 unsigned char request_code;
 unsigned char minor_code;
} XErrorEvent;

typedef struct {
 int type;
 unsigned long serial;
 int send_event;
 Display *display;
 Window window;
} XAnyEvent;







typedef struct
    {
    int type;
    unsigned long serial;
    int send_event;
    Display *display;
    int extension;
    int evtype;
    } XGenericEvent;

typedef struct {
    int type;
    unsigned long serial;
    int send_event;
    Display *display;
    int extension;
    int evtype;
    unsigned int cookie;
    void *data;
} XGenericEventCookie;





typedef union _XEvent {
        int type;
 XAnyEvent xany;
 XKeyEvent xkey;
 XButtonEvent xbutton;
 XMotionEvent xmotion;
 XCrossingEvent xcrossing;
 XFocusChangeEvent xfocus;
 XExposeEvent xexpose;
 XGraphicsExposeEvent xgraphicsexpose;
 XNoExposeEvent xnoexpose;
 XVisibilityEvent xvisibility;
 XCreateWindowEvent xcreatewindow;
 XDestroyWindowEvent xdestroywindow;
 XUnmapEvent xunmap;
 XMapEvent xmap;
 XMapRequestEvent xmaprequest;
 XReparentEvent xreparent;
 XConfigureEvent xconfigure;
 XGravityEvent xgravity;
 XResizeRequestEvent xresizerequest;
 XConfigureRequestEvent xconfigurerequest;
 XCirculateEvent xcirculate;
 XCirculateRequestEvent xcirculaterequest;
 XPropertyEvent xproperty;
 XSelectionClearEvent xselectionclear;
 XSelectionRequestEvent xselectionrequest;
 XSelectionEvent xselection;
 XColormapEvent xcolormap;
 XClientMessageEvent xclient;
 XMappingEvent xmapping;
 XErrorEvent xerror;
 XKeymapEvent xkeymap;
 XGenericEvent xgeneric;
 XGenericEventCookie xcookie;
 long pad[24];
} XEvent;







typedef struct {
    short lbearing;
    short rbearing;
    short width;
    short ascent;
    short descent;
    unsigned short attributes;
} XCharStruct;





typedef struct {
    Atom name;
    unsigned long card32;
} XFontProp;

typedef struct {
    XExtData *ext_data;
    Font fid;
    unsigned direction;
    unsigned min_char_or_byte2;
    unsigned max_char_or_byte2;
    unsigned min_byte1;
    unsigned max_byte1;
    int all_chars_exist;
    unsigned default_char;
    int n_properties;
    XFontProp *properties;
    XCharStruct min_bounds;
    XCharStruct max_bounds;
    XCharStruct *per_char;
    int ascent;
    int descent;
} XFontStruct;




typedef struct {
    char *chars;
    int nchars;
    int delta;
    Font font;
} XTextItem;

typedef struct {
    unsigned char byte1;
    unsigned char byte2;
} XChar2b;

typedef struct {
    XChar2b *chars;
    int nchars;
    int delta;
    Font font;
} XTextItem16;


typedef union { Display *display;
  GC gc;
  Visual *visual;
  Screen *screen;
  ScreenFormat *pixmap_format;
  XFontStruct *font; } XEDataObject;

typedef struct {
    XRectangle max_ink_extent;
    XRectangle max_logical_extent;
} XFontSetExtents;





typedef struct _XOM *XOM;
typedef struct _XOC *XOC, *XFontSet;

typedef struct {
    char *chars;
    int nchars;
    int delta;
    XFontSet font_set;
} XmbTextItem;

typedef struct {
    wchar_t *chars;
    int nchars;
    int delta;
    XFontSet font_set;
} XwcTextItem;
# 1121 "/usr/include/X11/Xlib.h" 3 4
typedef struct {
    int charset_count;
    char **charset_list;
} XOMCharSetList;

typedef enum {
    XOMOrientation_LTR_TTB,
    XOMOrientation_RTL_TTB,
    XOMOrientation_TTB_LTR,
    XOMOrientation_TTB_RTL,
    XOMOrientation_Context
} XOrientation;

typedef struct {
    int num_orientation;
    XOrientation *orientation;
} XOMOrientation;

typedef struct {
    int num_font;
    XFontStruct **font_struct_list;
    char **font_name_list;
} XOMFontInfo;

typedef struct _XIM *XIM;
typedef struct _XIC *XIC;

typedef void (*XIMProc)(
    XIM,
    XPointer,
    XPointer
);

typedef int (*XICProc)(
    XIC,
    XPointer,
    XPointer
);

typedef void (*XIDProc)(
    Display*,
    XPointer,
    XPointer
);

typedef unsigned long XIMStyle;

typedef struct {
    unsigned short count_styles;
    XIMStyle *supported_styles;
} XIMStyles;
# 1233 "/usr/include/X11/Xlib.h" 3 4
typedef void *XVaNestedList;

typedef struct {
    XPointer client_data;
    XIMProc callback;
} XIMCallback;

typedef struct {
    XPointer client_data;
    XICProc callback;
} XICCallback;

typedef unsigned long XIMFeedback;
# 1257 "/usr/include/X11/Xlib.h" 3 4
typedef struct _XIMText {
    unsigned short length;
    XIMFeedback *feedback;
    int encoding_is_wchar;
    union {
 char *multi_byte;
 wchar_t *wide_char;
    } string;
} XIMText;

typedef unsigned long XIMPreeditState;





typedef struct _XIMPreeditStateNotifyCallbackStruct {
    XIMPreeditState state;
} XIMPreeditStateNotifyCallbackStruct;

typedef unsigned long XIMResetState;




typedef unsigned long XIMStringConversionFeedback;
# 1291 "/usr/include/X11/Xlib.h" 3 4
typedef struct _XIMStringConversionText {
    unsigned short length;
    XIMStringConversionFeedback *feedback;
    int encoding_is_wchar;
    union {
 char *mbs;
 wchar_t *wcs;
    } string;
} XIMStringConversionText;

typedef unsigned short XIMStringConversionPosition;

typedef unsigned short XIMStringConversionType;






typedef unsigned short XIMStringConversionOperation;




typedef enum {
    XIMForwardChar, XIMBackwardChar,
    XIMForwardWord, XIMBackwardWord,
    XIMCaretUp, XIMCaretDown,
    XIMNextLine, XIMPreviousLine,
    XIMLineStart, XIMLineEnd,
    XIMAbsolutePosition,
    XIMDontChange
} XIMCaretDirection;

typedef struct _XIMStringConversionCallbackStruct {
    XIMStringConversionPosition position;
    XIMCaretDirection direction;
    XIMStringConversionOperation operation;
    unsigned short factor;
    XIMStringConversionText *text;
} XIMStringConversionCallbackStruct;

typedef struct _XIMPreeditDrawCallbackStruct {
    int caret;
    int chg_first;
    int chg_length;
    XIMText *text;
} XIMPreeditDrawCallbackStruct;

typedef enum {
    XIMIsInvisible,
    XIMIsPrimary,
    XIMIsSecondary
} XIMCaretStyle;

typedef struct _XIMPreeditCaretCallbackStruct {
    int position;
    XIMCaretDirection direction;
    XIMCaretStyle style;
} XIMPreeditCaretCallbackStruct;

typedef enum {
    XIMTextType,
    XIMBitmapType
} XIMStatusDataType;

typedef struct _XIMStatusDrawCallbackStruct {
    XIMStatusDataType type;
    union {
 XIMText *text;
 Pixmap bitmap;
    } data;
} XIMStatusDrawCallbackStruct;

typedef struct _XIMHotKeyTrigger {
    KeySym keysym;
    int modifier;
    int modifier_mask;
} XIMHotKeyTrigger;

typedef struct _XIMHotKeyTriggers {
    int num_hot_key;
    XIMHotKeyTrigger *key;
} XIMHotKeyTriggers;

typedef unsigned long XIMHotKeyState;




typedef struct {
    unsigned short count_values;
    char **supported_values;
} XIMValuesList;







extern int _Xdebug;

extern XFontStruct *XLoadQueryFont(
    Display* ,
    const char*
);

extern XFontStruct *XQueryFont(
    Display* ,
    XID
);


extern XTimeCoord *XGetMotionEvents(
    Display* ,
    Window ,
    Time ,
    Time ,
    int*
);

extern XModifierKeymap *XDeleteModifiermapEntry(
    XModifierKeymap* ,



    KeyCode ,

    int
);

extern XModifierKeymap *XGetModifierMapping(
    Display*
);

extern XModifierKeymap *XInsertModifiermapEntry(
    XModifierKeymap* ,



    KeyCode ,

    int
);

extern XModifierKeymap *XNewModifiermap(
    int
);

extern XImage *XCreateImage(
    Display* ,
    Visual* ,
    unsigned int ,
    int ,
    int ,
    char* ,
    unsigned int ,
    unsigned int ,
    int ,
    int
);
extern int XInitImage(
    XImage*
);
extern XImage *XGetImage(
    Display* ,
    Drawable ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    unsigned long ,
    int
);
extern XImage *XGetSubImage(
    Display* ,
    Drawable ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    unsigned long ,
    int ,
    XImage* ,
    int ,
    int
);




extern Display *XOpenDisplay(
    const char*
);

extern void XrmInitialize(
    void
);

extern char *XFetchBytes(
    Display* ,
    int*
);
extern char *XFetchBuffer(
    Display* ,
    int* ,
    int
);
extern char *XGetAtomName(
    Display* ,
    Atom
);
extern int XGetAtomNames(
    Display* ,
    Atom* ,
    int ,
    char**
);
extern char *XGetDefault(
    Display* ,
    const char* ,
    const char*
);
extern char *XDisplayName(
    const char*
);
extern char *XKeysymToString(
    KeySym
);

extern int (*XSynchronize(
    Display* ,
    int
))(
    Display*
);
extern int (*XSetAfterFunction(
    Display* ,
    int (*) (
      Display*
            )
))(
    Display*
);
extern Atom XInternAtom(
    Display* ,
    const char* ,
    int
);
extern int XInternAtoms(
    Display* ,
    char** ,
    int ,
    int ,
    Atom*
);
extern Colormap XCopyColormapAndFree(
    Display* ,
    Colormap
);
extern Colormap XCreateColormap(
    Display* ,
    Window ,
    Visual* ,
    int
);
extern Cursor XCreatePixmapCursor(
    Display* ,
    Pixmap ,
    Pixmap ,
    XColor* ,
    XColor* ,
    unsigned int ,
    unsigned int
);
extern Cursor XCreateGlyphCursor(
    Display* ,
    Font ,
    Font ,
    unsigned int ,
    unsigned int ,
    XColor const * ,
    XColor const *
);
extern Cursor XCreateFontCursor(
    Display* ,
    unsigned int
);
extern Font XLoadFont(
    Display* ,
    const char*
);
extern GC XCreateGC(
    Display* ,
    Drawable ,
    unsigned long ,
    XGCValues*
);
extern GContext XGContextFromGC(
    GC
);
extern void XFlushGC(
    Display* ,
    GC
);
extern Pixmap XCreatePixmap(
    Display* ,
    Drawable ,
    unsigned int ,
    unsigned int ,
    unsigned int
);
extern Pixmap XCreateBitmapFromData(
    Display* ,
    Drawable ,
    const char* ,
    unsigned int ,
    unsigned int
);
extern Pixmap XCreatePixmapFromBitmapData(
    Display* ,
    Drawable ,
    char* ,
    unsigned int ,
    unsigned int ,
    unsigned long ,
    unsigned long ,
    unsigned int
);
extern Window XCreateSimpleWindow(
    Display* ,
    Window ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    unsigned int ,
    unsigned long ,
    unsigned long
);
extern Window XGetSelectionOwner(
    Display* ,
    Atom
);
extern Window XCreateWindow(
    Display* ,
    Window ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    unsigned int ,
    int ,
    unsigned int ,
    Visual* ,
    unsigned long ,
    XSetWindowAttributes*
);
extern Colormap *XListInstalledColormaps(
    Display* ,
    Window ,
    int*
);
extern char **XListFonts(
    Display* ,
    const char* ,
    int ,
    int*
);
extern char **XListFontsWithInfo(
    Display* ,
    const char* ,
    int ,
    int* ,
    XFontStruct**
);
extern char **XGetFontPath(
    Display* ,
    int*
);
extern char **XListExtensions(
    Display* ,
    int*
);
extern Atom *XListProperties(
    Display* ,
    Window ,
    int*
);
extern XHostAddress *XListHosts(
    Display* ,
    int* ,
    int*
);
__attribute__((deprecated))
extern KeySym XKeycodeToKeysym(
    Display* ,



    KeyCode ,

    int
);
extern KeySym XLookupKeysym(
    XKeyEvent* ,
    int
);
extern KeySym *XGetKeyboardMapping(
    Display* ,



    KeyCode ,

    int ,
    int*
);
extern KeySym XStringToKeysym(
    const char*
);
extern long XMaxRequestSize(
    Display*
);
extern long XExtendedMaxRequestSize(
    Display*
);
extern char *XResourceManagerString(
    Display*
);
extern char *XScreenResourceString(
 Screen*
);
extern unsigned long XDisplayMotionBufferSize(
    Display*
);
extern VisualID XVisualIDFromVisual(
    Visual*
);



extern int XInitThreads(
    void
);

extern void XLockDisplay(
    Display*
);

extern void XUnlockDisplay(
    Display*
);



extern XExtCodes *XInitExtension(
    Display* ,
    const char*
);

extern XExtCodes *XAddExtension(
    Display*
);
extern XExtData *XFindOnExtensionList(
    XExtData** ,
    int
);
extern XExtData **XEHeadOfExtensionList(
    XEDataObject
);


extern Window XRootWindow(
    Display* ,
    int
);
extern Window XDefaultRootWindow(
    Display*
);
extern Window XRootWindowOfScreen(
    Screen*
);
extern Visual *XDefaultVisual(
    Display* ,
    int
);
extern Visual *XDefaultVisualOfScreen(
    Screen*
);
extern GC XDefaultGC(
    Display* ,
    int
);
extern GC XDefaultGCOfScreen(
    Screen*
);
extern unsigned long XBlackPixel(
    Display* ,
    int
);
extern unsigned long XWhitePixel(
    Display* ,
    int
);
extern unsigned long XAllPlanes(
    void
);
extern unsigned long XBlackPixelOfScreen(
    Screen*
);
extern unsigned long XWhitePixelOfScreen(
    Screen*
);
extern unsigned long XNextRequest(
    Display*
);
extern unsigned long XLastKnownRequestProcessed(
    Display*
);
extern char *XServerVendor(
    Display*
);
extern char *XDisplayString(
    Display*
);
extern Colormap XDefaultColormap(
    Display* ,
    int
);
extern Colormap XDefaultColormapOfScreen(
    Screen*
);
extern Display *XDisplayOfScreen(
    Screen*
);
extern Screen *XScreenOfDisplay(
    Display* ,
    int
);
extern Screen *XDefaultScreenOfDisplay(
    Display*
);
extern long XEventMaskOfScreen(
    Screen*
);

extern int XScreenNumberOfScreen(
    Screen*
);

typedef int (*XErrorHandler) (
    Display* ,
    XErrorEvent*
);

extern XErrorHandler XSetErrorHandler (
    XErrorHandler
);


typedef int (*XIOErrorHandler) (
    Display*
);

extern XIOErrorHandler XSetIOErrorHandler (
    XIOErrorHandler
);


extern XPixmapFormatValues *XListPixmapFormats(
    Display* ,
    int*
);
extern int *XListDepths(
    Display* ,
    int ,
    int*
);



extern int XReconfigureWMWindow(
    Display* ,
    Window ,
    int ,
    unsigned int ,
    XWindowChanges*
);

extern int XGetWMProtocols(
    Display* ,
    Window ,
    Atom** ,
    int*
);
extern int XSetWMProtocols(
    Display* ,
    Window ,
    Atom* ,
    int
);
extern int XIconifyWindow(
    Display* ,
    Window ,
    int
);
extern int XWithdrawWindow(
    Display* ,
    Window ,
    int
);
extern int XGetCommand(
    Display* ,
    Window ,
    char*** ,
    int*
);
extern int XGetWMColormapWindows(
    Display* ,
    Window ,
    Window** ,
    int*
);
extern int XSetWMColormapWindows(
    Display* ,
    Window ,
    Window* ,
    int
);
extern void XFreeStringList(
    char**
);
extern int XSetTransientForHint(
    Display* ,
    Window ,
    Window
);



extern int XActivateScreenSaver(
    Display*
);

extern int XAddHost(
    Display* ,
    XHostAddress*
);

extern int XAddHosts(
    Display* ,
    XHostAddress* ,
    int
);

extern int XAddToExtensionList(
    struct _XExtData** ,
    XExtData*
);

extern int XAddToSaveSet(
    Display* ,
    Window
);

extern int XAllocColor(
    Display* ,
    Colormap ,
    XColor*
);

extern int XAllocColorCells(
    Display* ,
    Colormap ,
    int ,
    unsigned long* ,
    unsigned int ,
    unsigned long* ,
    unsigned int
);

extern int XAllocColorPlanes(
    Display* ,
    Colormap ,
    int ,
    unsigned long* ,
    int ,
    int ,
    int ,
    int ,
    unsigned long* ,
    unsigned long* ,
    unsigned long*
);

extern int XAllocNamedColor(
    Display* ,
    Colormap ,
    const char* ,
    XColor* ,
    XColor*
);

extern int XAllowEvents(
    Display* ,
    int ,
    Time
);

extern int XAutoRepeatOff(
    Display*
);

extern int XAutoRepeatOn(
    Display*
);

extern int XBell(
    Display* ,
    int
);

extern int XBitmapBitOrder(
    Display*
);

extern int XBitmapPad(
    Display*
);

extern int XBitmapUnit(
    Display*
);

extern int XCellsOfScreen(
    Screen*
);

extern int XChangeActivePointerGrab(
    Display* ,
    unsigned int ,
    Cursor ,
    Time
);

extern int XChangeGC(
    Display* ,
    GC ,
    unsigned long ,
    XGCValues*
);

extern int XChangeKeyboardControl(
    Display* ,
    unsigned long ,
    XKeyboardControl*
);

extern int XChangeKeyboardMapping(
    Display* ,
    int ,
    int ,
    KeySym* ,
    int
);

extern int XChangePointerControl(
    Display* ,
    int ,
    int ,
    int ,
    int ,
    int
);

extern int XChangeProperty(
    Display* ,
    Window ,
    Atom ,
    Atom ,
    int ,
    int ,
    const unsigned char* ,
    int
);

extern int XChangeSaveSet(
    Display* ,
    Window ,
    int
);

extern int XChangeWindowAttributes(
    Display* ,
    Window ,
    unsigned long ,
    XSetWindowAttributes*
);

extern int XCheckIfEvent(
    Display* ,
    XEvent* ,
    int (*) (
        Display* ,
               XEvent* ,
               XPointer
             ) ,
    XPointer
);

extern int XCheckMaskEvent(
    Display* ,
    long ,
    XEvent*
);

extern int XCheckTypedEvent(
    Display* ,
    int ,
    XEvent*
);

extern int XCheckTypedWindowEvent(
    Display* ,
    Window ,
    int ,
    XEvent*
);

extern int XCheckWindowEvent(
    Display* ,
    Window ,
    long ,
    XEvent*
);

extern int XCirculateSubwindows(
    Display* ,
    Window ,
    int
);

extern int XCirculateSubwindowsDown(
    Display* ,
    Window
);

extern int XCirculateSubwindowsUp(
    Display* ,
    Window
);

extern int XClearArea(
    Display* ,
    Window ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    int
);

extern int XClearWindow(
    Display* ,
    Window
);

extern int XCloseDisplay(
    Display*
);

extern int XConfigureWindow(
    Display* ,
    Window ,
    unsigned int ,
    XWindowChanges*
);

extern int XConnectionNumber(
    Display*
);

extern int XConvertSelection(
    Display* ,
    Atom ,
    Atom ,
    Atom ,
    Window ,
    Time
);

extern int XCopyArea(
    Display* ,
    Drawable ,
    Drawable ,
    GC ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    int ,
    int
);

extern int XCopyGC(
    Display* ,
    GC ,
    unsigned long ,
    GC
);

extern int XCopyPlane(
    Display* ,
    Drawable ,
    Drawable ,
    GC ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    int ,
    int ,
    unsigned long
);

extern int XDefaultDepth(
    Display* ,
    int
);

extern int XDefaultDepthOfScreen(
    Screen*
);

extern int XDefaultScreen(
    Display*
);

extern int XDefineCursor(
    Display* ,
    Window ,
    Cursor
);

extern int XDeleteProperty(
    Display* ,
    Window ,
    Atom
);

extern int XDestroyWindow(
    Display* ,
    Window
);

extern int XDestroySubwindows(
    Display* ,
    Window
);

extern int XDoesBackingStore(
    Screen*
);

extern int XDoesSaveUnders(
    Screen*
);

extern int XDisableAccessControl(
    Display*
);


extern int XDisplayCells(
    Display* ,
    int
);

extern int XDisplayHeight(
    Display* ,
    int
);

extern int XDisplayHeightMM(
    Display* ,
    int
);

extern int XDisplayKeycodes(
    Display* ,
    int* ,
    int*
);

extern int XDisplayPlanes(
    Display* ,
    int
);

extern int XDisplayWidth(
    Display* ,
    int
);

extern int XDisplayWidthMM(
    Display* ,
    int
);

extern int XDrawArc(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    int ,
    int
);

extern int XDrawArcs(
    Display* ,
    Drawable ,
    GC ,
    XArc* ,
    int
);

extern int XDrawImageString(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    const char* ,
    int
);

extern int XDrawImageString16(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    const XChar2b* ,
    int
);

extern int XDrawLine(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    int ,
    int
);

extern int XDrawLines(
    Display* ,
    Drawable ,
    GC ,
    XPoint* ,
    int ,
    int
);

extern int XDrawPoint(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int
);

extern int XDrawPoints(
    Display* ,
    Drawable ,
    GC ,
    XPoint* ,
    int ,
    int
);

extern int XDrawRectangle(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    unsigned int ,
    unsigned int
);

extern int XDrawRectangles(
    Display* ,
    Drawable ,
    GC ,
    XRectangle* ,
    int
);

extern int XDrawSegments(
    Display* ,
    Drawable ,
    GC ,
    XSegment* ,
    int
);

extern int XDrawString(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    const char* ,
    int
);

extern int XDrawString16(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    const XChar2b* ,
    int
);

extern int XDrawText(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    XTextItem* ,
    int
);

extern int XDrawText16(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    XTextItem16* ,
    int
);

extern int XEnableAccessControl(
    Display*
);

extern int XEventsQueued(
    Display* ,
    int
);

extern int XFetchName(
    Display* ,
    Window ,
    char**
);

extern int XFillArc(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    int ,
    int
);

extern int XFillArcs(
    Display* ,
    Drawable ,
    GC ,
    XArc* ,
    int
);

extern int XFillPolygon(
    Display* ,
    Drawable ,
    GC ,
    XPoint* ,
    int ,
    int ,
    int
);

extern int XFillRectangle(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    unsigned int ,
    unsigned int
);

extern int XFillRectangles(
    Display* ,
    Drawable ,
    GC ,
    XRectangle* ,
    int
);

extern int XFlush(
    Display*
);

extern int XForceScreenSaver(
    Display* ,
    int
);

extern int XFree(
    void*
);

extern int XFreeColormap(
    Display* ,
    Colormap
);

extern int XFreeColors(
    Display* ,
    Colormap ,
    unsigned long* ,
    int ,
    unsigned long
);

extern int XFreeCursor(
    Display* ,
    Cursor
);

extern int XFreeExtensionList(
    char**
);

extern int XFreeFont(
    Display* ,
    XFontStruct*
);

extern int XFreeFontInfo(
    char** ,
    XFontStruct* ,
    int
);

extern int XFreeFontNames(
    char**
);

extern int XFreeFontPath(
    char**
);

extern int XFreeGC(
    Display* ,
    GC
);

extern int XFreeModifiermap(
    XModifierKeymap*
);

extern int XFreePixmap(
    Display* ,
    Pixmap
);

extern int XGeometry(
    Display* ,
    int ,
    const char* ,
    const char* ,
    unsigned int ,
    unsigned int ,
    unsigned int ,
    int ,
    int ,
    int* ,
    int* ,
    int* ,
    int*
);

extern int XGetErrorDatabaseText(
    Display* ,
    const char* ,
    const char* ,
    const char* ,
    char* ,
    int
);

extern int XGetErrorText(
    Display* ,
    int ,
    char* ,
    int
);

extern int XGetFontProperty(
    XFontStruct* ,
    Atom ,
    unsigned long*
);

extern int XGetGCValues(
    Display* ,
    GC ,
    unsigned long ,
    XGCValues*
);

extern int XGetGeometry(
    Display* ,
    Drawable ,
    Window* ,
    int* ,
    int* ,
    unsigned int* ,
    unsigned int* ,
    unsigned int* ,
    unsigned int*
);

extern int XGetIconName(
    Display* ,
    Window ,
    char**
);

extern int XGetInputFocus(
    Display* ,
    Window* ,
    int*
);

extern int XGetKeyboardControl(
    Display* ,
    XKeyboardState*
);

extern int XGetPointerControl(
    Display* ,
    int* ,
    int* ,
    int*
);

extern int XGetPointerMapping(
    Display* ,
    unsigned char* ,
    int
);

extern int XGetScreenSaver(
    Display* ,
    int* ,
    int* ,
    int* ,
    int*
);

extern int XGetTransientForHint(
    Display* ,
    Window ,
    Window*
);

extern int XGetWindowProperty(
    Display* ,
    Window ,
    Atom ,
    long ,
    long ,
    int ,
    Atom ,
    Atom* ,
    int* ,
    unsigned long* ,
    unsigned long* ,
    unsigned char**
);

extern int XGetWindowAttributes(
    Display* ,
    Window ,
    XWindowAttributes*
);

extern int XGrabButton(
    Display* ,
    unsigned int ,
    unsigned int ,
    Window ,
    int ,
    unsigned int ,
    int ,
    int ,
    Window ,
    Cursor
);

extern int XGrabKey(
    Display* ,
    int ,
    unsigned int ,
    Window ,
    int ,
    int ,
    int
);

extern int XGrabKeyboard(
    Display* ,
    Window ,
    int ,
    int ,
    int ,
    Time
);

extern int XGrabPointer(
    Display* ,
    Window ,
    int ,
    unsigned int ,
    int ,
    int ,
    Window ,
    Cursor ,
    Time
);

extern int XGrabServer(
    Display*
);

extern int XHeightMMOfScreen(
    Screen*
);

extern int XHeightOfScreen(
    Screen*
);

extern int XIfEvent(
    Display* ,
    XEvent* ,
    int (*) (
        Display* ,
               XEvent* ,
               XPointer
             ) ,
    XPointer
);

extern int XImageByteOrder(
    Display*
);

extern int XInstallColormap(
    Display* ,
    Colormap
);

extern KeyCode XKeysymToKeycode(
    Display* ,
    KeySym
);

extern int XKillClient(
    Display* ,
    XID
);

extern int XLookupColor(
    Display* ,
    Colormap ,
    const char* ,
    XColor* ,
    XColor*
);

extern int XLowerWindow(
    Display* ,
    Window
);

extern int XMapRaised(
    Display* ,
    Window
);

extern int XMapSubwindows(
    Display* ,
    Window
);

extern int XMapWindow(
    Display* ,
    Window
);

extern int XMaskEvent(
    Display* ,
    long ,
    XEvent*
);

extern int XMaxCmapsOfScreen(
    Screen*
);

extern int XMinCmapsOfScreen(
    Screen*
);

extern int XMoveResizeWindow(
    Display* ,
    Window ,
    int ,
    int ,
    unsigned int ,
    unsigned int
);

extern int XMoveWindow(
    Display* ,
    Window ,
    int ,
    int
);

extern int XNextEvent(
    Display* ,
    XEvent*
);

extern int XNoOp(
    Display*
);

extern int XParseColor(
    Display* ,
    Colormap ,
    const char* ,
    XColor*
);

extern int XParseGeometry(
    const char* ,
    int* ,
    int* ,
    unsigned int* ,
    unsigned int*
);

extern int XPeekEvent(
    Display* ,
    XEvent*
);

extern int XPeekIfEvent(
    Display* ,
    XEvent* ,
    int (*) (
        Display* ,
               XEvent* ,
               XPointer
             ) ,
    XPointer
);

extern int XPending(
    Display*
);

extern int XPlanesOfScreen(
    Screen*
);

extern int XProtocolRevision(
    Display*
);

extern int XProtocolVersion(
    Display*
);


extern int XPutBackEvent(
    Display* ,
    XEvent*
);

extern int XPutImage(
    Display* ,
    Drawable ,
    GC ,
    XImage* ,
    int ,
    int ,
    int ,
    int ,
    unsigned int ,
    unsigned int
);

extern int XQLength(
    Display*
);

extern int XQueryBestCursor(
    Display* ,
    Drawable ,
    unsigned int ,
    unsigned int ,
    unsigned int* ,
    unsigned int*
);

extern int XQueryBestSize(
    Display* ,
    int ,
    Drawable ,
    unsigned int ,
    unsigned int ,
    unsigned int* ,
    unsigned int*
);

extern int XQueryBestStipple(
    Display* ,
    Drawable ,
    unsigned int ,
    unsigned int ,
    unsigned int* ,
    unsigned int*
);

extern int XQueryBestTile(
    Display* ,
    Drawable ,
    unsigned int ,
    unsigned int ,
    unsigned int* ,
    unsigned int*
);

extern int XQueryColor(
    Display* ,
    Colormap ,
    XColor*
);

extern int XQueryColors(
    Display* ,
    Colormap ,
    XColor* ,
    int
);

extern int XQueryExtension(
    Display* ,
    const char* ,
    int* ,
    int* ,
    int*
);

extern int XQueryKeymap(
    Display* ,
    char [32]
);

extern int XQueryPointer(
    Display* ,
    Window ,
    Window* ,
    Window* ,
    int* ,
    int* ,
    int* ,
    int* ,
    unsigned int*
);

extern int XQueryTextExtents(
    Display* ,
    XID ,
    const char* ,
    int ,
    int* ,
    int* ,
    int* ,
    XCharStruct*
);

extern int XQueryTextExtents16(
    Display* ,
    XID ,
    const XChar2b* ,
    int ,
    int* ,
    int* ,
    int* ,
    XCharStruct*
);

extern int XQueryTree(
    Display* ,
    Window ,
    Window* ,
    Window* ,
    Window** ,
    unsigned int*
);

extern int XRaiseWindow(
    Display* ,
    Window
);

extern int XReadBitmapFile(
    Display* ,
    Drawable ,
    const char* ,
    unsigned int* ,
    unsigned int* ,
    Pixmap* ,
    int* ,
    int*
);

extern int XReadBitmapFileData(
    const char* ,
    unsigned int* ,
    unsigned int* ,
    unsigned char** ,
    int* ,
    int*
);

extern int XRebindKeysym(
    Display* ,
    KeySym ,
    KeySym* ,
    int ,
    const unsigned char* ,
    int
);

extern int XRecolorCursor(
    Display* ,
    Cursor ,
    XColor* ,
    XColor*
);

extern int XRefreshKeyboardMapping(
    XMappingEvent*
);

extern int XRemoveFromSaveSet(
    Display* ,
    Window
);

extern int XRemoveHost(
    Display* ,
    XHostAddress*
);

extern int XRemoveHosts(
    Display* ,
    XHostAddress* ,
    int
);

extern int XReparentWindow(
    Display* ,
    Window ,
    Window ,
    int ,
    int
);

extern int XResetScreenSaver(
    Display*
);

extern int XResizeWindow(
    Display* ,
    Window ,
    unsigned int ,
    unsigned int
);

extern int XRestackWindows(
    Display* ,
    Window* ,
    int
);

extern int XRotateBuffers(
    Display* ,
    int
);

extern int XRotateWindowProperties(
    Display* ,
    Window ,
    Atom* ,
    int ,
    int
);

extern int XScreenCount(
    Display*
);

extern int XSelectInput(
    Display* ,
    Window ,
    long
);

extern int XSendEvent(
    Display* ,
    Window ,
    int ,
    long ,
    XEvent*
);

extern int XSetAccessControl(
    Display* ,
    int
);

extern int XSetArcMode(
    Display* ,
    GC ,
    int
);

extern int XSetBackground(
    Display* ,
    GC ,
    unsigned long
);

extern int XSetClipMask(
    Display* ,
    GC ,
    Pixmap
);

extern int XSetClipOrigin(
    Display* ,
    GC ,
    int ,
    int
);

extern int XSetClipRectangles(
    Display* ,
    GC ,
    int ,
    int ,
    XRectangle* ,
    int ,
    int
);

extern int XSetCloseDownMode(
    Display* ,
    int
);

extern int XSetCommand(
    Display* ,
    Window ,
    char** ,
    int
);

extern int XSetDashes(
    Display* ,
    GC ,
    int ,
    const char* ,
    int
);

extern int XSetFillRule(
    Display* ,
    GC ,
    int
);

extern int XSetFillStyle(
    Display* ,
    GC ,
    int
);

extern int XSetFont(
    Display* ,
    GC ,
    Font
);

extern int XSetFontPath(
    Display* ,
    char** ,
    int
);

extern int XSetForeground(
    Display* ,
    GC ,
    unsigned long
);

extern int XSetFunction(
    Display* ,
    GC ,
    int
);

extern int XSetGraphicsExposures(
    Display* ,
    GC ,
    int
);

extern int XSetIconName(
    Display* ,
    Window ,
    const char*
);

extern int XSetInputFocus(
    Display* ,
    Window ,
    int ,
    Time
);

extern int XSetLineAttributes(
    Display* ,
    GC ,
    unsigned int ,
    int ,
    int ,
    int
);

extern int XSetModifierMapping(
    Display* ,
    XModifierKeymap*
);

extern int XSetPlaneMask(
    Display* ,
    GC ,
    unsigned long
);

extern int XSetPointerMapping(
    Display* ,
    const unsigned char* ,
    int
);

extern int XSetScreenSaver(
    Display* ,
    int ,
    int ,
    int ,
    int
);

extern int XSetSelectionOwner(
    Display* ,
    Atom ,
    Window ,
    Time
);

extern int XSetState(
    Display* ,
    GC ,
    unsigned long ,
    unsigned long ,
    int ,
    unsigned long
);

extern int XSetStipple(
    Display* ,
    GC ,
    Pixmap
);

extern int XSetSubwindowMode(
    Display* ,
    GC ,
    int
);

extern int XSetTSOrigin(
    Display* ,
    GC ,
    int ,
    int
);

extern int XSetTile(
    Display* ,
    GC ,
    Pixmap
);

extern int XSetWindowBackground(
    Display* ,
    Window ,
    unsigned long
);

extern int XSetWindowBackgroundPixmap(
    Display* ,
    Window ,
    Pixmap
);

extern int XSetWindowBorder(
    Display* ,
    Window ,
    unsigned long
);

extern int XSetWindowBorderPixmap(
    Display* ,
    Window ,
    Pixmap
);

extern int XSetWindowBorderWidth(
    Display* ,
    Window ,
    unsigned int
);

extern int XSetWindowColormap(
    Display* ,
    Window ,
    Colormap
);

extern int XStoreBuffer(
    Display* ,
    const char* ,
    int ,
    int
);

extern int XStoreBytes(
    Display* ,
    const char* ,
    int
);

extern int XStoreColor(
    Display* ,
    Colormap ,
    XColor*
);

extern int XStoreColors(
    Display* ,
    Colormap ,
    XColor* ,
    int
);

extern int XStoreName(
    Display* ,
    Window ,
    const char*
);

extern int XStoreNamedColor(
    Display* ,
    Colormap ,
    const char* ,
    unsigned long ,
    int
);

extern int XSync(
    Display* ,
    int
);

extern int XTextExtents(
    XFontStruct* ,
    const char* ,
    int ,
    int* ,
    int* ,
    int* ,
    XCharStruct*
);

extern int XTextExtents16(
    XFontStruct* ,
    const XChar2b* ,
    int ,
    int* ,
    int* ,
    int* ,
    XCharStruct*
);

extern int XTextWidth(
    XFontStruct* ,
    const char* ,
    int
);

extern int XTextWidth16(
    XFontStruct* ,
    const XChar2b* ,
    int
);

extern int XTranslateCoordinates(
    Display* ,
    Window ,
    Window ,
    int ,
    int ,
    int* ,
    int* ,
    Window*
);

extern int XUndefineCursor(
    Display* ,
    Window
);

extern int XUngrabButton(
    Display* ,
    unsigned int ,
    unsigned int ,
    Window
);

extern int XUngrabKey(
    Display* ,
    int ,
    unsigned int ,
    Window
);

extern int XUngrabKeyboard(
    Display* ,
    Time
);

extern int XUngrabPointer(
    Display* ,
    Time
);

extern int XUngrabServer(
    Display*
);

extern int XUninstallColormap(
    Display* ,
    Colormap
);

extern int XUnloadFont(
    Display* ,
    Font
);

extern int XUnmapSubwindows(
    Display* ,
    Window
);

extern int XUnmapWindow(
    Display* ,
    Window
);

extern int XVendorRelease(
    Display*
);

extern int XWarpPointer(
    Display* ,
    Window ,
    Window ,
    int ,
    int ,
    unsigned int ,
    unsigned int ,
    int ,
    int
);

extern int XWidthMMOfScreen(
    Screen*
);

extern int XWidthOfScreen(
    Screen*
);

extern int XWindowEvent(
    Display* ,
    Window ,
    long ,
    XEvent*
);

extern int XWriteBitmapFile(
    Display* ,
    const char* ,
    Pixmap ,
    unsigned int ,
    unsigned int ,
    int ,
    int
);

extern int XSupportsLocale (void);

extern char *XSetLocaleModifiers(
    const char*
);

extern XOM XOpenOM(
    Display* ,
    struct _XrmHashBucketRec* ,
    const char* ,
    const char*
);

extern int XCloseOM(
    XOM
);

extern char *XSetOMValues(
    XOM ,
    ...
) __attribute__ ((__sentinel__(0)));

extern char *XGetOMValues(
    XOM ,
    ...
) __attribute__ ((__sentinel__(0)));

extern Display *XDisplayOfOM(
    XOM
);

extern char *XLocaleOfOM(
    XOM
);

extern XOC XCreateOC(
    XOM ,
    ...
) __attribute__ ((__sentinel__(0)));

extern void XDestroyOC(
    XOC
);

extern XOM XOMOfOC(
    XOC
);

extern char *XSetOCValues(
    XOC ,
    ...
) __attribute__ ((__sentinel__(0)));

extern char *XGetOCValues(
    XOC ,
    ...
) __attribute__ ((__sentinel__(0)));

extern XFontSet XCreateFontSet(
    Display* ,
    const char* ,
    char*** ,
    int* ,
    char**
);

extern void XFreeFontSet(
    Display* ,
    XFontSet
);

extern int XFontsOfFontSet(
    XFontSet ,
    XFontStruct*** ,
    char***
);

extern char *XBaseFontNameListOfFontSet(
    XFontSet
);

extern char *XLocaleOfFontSet(
    XFontSet
);

extern int XContextDependentDrawing(
    XFontSet
);

extern int XDirectionalDependentDrawing(
    XFontSet
);

extern int XContextualDrawing(
    XFontSet
);

extern XFontSetExtents *XExtentsOfFontSet(
    XFontSet
);

extern int XmbTextEscapement(
    XFontSet ,
    const char* ,
    int
);

extern int XwcTextEscapement(
    XFontSet ,
    const wchar_t* ,
    int
);

extern int Xutf8TextEscapement(
    XFontSet ,
    const char* ,
    int
);

extern int XmbTextExtents(
    XFontSet ,
    const char* ,
    int ,
    XRectangle* ,
    XRectangle*
);

extern int XwcTextExtents(
    XFontSet ,
    const wchar_t* ,
    int ,
    XRectangle* ,
    XRectangle*
);

extern int Xutf8TextExtents(
    XFontSet ,
    const char* ,
    int ,
    XRectangle* ,
    XRectangle*
);

extern int XmbTextPerCharExtents(
    XFontSet ,
    const char* ,
    int ,
    XRectangle* ,
    XRectangle* ,
    int ,
    int* ,
    XRectangle* ,
    XRectangle*
);

extern int XwcTextPerCharExtents(
    XFontSet ,
    const wchar_t* ,
    int ,
    XRectangle* ,
    XRectangle* ,
    int ,
    int* ,
    XRectangle* ,
    XRectangle*
);

extern int Xutf8TextPerCharExtents(
    XFontSet ,
    const char* ,
    int ,
    XRectangle* ,
    XRectangle* ,
    int ,
    int* ,
    XRectangle* ,
    XRectangle*
);

extern void XmbDrawText(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    XmbTextItem* ,
    int
);

extern void XwcDrawText(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    XwcTextItem* ,
    int
);

extern void Xutf8DrawText(
    Display* ,
    Drawable ,
    GC ,
    int ,
    int ,
    XmbTextItem* ,
    int
);

extern void XmbDrawString(
    Display* ,
    Drawable ,
    XFontSet ,
    GC ,
    int ,
    int ,
    const char* ,
    int
);

extern void XwcDrawString(
    Display* ,
    Drawable ,
    XFontSet ,
    GC ,
    int ,
    int ,
    const wchar_t* ,
    int
);

extern void Xutf8DrawString(
    Display* ,
    Drawable ,
    XFontSet ,
    GC ,
    int ,
    int ,
    const char* ,
    int
);

extern void XmbDrawImageString(
    Display* ,
    Drawable ,
    XFontSet ,
    GC ,
    int ,
    int ,
    const char* ,
    int
);

extern void XwcDrawImageString(
    Display* ,
    Drawable ,
    XFontSet ,
    GC ,
    int ,
    int ,
    const wchar_t* ,
    int
);

extern void Xutf8DrawImageString(
    Display* ,
    Drawable ,
    XFontSet ,
    GC ,
    int ,
    int ,
    const char* ,
    int
);

extern XIM XOpenIM(
    Display* ,
    struct _XrmHashBucketRec* ,
    char* ,
    char*
);

extern int XCloseIM(
    XIM
);

extern char *XGetIMValues(
    XIM , ...
) __attribute__ ((__sentinel__(0)));

extern char *XSetIMValues(
    XIM , ...
) __attribute__ ((__sentinel__(0)));

extern Display *XDisplayOfIM(
    XIM
);

extern char *XLocaleOfIM(
    XIM
);

extern XIC XCreateIC(
    XIM , ...
) __attribute__ ((__sentinel__(0)));

extern void XDestroyIC(
    XIC
);

extern void XSetICFocus(
    XIC
);

extern void XUnsetICFocus(
    XIC
);

extern wchar_t *XwcResetIC(
    XIC
);

extern char *XmbResetIC(
    XIC
);

extern char *Xutf8ResetIC(
    XIC
);

extern char *XSetICValues(
    XIC , ...
) __attribute__ ((__sentinel__(0)));

extern char *XGetICValues(
    XIC , ...
) __attribute__ ((__sentinel__(0)));

extern XIM XIMOfIC(
    XIC
);

extern int XFilterEvent(
    XEvent* ,
    Window
);

extern int XmbLookupString(
    XIC ,
    XKeyPressedEvent* ,
    char* ,
    int ,
    KeySym* ,
    int*
);

extern int XwcLookupString(
    XIC ,
    XKeyPressedEvent* ,
    wchar_t* ,
    int ,
    KeySym* ,
    int*
);

extern int Xutf8LookupString(
    XIC ,
    XKeyPressedEvent* ,
    char* ,
    int ,
    KeySym* ,
    int*
);

extern XVaNestedList XVaCreateNestedList(
    int , ...
) __attribute__ ((__sentinel__(0)));



extern int XRegisterIMInstantiateCallback(
    Display* ,
    struct _XrmHashBucketRec* ,
    char* ,
    char* ,
    XIDProc ,
    XPointer
);

extern int XUnregisterIMInstantiateCallback(
    Display* ,
    struct _XrmHashBucketRec* ,
    char* ,
    char* ,
    XIDProc ,
    XPointer
);

typedef void (*XConnectionWatchProc)(
    Display* ,
    XPointer ,
    int ,
    int ,
    XPointer*
);


extern int XInternalConnectionNumbers(
    Display* ,
    int** ,
    int*
);

extern void XProcessInternalConnection(
    Display* ,
    int
);

extern int XAddConnectionWatch(
    Display* ,
    XConnectionWatchProc ,
    XPointer
);

extern void XRemoveConnectionWatch(
    Display* ,
    XConnectionWatchProc ,
    XPointer
);

extern void XSetAuthorization(
    char * ,
    int ,
    char * ,
    int
);

extern int _Xmbtowc(
    wchar_t * ,
    char * ,
    int
);

extern int _Xwctomb(
    char * ,
    wchar_t
);

extern int XGetEventData(
    Display* ,
    XGenericEventCookie*
);

extern void XFreeEventData(
    Display* ,
    XGenericEventCookie*
);


#pragma clang diagnostic pop
# 54 "/usr/include/X11/Intrinsic.h" 2 3 4
# 1 "/usr/include/X11/Xutil.h" 1 3 4
# 54 "/usr/include/X11/Xutil.h" 3 4
# 1 "/usr/include/X11/keysym.h" 1 3 4
# 73 "/usr/include/X11/keysym.h" 3 4
# 1 "/usr/include/X11/keysymdef.h" 1 3 4
# 74 "/usr/include/X11/keysym.h" 2 3 4
# 55 "/usr/include/X11/Xutil.h" 2 3 4





#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wpadded"
# 81 "/usr/include/X11/Xutil.h" 3 4
typedef struct {
     long flags;
 int x, y;
 int width, height;
 int min_width, min_height;
 int max_width, max_height;
     int width_inc, height_inc;
 struct {
  int x;
  int y;
 } min_aspect, max_aspect;
 int base_width, base_height;
 int win_gravity;
} XSizeHints;
# 119 "/usr/include/X11/Xutil.h" 3 4
typedef struct {
 long flags;
 int input;

 int initial_state;
 Pixmap icon_pixmap;
 Window icon_window;
 int icon_x, icon_y;
 Pixmap icon_mask;
 XID window_group;

} XWMHints;
# 163 "/usr/include/X11/Xutil.h" 3 4
typedef struct {
    unsigned char *value;
    Atom encoding;
    int format;
    unsigned long nitems;
} XTextProperty;





typedef enum {
    XStringStyle,
    XCompoundTextStyle,
    XTextStyle,
    XStdICCTextStyle,

    XUTF8StringStyle
} XICCEncodingStyle;

typedef struct {
 int min_width, min_height;
 int max_width, max_height;
 int width_inc, height_inc;
} XIconSize;

typedef struct {
 char *res_name;
 char *res_class;
} XClassHint;
# 231 "/usr/include/X11/Xutil.h" 3 4
typedef struct _XComposeStatus {
    XPointer compose_ptr;
    int chars_matched;
} XComposeStatus;
# 273 "/usr/include/X11/Xutil.h" 3 4
typedef struct _XRegion *Region;
# 287 "/usr/include/X11/Xutil.h" 3 4
typedef struct {
  Visual *visual;
  VisualID visualid;
  int screen;
  int depth;



  int class;

  unsigned long red_mask;
  unsigned long green_mask;
  unsigned long blue_mask;
  int colormap_size;
  int bits_per_rgb;
} XVisualInfo;
# 320 "/usr/include/X11/Xutil.h" 3 4
typedef struct {
 Colormap colormap;
 unsigned long red_max;
 unsigned long red_mult;
 unsigned long green_max;
 unsigned long green_mult;
 unsigned long blue_max;
 unsigned long blue_mult;
 unsigned long base_pixel;
 VisualID visualid;
 XID killid;
} XStandardColormap;
# 357 "/usr/include/X11/Xutil.h" 3 4
typedef int XContext;
# 366 "/usr/include/X11/Xutil.h" 3 4
extern XClassHint *XAllocClassHint (
    void
);

extern XIconSize *XAllocIconSize (
    void
);

extern XSizeHints *XAllocSizeHints (
    void
);

extern XStandardColormap *XAllocStandardColormap (
    void
);

extern XWMHints *XAllocWMHints (
    void
);

extern int XClipBox(
    Region ,
    XRectangle*
);

extern Region XCreateRegion(
    void
);

extern const char *XDefaultString (void);

extern int XDeleteContext(
    Display* ,
    XID ,
    XContext
);

extern int XDestroyRegion(
    Region
);

extern int XEmptyRegion(
    Region
);

extern int XEqualRegion(
    Region ,
    Region
);

extern int XFindContext(
    Display* ,
    XID ,
    XContext ,
    XPointer*
);

extern int XGetClassHint(
    Display* ,
    Window ,
    XClassHint*
);

extern int XGetIconSizes(
    Display* ,
    Window ,
    XIconSize** ,
    int*
);

extern int XGetNormalHints(
    Display* ,
    Window ,
    XSizeHints*
);

extern int XGetRGBColormaps(
    Display* ,
    Window ,
    XStandardColormap** ,
    int* ,
    Atom
);

extern int XGetSizeHints(
    Display* ,
    Window ,
    XSizeHints* ,
    Atom
);

extern int XGetStandardColormap(
    Display* ,
    Window ,
    XStandardColormap* ,
    Atom
);

extern int XGetTextProperty(
    Display* ,
    Window ,
    XTextProperty* ,
    Atom
);

extern XVisualInfo *XGetVisualInfo(
    Display* ,
    long ,
    XVisualInfo* ,
    int*
);

extern int XGetWMClientMachine(
    Display* ,
    Window ,
    XTextProperty*
);

extern XWMHints *XGetWMHints(
    Display* ,
    Window
);

extern int XGetWMIconName(
    Display* ,
    Window ,
    XTextProperty*
);

extern int XGetWMName(
    Display* ,
    Window ,
    XTextProperty*
);

extern int XGetWMNormalHints(
    Display* ,
    Window ,
    XSizeHints* ,
    long*
);

extern int XGetWMSizeHints(
    Display* ,
    Window ,
    XSizeHints* ,
    long* ,
    Atom
);

extern int XGetZoomHints(
    Display* ,
    Window ,
    XSizeHints*
);

extern int XIntersectRegion(
    Region ,
    Region ,
    Region
);

extern void XConvertCase(
    KeySym ,
    KeySym* ,
    KeySym*
);

extern int XLookupString(
    XKeyEvent* ,
    char* ,
    int ,
    KeySym* ,
    XComposeStatus*
);

extern int XMatchVisualInfo(
    Display* ,
    int ,
    int ,
    int ,
    XVisualInfo*
);

extern int XOffsetRegion(
    Region ,
    int ,
    int
);

extern int XPointInRegion(
    Region ,
    int ,
    int
);

extern Region XPolygonRegion(
    XPoint* ,
    int ,
    int
);

extern int XRectInRegion(
    Region ,
    int ,
    int ,
    unsigned int ,
    unsigned int
);

extern int XSaveContext(
    Display* ,
    XID ,
    XContext ,
    const char*
);

extern int XSetClassHint(
    Display* ,
    Window ,
    XClassHint*
);

extern int XSetIconSizes(
    Display* ,
    Window ,
    XIconSize* ,
    int
);

extern int XSetNormalHints(
    Display* ,
    Window ,
    XSizeHints*
);

extern void XSetRGBColormaps(
    Display* ,
    Window ,
    XStandardColormap* ,
    int ,
    Atom
);

extern int XSetSizeHints(
    Display* ,
    Window ,
    XSizeHints* ,
    Atom
);

extern int XSetStandardProperties(
    Display* ,
    Window ,
    const char* ,
    const char* ,
    Pixmap ,
    char** ,
    int ,
    XSizeHints*
);

extern void XSetTextProperty(
    Display* ,
    Window ,
    XTextProperty* ,
    Atom
);

extern void XSetWMClientMachine(
    Display* ,
    Window ,
    XTextProperty*
);

extern int XSetWMHints(
    Display* ,
    Window ,
    XWMHints*
);

extern void XSetWMIconName(
    Display* ,
    Window ,
    XTextProperty*
);

extern void XSetWMName(
    Display* ,
    Window ,
    XTextProperty*
);

extern void XSetWMNormalHints(
    Display* ,
    Window ,
    XSizeHints*
);

extern void XSetWMProperties(
    Display* ,
    Window ,
    XTextProperty* ,
    XTextProperty* ,
    char** ,
    int ,
    XSizeHints* ,
    XWMHints* ,
    XClassHint*
);

extern void XmbSetWMProperties(
    Display* ,
    Window ,
    const char* ,
    const char* ,
    char** ,
    int ,
    XSizeHints* ,
    XWMHints* ,
    XClassHint*
);

extern void Xutf8SetWMProperties(
    Display* ,
    Window ,
    const char* ,
    const char* ,
    char** ,
    int ,
    XSizeHints* ,
    XWMHints* ,
    XClassHint*
);

extern void XSetWMSizeHints(
    Display* ,
    Window ,
    XSizeHints* ,
    Atom
);

extern int XSetRegion(
    Display* ,
    GC ,
    Region
);

extern void XSetStandardColormap(
    Display* ,
    Window ,
    XStandardColormap* ,
    Atom
);

extern int XSetZoomHints(
    Display* ,
    Window ,
    XSizeHints*
);

extern int XShrinkRegion(
    Region ,
    int ,
    int
);

extern int XStringListToTextProperty(
    char** ,
    int ,
    XTextProperty*
);

extern int XSubtractRegion(
    Region ,
    Region ,
    Region
);

extern int XmbTextListToTextProperty(
    Display* display,
    char** list,
    int count,
    XICCEncodingStyle style,
    XTextProperty* text_prop_return
);

extern int XwcTextListToTextProperty(
    Display* display,
    wchar_t** list,
    int count,
    XICCEncodingStyle style,
    XTextProperty* text_prop_return
);

extern int Xutf8TextListToTextProperty(
    Display* display,
    char** list,
    int count,
    XICCEncodingStyle style,
    XTextProperty* text_prop_return
);

extern void XwcFreeStringList(
    wchar_t** list
);

extern int XTextPropertyToStringList(
    XTextProperty* ,
    char*** ,
    int*
);

extern int XmbTextPropertyToTextList(
    Display* display,
    const XTextProperty* text_prop,
    char*** list_return,
    int* count_return
);

extern int XwcTextPropertyToTextList(
    Display* display,
    const XTextProperty* text_prop,
    wchar_t*** list_return,
    int* count_return
);

extern int Xutf8TextPropertyToTextList(
    Display* display,
    const XTextProperty* text_prop,
    char*** list_return,
    int* count_return
);

extern int XUnionRectWithRegion(
    XRectangle* ,
    Region ,
    Region
);

extern int XUnionRegion(
    Region ,
    Region ,
    Region
);

extern int XWMGeometry(
    Display* ,
    int ,
    const char* ,
    const char* ,
    unsigned int ,
    XSizeHints* ,
    int* ,
    int* ,
    int* ,
    int* ,
    int*
);

extern int XXorRegion(
    Region ,
    Region ,
    Region
);


#pragma clang diagnostic pop
# 55 "/usr/include/X11/Intrinsic.h" 2 3 4
# 1 "/usr/include/X11/Xresource.h" 1 3 4
# 74 "/usr/include/X11/Xresource.h" 3 4
extern char *Xpermalloc(
    unsigned int
);







typedef int XrmQuark, *XrmQuarkList;


typedef char *XrmString;



extern XrmQuark XrmStringToQuark(
    const char*
);

extern XrmQuark XrmPermStringToQuark(
    const char*
);


extern XrmString XrmQuarkToString(
    XrmQuark
);

extern XrmQuark XrmUniqueQuark(
    void
);
# 117 "/usr/include/X11/Xresource.h" 3 4
typedef enum {XrmBindTightly, XrmBindLoosely} XrmBinding, *XrmBindingList;

extern void XrmStringToQuarkList(
    const char* ,
    XrmQuarkList
);

extern void XrmStringToBindingQuarkList(
    const char* ,
    XrmBindingList ,
    XrmQuarkList
);







typedef XrmQuark XrmName;
typedef XrmQuarkList XrmNameList;




typedef XrmQuark XrmClass;
typedef XrmQuarkList XrmClassList;
# 156 "/usr/include/X11/Xresource.h" 3 4
typedef XrmQuark XrmRepresentation;



typedef struct {
    unsigned int size;
    XPointer addr;
} XrmValue, *XrmValuePtr;
# 172 "/usr/include/X11/Xresource.h" 3 4
typedef struct _XrmHashBucketRec *XrmHashBucket;
typedef XrmHashBucket *XrmHashTable;
typedef XrmHashTable XrmSearchList[];
typedef struct _XrmHashBucketRec *XrmDatabase;


extern void XrmDestroyDatabase(
    XrmDatabase
);

extern void XrmQPutResource(
    XrmDatabase* ,
    XrmBindingList ,
    XrmQuarkList ,
    XrmRepresentation ,
    XrmValue*
);

extern void XrmPutResource(
    XrmDatabase* ,
    const char* ,
    const char* ,
    XrmValue*
);

extern void XrmQPutStringResource(
    XrmDatabase* ,
    XrmBindingList ,
    XrmQuarkList ,
    const char*
);

extern void XrmPutStringResource(
    XrmDatabase* ,
    const char* ,
    const char*
);

extern void XrmPutLineResource(
    XrmDatabase* ,
    const char*
);

extern int XrmQGetResource(
    XrmDatabase ,
    XrmNameList ,
    XrmClassList ,
    XrmRepresentation* ,
    XrmValue*
);

extern int XrmGetResource(
    XrmDatabase ,
    const char* ,
    const char* ,
    char** ,
    XrmValue*
);

extern int XrmQGetSearchList(
    XrmDatabase ,
    XrmNameList ,
    XrmClassList ,
    XrmSearchList ,
    int
);

extern int XrmQGetSearchResource(
    XrmSearchList ,
    XrmName ,
    XrmClass ,
    XrmRepresentation* ,
    XrmValue*
);
# 255 "/usr/include/X11/Xresource.h" 3 4
extern void XrmSetDatabase(
    Display* ,
    XrmDatabase
);

extern XrmDatabase XrmGetDatabase(
    Display*
);



extern XrmDatabase XrmGetFileDatabase(
    const char*
);

extern int XrmCombineFileDatabase(
    const char* ,
    XrmDatabase* ,
    int
);

extern XrmDatabase XrmGetStringDatabase(
    const char*
);

extern void XrmPutFileDatabase(
    XrmDatabase ,
    const char*
);

extern void XrmMergeDatabases(
    XrmDatabase ,
    XrmDatabase*
);

extern void XrmCombineDatabase(
    XrmDatabase ,
    XrmDatabase* ,
    int
);




extern int XrmEnumerateDatabase(
    XrmDatabase ,
    XrmNameList ,
    XrmClassList ,
    int ,
    int (*)(
      XrmDatabase* ,
      XrmBindingList ,
      XrmQuarkList ,
      XrmRepresentation* ,
      XrmValue* ,
      XPointer
      ) ,
    XPointer
);

extern const char *XrmLocaleOfDatabase(
    XrmDatabase
);
# 326 "/usr/include/X11/Xresource.h" 3 4
typedef enum {
    XrmoptionNoArg,
    XrmoptionIsArg,
    XrmoptionStickyArg,
    XrmoptionSepArg,
    XrmoptionResArg,
    XrmoptionSkipArg,
    XrmoptionSkipLine,
    XrmoptionSkipNArgs

} XrmOptionKind;

typedef struct {
    char *option;
    char *specifier;
    XrmOptionKind argKind;
    XPointer value;
} XrmOptionDescRec, *XrmOptionDescList;


extern void XrmParseCommand(
    XrmDatabase* ,
    XrmOptionDescList ,
    int ,
    const char* ,
    int* ,
    char**
);
# 56 "/usr/include/X11/Intrinsic.h" 2 3 4
# 66 "/usr/include/X11/Intrinsic.h" 3 4
typedef char *String;
# 90 "/usr/include/X11/Intrinsic.h" 3 4
# 1 "/llvm-project/build/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 91 "/usr/include/X11/Intrinsic.h" 2 3 4
# 107 "/usr/include/X11/Intrinsic.h" 3 4
typedef struct _WidgetRec *Widget;
typedef Widget *WidgetList;
typedef struct _WidgetClassRec *WidgetClass;
typedef struct _CompositeRec *CompositeWidget;
typedef struct _XtActionsRec *XtActionList;
typedef struct _XtEventRec *XtEventTable;

typedef struct _XtAppStruct *XtAppContext;
typedef unsigned long XtValueMask;
typedef unsigned long XtIntervalId;
typedef unsigned long XtInputId;
typedef unsigned long XtWorkProcId;
typedef unsigned long XtSignalId;
typedef unsigned int XtGeometryMask;
typedef unsigned long XtGCMask;
typedef unsigned long Pixel;
typedef int XtCacheType;
# 150 "/usr/include/X11/Intrinsic.h" 3 4
typedef char Boolean;
typedef long XtArgVal;
typedef unsigned char XtEnum;

typedef unsigned int Cardinal;
typedef unsigned short Dimension;
typedef short Position;

typedef void* XtPointer;



typedef XtPointer Opaque;


# 1 "/usr/include/X11/Core.h" 1 3 4
# 53 "/usr/include/X11/Core.h" 3 4
typedef struct _WidgetClassRec *CoreWidgetClass;
typedef struct _WidgetRec *CoreWidget;
extern WidgetClass coreWidgetClass;


extern WidgetClass widgetClass;
# 165 "/usr/include/X11/Intrinsic.h" 2 3 4
# 1 "/usr/include/X11/Composite.h" 1 3 4
# 51 "/usr/include/X11/Composite.h" 3 4
typedef struct _CompositeClassRec *CompositeWidgetClass;

typedef Cardinal (*XtOrderProc)(
    Widget
);



extern void XtManageChildren(
    WidgetList ,
    Cardinal
);

extern void XtManageChild(
    Widget
);

extern void XtUnmanageChildren(
    WidgetList ,
    Cardinal
);

extern void XtUnmanageChild(
    Widget
);

typedef void (*XtDoChangeProc)(
    Widget ,
    WidgetList ,
    Cardinal * ,
    WidgetList ,
    Cardinal * ,
    XtPointer
);

extern void XtChangeManagedSet(
    WidgetList ,
    Cardinal ,
    XtDoChangeProc ,
    XtPointer ,
    WidgetList ,
    Cardinal
);




extern WidgetClass compositeWidgetClass;
# 166 "/usr/include/X11/Intrinsic.h" 2 3 4
# 1 "/usr/include/X11/Constraint.h" 1 3 4
# 53 "/usr/include/X11/Constraint.h" 3 4
typedef struct _ConstraintClassRec *ConstraintWidgetClass;


extern WidgetClass constraintWidgetClass;
# 167 "/usr/include/X11/Intrinsic.h" 2 3 4
# 1 "/usr/include/X11/Object.h" 1 3 4
# 53 "/usr/include/X11/Object.h" 3 4
typedef struct _ObjectRec *Object;
typedef struct _ObjectClassRec *ObjectClass;


extern WidgetClass objectClass;
# 168 "/usr/include/X11/Intrinsic.h" 2 3 4
# 1 "/usr/include/X11/RectObj.h" 1 3 4
# 53 "/usr/include/X11/RectObj.h" 3 4
typedef struct _RectObjRec *RectObj;
typedef struct _RectObjClassRec *RectObjClass;


extern WidgetClass rectObjClass;
# 169 "/usr/include/X11/Intrinsic.h" 2 3 4

typedef struct _TranslationData *XtTranslations;
typedef struct _TranslationData *XtAccelerators;
typedef unsigned int Modifiers;

typedef void (*XtActionProc)(
    Widget ,
    XEvent* ,
    String* ,
    Cardinal*
);

typedef XtActionProc* XtBoundActions;

typedef struct _XtActionsRec{
    String string;
    XtActionProc proc;
} XtActionsRec;

typedef enum {


    XtAddress,
    XtBaseOffset,
    XtImmediate,
    XtResourceString,
    XtResourceQuark,
    XtWidgetBaseOffset,
    XtProcedureArg
} XtAddressMode;

typedef struct {
    XtAddressMode address_mode;
    XtPointer address_id;
    Cardinal size;
} XtConvertArgRec, *XtConvertArgList;

typedef void (*XtConvertArgProc)(
    Widget ,
    Cardinal* ,
    XrmValue*
);

typedef struct {
    XtGeometryMask request_mode;
    Position x, y;
    Dimension width, height, border_width;
    Widget sibling;
    int stack_mode;
} XtWidgetGeometry;







typedef void (*XtConverter)(
    XrmValue* ,
    Cardinal* ,
    XrmValue* ,
    XrmValue*
);

typedef Boolean (*XtTypeConverter)(
    Display* ,
    XrmValue* ,
    Cardinal* ,
    XrmValue* ,
    XrmValue* ,
    XtPointer*
);

typedef void (*XtDestructor)(
    XtAppContext ,
    XrmValue* ,
    XtPointer ,
    XrmValue* ,
    Cardinal*
);

typedef Opaque XtCacheRef;

typedef Opaque XtActionHookId;

typedef void (*XtActionHookProc)(
    Widget ,
    XtPointer ,
    String ,
    XEvent* ,
    String* ,
    Cardinal*
);

typedef unsigned long XtBlockHookId;

typedef void (*XtBlockHookProc)(
    XtPointer
);

typedef void (*XtKeyProc)(
    Display* ,
    KeyCode ,
    Modifiers ,
    Modifiers* ,
    KeySym*
);

typedef void (*XtCaseProc)(
    Display* ,
    KeySym ,
    KeySym* ,
    KeySym*
);

typedef void (*XtEventHandler)(
    Widget ,
    XtPointer ,
    XEvent* ,
    Boolean*
);
typedef unsigned long EventMask;

typedef enum {XtListHead, XtListTail } XtListPosition;

typedef unsigned long XtInputMask;





typedef void (*XtTimerCallbackProc)(
    XtPointer ,
    XtIntervalId*
);

typedef void (*XtInputCallbackProc)(
    XtPointer ,
    int* ,
    XtInputId*
);

typedef void (*XtSignalCallbackProc)(
    XtPointer ,
    XtSignalId*
);

typedef struct {
    String name;
    XtArgVal value;
} Arg, *ArgList;

typedef XtPointer XtVarArgsList;

typedef void (*XtCallbackProc)(
    Widget ,
    XtPointer ,
    XtPointer
);

typedef struct _XtCallbackRec {
    XtCallbackProc callback;
    XtPointer closure;
} XtCallbackRec, *XtCallbackList;

typedef enum {
 XtCallbackNoList,
 XtCallbackHasNone,
 XtCallbackHasSome
} XtCallbackStatus;

typedef enum {
    XtGeometryYes,
    XtGeometryNo,
    XtGeometryAlmost,
    XtGeometryDone
} XtGeometryResult;

typedef enum {XtGrabNone, XtGrabNonexclusive, XtGrabExclusive} XtGrabKind;

typedef struct {
    Widget shell_widget;
    Widget enable_widget;
} XtPopdownIDRec, *XtPopdownID;

typedef struct _XtResource {
    String resource_name;
    String resource_class;
    String resource_type;
    Cardinal resource_size;
    Cardinal resource_offset;
    String default_type;
    XtPointer default_addr;
} XtResource, *XtResourceList;

typedef void (*XtResourceDefaultProc)(
    Widget ,
    int ,
    XrmValue*
);

typedef String (*XtLanguageProc)(
    Display* ,
    String ,
    XtPointer
);

typedef void (*XtErrorMsgHandler)(
    String ,
    String ,
    String ,
    String ,
    String* ,
    Cardinal*
);

typedef void (*XtErrorHandler)(
  String
);

typedef void (*XtCreatePopupChildProc)(
    Widget
);

typedef Boolean (*XtWorkProc)(
    XtPointer
);

typedef struct {
    char match;
    String substitution;
} SubstitutionRec, *Substitution;

typedef Boolean (*XtFilePredicate)(
   String
);

typedef XtPointer XtRequestId;

typedef Boolean (*XtConvertSelectionProc)(
    Widget ,
    Atom* ,
    Atom* ,
    Atom* ,
    XtPointer* ,
    unsigned long* ,
    int*
);

typedef void (*XtLoseSelectionProc)(
    Widget ,
    Atom*
);

typedef void (*XtSelectionDoneProc)(
    Widget ,
    Atom* ,
    Atom*
);

typedef void (*XtSelectionCallbackProc)(
    Widget ,
    XtPointer ,
    Atom* ,
    Atom* ,
    XtPointer ,
    unsigned long* ,
    int*
);

typedef void (*XtLoseSelectionIncrProc)(
    Widget ,
    Atom* ,
    XtPointer
);

typedef void (*XtSelectionDoneIncrProc)(
    Widget ,
    Atom* ,
    Atom* ,
    XtRequestId* ,
    XtPointer
);

typedef Boolean (*XtConvertSelectionIncrProc)(
    Widget ,
    Atom* ,
    Atom* ,
    Atom* ,
    XtPointer* ,
    unsigned long* ,
    int* ,
    unsigned long* ,
    XtPointer ,
    XtRequestId*
);

typedef void (*XtCancelConvertSelectionProc)(
    Widget ,
    Atom* ,
    Atom* ,
    XtRequestId* ,
    XtPointer
);

typedef Boolean (*XtEventDispatchProc)(
    XEvent*
);

typedef void (*XtExtensionSelectProc)(
    Widget ,
    int* ,
    XtPointer* ,
    int ,
    XtPointer
);
# 494 "/usr/include/X11/Intrinsic.h" 3 4
extern Boolean XtConvertAndStore(
    Widget ,
    const char* ,
    XrmValue* ,
    const char* ,
    XrmValue*
);

extern Boolean XtCallConverter(
    Display* ,
    XtTypeConverter ,
    XrmValuePtr ,
    Cardinal ,
    XrmValuePtr ,
    XrmValue* ,
    XtCacheRef*
);

extern Boolean XtDispatchEvent(
    XEvent*
);

extern Boolean XtCallAcceptFocus(
    Widget ,
    Time*
);

extern Boolean XtPeekEvent(
    XEvent*
);

extern Boolean XtAppPeekEvent(
    XtAppContext ,
    XEvent*
);

extern Boolean XtIsSubclass(
    Widget ,
    WidgetClass
);

extern Boolean XtIsObject(
    Widget
);

extern Boolean _XtCheckSubclassFlag(
    Widget ,
    XtEnum
);

extern Boolean _XtIsSubclassOf(
    Widget ,
    WidgetClass ,
    WidgetClass ,
    XtEnum
);

extern Boolean XtIsManaged(
    Widget
);

extern Boolean XtIsRealized(
    Widget
);

extern Boolean XtIsSensitive(
    Widget
);

extern Boolean XtOwnSelection(
    Widget ,
    Atom ,
    Time ,
    XtConvertSelectionProc ,
    XtLoseSelectionProc ,
    XtSelectionDoneProc
);

extern Boolean XtOwnSelectionIncremental(
    Widget ,
    Atom ,
    Time ,
    XtConvertSelectionIncrProc ,
    XtLoseSelectionIncrProc ,
    XtSelectionDoneIncrProc ,
    XtCancelConvertSelectionProc ,
    XtPointer
);

extern XtGeometryResult XtMakeResizeRequest(
    Widget ,
    Dimension ,
    Dimension ,
    Dimension* ,
    Dimension*
);

extern void XtTranslateCoords(
    Widget ,
    Position ,
    Position ,
    Position* ,
    Position*
);

extern KeySym* XtGetKeysymTable(
    Display* ,
    KeyCode* ,
    int*
);

extern void XtKeysymToKeycodeList(
    Display* ,
    KeySym ,
    KeyCode** ,
    Cardinal*
);

extern void XtStringConversionWarning(
    const char* ,
    const char*
);

extern void XtDisplayStringConversionWarning(
    Display* ,
    const char* ,
    const char*
);

extern XtConvertArgRec const colorConvertArgs[];
extern XtConvertArgRec const screenConvertArg[];

extern void XtAppAddConverter(
    XtAppContext ,
    const char* ,
    const char* ,
    XtConverter ,
    XtConvertArgList ,
    Cardinal
);

extern void XtAddConverter(
    const char* ,
    const char* ,
    XtConverter ,
    XtConvertArgList ,
    Cardinal
);

extern void XtSetTypeConverter(
    const char* ,
    const char* ,
    XtTypeConverter ,
    XtConvertArgList ,
    Cardinal ,
    XtCacheType ,
    XtDestructor
);

extern void XtAppSetTypeConverter(
    XtAppContext ,
    const char* ,
    const char* ,
    XtTypeConverter ,
    XtConvertArgList ,
    Cardinal ,
    XtCacheType ,
    XtDestructor
);

extern void XtConvert(
    Widget ,
    const char* ,
    XrmValue* ,
    const char* ,
    XrmValue*
);

extern void XtDirectConvert(
    XtConverter ,
    XrmValuePtr ,
    Cardinal ,
    XrmValuePtr ,
    XrmValue*
);







extern XtTranslations XtParseTranslationTable(
    const char*
);

extern XtAccelerators XtParseAcceleratorTable(
    const char*
);

extern void XtOverrideTranslations(
    Widget ,
    XtTranslations
);

extern void XtAugmentTranslations(
    Widget ,
    XtTranslations
);

extern void XtInstallAccelerators(
    Widget ,
    Widget
);

extern void XtInstallAllAccelerators(
    Widget ,
    Widget
);

extern void XtUninstallTranslations(
    Widget
);

extern void XtAppAddActions(
    XtAppContext ,
    XtActionList ,
    Cardinal
);

extern void XtAddActions(
    XtActionList ,
    Cardinal
);

extern XtActionHookId XtAppAddActionHook(
    XtAppContext ,
    XtActionHookProc ,
    XtPointer
);

extern void XtRemoveActionHook(
    XtActionHookId
);

extern void XtGetActionList(
    WidgetClass ,
    XtActionList* ,
    Cardinal*
);

extern void XtCallActionProc(
    Widget ,
    const char* ,
    XEvent* ,
    String* ,
    Cardinal
);

extern void XtRegisterGrabAction(
    XtActionProc ,
    Boolean ,
    unsigned int ,
    int ,
    int
);

extern void XtSetMultiClickTime(
    Display* ,
    int
);

extern int XtGetMultiClickTime(
    Display*
);

extern KeySym XtGetActionKeysym(
    XEvent* ,
    Modifiers*
);







extern void XtTranslateKeycode(
    Display* ,
    KeyCode ,
    Modifiers ,
    Modifiers* ,
    KeySym*
);

extern void XtTranslateKey(
    Display* ,
    KeyCode ,
    Modifiers ,
    Modifiers* ,
    KeySym*
);

extern void XtSetKeyTranslator(
    Display* ,
    XtKeyProc
);

extern void XtRegisterCaseConverter(
    Display* ,
    XtCaseProc ,
    KeySym ,
    KeySym
);

extern void XtConvertCase(
    Display* ,
    KeySym ,
    KeySym* ,
    KeySym*
);
# 827 "/usr/include/X11/Intrinsic.h" 3 4
extern void XtAddEventHandler(
    Widget ,
    EventMask ,
    Boolean ,
    XtEventHandler ,
    XtPointer
);

extern void XtRemoveEventHandler(
    Widget ,
    EventMask ,
    Boolean ,
    XtEventHandler ,
    XtPointer
);

extern void XtAddRawEventHandler(
    Widget ,
    EventMask ,
    Boolean ,
    XtEventHandler ,
    XtPointer
);

extern void XtRemoveRawEventHandler(
    Widget ,
    EventMask ,
    Boolean ,
    XtEventHandler ,
    XtPointer
);

extern void XtInsertEventHandler(
    Widget ,
    EventMask ,
    Boolean ,
    XtEventHandler ,
    XtPointer ,
    XtListPosition
);

extern void XtInsertRawEventHandler(
    Widget ,
    EventMask ,
    Boolean ,
    XtEventHandler ,
    XtPointer ,
    XtListPosition
);

extern XtEventDispatchProc XtSetEventDispatcher(
    Display* ,
    int ,
    XtEventDispatchProc
);

extern Boolean XtDispatchEventToWidget(
    Widget ,
    XEvent*
);

extern void XtInsertEventTypeHandler(
    Widget ,
    int ,
    XtPointer ,
    XtEventHandler ,
    XtPointer ,
    XtListPosition
);

extern void XtRemoveEventTypeHandler(
    Widget ,
    int ,
    XtPointer ,
    XtEventHandler ,
    XtPointer
);

extern EventMask XtBuildEventMask(
    Widget
);

extern void XtRegisterExtensionSelector(
    Display* ,
    int ,
    int ,
    XtExtensionSelectProc ,
    XtPointer
);

extern void XtAddGrab(
    Widget ,
    Boolean ,
    Boolean
);

extern void XtRemoveGrab(
    Widget
);

extern void XtProcessEvent(
    XtInputMask
);

extern void XtAppProcessEvent(
    XtAppContext ,
    XtInputMask
);

extern void XtMainLoop(
    void
);

extern void XtAppMainLoop(
    XtAppContext
);

extern void XtAddExposureToRegion(
    XEvent* ,
    Region
);

extern void XtSetKeyboardFocus(
    Widget ,
    Widget
);

extern Widget XtGetKeyboardFocusWidget(
    Widget
);

extern XEvent* XtLastEventProcessed(
    Display*
);

extern Time XtLastTimestampProcessed(
    Display*
);







extern XtIntervalId XtAddTimeOut(
    unsigned long ,
    XtTimerCallbackProc ,
    XtPointer
);

extern XtIntervalId XtAppAddTimeOut(
    XtAppContext ,
    unsigned long ,
    XtTimerCallbackProc ,
    XtPointer
);

extern void XtRemoveTimeOut(
    XtIntervalId
);

extern XtInputId XtAddInput(
    int ,
    XtPointer ,
    XtInputCallbackProc ,
    XtPointer
);

extern XtInputId XtAppAddInput(
    XtAppContext ,
    int ,
    XtPointer ,
    XtInputCallbackProc ,
    XtPointer
);

extern void XtRemoveInput(
    XtInputId
);

extern XtSignalId XtAddSignal(
    XtSignalCallbackProc ,
    XtPointer );

extern XtSignalId XtAppAddSignal(
    XtAppContext ,
    XtSignalCallbackProc ,
    XtPointer
);

extern void XtRemoveSignal(
    XtSignalId
);

extern void XtNoticeSignal(
    XtSignalId
);

extern void XtNextEvent(
    XEvent*
);

extern void XtAppNextEvent(
    XtAppContext ,
    XEvent*
);







extern Boolean XtPending(
    void
);

extern XtInputMask XtAppPending(
    XtAppContext
);

extern XtBlockHookId XtAppAddBlockHook(
    XtAppContext ,
    XtBlockHookProc ,
    XtPointer
);

extern void XtRemoveBlockHook(
    XtBlockHookId
);
# 1072 "/usr/include/X11/Intrinsic.h" 3 4
extern Boolean XtIsOverrideShell(Widget );







extern Boolean XtIsVendorShell(Widget );





extern Boolean XtIsTransientShell(Widget );






extern Boolean XtIsApplicationShell(Widget );





extern Boolean XtIsSessionShell(Widget );




extern void XtRealizeWidget(
    Widget
);

void XtUnrealizeWidget(
    Widget
);

extern void XtDestroyWidget(
    Widget
);

extern void XtSetSensitive(
    Widget ,
    Boolean
);

extern void XtSetMappedWhenManaged(
    Widget ,
    Boolean
);

extern Widget XtNameToWidget(
    Widget ,
    const char*
);

extern Widget XtWindowToWidget(
    Display* ,
    Window
);

extern XtPointer XtGetClassExtension(
    WidgetClass ,
    Cardinal ,
    XrmQuark ,
    long ,
    Cardinal
);
# 1154 "/usr/include/X11/Intrinsic.h" 3 4
extern ArgList XtMergeArgLists(
    ArgList ,
    Cardinal ,
    ArgList ,
    Cardinal
);
# 1170 "/usr/include/X11/Intrinsic.h" 3 4
extern XtVarArgsList XtVaCreateArgsList(
    XtPointer , ...
) __attribute__ ((__sentinel__(0)));
# 1184 "/usr/include/X11/Intrinsic.h" 3 4
extern Display *XtDisplay(
    Widget
);

extern Display *XtDisplayOfObject(
    Widget
);

extern Screen *XtScreen(
    Widget
);

extern Screen *XtScreenOfObject(
    Widget
);

extern Window XtWindow(
    Widget
);

extern Window XtWindowOfObject(
    Widget
);

extern String XtName(
    Widget
);

extern WidgetClass XtSuperclass(
    Widget
);

extern WidgetClass XtClass(
    Widget
);

extern Widget XtParent(
    Widget
);




extern void XtMapWidget(Widget );



extern void XtUnmapWidget(Widget );



extern void XtAddCallback(
    Widget ,
    const char* ,
    XtCallbackProc ,
    XtPointer
);

extern void XtRemoveCallback(
    Widget ,
    const char* ,
    XtCallbackProc ,
    XtPointer
);

extern void XtAddCallbacks(
    Widget ,
    const char* ,
    XtCallbackList
);

extern void XtRemoveCallbacks(
    Widget ,
    const char* ,
    XtCallbackList
);

extern void XtRemoveAllCallbacks(
    Widget ,
    const char*
);


extern void XtCallCallbacks(
    Widget ,
    const char* ,
    XtPointer
);

extern void XtCallCallbackList(
    Widget ,
    XtCallbackList ,
    XtPointer
);

extern XtCallbackStatus XtHasCallbacks(
    Widget ,
    const char*
);
# 1291 "/usr/include/X11/Intrinsic.h" 3 4
extern XtGeometryResult XtMakeGeometryRequest(
    Widget ,
    XtWidgetGeometry* ,
    XtWidgetGeometry*
);

extern XtGeometryResult XtQueryGeometry(
    Widget ,
    XtWidgetGeometry* ,
    XtWidgetGeometry*
);

extern Widget XtCreatePopupShell(
    const char* ,
    WidgetClass ,
    Widget ,
    ArgList ,
    Cardinal
);

extern Widget XtVaCreatePopupShell(
    const char* ,
    WidgetClass ,
    Widget ,
    ...
) __attribute__ ((__sentinel__(0)));

extern void XtPopup(
    Widget ,
    XtGrabKind
);

extern void XtPopupSpringLoaded(
    Widget
);

extern void XtCallbackNone(
    Widget ,
    XtPointer ,
    XtPointer
);

extern void XtCallbackNonexclusive(
    Widget ,
    XtPointer ,
    XtPointer
);

extern void XtCallbackExclusive(
    Widget ,
    XtPointer ,
    XtPointer
);

extern void XtPopdown(
    Widget
);

extern void XtCallbackPopdown(
    Widget ,
    XtPointer ,
    XtPointer
);

extern void XtMenuPopupAction(
    Widget ,
    XEvent* ,
    String* ,
    Cardinal*
);

extern Widget XtCreateWidget(
    const char* ,
    WidgetClass ,
    Widget ,
    ArgList ,
    Cardinal
);

extern Widget XtCreateManagedWidget(
    const char* ,
    WidgetClass ,
    Widget ,
    ArgList ,
    Cardinal
);

extern Widget XtVaCreateWidget(
    const char* ,
    WidgetClass ,
    Widget ,
    ...
) __attribute__ ((__sentinel__(0)));

extern Widget XtVaCreateManagedWidget(
    const char* ,
    WidgetClass ,
    Widget ,
    ...
) __attribute__ ((__sentinel__(0)));

extern Widget XtCreateApplicationShell(
    const char* ,
    WidgetClass ,
    ArgList ,
    Cardinal
);

extern Widget XtAppCreateShell(
    const char* ,
    const char* ,
    WidgetClass ,
    Display* ,
    ArgList ,
    Cardinal
);

extern Widget XtVaAppCreateShell(
    const char* ,
    const char* ,
    WidgetClass ,
    Display* ,
    ...
) __attribute__ ((__sentinel__(0)));







extern void XtToolkitInitialize(
    void
);

extern XtLanguageProc XtSetLanguageProc(
    XtAppContext ,
    XtLanguageProc ,
    XtPointer
);

extern void XtDisplayInitialize(
    XtAppContext ,
    Display* ,
    const char* ,
    const char* ,
    XrmOptionDescRec* ,
    Cardinal ,
    int* ,
    char**
);

extern Widget XtOpenApplication(
    XtAppContext* ,
    const char* ,
    XrmOptionDescList ,
    Cardinal ,
    int* ,
    String* ,
    String* ,
    WidgetClass ,
    ArgList ,
    Cardinal
);

extern Widget XtVaOpenApplication(
    XtAppContext* ,
    const char* ,
    XrmOptionDescList ,
    Cardinal ,
    int* ,
    String* ,
    String* ,
    WidgetClass ,
    ...
) __attribute__ ((__sentinel__(0)));

extern Widget XtAppInitialize(
    XtAppContext* ,
    const char* ,
    XrmOptionDescList ,
    Cardinal ,
    int* ,
    String* ,
    String* ,
    ArgList ,
    Cardinal
);

extern Widget XtVaAppInitialize(
    XtAppContext* ,
    const char* ,
    XrmOptionDescList ,
    Cardinal ,
    int* ,
    String* ,
    String* ,
    ...
) __attribute__ ((__sentinel__(0)));

extern Widget XtInitialize(
    const char* ,
    const char* ,
    XrmOptionDescRec* ,
    Cardinal ,
    int* ,
    char**
);

extern Display *XtOpenDisplay(
    XtAppContext ,
    const char* ,
    const char* ,
    const char* ,
    XrmOptionDescRec* ,
    Cardinal ,
    int* ,
    char**
);

extern XtAppContext XtCreateApplicationContext(
    void
);

extern void XtAppSetFallbackResources(
    XtAppContext ,
    String*
);

extern void XtDestroyApplicationContext(
    XtAppContext
);

extern void XtInitializeWidgetClass(
    WidgetClass
);

extern XtAppContext XtWidgetToApplicationContext(
    Widget
);

extern XtAppContext XtDisplayToApplicationContext(
    Display*
);

extern XrmDatabase XtDatabase(
    Display*
);

extern XrmDatabase XtScreenDatabase(
    Screen*
);

extern void XtCloseDisplay(
    Display*
);

extern void XtGetApplicationResources(
    Widget ,
    XtPointer ,
    XtResourceList ,
    Cardinal ,
    ArgList ,
    Cardinal
);

extern void XtVaGetApplicationResources(
    Widget ,
    XtPointer ,
    XtResourceList ,
    Cardinal ,
    ...
) __attribute__ ((__sentinel__(0)));

extern void XtGetSubresources(
    Widget ,
    XtPointer ,
    const char* ,
    const char* ,
    XtResourceList ,
    Cardinal ,
    ArgList ,
    Cardinal
);

extern void XtVaGetSubresources(
    Widget ,
    XtPointer ,
    const char* ,
    const char* ,
    XtResourceList ,
    Cardinal ,
    ...
) __attribute__ ((__sentinel__(0)));

extern void XtSetValues(
    Widget ,
    ArgList ,
    Cardinal
);

extern void XtVaSetValues(
    Widget ,
    ...
) __attribute__ ((__sentinel__(0)));

extern void XtGetValues(
    Widget ,
    ArgList ,
    Cardinal
);

extern void XtVaGetValues(
    Widget ,
    ...
) __attribute__ ((__sentinel__(0)));

extern void XtSetSubvalues(
    XtPointer ,
    XtResourceList ,
    Cardinal ,
    ArgList ,
    Cardinal
);

extern void XtVaSetSubvalues(
    XtPointer ,
    XtResourceList ,
    Cardinal ,
    ...
) __attribute__ ((__sentinel__(0)));

extern void XtGetSubvalues(
    XtPointer ,
    XtResourceList ,
    Cardinal ,
    ArgList ,
    Cardinal
);

extern void XtVaGetSubvalues(
    XtPointer ,
    XtResourceList ,
    Cardinal ,
    ...
) __attribute__ ((__sentinel__(0)));

extern void XtGetResourceList(
    WidgetClass ,
    XtResourceList* ,
    Cardinal*
);

extern void XtGetConstraintResourceList(
    WidgetClass ,
    XtResourceList* ,
    Cardinal*
);
# 1675 "/usr/include/X11/Intrinsic.h" 3 4
typedef struct _XtCheckpointTokenRec {
    int save_type;
    int interact_style;
    Boolean shutdown;
    Boolean fast;
    Boolean cancel_shutdown;
    int phase;
    int interact_dialog_type;
    Boolean request_cancel;
    Boolean request_next_phase;
    Boolean save_success;
    int type;
    Widget widget;
} XtCheckpointTokenRec, *XtCheckpointToken;

XtCheckpointToken XtSessionGetToken(
    Widget
);

void XtSessionReturnToken(
    XtCheckpointToken
);







extern XtErrorMsgHandler XtAppSetErrorMsgHandler(
    XtAppContext ,
    XtErrorMsgHandler
);

extern void XtSetErrorMsgHandler(
    XtErrorMsgHandler
);

extern XtErrorMsgHandler XtAppSetWarningMsgHandler(
    XtAppContext ,
    XtErrorMsgHandler
);

extern void XtSetWarningMsgHandler(
    XtErrorMsgHandler
);

extern void XtAppErrorMsg(
    XtAppContext ,
    const char* ,
    const char* ,
    const char* ,
    const char* ,
    String* ,
    Cardinal*
);

extern void XtErrorMsg(
    const char* ,
    const char* ,
    const char* ,
    const char* ,
    String* ,
    Cardinal*
);

extern void XtAppWarningMsg(
    XtAppContext ,
    const char* ,
    const char* ,
    const char* ,
    const char* ,
    String* ,
    Cardinal*
);

extern void XtWarningMsg(
    const char* ,
    const char* ,
    const char* ,
    const char* ,
    String* ,
    Cardinal*
);

extern XtErrorHandler XtAppSetErrorHandler(
    XtAppContext ,
    XtErrorHandler
);

extern void XtSetErrorHandler(
    XtErrorHandler
);

extern XtErrorHandler XtAppSetWarningHandler(
    XtAppContext ,
    XtErrorHandler
);

extern void XtSetWarningHandler(
    XtErrorHandler
);

extern void XtAppError(
    XtAppContext ,
    const char*
);

extern void XtError(
    const char*
);

extern void XtAppWarning(
    XtAppContext ,
    const char*
);

extern void XtWarning(
    const char*
);

extern XrmDatabase *XtAppGetErrorDatabase(
    XtAppContext
);

extern XrmDatabase *XtGetErrorDatabase(
    void
);

extern void XtAppGetErrorDatabaseText(
    XtAppContext ,
    const char* ,
    const char* ,
    const char* ,
    const char* ,
    String ,
    int ,
    XrmDatabase
);

extern void XtGetErrorDatabaseText(
    const char* ,
    const char* ,
    const char* ,
    const char* ,
    String ,
    int
);







extern char *XtMalloc(
    Cardinal
);

extern char *XtCalloc(
    Cardinal ,
    Cardinal
);

extern char *XtRealloc(
    char* ,
    Cardinal
);

extern void XtFree(
    char*
);




extern Cardinal XtAsprintf(
    String *new_string,
    const char * restrict format,
    ...
) __attribute__((__format__(__printf__,2,3)));
# 1893 "/usr/include/X11/Intrinsic.h" 3 4
extern String XtNewString(String );
# 1903 "/usr/include/X11/Intrinsic.h" 3 4
extern XtWorkProcId XtAddWorkProc(
    XtWorkProc ,
    XtPointer
);

extern XtWorkProcId XtAppAddWorkProc(
    XtAppContext ,
    XtWorkProc ,
    XtPointer
);

extern void XtRemoveWorkProc(
    XtWorkProcId
);







extern GC XtGetGC(
    Widget ,
    XtGCMask ,
    XGCValues*
);

extern GC XtAllocateGC(
    Widget ,
    Cardinal ,
    XtGCMask ,
    XGCValues* ,
    XtGCMask ,
    XtGCMask
);





extern void XtDestroyGC(
    GC
);

extern void XtReleaseGC(
    Widget ,
    GC
);



extern void XtAppReleaseCacheRefs(
    XtAppContext ,
    XtCacheRef*
);

extern void XtCallbackReleaseCacheRef(
    Widget ,
    XtPointer ,
    XtPointer
);

extern void XtCallbackReleaseCacheRefList(
    Widget ,
    XtPointer ,
    XtPointer
);

extern void XtSetWMColormapWindows(
    Widget ,
    Widget* ,
    Cardinal
);

extern String XtFindFile(
    const char* ,
    Substitution ,
    Cardinal ,
    XtFilePredicate
);

extern String XtResolvePathname(
    Display* ,
    const char* ,
    const char* ,
    const char* ,
    const char* ,
    Substitution ,
    Cardinal ,
    XtFilePredicate
);
# 2003 "/usr/include/X11/Intrinsic.h" 3 4
extern void XtDisownSelection(
    Widget ,
    Atom ,
    Time
);

extern void XtGetSelectionValue(
    Widget ,
    Atom ,
    Atom ,
    XtSelectionCallbackProc ,
    XtPointer ,
    Time
);

extern void XtGetSelectionValues(
    Widget ,
    Atom ,
    Atom* ,
    int ,
    XtSelectionCallbackProc ,
    XtPointer* ,
    Time
);

extern void XtAppSetSelectionTimeout(
    XtAppContext ,
    unsigned long
);

extern void XtSetSelectionTimeout(
    unsigned long
);

extern unsigned long XtAppGetSelectionTimeout(
    XtAppContext
);

extern unsigned long XtGetSelectionTimeout(
    void
);

extern XSelectionRequestEvent *XtGetSelectionRequest(
    Widget ,
    Atom ,
    XtRequestId
);

extern void XtGetSelectionValueIncremental(
    Widget ,
    Atom ,
    Atom ,
    XtSelectionCallbackProc ,
    XtPointer ,
    Time
);

extern void XtGetSelectionValuesIncremental(
    Widget ,
    Atom ,
    Atom* ,
    int ,
    XtSelectionCallbackProc ,
    XtPointer* ,
    Time
);

extern void XtSetSelectionParameters(
    Widget ,
    Atom ,
    Atom ,
    XtPointer ,
    unsigned long ,
    int
);

extern void XtGetSelectionParameters(
    Widget ,
    Atom ,
    XtRequestId ,
    Atom* ,
    XtPointer* ,
    unsigned long* ,
    int*
);

extern void XtCreateSelectionRequest(
    Widget ,
    Atom
);

extern void XtSendSelectionRequest(
    Widget ,
    Atom ,
    Time
);

extern void XtCancelSelectionRequest(
    Widget ,
    Atom
);

extern Atom XtReservePropertyAtom(
    Widget
);

extern void XtReleasePropertyAtom(
    Widget ,
    Atom
);

extern void XtGrabKey(
    Widget ,
    KeyCode ,
    Modifiers ,
    Boolean ,
    int ,
    int
);

extern void XtUngrabKey(
    Widget ,
    KeyCode ,
    Modifiers
);

extern int XtGrabKeyboard(
    Widget ,
    Boolean ,
    int ,
    int ,
    Time
);

extern void XtUngrabKeyboard(
    Widget ,
    Time
);

extern void XtGrabButton(
    Widget ,
    int ,
    Modifiers ,
    Boolean ,
    unsigned int ,
    int ,
    int ,
    Window ,
    Cursor
);

extern void XtUngrabButton(
    Widget ,
    unsigned int ,
    Modifiers
);

extern int XtGrabPointer(
    Widget ,
    Boolean ,
    unsigned int ,
    int ,
    int ,
    Window ,
    Cursor ,
    Time
);

extern void XtUngrabPointer(
    Widget ,
    Time
);

extern void XtGetApplicationNameAndClass(
    Display* ,
    String* ,
    String*
);

extern void XtRegisterDrawable(
    Display* ,
    Drawable ,
    Widget
);

extern void XtUnregisterDrawable(
    Display* ,
    Drawable
);

extern Widget XtHooksOfDisplay(
    Display*
);

typedef struct {
    String type;
    Widget widget;
    ArgList args;
    Cardinal num_args;
} XtCreateHookDataRec, *XtCreateHookData;

typedef struct {
    String type;
    Widget widget;
    XtPointer event_data;
    Cardinal num_event_data;
} XtChangeHookDataRec, *XtChangeHookData;

typedef struct {
    Widget old, req;
    ArgList args;
    Cardinal num_args;
} XtChangeHookSetValuesDataRec, *XtChangeHookSetValuesData;

typedef struct {
    String type;
    Widget widget;
    XtGeometryMask changeMask;
    XWindowChanges changes;
} XtConfigureHookDataRec, *XtConfigureHookData;

typedef struct {
    String type;
    Widget widget;
    XtWidgetGeometry* request;
    XtWidgetGeometry* reply;
    XtGeometryResult result;
} XtGeometryHookDataRec, *XtGeometryHookData;

typedef struct {
    String type;
    Widget widget;
} XtDestroyHookDataRec, *XtDestroyHookData;

extern void XtGetDisplays(
    XtAppContext ,
    Display*** ,
    Cardinal*
);

extern Boolean XtToolkitThreadInitialize(
    void
);

extern void XtAppSetExitFlag(
    XtAppContext
);

extern Boolean XtAppGetExitFlag(
    XtAppContext
);

extern void XtAppLock(
    XtAppContext
);

extern void XtAppUnlock(
    XtAppContext
);
# 2270 "/usr/include/X11/Intrinsic.h" 3 4
extern Boolean XtCvtStringToAcceleratorTable(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtStringToAtom(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtStringToBool(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtStringToBoolean(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtStringToCommandArgArray(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtStringToCursor(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtStringToDimension(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtStringToDirectoryString(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtStringToDisplay(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtStringToFile(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtStringToFloat(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtStringToFont(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtStringToFontSet(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtStringToFontStruct(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtStringToGravity(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtStringToInitialState(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtStringToInt(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtStringToPixel(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);



extern Boolean XtCvtStringToRestartStyle(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtStringToShort(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtStringToTranslationTable(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtStringToUnsignedChar(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtStringToVisual(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);



extern Boolean XtCvtIntToBool(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtIntToBoolean(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtIntToColor(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);



extern Boolean XtCvtIntToFloat(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtIntToFont(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtIntToPixel(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtIntToPixmap(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);



extern Boolean XtCvtIntToShort(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);

extern Boolean XtCvtIntToUnsignedChar(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);



extern Boolean XtCvtColorToPixel(
    Display* ,
    XrmValuePtr ,
    Cardinal* ,
    XrmValuePtr ,
    XrmValuePtr ,
    XtPointer*
);
# 116 "./structs.h" 2
# 137 "./structs.h"
typedef struct filemark
{
    pos_T mark;
    int fnum;
} fmark_T;


typedef struct xfilemark
{
    fmark_T fmark;
    char_u *fname;

    time_T time_set;

} xfmark_T;




typedef struct taggy
{
    char_u *tagname;
    fmark_T fmark;
    int cur_match;
    int cur_fnum;
    char_u *user_data;
} taggy_T;






typedef struct
{

    int wo_arab;



    int wo_bri;

    char_u *wo_briopt;


    char_u *wo_wcr;


    int wo_diff;



    long wo_fdc;

    int wo_fdc_save;

    int wo_fen;

    int wo_fen_save;

    char_u *wo_fdi;

    long wo_fdl;

    int wo_fdl_save;

    char_u *wo_fdm;

    char_u *wo_fdm_save;

    long wo_fml;

    long wo_fdn;


    char_u *wo_fde;

    char_u *wo_fdt;


    char_u *wo_fmr;



    int wo_lbr;


    int wo_list;

    int wo_nu;

    int wo_rnu;


    long wo_nuw;


    int wo_wfh;

    int wo_wfw;


    int wo_pvw;



    int wo_rl;

    char_u *wo_rlc;


    long wo_scr;


    int wo_spell;



    int wo_cuc;

    int wo_cul;

    char_u *wo_culopt;

    char_u *wo_cc;



    char_u *wo_sbr;



    char_u *wo_stl;


    int wo_scb;

    int wo_diff_saved;

    int wo_scb_save;

    int wo_wrap;


    int wo_wrap_save;



    char_u *wo_cocu;

    long wo_cole;


    int wo_crb;

    int wo_crb_save;


    char_u *wo_scl;



    char_u *wo_twk;

    char_u *wo_tws;




    sctx_T wo_script_ctx[WV_COUNT];


} winopt_T;
# 321 "./structs.h"
struct wininfo_S
{
    wininfo_T *wi_next;
    wininfo_T *wi_prev;
    win_T *wi_win;
    pos_T wi_fpos;
    int wi_optset;
    winopt_T wi_opt;

    int wi_fold_manual;
    garray_T wi_folds;

};





typedef struct foldinfo
{
    int fi_level;

    int fi_lnum;
    int fi_low_level;

} foldinfo_T;




typedef struct
{
    pos_T vi_start;
    pos_T vi_end;
    int vi_mode;
    colnr_T vi_curswant;
} visualinfo_T;







typedef struct {
    char_u *ul_line;
    long ul_len;

} undoline_T;

typedef struct u_entry u_entry_T;
typedef struct u_header u_header_T;
struct u_entry
{
    u_entry_T *ue_next;
    linenr_T ue_top;
    linenr_T ue_bot;
    linenr_T ue_lcount;
    undoline_T *ue_array;
    long ue_size;



};

struct u_header
{


    union {
 u_header_T *ptr;
 long seq;
    } uh_next;
    union {
 u_header_T *ptr;
 long seq;
    } uh_prev;
    union {
 u_header_T *ptr;
 long seq;
    } uh_alt_next;
    union {
 u_header_T *ptr;
 long seq;
    } uh_alt_prev;
    long uh_seq;
    int uh_walk;
    u_entry_T *uh_entry;
    u_entry_T *uh_getbot_entry;
    pos_T uh_cursor;
    long uh_cursor_vcol;
    int uh_flags;
    pos_T uh_namedm[('z' - 'a' + 1)];
    visualinfo_T uh_visual;
    time_T uh_time;
    long uh_save_nr;




};
# 435 "./structs.h"
typedef struct m_info minfo_T;




struct m_info
{

    long_u m_size;



    minfo_T *m_next;
};





typedef struct block_hdr bhdr_T;
typedef struct memfile memfile_T;
typedef long blocknr_T;
# 465 "./structs.h"
typedef struct mf_hashitem_S mf_hashitem_T;

struct mf_hashitem_S
{
    mf_hashitem_T *mhi_next;
    mf_hashitem_T *mhi_prev;
    blocknr_T mhi_key;
};



typedef struct mf_hashtab_S
{
    long_u mht_mask;

    long_u mht_count;
    mf_hashitem_T **mht_buckets;

    mf_hashitem_T *mht_small_buckets[64];
    char mht_fixed;
} mf_hashtab_T;
# 502 "./structs.h"
struct block_hdr
{
    mf_hashitem_T bh_hashitem;


    bhdr_T *bh_next;
    bhdr_T *bh_prev;
    char_u *bh_data;
    int bh_page_count;



    char bh_flags;
};







typedef struct nr_trans NR_TRANS;

struct nr_trans
{
    mf_hashitem_T nt_hashitem;


    blocknr_T nt_new_bnum;
};


typedef struct buffblock buffblock_T;
typedef struct buffheader buffheader_T;




struct buffblock
{
    buffblock_T *b_next;
    char_u b_str[1];
};




struct buffheader
{
    buffblock_T bh_first;
    buffblock_T *bh_curr;
    int bh_index;
    int bh_space;
};

typedef struct
{
    buffheader_T sr_redobuff;
    buffheader_T sr_old_redobuff;
} save_redo_T;




typedef struct expand
{
    char_u *xp_pattern;
    int xp_context;
    int xp_pattern_len;

    char_u *xp_arg;
    sctx_T xp_script_ctx;

    int xp_backslash;

    int xp_shell;


    int xp_numfiles;

    int xp_col;
    char_u **xp_files;
    char_u *xp_line;
} expand_T;
# 599 "./structs.h"
typedef struct
{
    char_u *cmdbuff;
    int cmdbufflen;
    int cmdlen;
    int cmdpos;
    int cmdspos;
    int cmdfirstc;
    int cmdindent;
    char_u *cmdprompt;
    int cmdattr;
    int overstrike;

    expand_T *xpc;

    int xp_context;

    char_u *xp_arg;
    int input_fn;

} cmdline_info_T;






typedef struct
{
    int cmod_flags;
# 644 "./structs.h"
    int cmod_split;
    int cmod_tab;
    regmatch_T cmod_filter_regmatch;
    int cmod_filter_force;

    int cmod_verbose;


    char_u *cmod_save_ei;

    int cmod_did_sandbox;

    long cmod_verbose_save;

    int cmod_save_msg_silent;

    int cmod_save_msg_scroll;
    int cmod_did_esilent;
} cmdmod_T;



struct memfile
{
    char_u *mf_fname;
    char_u *mf_ffname;
    int mf_fd;
    int mf_flags;
    int mf_reopen;
    bhdr_T *mf_free_first;
    bhdr_T *mf_used_first;
    bhdr_T *mf_used_last;
    unsigned mf_used_count;
    unsigned mf_used_count_max;
    mf_hashtab_T mf_hash;
    mf_hashtab_T mf_trans;
    blocknr_T mf_blocknr_max;
    blocknr_T mf_blocknr_min;
    blocknr_T mf_neg_count;
    blocknr_T mf_infile_count;
    unsigned mf_page_size;
    int mf_dirty;

    buf_T *mf_buffer;
    char_u mf_seed[8];



    char_u *mf_old_key;
    int mf_old_cm;
    char_u mf_old_seed[8];

};
# 706 "./structs.h"
typedef struct info_pointer
{
    blocknr_T ip_bnum;
    linenr_T ip_low;
    linenr_T ip_high;
    int ip_index;
} infoptr_T;


typedef struct ml_chunksize
{
    int mlcs_numlines;
    long mlcs_totalsize;
} chunksize_T;
# 732 "./structs.h"
typedef struct memline
{
    linenr_T ml_line_count;

    memfile_T *ml_mfp;

    infoptr_T *ml_stack;
    int ml_stack_top;
    int ml_stack_size;





    int ml_flags;

    colnr_T ml_line_len;
    linenr_T ml_line_lnum;
    char_u *ml_line_ptr;

    bhdr_T *ml_locked;
    linenr_T ml_locked_low;
    linenr_T ml_locked_high;
    int ml_locked_lineadd;

    chunksize_T *ml_chunksize;
    int ml_numchunks;
    int ml_usedchunks;

} memline_T;
# 778 "./structs.h"
typedef struct textprop_S
{
    colnr_T tp_col;
    colnr_T tp_len;
    int tp_id;
    int tp_type;
    int tp_flags;
} textprop_T;







typedef struct proptype_S
{
    int pt_id;
    int pt_type;
    int pt_hl_id;
    int pt_priority;
    int pt_flags;
    char_u pt_name[1];
} proptype_T;






typedef struct signgroup_S
{
    int sg_next_sign_id;
    short_u sg_refcount;
    char_u sg_name[1];
} signgroup_T;

typedef struct sign_entry sign_entry_T;
struct sign_entry
{
    int se_id;
    int se_typenr;
    int se_priority;
    linenr_T se_lnum;
    signgroup_T *se_group;
    sign_entry_T *se_next;
    sign_entry_T *se_prev;
};




typedef struct sign_attrs_S {
    int sat_typenr;
    void *sat_icon;
    char_u *sat_text;
    int sat_texthl;
    int sat_linehl;
    int sat_priority;
} sign_attrs_T;
# 853 "./structs.h"
typedef struct arglist
{
    garray_T al_ga;
    int al_refcount;
    int id;
} alist_T;






typedef struct argentry
{
    char_u *ae_fname;
    int ae_fnum;
} aentry_T;
# 886 "./structs.h"
typedef struct eslist_elem eslist_T;
struct eslist_elem
{
    int saved_emsg_silent;
    eslist_T *next;
};







typedef struct {
    short cs_flags[50];
    char cs_pending[50];
    union {
 void *csp_rv[50];
 void *csp_ex[50];
    } cs_pend;
    void *cs_forinfo[50];
    int cs_line[50];
    int cs_block_id[50];
    int cs_script_var_len[50];

    int cs_idx;
    int cs_looplevel;
    int cs_trylevel;
    eslist_T *cs_emsg_silent_list;
    char cs_lflags;
} cstack_T;
# 966 "./structs.h"
typedef struct msglist msglist_T;
struct msglist
{
    char *msg;
    char *throw_msg;
    char_u *sfile;
    long slnum;
    msglist_T *next;
};




typedef enum
{
    ET_USER,
    ET_ERROR,
    ET_INTERRUPT,
} except_type_T;





typedef struct vim_exception except_T;
struct vim_exception
{
    except_type_T type;
    char *value;
    struct msglist *messages;
    char_u *throw_name;
    linenr_T throw_lnum;
    except_T *caught;
};






typedef struct cleanup_stuff cleanup_T;
struct cleanup_stuff
{
    int pending;
    except_T *exception;
};



struct sp_syn
{
    int inc_tag;
    short id;
    short *cont_in_list;
};




typedef struct keyentry keyentry_T;

struct keyentry
{
    keyentry_T *ke_next;
    struct sp_syn k_syn;
    short *next_list;
    int flags;
    int k_char;
    char_u keyword[1];
};




typedef struct buf_state
{
    int bs_idx;
    int bs_flags;

    int bs_seqnr;
    int bs_cchar;

    reg_extmatch_T *bs_extmatch;
} bufstate_T;





typedef struct syn_state synstate_T;

struct syn_state
{
    synstate_T *sst_next;
    linenr_T sst_lnum;
    union
    {
 bufstate_T sst_stack[7];
 garray_T sst_ga;
    } sst_union;
    int sst_next_flags;
    int sst_stacksize;
    short *sst_next_list;

    disptick_T sst_tick;
    linenr_T sst_change_lnum;

};







typedef struct attr_entry
{
    short ae_attr;
    union
    {
 struct
 {
     char_u *start;
     char_u *stop;
 } term;
 struct
 {

     short_u fg_color;
     short_u bg_color;
     short_u ul_color;

     long fg_rgb;
     long bg_rgb;
     long ul_rgb;

 } cterm;
# 1115 "./structs.h"
    } ae_u;
} attrentry_T;




# 1 "/usr/include/iconv.h" 1 3 4
# 23 "/usr/include/iconv.h" 3 4
# 1 "/llvm-project/build/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 24 "/usr/include/iconv.h" 2 3 4





typedef void *iconv_t;







extern iconv_t iconv_open (const char *__tocode, const char *__fromcode);




extern size_t iconv (iconv_t __cd, char **__restrict __inbuf,
       size_t *__restrict __inbytesleft,
       char **__restrict __outbuf,
       size_t *__restrict __outbytesleft);





extern int iconv_close (iconv_t __cd);
# 1121 "./structs.h" 2
# 1138 "./structs.h"
typedef struct
{
    char_u *tb_buf;
    char_u *tb_noremap;
    int tb_buflen;
    int tb_off;
    int tb_len;
    int tb_maplen;
    int tb_silent;
    int tb_no_abbr_cnt;
    int tb_change_cnt;
} typebuf_T;


typedef struct
{
    typebuf_T save_typebuf;
    int typebuf_valid;
    int old_char;
    int old_mod_mask;
    buffheader_T save_readbuf1;
    buffheader_T save_readbuf2;

    char_u *save_inputbuf;

} tasave_T;




typedef struct
{
    int vc_type;
    int vc_factor;





    iconv_t vc_fd;

    int vc_fail;
} vimconv_T;




typedef struct hist_entry
{
    int hisnum;
    int viminfo;
    char_u *hisstr;
    time_t time_set;
} histentry_T;
# 1212 "./structs.h"
typedef struct mapblock mapblock_T;
struct mapblock
{
    mapblock_T *m_next;
    char_u *m_keys;
    char_u *m_str;
    char_u *m_orig_str;
    int m_keylen;
    int m_mode;
    int m_simplified;

    int m_noremap;
    char m_silent;
    char m_nowait;

    char m_expr;
    sctx_T m_script_ctx;

};





typedef struct
{
    char_u *start;
    int userhl;
} stl_hlrec_T;
# 1255 "./structs.h"
typedef struct hashitem_S
{
    long_u hi_hash;
    char_u *hi_key;
} hashitem_T;
# 1271 "./structs.h"
typedef struct hashtable_S
{
    long_u ht_mask;

    long_u ht_used;
    long_u ht_filled;
    int ht_changed;
    int ht_locked;
    int ht_error;

    hashitem_T *ht_array;

    hashitem_T ht_smallarray[16];
} hashtab_T;

typedef long_u hash_T;
# 1321 "./structs.h"
  typedef long long varnumber_T;
  typedef unsigned long long uvarnumber_T;
# 1336 "./structs.h"
typedef signed char int8_T;

typedef double float_T;

typedef struct listvar_S list_T;
typedef struct dictvar_S dict_T;
typedef struct partial_S partial_T;
typedef struct blobvar_S blob_T;






typedef struct {
    char_u *cb_name;
    partial_T *cb_partial;
    int cb_free_name;
} callback_T;

typedef struct isn_S isn_T;
typedef struct dfunc_S dfunc_T;

typedef struct jobvar_S job_T;
typedef struct readq_S readq_T;
typedef struct writeq_S writeq_T;
typedef struct jsonq_S jsonq_T;
typedef struct cbq_S cbq_T;
typedef struct channel_S channel_T;
typedef struct cctx_S cctx_T;

typedef enum
{
    VAR_UNKNOWN = 0,
    VAR_ANY,
    VAR_VOID,
    VAR_BOOL,
    VAR_SPECIAL,
    VAR_NUMBER,
    VAR_FLOAT,
    VAR_STRING,
    VAR_BLOB,
    VAR_FUNC,
    VAR_PARTIAL,
    VAR_LIST,
    VAR_DICT,
    VAR_JOB,
    VAR_CHANNEL,
} vartype_T;


typedef struct type_S type_T;
struct type_S {
    vartype_T tt_type;
    int8_T tt_argcount;
    char tt_min_argcount;
    char tt_flags;
    type_T *tt_member;
    type_T **tt_args;
};
# 1405 "./structs.h"
typedef struct
{
    vartype_T v_type;
    char v_lock;
    union
    {
 varnumber_T v_number;

 float_T v_float;

 char_u *v_string;
 list_T *v_list;
 dict_T *v_dict;
 partial_T *v_partial;

 job_T *v_job;
 channel_T *v_channel;

 blob_T *v_blob;
    } vval;
} typval_T;
# 1439 "./structs.h"
typedef struct listitem_S listitem_T;

struct listitem_S
{
    listitem_T *li_next;
    listitem_T *li_prev;
    typval_T li_tv;
};


typedef struct listwatch_S listwatch_T;

struct listwatch_S
{
    listitem_T *lw_item;
    listwatch_T *lw_next;
};
# 1464 "./structs.h"
struct listvar_S
{
    listitem_T *lv_first;
    listwatch_T *lv_watch;
    union {
 struct {

     varnumber_T lv_start;
     varnumber_T lv_end;
     int lv_stride;
 } nonmat;
 struct {
     listitem_T *lv_last;
     listitem_T *lv_idx_item;
     int lv_idx;
 } mat;
    } lv_u;
    list_T *lv_copylist;
    list_T *lv_used_next;
    list_T *lv_used_prev;
    int lv_refcount;
    int lv_len;
    int lv_with_items;

    int lv_copyID;
    char lv_lock;
};




typedef struct {
    list_T sl_list;
    listitem_T sl_items[10];
} staticList10_T;






struct dictitem_S
{
    typval_T di_tv;
    char_u di_flags;
    char_u di_key[1];
};
typedef struct dictitem_S dictitem_T;






struct dictitem16_S
{
    typval_T di_tv;
    char_u di_flags;
    char_u di_key[16 + 1];
};
typedef struct dictitem16_S dictitem16_T;
# 1537 "./structs.h"
struct dictvar_S
{
    char dv_lock;
    char dv_scope;
    int dv_refcount;
    int dv_copyID;
    hashtab_T dv_hashtab;
    dict_T *dv_copydict;
    dict_T *dv_used_next;
    dict_T *dv_used_prev;
};




struct blobvar_S
{
    garray_T bv_ga;
    int bv_refcount;
    char bv_lock;
};

typedef int (*cfunc_T)(int argcount, typval_T *argvars, typval_T *rettv, void *state);
typedef void (*cfunc_free_T)(void *state);


typedef enum {
    GETLINE_NONE,
    GETLINE_CONCAT_CONT,
    GETLINE_CONCAT_ALL
} getline_opt_T;


typedef struct funccall_S funccall_T;


typedef enum {
    UF_NOT_COMPILED,
    UF_TO_BE_COMPILED,
    UF_COMPILING,
    UF_COMPILED
} def_status_T;





typedef struct
{
    int uf_varargs;
    int uf_flags;
    int uf_calls;
    int uf_cleared;
    def_status_T uf_def_status;
    int uf_dfunc_idx;
    garray_T uf_args;
    garray_T uf_def_args;


    type_T **uf_arg_types;
    type_T *uf_ret_type;
    garray_T uf_type_list;
    int *uf_def_arg_idx;

    char_u *uf_va_name;
    type_T *uf_va_type;
    type_T *uf_func_type;
    int uf_block_depth;
    int *uf_block_ids;






    garray_T uf_lines;

    int uf_profiling;
    int uf_prof_initialized;

    int uf_tm_count;
    proftime_T uf_tm_total;
    proftime_T uf_tm_self;
    proftime_T uf_tm_children;

    int *uf_tml_count;
    proftime_T *uf_tml_total;
    proftime_T *uf_tml_self;
    proftime_T uf_tml_start;
    proftime_T uf_tml_children;
    proftime_T uf_tml_wait;
    int uf_tml_idx;
    int uf_tml_execed;

    sctx_T uf_script_ctx;


    int uf_script_ctx_version;
    int uf_refcount;

    funccall_T *uf_scoped;

    char_u *uf_name_exp;

    char_u uf_name[1];


} ufunc_T;
# 1668 "./structs.h"
struct funccall_S
{
    ufunc_T *func;
    int linenr;
    int returned;
    struct
    {
 dictitem_T var;
 char_u room[20];
    } fixvar[12];
    dict_T l_vars;
    dictitem_T l_vars_var;
    dict_T l_avars;
    dictitem_T l_avars_var;
    list_T l_varlist;
    listitem_T l_listitems[20];
    typval_T *rettv;
    linenr_T breakpoint;
    int dbg_tick;
    int level;

    proftime_T prof_child;

    funccall_T *caller;



    int fc_refcount;

    int fc_copyID;
    garray_T fc_funcs;

};




typedef struct
{
    dict_T *fd_dict;
    char_u *fd_newkey;
    dictitem_T *fd_di;
} funcdict_T;

typedef struct funccal_entry funccal_entry_T;
struct funccal_entry {
    void *top_funccal;
    funccal_entry_T *next;
};
# 1727 "./structs.h"
typedef struct {
    dictitem_T sv_var;
    dict_T sv_dict;
} scriptvar_T;





typedef struct sallvar_S sallvar_T;
struct sallvar_S {
    sallvar_T *sav_next;
    int sav_block_id;
    int sav_var_vals_idx;




    dictitem_T *sav_di;
    typval_T sav_tv;
    char_u sav_flags;
    char_u sav_key[1];
};
# 1765 "./structs.h"
typedef struct {
    char_u *sv_name;
    typval_T *sv_tv;
    type_T *sv_type;
    int sv_const;
    int sv_export;
} svar_T;

typedef struct {
    char_u *imp_name;
    int imp_sid;


    int imp_all;


    type_T *imp_type;
    int imp_var_vals_idx;


    char_u *imp_funcname;
} imported_T;






typedef struct
{
    char_u *sn_name;



    scriptvar_T *sn_vars;
# 1808 "./structs.h"
    dict_T sn_all_vars;




    garray_T sn_var_vals;

    garray_T sn_imports;
    garray_T sn_type_list;
    int sn_current_block_id;
    int sn_last_block_id;

    int sn_version;
    int sn_had_command;
    char_u *sn_save_cpo;


    int sn_prof_on;
    int sn_pr_force;
    proftime_T sn_pr_child;
    int sn_pr_nest;

    int sn_pr_count;
    proftime_T sn_pr_total;
    proftime_T sn_pr_self;
    proftime_T sn_pr_start;
    proftime_T sn_pr_children;

    garray_T sn_prl_ga;
    proftime_T sn_prl_start;
    proftime_T sn_prl_children;
    proftime_T sn_prl_wait;
    int sn_prl_idx;
    int sn_prl_execed;

} scriptitem_T;



typedef struct {
    int eval_flags;
    int eval_break_count;


    char_u *(*eval_getline)(int, void *, int, getline_opt_T);
    void *eval_cookie;


    cctx_T *eval_cctx;




    garray_T eval_ga;


    char_u *eval_tofree;


    char_u *eval_tofree_lambda;
} evalarg_T;
# 1878 "./structs.h"
typedef struct sn_prl_S
{
    int snp_count;
    proftime_T sn_prl_total;
    proftime_T sn_prl_self;
} sn_prl_T;
# 1922 "./structs.h"
typedef struct {
    int (* argv_func)(int, typval_T *, int, int);
    linenr_T firstline;
    linenr_T lastline;
    int *doesrange;
    int evaluate;
    partial_T *partial;
    dict_T *selfdict;
    typval_T *basetv;
} funcexe_T;





typedef struct funcstack_S
{
    garray_T fs_ga;



    int fs_var_offset;


    int fs_refcount;
    int fs_min_refcount;
    int fs_copyID;
} funcstack_T;

struct partial_S
{
    int pt_refcount;
    char_u *pt_name;

    ufunc_T *pt_func;

    int pt_auto;



    garray_T *pt_ectx_stack;
    int pt_ectx_frame;
    funcstack_T *pt_funcstack;


    int pt_argc;
    typval_T *pt_argv;

    dict_T *pt_dict;
    int pt_copyID;
};

typedef struct AutoPatCmd_S AutoPatCmd;




typedef enum {
    ETYPE_TOP,
    ETYPE_SCRIPT,
    ETYPE_UFUNC,
    ETYPE_AUCMD,
    ETYPE_MODELINE,
    ETYPE_EXCEPT,
    ETYPE_ARGS,
    ETYPE_ENV,
    ETYPE_INTERNAL,
    ETYPE_SPELL,
} etype_T;

typedef struct {
    long es_lnum;
    char_u *es_name;
    etype_T es_type;
    union {
 sctx_T *sctx;

 ufunc_T *ufunc;

 AutoPatCmd *aucmd;
 except_T *except;
    } es_info;

    scid_T es_save_sid;

} estack_T;


typedef struct {
    int backspace;
    int enter;
    int interrupt;
    int nl_does_cr;
} ttyinfo_T;


typedef enum
{
    JOB_FAILED,
    JOB_STARTED,
    JOB_ENDED,
    JOB_FINISHED,
} jobstatus_T;




struct jobvar_S
{
    job_T *jv_next;
    job_T *jv_prev;

    pid_t jv_pid;





    char_u *jv_tty_in;
    char_u *jv_tty_out;
    jobstatus_T jv_status;
    char_u *jv_stoponexit;

    char_u *jv_termsig;




    int jv_exitval;
    callback_T jv_exit_cb;

    buf_T *jv_in_buf;

    int jv_refcount;
    int jv_copyID;

    channel_T *jv_channel;
    char **jv_argv;
};




struct readq_S
{
    char_u *rq_buffer;
    long_u rq_buflen;
    readq_T *rq_next;
    readq_T *rq_prev;
};

struct writeq_S
{
    garray_T wq_ga;
    writeq_T *wq_next;
    writeq_T *wq_prev;
};

struct jsonq_S
{
    typval_T *jq_value;
    jsonq_T *jq_next;
    jsonq_T *jq_prev;
    int jq_no_callback;
};

struct cbq_S
{
    callback_T cq_callback;
    int cq_seq_nr;
    cbq_T *cq_next;
    cbq_T *cq_prev;
};


typedef enum
{
    MODE_NL = 0,
    MODE_RAW,
    MODE_JSON,
    MODE_JS,
} ch_mode_T;

typedef enum {
    JIO_PIPE,
    JIO_NULL,
    JIO_FILE,
    JIO_BUFFER,
    JIO_OUT
} job_io_T;





typedef enum {
    PART_SOCK = 0,


    PART_OUT,

    PART_ERR,

    PART_IN,


    PART_COUNT,
} ch_part_T;




typedef struct {
    sock_T ch_fd;
# 2148 "./structs.h"
    ch_mode_T ch_mode;
    job_io_T ch_io;
    int ch_timeout;

    readq_T ch_head;
    jsonq_T ch_json_head;
    garray_T ch_block_ids;





    size_t ch_wait_len;



    struct timeval ch_deadline;

    int ch_block_write;

    int ch_nonblocking;
    writeq_T ch_writeque;

    cbq_T ch_cb_head;
    callback_T ch_callback;

    bufref_T ch_bufref;
    int ch_nomodifiable;
    int ch_nomod_error;
    int ch_buf_append;
    linenr_T ch_buf_top;
    linenr_T ch_buf_bot;
} chanpart_T;

struct channel_S {
    channel_T *ch_next;
    channel_T *ch_prev;

    int ch_id;
    int ch_last_msg_id;

    chanpart_T ch_part[PART_COUNT];
    int ch_write_text_mode;

    char *ch_hostname;
    int ch_port;

    int ch_to_be_closed;


    int ch_to_be_freed;

    int ch_error;





    void (*ch_nb_close_cb)(void);






    callback_T ch_callback;
    callback_T ch_close_cb;
    int ch_drop_never;
    int ch_keep_open;
    int ch_nonblock;

    job_T *ch_job;


    int ch_job_killed;

    int ch_anonymous_pipe;
    int ch_killing;

    int ch_refcount;
    int ch_copyID;
};
# 2293 "./structs.h"
typedef struct
{
    int jo_set;
    int jo_set2;

    ch_mode_T jo_mode;
    ch_mode_T jo_in_mode;
    ch_mode_T jo_out_mode;
    ch_mode_T jo_err_mode;
    int jo_noblock;

    job_io_T jo_io[4];
    char_u jo_io_name_buf[4][65];
    char_u *jo_io_name[4];
    int jo_io_buf[4];
    int jo_pty;
    int jo_modifiable[4];
    int jo_message[4];
    channel_T *jo_channel;

    linenr_T jo_in_top;
    linenr_T jo_in_bot;

    callback_T jo_callback;
    callback_T jo_out_cb;
    callback_T jo_err_cb;
    callback_T jo_close_cb;
    callback_T jo_exit_cb;
    int jo_drop_never;
    int jo_waittime;
    int jo_timeout;
    int jo_out_timeout;
    int jo_err_timeout;
    int jo_block_write;
    int jo_part;
    int jo_id;
    char_u jo_stoponexit_buf[65];
    char_u *jo_stoponexit;
    dict_T *jo_env;
    char_u jo_cwd_buf[65];
    char_u *jo_cwd;



    int jo_term_rows;
    int jo_term_cols;
    int jo_vertical;
    int jo_curwin;
    buf_T *jo_bufnr_buf;
    int jo_hidden;
    int jo_term_norestore;
    char_u jo_term_name_buf[65];
    char_u *jo_term_name;
    char_u jo_term_opencmd_buf[65];
    char_u *jo_term_opencmd;
    int jo_term_finish;
    char_u jo_eof_chars_buf[65];
    char_u *jo_eof_chars;
    char_u jo_term_kill_buf[65];
    char_u *jo_term_kill;

    long_u jo_ansi_colors[16];

    char_u jo_term_highlight_buf[65];
    char_u *jo_term_highlight;
    int jo_tty_type;
    char_u jo_term_api_buf[65];
    char_u *jo_term_api;

} jobopt_T;





typedef struct listener_S listener_T;
struct listener_S
{
    listener_T *lr_next;
    int lr_id;
    callback_T lr_callback;
};





typedef struct ht_stack_S
{
    hashtab_T *ht;
    struct ht_stack_S *prev;
} ht_stack_T;




typedef struct list_stack_S
{
    list_T *list;
    struct list_stack_S *prev;
} list_stack_T;





typedef struct
{
    long_u dit_todo;
    hashitem_T *dit_hi;
} dict_iterator_T;
# 2421 "./structs.h"
typedef struct qf_info_S qf_info_T;





typedef struct {
    proftime_T total;
    proftime_T slowest;
    long count;
    long match;
} syn_time_T;


typedef struct timer_S timer_T;
struct timer_S
{
    long tr_id;

    timer_T *tr_next;
    timer_T *tr_prev;
    proftime_T tr_due;
    char tr_firing;
    char tr_paused;
    int tr_repeat;
    long tr_interval;
    callback_T tr_callback;
    int tr_emsg_count;

};






typedef struct {
    int method_nr;
    void *method_state;
} cryptstate_T;
# 2474 "./structs.h"
typedef enum {
    POPPOS_BOTLEFT,
    POPPOS_TOPLEFT,
    POPPOS_BOTRIGHT,
    POPPOS_TOPRIGHT,
    POPPOS_CENTER,
    POPPOS_NONE
} poppos_T;

typedef enum {
    POPCLOSE_NONE,
    POPCLOSE_BUTTON,
    POPCLOSE_CLICK
} popclose_T;
# 2499 "./structs.h"
typedef struct {

    hashtab_T b_keywtab;
    hashtab_T b_keywtab_ic;
    int b_syn_error;

    int b_syn_slow;

    int b_syn_ic;
    int b_syn_foldlevel;
    int b_syn_spell;
    garray_T b_syn_patterns;
    garray_T b_syn_clusters;
    int b_spell_cluster_id;
    int b_nospell_cluster_id;
    int b_syn_containedin;

    int b_syn_sync_flags;
    short b_syn_sync_id;
    long b_syn_sync_minlines;
    long b_syn_sync_maxlines;
    long b_syn_sync_linebreaks;
    char_u *b_syn_linecont_pat;
    regprog_T *b_syn_linecont_prog;

    syn_time_T b_syn_linecont_time;

    int b_syn_linecont_ic;
    int b_syn_topgrp;

    int b_syn_conceal;


    int b_syn_folditems;
# 2549 "./structs.h"
    synstate_T *b_sst_array;
    int b_sst_len;
    synstate_T *b_sst_first;
    synstate_T *b_sst_firstfree;
    int b_sst_freecount;
    linenr_T b_sst_check_lnum;
    short_u b_sst_lasttick;




    garray_T b_langp;
    char_u b_spell_ismw[256];
    char_u *b_spell_ismw_mb;
    char_u *b_p_spc;
    regprog_T *b_cap_prog;
    char_u *b_p_spf;
    char_u *b_p_spl;
    char_u *b_p_spo;
    int b_cjk;




    char_u b_syn_chartab[32];
    char_u *b_syn_isk;
} synblock_T;
# 2586 "./structs.h"
struct file_buffer
{
    memline_T b_ml;


    buf_T *b_next;
    buf_T *b_prev;

    int b_nwindows;

    int b_flags;
    int b_locked;
# 2606 "./structs.h"
    char_u *b_ffname;
    char_u *b_sfname;

    char_u *b_fname;



    int b_dev_valid;
    dev_t b_dev;
    ino_t b_ino;






    int b_fnum;
    char_u b_key[4 * 2 + 1];



    int b_changed;

    dictitem16_T b_ct_di;




    varnumber_T b_last_changedtick;

    varnumber_T b_last_changedtick_pum;


    int b_saving;






    int b_mod_set;

    linenr_T b_mod_top;
    linenr_T b_mod_bot;

    long b_mod_xlines;


    wininfo_T *b_wininfo;

    long b_mtime;
    long b_mtime_read;
    off_T b_orig_size;
    int b_orig_mode;

    time_T b_last_used;



    pos_T b_namedm[('z' - 'a' + 1)];


    visualinfo_T b_visual;

    int b_visual_mode_eval;


    pos_T b_last_cursor;

    pos_T b_last_insert;
    pos_T b_last_change;





    pos_T b_changelist[100];
    int b_changelistlen;
    int b_new_change;






    char_u b_chartab[32];


    mapblock_T *(b_maphash[256]);


    mapblock_T *b_first_abbr;


    garray_T b_ucmds;

    pos_T b_op_start;
    pos_T b_op_start_orig;
    pos_T b_op_end;


    int b_marks_read;





    u_header_T *b_u_oldhead;
    u_header_T *b_u_newhead;

    u_header_T *b_u_curhead;
    int b_u_numhead;
    int b_u_synced;
    long b_u_seq_last;
    long b_u_save_nr_last;
    long b_u_seq_cur;
    time_T b_u_time_cur;
    long b_u_save_nr_cur;




    undoline_T b_u_line_ptr;
    linenr_T b_u_line_lnum;
    colnr_T b_u_line_colnr;

    int b_scanned;


    long b_p_iminsert;
    long b_p_imsearch;







    short b_kmap_state;


    garray_T b_kmap_ga;







    int b_p_initialized;


    sctx_T b_p_script_ctx[BV_COUNT];


    int b_p_ai;
    int b_p_ai_nopaste;
    char_u *b_p_bkc;
    unsigned b_bkc_flags;
    int b_p_ci;
    int b_p_bin;
    int b_p_bomb;
    char_u *b_p_bh;
    char_u *b_p_bt;



    int b_has_qf_entry;

    int b_p_bl;

    int b_p_cin;
    char_u *b_p_cino;
    char_u *b_p_cink;


    char_u *b_p_cinw;

    char_u *b_p_com;

    char_u *b_p_cms;

    char_u *b_p_cpt;




    char_u *b_p_cfu;
    char_u *b_p_ofu;


    char_u *b_p_tfu;

    int b_p_eol;
    int b_p_fixeol;
    int b_p_et;
    int b_p_et_nobin;
    int b_p_et_nopaste;
    char_u *b_p_fenc;
    char_u *b_p_ff;
    char_u *b_p_ft;
    char_u *b_p_fo;
    char_u *b_p_flp;
    int b_p_inf;
    char_u *b_p_isk;

    char_u *b_p_def;
    char_u *b_p_inc;

    char_u *b_p_inex;
    long_u b_p_inex_flags;



    char_u *b_p_inde;
    long_u b_p_inde_flags;
    char_u *b_p_indk;

    char_u *b_p_fp;

    char_u *b_p_fex;
    long_u b_p_fex_flags;


    char_u *b_p_key;

    char_u *b_p_kp;

    int b_p_lisp;

    char_u *b_p_menc;
    char_u *b_p_mps;
    int b_p_ml;
    int b_p_ml_nobin;
    int b_p_ma;
    char_u *b_p_nf;
    int b_p_pi;

    char_u *b_p_qe;

    int b_p_ro;
    long b_p_sw;
    int b_p_sn;

    int b_p_si;

    long b_p_sts;
    long b_p_sts_nopaste;

    char_u *b_p_sua;

    int b_p_swf;

    long b_p_smc;
    char_u *b_p_syn;

    long b_p_ts;
    int b_p_tx;
    long b_p_tw;
    long b_p_tw_nobin;
    long b_p_tw_nopaste;
    long b_p_wm;
    long b_p_wm_nobin;
    long b_p_wm_nopaste;

    char_u *b_p_vsts;
    int *b_p_vsts_array;
    char_u *b_p_vsts_nopaste;
    char_u *b_p_vts;
    int *b_p_vts_array;


    char_u *b_p_keymap;






    char_u *b_p_gp;
    char_u *b_p_mp;
    char_u *b_p_efm;

    char_u *b_p_ep;
    char_u *b_p_path;
    int b_p_ar;
    char_u *b_p_tags;
    char_u *b_p_tc;
    unsigned b_tc_flags;
    char_u *b_p_dict;
    char_u *b_p_tsr;
    long b_p_ul;

    int b_p_udf;


    char_u *b_p_lw;


    long b_p_twsl;
# 2914 "./structs.h"
    int b_ind_level;
    int b_ind_open_imag;
    int b_ind_no_brace;
    int b_ind_first_open;
    int b_ind_open_extra;
    int b_ind_close_extra;
    int b_ind_open_left_imag;
    int b_ind_jump_label;
    int b_ind_case;
    int b_ind_case_code;
    int b_ind_case_break;
    int b_ind_param;
    int b_ind_func_type;
    int b_ind_comment;
    int b_ind_in_comment;
    int b_ind_in_comment2;
    int b_ind_cpp_baseclass;
    int b_ind_continuation;
    int b_ind_unclosed;
    int b_ind_unclosed2;
    int b_ind_unclosed_noignore;
    int b_ind_unclosed_wrapped;
    int b_ind_unclosed_whiteok;
    int b_ind_matching_paren;
    int b_ind_paren_prev;
    int b_ind_maxparen;
    int b_ind_maxcomment;
    int b_ind_scopedecl;
    int b_ind_scopedecl_code;
    int b_ind_java;
    int b_ind_js;
    int b_ind_keep_case_label;
    int b_ind_hash_comment;
    int b_ind_cpp_namespace;
    int b_ind_if_for_while;
    int b_ind_cpp_extern_c;
    int b_ind_pragma;


    linenr_T b_no_eol_lnum;


    int b_start_eol;
    int b_start_ffc;
    char_u *b_start_fenc;
    int b_bad_char;
    int b_start_bomb;


    dictitem_T b_bufvar;
    dict_T *b_vars;

    listener_T *b_listener;
    list_T *b_recorded_changes;


    int b_has_textprop;
    hashtab_T *b_proptypes;



    char_u *b_p_bexpr;
    long_u b_p_bexpr_flags;


    char_u *b_p_cm;





    int b_may_swap;
    int b_did_warn;






    int b_help;


    int b_spell;




    int b_shortname;


    char_u *b_prompt_text;
    callback_T b_prompt_callback;
    callback_T b_prompt_interrupt;
    int b_prompt_insert;
# 3035 "./structs.h"
    synblock_T b_s;





    sign_entry_T *b_signlist;

    int b_has_sign_column;






    int b_netbeans_file;
    int b_was_netbeans_file;


    int b_write_to_channel;




    cryptstate_T *b_cryptstate;


    int b_mapped_ctrl_c;


    term_T *b_term;



    int b_diff_failed;

};
# 3094 "./structs.h"
typedef struct diffblock_S diff_T;
struct diffblock_S
{
    diff_T *df_next;
    linenr_T df_lnum[8];
    linenr_T df_count[8];
};
# 3113 "./structs.h"
typedef struct tabpage_S tabpage_T;
struct tabpage_S
{
    tabpage_T *tp_next;
    frame_T *tp_topframe;
    win_T *tp_curwin;
    win_T *tp_prevwin;
    win_T *tp_firstwin;
    win_T *tp_lastwin;

    win_T *tp_first_popupwin;

    long tp_old_Rows;
    long tp_old_Columns;
    long tp_ch_used;






    char_u *tp_localdir;

    char_u *tp_prevdir;


    diff_T *tp_first_diff;
    buf_T *(tp_diffbuf[8]);
    int tp_diff_invalid;
    int tp_diff_update;

    frame_T *(tp_snapshot[2]);

    dictitem_T tp_winvar;
    dict_T *tp_vars;
# 3157 "./structs.h"
};
# 3171 "./structs.h"
typedef struct w_line
{
    linenr_T wl_lnum;
    short_u wl_size;
    char wl_valid;

    char wl_folded;
    linenr_T wl_lastlnum;

} wline_T;





struct frame_S
{
    char fr_layout;
    int fr_width;
    int fr_newwidth;
    int fr_height;
    int fr_newheight;
    frame_T *fr_parent;
    frame_T *fr_next;

    frame_T *fr_prev;


    frame_T *fr_child;
    win_T *fr_win;
};
# 3213 "./structs.h"
typedef struct
{
    regmmatch_T rm;

    buf_T *buf;
    linenr_T lnum;
    int attr;
    int attr_cur;
    linenr_T first_lnum;
    colnr_T startcol;
    colnr_T endcol;
    int is_addpos;


    proftime_T tm;

} match_T;







typedef struct
{
    linenr_T lnum;
    colnr_T col;
    int len;
} llpos_T;





typedef struct posmatch posmatch_T;
struct posmatch
{
    llpos_T pos[8];
    int cur;
    linenr_T toplnum;
    linenr_T botlnum;
};





typedef struct matchitem matchitem_T;
struct matchitem
{
    matchitem_T *next;
    int id;
    int priority;
    char_u *pattern;
    regmmatch_T match;
    posmatch_T pos;
    match_T hl;
    int hlg_id;

    int conceal_char;

};



typedef struct
{
    int w_topline_save;
    int w_topline_corr;
    pos_T w_cursor_save;
    pos_T w_cursor_corr;
} pos_save_T;


typedef struct {
    int wb_startcol;
    int wb_endcol;
    vimmenu_T *wb_menu;
} winbar_item_T;







struct window_S
{
    int w_id;

    buf_T *w_buffer;

    win_T *w_prev;
    win_T *w_next;


    synblock_T *w_s;


    int w_closing;


    frame_T *w_frame;

    pos_T w_cursor;

    colnr_T w_curswant;



    int w_set_curswant;




    linenr_T w_last_cursorline;





    char w_old_visual_mode;
    linenr_T w_old_cursor_lnum;
    colnr_T w_old_cursor_fcol;
    colnr_T w_old_cursor_lcol;
    linenr_T w_old_visual_lnum;
    colnr_T w_old_visual_col;
    colnr_T w_old_curswant;





    linenr_T w_topline;

    char w_topline_was_set;


    linenr_T w_botline;



    int w_topfill;
    int w_old_topfill;
    int w_botfill;

    int w_old_botfill;

    colnr_T w_leftcol;


    colnr_T w_skipcol;


    int w_empty_rows;

    int w_filler_rows;







    int w_winrow;
    int w_height;


    int w_status_height;
    int w_wincol;
    int w_width;
    int w_vsep_width;

    pos_save_T w_save_cursor;


    int w_popup_flags;
    int w_popup_handled;
    char_u *w_popup_title;
    poppos_T w_popup_pos;
    int w_popup_fixed;
    int w_popup_prop_type;
    win_T *w_popup_prop_win;
    int w_popup_prop_id;
    int w_zindex;
    int w_minheight;
    int w_minwidth;
    int w_maxheight;
    int w_maxwidth;
    int w_maxwidth_opt;
    int w_wantline;
    int w_wantcol;
    int w_firstline;
    int w_want_scrollbar;
    int w_has_scrollbar;
    char_u *w_scrollbar_highlight;
    char_u *w_thumb_highlight;
    int w_popup_padding[4];
    int w_popup_border[4];
    char_u *w_border_highlight[4];
    int w_border_char[8];

    int w_popup_leftoff;
    int w_popup_rightoff;
    varnumber_T w_popup_last_changedtick;

    varnumber_T w_popup_prop_changedtick;


    int w_popup_prop_topline;


    linenr_T w_popup_last_curline;

    callback_T w_close_cb;
    callback_T w_filter_cb;
    int w_filter_errors;
    int w_filter_mode;

    win_T *w_popup_curwin;
    linenr_T w_popup_lnum;
    colnr_T w_popup_mincol;
    colnr_T w_popup_maxcol;
    int w_popup_mouse_row;
    int w_popup_mouse_mincol;
    int w_popup_mouse_maxcol;
    popclose_T w_popup_close;

    list_T *w_popup_mask;
    char_u *w_popup_mask_cells;
    int w_popup_mask_height;
    int w_popup_mask_width;

    timer_T *w_popup_timer;


    int w_flags;
# 3467 "./structs.h"
    int w_valid;
    pos_T w_valid_cursor;

    colnr_T w_valid_leftcol;





    int w_cline_height;

    int w_cline_folded;


    int w_cline_row;

    colnr_T w_virtcol;
# 3495 "./structs.h"
    int w_wrow, w_wcol;
# 3507 "./structs.h"
    int w_lines_valid;
    wline_T *w_lines;


    garray_T w_folds;
    char w_fold_manual;

    char w_foldinvalid;



    int w_nrwidth;







    int w_redr_type;
    int w_upd_rows;

    linenr_T w_redraw_top;
    linenr_T w_redraw_bot;
    int w_redr_status;



    pos_T w_ru_cursor;
    colnr_T w_ru_virtcol;
    linenr_T w_ru_topline;
    linenr_T w_ru_line_count;

    int w_ru_topfill;

    char w_ru_empty;


    int w_alt_fnum;

    alist_T *w_alist;
    int w_arg_idx;

    int w_arg_idx_invalid;

    char_u *w_localdir;

    char_u *w_prevdir;

    vimmenu_T *w_winbar;
    winbar_item_T *w_winbar_items;
    int w_winbar_height;
# 3568 "./structs.h"
    winopt_T w_onebuf_opt;
    winopt_T w_allbuf_opt;



    long_u w_p_stl_flags;


    long_u w_p_fde_flags;
    long_u w_p_fdt_flags;


    int *w_p_cc_cols;
    char_u w_p_culopt_flags;

    long w_p_siso;
    long w_p_so;


    int w_briopt_min;
    int w_briopt_shift;
    int w_briopt_sbr;





    long w_scbind_pos;


    dictitem_T w_winvar;
    dict_T *w_vars;







    pos_T w_pcmark;
    pos_T w_prev_pcmark;





    xfmark_T w_jumplist[100];
    int w_jumplistlen;
    int w_jumplistidx;

    int w_changelistidx;



    matchitem_T *w_match_head;
    int w_next_match_id;
# 3632 "./structs.h"
    taggy_T w_tagstack[20];
    int w_tagstackidx;
    int w_tagstacklen;







    int w_fraction;
    int w_prev_fraction_row;





    linenr_T w_nrwidth_line_count;

    long w_nuw_cached;
    int w_nrwidth_width;



    qf_info_T *w_llist;




    qf_info_T *w_llist_ref;
# 3687 "./structs.h"
};




typedef struct oparg_S
{
    int op_type;
    int regname;
    int motion_type;
    int motion_force;
    int use_reg_one;

    int inclusive;

    int end_adjusted;

    pos_T start;
    pos_T end;
    pos_T cursor_start;

    long line_count;

    int empty;

    int is_VIsual;
    int block_mode;
    colnr_T start_vcol;
    colnr_T end_vcol;
    long prev_opcount;
    long prev_count0;
} oparg_T;




typedef struct cmdarg_S
{
    oparg_T *oap;
    int prechar;
    int cmdchar;
    int nchar;
    int ncharC1;
    int ncharC2;
    int extra_char;
    long opcount;
    long count0;
    long count1;
    int arg;
    int retval;
    char_u *searchbuf;
} cmdarg_T;
# 3778 "./structs.h"
typedef struct cursor_entry
{
    int shape;
    int mshape;
    int percentage;
    long blinkwait;
    long blinkon;
    long blinkoff;
    int id;
    int id_lm;
    char *name;
    char used_for;
} cursorentry_T;
# 3822 "./structs.h"
struct VimMenu
{
    int modes;
    int enabled;
    char_u *name;
    char_u *dname;

    char_u *en_name;

    char_u *en_dname;


    int mnemonic;
    char_u *actext;
    int priority;
# 3845 "./structs.h"
    char_u *strings[8];
    int noremap[8];
    char silent[8];
    vimmenu_T *children;
    vimmenu_T *parent;
    vimmenu_T *next;
# 3890 "./structs.h"
};
# 3901 "./structs.h"
typedef struct
{
    buf_T *save_curbuf;
    int use_aucmd_win;
    int save_curwin_id;
    int new_curwin_id;
    int save_prevwin_id;
    bufref_T new_curbuf;
    char_u *globaldir;
} aco_save_T;




typedef struct
{
    const char *name;
    int hasnum;
    long number;
    char_u *string;
    int strlen;
    int present;
} option_table_T;




typedef struct
{
    long_u fg_color;
    long_u bg_color;
    int bold;
    int italic;
    int underline;
    int undercurl;
} prt_text_attr_T;




typedef struct
{
    int n_collated_copies;
    int n_uncollated_copies;
    int duplex;
    int chars_per_line;
    int lines_per_page;
    int has_color;
    prt_text_attr_T number;

    int modec;
    int do_syntax;

    int user_abort;
    char_u *jobname;

    char_u *outfile;
    char_u *arguments;

} prt_settings_T;






typedef struct
{
    char_u *pum_text;
    char_u *pum_kind;
    char_u *pum_extra;
    char_u *pum_info;
} pumitem_T;




typedef struct
{
    char_u *tn_tags;
    char_u *tn_np;
    int tn_did_filefind_init;
    int tn_hf_idx;
    void *tn_search_ctx;
} tagname_T;

typedef struct {
  UINT32_T total[2];
  UINT32_T state[8];
  char_u buffer[64];
} context_sha256_T;




typedef enum
{
    EXPR_UNKNOWN = 0,
    EXPR_EQUAL,
    EXPR_NEQUAL,
    EXPR_GREATER,
    EXPR_GEQUAL,
    EXPR_SMALLER,
    EXPR_SEQUAL,
    EXPR_MATCH,
    EXPR_NOMATCH,
    EXPR_IS,
    EXPR_ISNOT,

    EXPR_ADD,
    EXPR_SUB,
    EXPR_MULT,
    EXPR_DIV,
    EXPR_REM,
} exptype_T;




struct js_reader
{
    char_u *js_buf;
    char_u *js_end;
    int js_used;
    int (*js_fill)(struct js_reader *);


    void *js_cookie;
    int js_cookie_arg;
};
typedef struct js_reader js_read_T;
# 4042 "./structs.h"
typedef struct
{
    int argc;
    char **argv;

    char_u *fname;

    int evim_mode;
    char_u *use_vimrc;
    int clean;

    int n_commands;
    char_u *commands[10];
    char_u cmds_tofree[10];
    int n_pre_commands;
    char_u *pre_commands[10];

    int edit_type;
    char_u *tagname;

    char_u *use_ef;


    int want_full_screen;
    int not_a_term;
    int tty_fail;
    char_u *term;

    int ask_for_key;

    int no_swap_file;

    int use_debug_break_level;

    int window_count;
    int window_layout;


    int serverArg;
    char_u *serverName_arg;
    char_u *serverStr;
    char_u *serverStrEnc;
    char_u *servername;
# 4094 "./structs.h"
    int diff_mode;

} mparm_T;
# 4125 "./structs.h"
typedef struct lval_S
{
    char_u *ll_name;
    char_u *ll_name_end;
    type_T *ll_type;
    char_u *ll_exp_name;
    typval_T *ll_tv;


    listitem_T *ll_li;
    list_T *ll_list;
    int ll_range;
    int ll_empty2;
    long ll_n1;
    long ll_n2;
    dict_T *ll_dict;
    dictitem_T *ll_di;
    char_u *ll_newkey;
    type_T *ll_valtype;
    blob_T *ll_blob;
} lval_T;



typedef struct {
    int save_msg_scroll;
    int save_restart_edit;
    int save_msg_didout;
    int save_State;
    int save_insertmode;
    int save_finish_op;
    int save_opcount;
    int save_reg_executing;
    tasave_T tabuf;
} save_state_T;

typedef struct {
    varnumber_T vv_prevcount;
    varnumber_T vv_count;
    varnumber_T vv_count1;
} vimvars_save_T;


typedef enum {
    CDSCOPE_GLOBAL,
    CDSCOPE_TABPAGE,
    CDSCOPE_WINDOW
} cdscope_T;


typedef enum
{
    VAR_FLAVOUR_DEFAULT,
    VAR_FLAVOUR_SESSION,
    VAR_FLAVOUR_VIMINFO
} var_flavour_T;


typedef enum {
    IGNORE_POPUP,
    FIND_POPUP,
    FAIL_POPUP
} mouse_find_T;
# 4215 "./structs.h"
struct block_def
{
    int startspaces;
    int endspaces;
    int textlen;
    char_u *textstart;
    colnr_T textcol;
    colnr_T start_vcol;
    colnr_T end_vcol;
    int is_short;
    int is_MAX;
    int is_oneChar;
    int pre_whitesp;
    int pre_whitesp_c;
    colnr_T end_char_vcols;
    colnr_T start_char_vcols;
};


typedef struct
{
    char_u **y_array;
    linenr_T y_size;
    char_u y_type;
    colnr_T y_width;

    time_t y_time_set;

} yankreg_T;



typedef struct soffset
{
    int dir;
    int line;
    int end;
    long off;
} soffset_T;


typedef struct spat
{
    char_u *pat;
    int magic;
    int no_scs;
    soffset_T off;
} spat_T;




typedef struct
{
    linenr_T sa_stop_lnum;

    proftime_T *sa_tm;
    int sa_timed_out;

    int sa_wrapped;
} searchit_arg_T;
# 1816 "./vim.h" 2

# 1 "./alloc.h" 1
# 13 "./alloc.h"
typedef enum {
 aid_none = 0,
 aid_qf_dirname_start,
 aid_qf_dirname_now,
 aid_qf_namebuf,
 aid_qf_module,
 aid_qf_errmsg,
 aid_qf_pattern,
 aid_tagstack_items,
 aid_tagstack_from,
 aid_tagstack_details,
 aid_sign_getdefined,
 aid_sign_getplaced,
 aid_sign_define_by_name,
 aid_sign_getlist,
 aid_sign_getplaced_dict,
 aid_sign_getplaced_list,
 aid_insert_sign,
 aid_sign_getinfo,
 aid_last
} alloc_id_T;
# 1818 "./vim.h" 2
# 2045 "./vim.h"
typedef struct
{
    int available;
    int owned;
    pos_T start;
    pos_T end;
    int vmode;


    short_u origin_row;
    short_u origin_start_col;
    short_u origin_end_col;
    short_u word_start_col;
    short_u word_end_col;


    short_u min_col;
    short_u max_col;
    short_u min_row;
    short_u max_row;


    pos_T prev;
    short_u state;
    short_u mode;


    Atom sel_atom;
# 2086 "./vim.h"
} Clipboard_T;
# 2096 "./vim.h"
typedef struct stat stat_T;






typedef enum {
    ASSERT_EQUAL,
    ASSERT_NOTEQUAL,
    ASSERT_MATCH,
    ASSERT_NOTMATCH,
    ASSERT_OTHER
} assert_type_T;


typedef enum {
    PASTE_INSERT,
    PASTE_CMDLINE,
    PASTE_EX,
    PASTE_ONE_CHAR
} paste_mode_T;


typedef enum {
    FLUSH_MINIMAL,
    FLUSH_TYPEAHEAD,
    FLUSH_INPUT
} flush_buffers_T;


typedef enum {
    USEPOPUP_NONE,
    USEPOPUP_NORMAL,
    USEPOPUP_HIDDEN
} use_popup_T;


typedef enum {
    ESTACK_NONE,
    ESTACK_SFILE,
    ESTACK_STACK
} estack_arg_T;







# 1 "./ex_cmds.h" 1
# 67 "./ex_cmds.h"
typedef enum {
    ADDR_LINES,
    ADDR_WINDOWS,
    ADDR_ARGUMENTS,
    ADDR_LOADED_BUFFERS,
    ADDR_BUFFERS,
    ADDR_TABS,
    ADDR_TABS_RELATIVE,
    ADDR_QUICKFIX_VALID,
    ADDR_QUICKFIX,
    ADDR_UNSIGNED,
    ADDR_OTHER,
    ADDR_NONE
} cmd_addr_T;



typedef struct exarg exarg_T;
# 109 "./ex_cmds.h"
enum CMD_index

{
CMD_append,


CMD_abbreviate,


CMD_abclear,


CMD_aboveleft,


CMD_all,


CMD_amenu,


CMD_anoremenu,


CMD_args,


CMD_argadd,


CMD_argdelete,


CMD_argdo,


CMD_argedit,


CMD_argglobal,


CMD_arglocal,


CMD_argument,


CMD_ascii,


CMD_autocmd,


CMD_augroup,


CMD_aunmenu,


CMD_buffer,


CMD_bNext,


CMD_ball,


CMD_badd,


CMD_balt,


CMD_bdelete,


CMD_behave,


CMD_belowright,


CMD_bfirst,


CMD_blast,


CMD_bmodified,


CMD_bnext,


CMD_botright,


CMD_bprevious,


CMD_brewind,


CMD_break,


CMD_breakadd,


CMD_breakdel,


CMD_breaklist,


CMD_browse,


CMD_buffers,


CMD_bufdo,


CMD_bunload,


CMD_bwipeout,


CMD_change,


CMD_cNext,


CMD_cNfile,


CMD_cabbrev,


CMD_cabclear,


CMD_cabove,


CMD_caddbuffer,


CMD_caddexpr,


CMD_caddfile,


CMD_cafter,


CMD_call,


CMD_catch,


CMD_cbuffer,


CMD_cbefore,


CMD_cbelow,


CMD_cbottom,


CMD_cc,


CMD_cclose,


CMD_cd,


CMD_cdo,


CMD_center,


CMD_cexpr,


CMD_cfile,


CMD_cfdo,


CMD_cfirst,


CMD_cgetfile,


CMD_cgetbuffer,


CMD_cgetexpr,


CMD_chdir,


CMD_changes,


CMD_checkpath,


CMD_checktime,


CMD_chistory,


CMD_clist,


CMD_clast,


CMD_close,


CMD_clearjumps,


CMD_cmap,


CMD_cmapclear,


CMD_cmenu,


CMD_cnext,


CMD_cnewer,


CMD_cnfile,


CMD_cnoremap,


CMD_cnoreabbrev,


CMD_cnoremenu,


CMD_copy,


CMD_colder,


CMD_colorscheme,


CMD_command,


CMD_comclear,


CMD_compiler,


CMD_continue,


CMD_confirm,


CMD_const,


CMD_copen,


CMD_cprevious,


CMD_cpfile,


CMD_cquit,


CMD_crewind,


CMD_cscope,


CMD_cstag,


CMD_cunmap,


CMD_cunabbrev,


CMD_cunmenu,


CMD_cwindow,


CMD_delete,


CMD_delmarks,


CMD_debug,


CMD_debuggreedy,


CMD_def,


CMD_defcompile,


CMD_delcommand,


CMD_delfunction,


CMD_display,


CMD_diffupdate,


CMD_diffget,


CMD_diffoff,


CMD_diffpatch,


CMD_diffput,


CMD_diffsplit,


CMD_diffthis,


CMD_digraphs,


CMD_disassemble,


CMD_djump,


CMD_dlist,


CMD_doautocmd,


CMD_doautoall,


CMD_drop,


CMD_dsearch,


CMD_dsplit,


CMD_edit,


CMD_earlier,


CMD_echo,


CMD_echoerr,


CMD_echohl,


CMD_echomsg,


CMD_echon,


CMD_else,


CMD_elseif,


CMD_emenu,


CMD_endif,


CMD_enddef,


CMD_endfunction,


CMD_endfor,


CMD_endtry,


CMD_endwhile,


CMD_enew,


CMD_eval,


CMD_ex,


CMD_execute,


CMD_exit,


CMD_export,


CMD_exusage,


CMD_file,


CMD_files,


CMD_filetype,


CMD_filter,


CMD_find,


CMD_final,


CMD_finally,


CMD_finish,


CMD_first,


CMD_fixdel,


CMD_fold,


CMD_foldclose,


CMD_folddoopen,


CMD_folddoclosed,


CMD_foldopen,


CMD_for,


CMD_function,


CMD_global,


CMD_goto,


CMD_grep,


CMD_grepadd,


CMD_gui,


CMD_gvim,


CMD_help,


CMD_helpclose,


CMD_helpfind,


CMD_helpgrep,


CMD_helptags,


CMD_hardcopy,


CMD_highlight,


CMD_hide,


CMD_history,


CMD_insert,


CMD_iabbrev,


CMD_iabclear,


CMD_if,


CMD_ijump,


CMD_ilist,


CMD_imap,


CMD_imapclear,


CMD_imenu,


CMD_import,


CMD_inoremap,


CMD_inoreabbrev,


CMD_inoremenu,


CMD_intro,


CMD_isearch,


CMD_isplit,


CMD_iunmap,


CMD_iunabbrev,


CMD_iunmenu,


CMD_join,


CMD_jumps,


CMD_k,


CMD_keepmarks,


CMD_keepjumps,


CMD_keeppatterns,


CMD_keepalt,


CMD_list,


CMD_lNext,


CMD_lNfile,


CMD_last,


CMD_labove,


CMD_language,


CMD_laddexpr,


CMD_laddbuffer,


CMD_laddfile,


CMD_lafter,


CMD_later,


CMD_lbuffer,


CMD_lbefore,


CMD_lbelow,


CMD_lbottom,


CMD_lcd,


CMD_lchdir,


CMD_lclose,


CMD_lcscope,


CMD_ldo,


CMD_left,


CMD_leftabove,


CMD_let,


CMD_lexpr,


CMD_lfile,


CMD_lfdo,


CMD_lfirst,


CMD_lgetfile,


CMD_lgetbuffer,


CMD_lgetexpr,


CMD_lgrep,


CMD_lgrepadd,


CMD_lhelpgrep,


CMD_lhistory,


CMD_ll,


CMD_llast,


CMD_llist,


CMD_lmap,


CMD_lmapclear,


CMD_lmake,


CMD_lnoremap,


CMD_lnext,


CMD_lnewer,


CMD_lnfile,


CMD_loadview,


CMD_loadkeymap,


CMD_lockmarks,


CMD_lockvar,


CMD_lolder,


CMD_lopen,


CMD_lprevious,


CMD_lpfile,


CMD_lrewind,


CMD_ltag,


CMD_lunmap,


CMD_lua,


CMD_luado,


CMD_luafile,


CMD_lvimgrep,


CMD_lvimgrepadd,


CMD_lwindow,


CMD_ls,


CMD_move,


CMD_mark,


CMD_make,


CMD_map,


CMD_mapclear,


CMD_marks,


CMD_match,


CMD_menu,


CMD_menutranslate,


CMD_messages,


CMD_mkexrc,


CMD_mksession,


CMD_mkspell,


CMD_mkvimrc,


CMD_mkview,


CMD_mode,


CMD_mzscheme,


CMD_mzfile,


CMD_next,


CMD_nbkey,


CMD_nbclose,


CMD_nbstart,


CMD_new,


CMD_nmap,


CMD_nmapclear,


CMD_nmenu,


CMD_nnoremap,


CMD_nnoremenu,


CMD_noremap,


CMD_noautocmd,


CMD_nohlsearch,


CMD_noreabbrev,


CMD_noremenu,


CMD_noswapfile,


CMD_normal,


CMD_number,


CMD_nunmap,


CMD_nunmenu,


CMD_open,


CMD_oldfiles,


CMD_omap,


CMD_omapclear,


CMD_omenu,


CMD_only,


CMD_onoremap,


CMD_onoremenu,


CMD_options,


CMD_ounmap,


CMD_ounmenu,


CMD_ownsyntax,


CMD_print,


CMD_packadd,


CMD_packloadall,


CMD_pclose,


CMD_perl,


CMD_perldo,


CMD_pedit,


CMD_pop,


CMD_popup,


CMD_ppop,


CMD_preserve,


CMD_previous,


CMD_promptfind,


CMD_promptrepl,


CMD_profile,


CMD_profdel,


CMD_psearch,


CMD_ptag,


CMD_ptNext,


CMD_ptfirst,


CMD_ptjump,


CMD_ptlast,


CMD_ptnext,


CMD_ptprevious,


CMD_ptrewind,


CMD_ptselect,


CMD_put,


CMD_pwd,


CMD_python,


CMD_pydo,


CMD_pyfile,


CMD_py3,


CMD_py3do,


CMD_python3,


CMD_py3file,


CMD_pyx,


CMD_pyxdo,


CMD_pythonx,


CMD_pyxfile,


CMD_quit,


CMD_quitall,


CMD_qall,


CMD_read,


CMD_recover,


CMD_redo,


CMD_redir,


CMD_redraw,


CMD_redrawstatus,


CMD_redrawtabline,


CMD_registers,


CMD_resize,


CMD_retab,


CMD_return,


CMD_rewind,


CMD_right,


CMD_rightbelow,


CMD_runtime,


CMD_ruby,


CMD_rubydo,


CMD_rubyfile,


CMD_rundo,


CMD_rviminfo,


CMD_substitute,


CMD_sNext,


CMD_sargument,


CMD_sall,


CMD_sandbox,


CMD_saveas,


CMD_sbuffer,


CMD_sbNext,


CMD_sball,


CMD_sbfirst,


CMD_sblast,


CMD_sbmodified,


CMD_sbnext,


CMD_sbprevious,


CMD_sbrewind,


CMD_scriptnames,


CMD_scriptencoding,


CMD_scriptversion,


CMD_scscope,


CMD_set,


CMD_setfiletype,


CMD_setglobal,


CMD_setlocal,


CMD_sfind,


CMD_sfirst,


CMD_shell,


CMD_simalt,


CMD_sign,


CMD_silent,


CMD_sleep,


CMD_slast,


CMD_smagic,


CMD_smap,


CMD_smapclear,


CMD_smenu,


CMD_snext,


CMD_snomagic,


CMD_snoremap,


CMD_snoremenu,


CMD_source,


CMD_sort,


CMD_split,


CMD_spellgood,


CMD_spelldump,


CMD_spellinfo,


CMD_spellrepall,


CMD_spellrare,


CMD_spellundo,


CMD_spellwrong,


CMD_sprevious,


CMD_srewind,


CMD_stop,


CMD_stag,


CMD_startinsert,


CMD_startgreplace,


CMD_startreplace,


CMD_stopinsert,


CMD_stjump,


CMD_stselect,


CMD_sunhide,


CMD_sunmap,


CMD_sunmenu,


CMD_suspend,


CMD_sview,


CMD_swapname,


CMD_syntax,


CMD_syntime,


CMD_syncbind,


CMD_smile,


CMD_t,


CMD_tNext,


CMD_tag,


CMD_tags,


CMD_tab,


CMD_tabclose,


CMD_tabdo,


CMD_tabedit,


CMD_tabfind,


CMD_tabfirst,


CMD_tabmove,


CMD_tablast,


CMD_tabnext,


CMD_tabnew,


CMD_tabonly,


CMD_tabprevious,


CMD_tabNext,


CMD_tabrewind,


CMD_tabs,


CMD_tcd,


CMD_tchdir,


CMD_tcl,


CMD_tcldo,


CMD_tclfile,


CMD_tearoff,


CMD_terminal,


CMD_tfirst,


CMD_throw,


CMD_tjump,


CMD_tlast,


CMD_tlmenu,


CMD_tlnoremenu,


CMD_tlunmenu,


CMD_tmenu,


CMD_tmap,


CMD_tmapclear,


CMD_tnext,


CMD_tnoremap,


CMD_topleft,


CMD_tprevious,


CMD_trewind,


CMD_try,


CMD_tselect,


CMD_tunmenu,


CMD_tunmap,


CMD_undo,


CMD_undojoin,


CMD_undolist,


CMD_unabbreviate,


CMD_unhide,


CMD_unlet,


CMD_unlockvar,


CMD_unmap,


CMD_unmenu,


CMD_unsilent,


CMD_update,


CMD_vglobal,


CMD_var,


CMD_version,


CMD_verbose,


CMD_vertical,


CMD_visual,


CMD_view,


CMD_vimgrep,


CMD_vimgrepadd,


CMD_vim9script,


CMD_viusage,


CMD_vmap,


CMD_vmapclear,


CMD_vmenu,


CMD_vnoremap,


CMD_vnew,


CMD_vnoremenu,


CMD_vsplit,


CMD_vunmap,


CMD_vunmenu,


CMD_write,


CMD_wNext,


CMD_wall,


CMD_while,


CMD_winsize,


CMD_wincmd,


CMD_windo,


CMD_winpos,


CMD_wnext,


CMD_wprevious,


CMD_wq,


CMD_wqall,


CMD_wundo,


CMD_wviminfo,


CMD_xit,


CMD_xall,


CMD_xmap,


CMD_xmapclear,


CMD_xmenu,


CMD_xnoremap,


CMD_xnoremenu,


CMD_xrestore,


CMD_xunmap,


CMD_xunmenu,


CMD_yank,


CMD_z,




CMD_bang,


CMD_pound,


CMD_and,


CMD_star,


CMD_lshift,


CMD_equal,


CMD_rshift,


CMD_at,


CMD_block,


CMD_endblock,


CMD_tilde,




CMD_Next,


CMD_Print,


CMD_X,






    CMD_SIZE,
    CMD_USER = -1,
    CMD_USER_BUF = -2

};


typedef enum CMD_index cmdidx_T;




struct exarg
{
    char_u *arg;
    char_u *nextcmd;
    char_u *cmd;
    char_u **cmdlinep;

    char_u *cmdline_tofree;

    cmdidx_T cmdidx;
    long argt;
    int skip;
    int forceit;
    int addr_count;
    linenr_T line1;
    linenr_T line2;
    cmd_addr_T addr_type;
    int flags;
    char_u *do_ecmd_cmd;
    linenr_T do_ecmd_lnum;
    int append;
    int usefilter;
    int amount;
    int regname;
    int force_bin;
    int read_edit;
    int force_ff;
    int force_enc;
    int bad_char;
    int useridx;
    char *errmsg;
    char_u *(*getline)(int, void *, int, getline_opt_T);
    void *cookie;

    cstack_T *cstack;

};
# 2146 "./vim.h" 2
# 1 "./spell.h" 1
# 41 "./spell.h"
typedef int idx_T;

typedef int salfirst_T;
# 60 "./spell.h"
typedef struct slang_S slang_T;
struct slang_S
{
    slang_T *sl_next;
    char_u *sl_name;
    char_u *sl_fname;
    int sl_add;

    char_u *sl_fbyts;
    long sl_fbyts_len;
    idx_T *sl_fidxs;
    char_u *sl_kbyts;
    idx_T *sl_kidxs;
    char_u *sl_pbyts;
    idx_T *sl_pidxs;

    char_u *sl_info;

    char_u sl_regions[8 * 2 + 1];


    char_u *sl_midword;

    hashtab_T sl_wordcount;

    int sl_compmax;
    int sl_compminlen;
    int sl_compsylmax;
    int sl_compoptions;
    garray_T sl_comppat;
    regprog_T *sl_compprog;

    char_u *sl_comprules;
    char_u *sl_compstartflags;
    char_u *sl_compallflags;
    char_u sl_nobreak;
    char_u *sl_syllable;
    garray_T sl_syl_items;

    int sl_prefixcnt;
    regprog_T **sl_prefprog;

    garray_T sl_rep;
    short sl_rep_first[256];

    garray_T sl_sal;
    salfirst_T sl_sal_first[256];

    int sl_followup;
    int sl_collapse;
    int sl_rem_accents;
    int sl_sofo;


    garray_T sl_repsal;
    short sl_repsal_first[256];
    int sl_nosplitsugs;
    int sl_nocompoundsugs;


    time_t sl_sugtime;
    char_u *sl_sbyts;
    idx_T *sl_sidxs;
    buf_T *sl_sugbuf;
    int sl_sugloaded;


    int sl_has_map;
    hashtab_T sl_map_hash;
    int sl_map_array[256];
    hashtab_T sl_sounddone;

};
# 191 "./spell.h"
typedef struct fromto_S
{
    char_u *ft_from;
    char_u *ft_to;
} fromto_T;




typedef struct salitem_S
{
    char_u *sm_lead;
    int sm_leadlen;
    char_u *sm_oneof;
    char_u *sm_rules;
    char_u *sm_to;
    int *sm_lead_w;
    int *sm_oneof_w;
    int *sm_to_w;
} salitem_T;
# 221 "./spell.h"
typedef struct langp_S
{
    slang_T *lp_slang;
    slang_T *lp_sallang;
    slang_T *lp_replang;
    int lp_region;
} langp_T;
# 239 "./spell.h"
typedef struct spelltab_S
{
    char_u st_isw[256];
    char_u st_isu[256];
    char_u st_fold[256];
    char_u st_upper[256];
} spelltab_T;








# 1 "/usr/include/wchar.h" 1 3 4
# 27 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/wchar.h" 2 3 4







# 1 "/llvm-project/build/lib/clang/12.0.0/include/stddef.h" 1 3 4
# 36 "/usr/include/wchar.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h" 1 3 4





typedef __mbstate_t mbstate_t;
# 43 "/usr/include/wchar.h" 2 3 4
# 83 "/usr/include/wchar.h" 3 4
struct tm;



extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) __attribute__ ((__nothrow__ ));


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) __attribute__ ((__nothrow__ ));



extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    locale_t __loc) __attribute__ ((__nothrow__ ));

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, locale_t __loc) __attribute__ ((__nothrow__ ));




extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) __attribute__ ((__nothrow__ ));



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) __attribute__ ((__nothrow__ ));







extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        locale_t __loc) __attribute__ ((__nothrow__ ));




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, locale_t __loc) __attribute__ ((__nothrow__ ));


extern wchar_t *wcsdup (const wchar_t *__s) __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__));
# 164 "/usr/include/wchar.h" 3 4
extern wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__));
# 174 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__));
# 187 "/usr/include/wchar.h" 3 4
extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__));
# 201 "/usr/include/wchar.h" 3 4
extern wchar_t *wcspbrk (const wchar_t *__wcs, const wchar_t *__accept)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__));
# 212 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsstr (const wchar_t *__haystack, const wchar_t *__needle)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__));



extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) __attribute__ ((__nothrow__ ));


extern size_t wcslen (const wchar_t *__s) __attribute__ ((__nothrow__ )) __attribute__ ((__pure__));
# 233 "/usr/include/wchar.h" 3 4
extern wchar_t *wcswcs (const wchar_t *__haystack, const wchar_t *__needle)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__));





extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__));
# 253 "/usr/include/wchar.h" 3 4
extern wchar_t *wmemchr (const wchar_t *__s, wchar_t __c, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__));



extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) __attribute__ ((__nothrow__ ));



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     __attribute__ ((__nothrow__ ));


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) __attribute__ ((__nothrow__ ));
# 284 "/usr/include/wchar.h" 3 4
extern wint_t btowc (int __c) __attribute__ ((__nothrow__ ));



extern int wctob (wint_t __c) __attribute__ ((__nothrow__ ));



extern int mbsinit (const mbstate_t *__ps) __attribute__ ((__nothrow__ )) __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) __attribute__ ((__nothrow__ ));


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ ));


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ ));
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ ));







extern wint_t __btowc_alias (int __c) __asm ("btowc");
extern __inline __attribute__ ((__gnu_inline__)) wint_t
__attribute__ ((__nothrow__ )) btowc (int __c)
{ return (__builtin_constant_p (__c) && __c >= '\0' && __c <= '\x7f'
   ? (wint_t) __c : __btowc_alias (__c)); }

extern int __wctob_alias (wint_t __c) __asm ("wctob");
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) wctob (wint_t __wc)
{ return (__builtin_constant_p (__wc) && __wc >= L'\0' && __wc <= L'\x7f'
   ? (int) __wc : __wctob_alias (__wc)); }

extern __inline __attribute__ ((__gnu_inline__)) size_t
__attribute__ ((__nothrow__ )) mbrlen (const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps)

{ return (__ps != ((void*)0)
   ? mbrtowc (((void*)0), __s, __n, __ps) : __mbrlen (__s, __n, ((void*)0))); }




extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ ));



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ ));





extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ ));



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ ));






extern int wcwidth (wchar_t __c) __attribute__ ((__nothrow__ ));



extern int wcswidth (const wchar_t *__s, size_t __n) __attribute__ ((__nothrow__ ));





extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ ));



extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ ));
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ ));
# 428 "/usr/include/wchar.h" 3 4
extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) __attribute__ ((__nothrow__ ));



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ ));




__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ ));



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) __attribute__ ((__nothrow__ ));
# 551 "/usr/include/wchar.h" 3 4
extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) __attribute__ ((__nothrow__ ));



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ ));
# 567 "/usr/include/wchar.h" 3 4
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ ));





extern int fwide (__FILE *__fp, int __mode) __attribute__ ((__nothrow__ ));






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     __attribute__ ((__nothrow__ )) ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ )) ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     __attribute__ ((__nothrow__ )) ;
# 642 "/usr/include/wchar.h" 3 4
extern int fwscanf (__FILE *__restrict __stream, const wchar_t *__restrict __format, ...) __asm__ ("" "__isoc99_fwscanf")


                                                          ;
extern int wscanf (const wchar_t *__restrict __format, ...) __asm__ ("" "__isoc99_wscanf")

                                                          ;
extern int swscanf (const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) __asm__ ("" "__isoc99_swscanf") __attribute__ ((__nothrow__ ))


                                                          ;
# 673 "/usr/include/wchar.h" 3 4
extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ )) ;





extern int vfwscanf (__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfwscanf")


                                                          ;
extern int vwscanf (const wchar_t *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vwscanf")

                                                          ;
extern int vswscanf (const wchar_t *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vswscanf") __attribute__ ((__nothrow__ ))


                                                          ;
# 727 "/usr/include/wchar.h" 3 4
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
# 835 "/usr/include/wchar.h" 3 4
extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ ));
# 850 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wchar2.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/wchar2.h" 3 4
extern wchar_t *__wmemcpy_chk (wchar_t *__restrict __s1,
          const wchar_t *__restrict __s2, size_t __n,
          size_t __ns1) __attribute__ ((__nothrow__ ));
extern wchar_t *__wmemcpy_alias (wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) __asm__ ("" "wmemcpy") __attribute__ ((__nothrow__ ));



extern wchar_t *__wmemcpy_chk_warn (wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n, size_t __ns1) __asm__ ("" "__wmemcpy_chk") __attribute__ ((__nothrow__ ))




            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) wchar_t *
__attribute__ ((__nothrow__ )) wmemcpy (wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n)

{
  if (__builtin_object_size (__s1, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n))
 return __wmemcpy_chk (__s1, __s2, __n,
         __builtin_object_size (__s1, 0) / sizeof (wchar_t));

      if (__n > __builtin_object_size (__s1, 0) / sizeof (wchar_t))
 return __wmemcpy_chk_warn (__s1, __s2, __n,
       __builtin_object_size (__s1, 0) / sizeof (wchar_t));
    }
  return __wmemcpy_alias (__s1, __s2, __n);
}


extern wchar_t *__wmemmove_chk (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, size_t __ns1) __attribute__ ((__nothrow__ ));
extern wchar_t *__wmemmove_alias (wchar_t *__s1, const wchar_t *__s2, size_t __n) __asm__ ("" "wmemmove") __attribute__ ((__nothrow__ ));


extern wchar_t *__wmemmove_chk_warn (wchar_t *__s1, const wchar_t *__s2, size_t __n, size_t __ns1) __asm__ ("" "__wmemmove_chk") __attribute__ ((__nothrow__ ))



            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) wchar_t *
__attribute__ ((__nothrow__ )) wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
{
  if (__builtin_object_size (__s1, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n))
 return __wmemmove_chk (__s1, __s2, __n,
          __builtin_object_size (__s1, 0) / sizeof (wchar_t));

      if (__n > __builtin_object_size (__s1, 0) / sizeof (wchar_t))
 return __wmemmove_chk_warn (__s1, __s2, __n,
        __builtin_object_size (__s1, 0) / sizeof (wchar_t));
    }
  return __wmemmove_alias (__s1, __s2, __n);
}
# 118 "/usr/include/x86_64-linux-gnu/bits/wchar2.h" 3 4
extern wchar_t *__wmemset_chk (wchar_t *__s, wchar_t __c, size_t __n,
          size_t __ns) __attribute__ ((__nothrow__ ));
extern wchar_t *__wmemset_alias (wchar_t *__s, wchar_t __c, size_t __n) __asm__ ("" "wmemset") __attribute__ ((__nothrow__ ));

extern wchar_t *__wmemset_chk_warn (wchar_t *__s, wchar_t __c, size_t __n, size_t __ns) __asm__ ("" "__wmemset_chk") __attribute__ ((__nothrow__ ))



            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) wchar_t *
__attribute__ ((__nothrow__ )) wmemset (wchar_t *__s, wchar_t __c, size_t __n)
{
  if (__builtin_object_size (__s, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n))
 return __wmemset_chk (__s, __c, __n, __builtin_object_size (__s, 0) / sizeof (wchar_t));

      if (__n > __builtin_object_size (__s, 0) / sizeof (wchar_t))
 return __wmemset_chk_warn (__s, __c, __n,
       __builtin_object_size (__s, 0) / sizeof (wchar_t));
    }
  return __wmemset_alias (__s, __c, __n);
}


extern wchar_t *__wcscpy_chk (wchar_t *__restrict __dest,
         const wchar_t *__restrict __src,
         size_t __n) __attribute__ ((__nothrow__ ));
extern wchar_t *__wcscpy_alias (wchar_t *__restrict __dest, const wchar_t *__restrict __src) __asm__ ("" "wcscpy") __attribute__ ((__nothrow__ ));



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) wchar_t *
__attribute__ ((__nothrow__ )) wcscpy (wchar_t *__restrict __dest, const wchar_t *__restrict __src)
{
  if (__builtin_object_size (__dest, 1 > 1) != (size_t) -1)
    return __wcscpy_chk (__dest, __src, __builtin_object_size (__dest, 1 > 1) / sizeof (wchar_t));
  return __wcscpy_alias (__dest, __src);
}


extern wchar_t *__wcpcpy_chk (wchar_t *__restrict __dest,
         const wchar_t *__restrict __src,
         size_t __destlen) __attribute__ ((__nothrow__ ));
extern wchar_t *__wcpcpy_alias (wchar_t *__restrict __dest, const wchar_t *__restrict __src) __asm__ ("" "wcpcpy") __attribute__ ((__nothrow__ ));



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) wchar_t *
__attribute__ ((__nothrow__ )) wcpcpy (wchar_t *__restrict __dest, const wchar_t *__restrict __src)
{
  if (__builtin_object_size (__dest, 1 > 1) != (size_t) -1)
    return __wcpcpy_chk (__dest, __src, __builtin_object_size (__dest, 1 > 1) / sizeof (wchar_t));
  return __wcpcpy_alias (__dest, __src);
}


extern wchar_t *__wcsncpy_chk (wchar_t *__restrict __dest,
          const wchar_t *__restrict __src, size_t __n,
          size_t __destlen) __attribute__ ((__nothrow__ ));
extern wchar_t *__wcsncpy_alias (wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) __asm__ ("" "wcsncpy") __attribute__ ((__nothrow__ ));



extern wchar_t *__wcsncpy_chk_warn (wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n, size_t __destlen) __asm__ ("" "__wcsncpy_chk") __attribute__ ((__nothrow__ ))




            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) wchar_t *
__attribute__ ((__nothrow__ )) wcsncpy (wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n)

{
  if (__builtin_object_size (__dest, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n))
 return __wcsncpy_chk (__dest, __src, __n,
         __builtin_object_size (__dest, 1 > 1) / sizeof (wchar_t));
      if (__n > __builtin_object_size (__dest, 1 > 1) / sizeof (wchar_t))
 return __wcsncpy_chk_warn (__dest, __src, __n,
       __builtin_object_size (__dest, 1 > 1) / sizeof (wchar_t));
    }
  return __wcsncpy_alias (__dest, __src, __n);
}


extern wchar_t *__wcpncpy_chk (wchar_t *__restrict __dest,
          const wchar_t *__restrict __src, size_t __n,
          size_t __destlen) __attribute__ ((__nothrow__ ));
extern wchar_t *__wcpncpy_alias (wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) __asm__ ("" "wcpncpy") __attribute__ ((__nothrow__ ));



extern wchar_t *__wcpncpy_chk_warn (wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n, size_t __destlen) __asm__ ("" "__wcpncpy_chk") __attribute__ ((__nothrow__ ))




            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) wchar_t *
__attribute__ ((__nothrow__ )) wcpncpy (wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n)

{
  if (__builtin_object_size (__dest, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n))
 return __wcpncpy_chk (__dest, __src, __n,
         __builtin_object_size (__dest, 1 > 1) / sizeof (wchar_t));
      if (__n > __builtin_object_size (__dest, 1 > 1) / sizeof (wchar_t))
 return __wcpncpy_chk_warn (__dest, __src, __n,
       __builtin_object_size (__dest, 1 > 1) / sizeof (wchar_t));
    }
  return __wcpncpy_alias (__dest, __src, __n);
}


extern wchar_t *__wcscat_chk (wchar_t *__restrict __dest,
         const wchar_t *__restrict __src,
         size_t __destlen) __attribute__ ((__nothrow__ ));
extern wchar_t *__wcscat_alias (wchar_t *__restrict __dest, const wchar_t *__restrict __src) __asm__ ("" "wcscat") __attribute__ ((__nothrow__ ));



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) wchar_t *
__attribute__ ((__nothrow__ )) wcscat (wchar_t *__restrict __dest, const wchar_t *__restrict __src)
{
  if (__builtin_object_size (__dest, 1 > 1) != (size_t) -1)
    return __wcscat_chk (__dest, __src, __builtin_object_size (__dest, 1 > 1) / sizeof (wchar_t));
  return __wcscat_alias (__dest, __src);
}


extern wchar_t *__wcsncat_chk (wchar_t *__restrict __dest,
          const wchar_t *__restrict __src,
          size_t __n, size_t __destlen) __attribute__ ((__nothrow__ ));
extern wchar_t *__wcsncat_alias (wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) __asm__ ("" "wcsncat") __attribute__ ((__nothrow__ ));




extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) wchar_t *
__attribute__ ((__nothrow__ )) wcsncat (wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n)

{
  if (__builtin_object_size (__dest, 1 > 1) != (size_t) -1)
    return __wcsncat_chk (__dest, __src, __n,
     __builtin_object_size (__dest, 1 > 1) / sizeof (wchar_t));
  return __wcsncat_alias (__dest, __src, __n);
}


extern int __swprintf_chk (wchar_t *__restrict __s, size_t __n,
      int __flag, size_t __s_len,
      const wchar_t *__restrict __format, ...)
     __attribute__ ((__nothrow__ )) ;

extern int __swprintf_alias (wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __fmt, ...) __asm__ ("" "swprintf") __attribute__ ((__nothrow__ ));
# 303 "/usr/include/x86_64-linux-gnu/bits/wchar2.h" 3 4
extern int __vswprintf_chk (wchar_t *__restrict __s, size_t __n,
       int __flag, size_t __s_len,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ )) ;

extern int __vswprintf_alias (wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __fmt, __gnuc_va_list __ap) __asm__ ("" "vswprintf") __attribute__ ((__nothrow__ ));




extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) vswprintf (wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __fmt, __gnuc_va_list __ap)

{
  if (__builtin_object_size (__s, 1 > 1) != (size_t) -1 || 1 > 1)
    return __vswprintf_chk (__s, __n, 1 - 1,
       __builtin_object_size (__s, 1 > 1) / sizeof (wchar_t), __fmt, __ap);
  return __vswprintf_alias (__s, __n, __fmt, __ap);
}
# 372 "/usr/include/x86_64-linux-gnu/bits/wchar2.h" 3 4
extern wchar_t *__fgetws_chk (wchar_t *__restrict __s, size_t __size, int __n,
         __FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern wchar_t *__fgetws_alias (wchar_t *__restrict __s, int __n, __FILE *__restrict __stream) __asm__ ("" "fgetws") __attribute__ ((__warn_unused_result__));


extern wchar_t *__fgetws_chk_warn (wchar_t *__restrict __s, size_t __size, int __n, __FILE *__restrict __stream) __asm__ ("" "__fgetws_chk")


     __attribute__ ((__warn_unused_result__)) ;


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__warn_unused_result__)) wchar_t *
fgetws (wchar_t *__restrict __s, int __n, __FILE *__restrict __stream)
{
  if (__builtin_object_size (__s, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n) || __n <= 0)
 return __fgetws_chk (__s, __builtin_object_size (__s, 1 > 1) / sizeof (wchar_t),
        __n, __stream);

      if ((size_t) __n > __builtin_object_size (__s, 1 > 1) / sizeof (wchar_t))
 return __fgetws_chk_warn (__s, __builtin_object_size (__s, 1 > 1) / sizeof (wchar_t),
      __n, __stream);
    }
  return __fgetws_alias (__s, __n, __stream);
}
# 432 "/usr/include/x86_64-linux-gnu/bits/wchar2.h" 3 4
extern size_t __wcrtomb_chk (char *__restrict __s, wchar_t __wchar,
        mbstate_t *__restrict __p,
        size_t __buflen) __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));
extern size_t __wcrtomb_alias (char *__restrict __s, wchar_t __wchar, mbstate_t *__restrict __ps) __asm__ ("" "wcrtomb") __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__warn_unused_result__)) size_t
__attribute__ ((__nothrow__ )) wcrtomb (char *__restrict __s, wchar_t __wchar, mbstate_t *__restrict __ps)

{







  if (__builtin_object_size (__s, 1 > 1) != (size_t) -1 && 16 > __builtin_object_size (__s, 1 > 1))
    return __wcrtomb_chk (__s, __wchar, __ps, __builtin_object_size (__s, 1 > 1));
  return __wcrtomb_alias (__s, __wchar, __ps);
}


extern size_t __mbsrtowcs_chk (wchar_t *__restrict __dst,
          const char **__restrict __src,
          size_t __len, mbstate_t *__restrict __ps,
          size_t __dstlen) __attribute__ ((__nothrow__ ));
extern size_t __mbsrtowcs_alias (wchar_t *__restrict __dst, const char **__restrict __src, size_t __len, mbstate_t *__restrict __ps) __asm__ ("" "mbsrtowcs") __attribute__ ((__nothrow__ ));




extern size_t __mbsrtowcs_chk_warn (wchar_t *__restrict __dst, const char **__restrict __src, size_t __len, mbstate_t *__restrict __ps, size_t __dstlen) __asm__ ("" "__mbsrtowcs_chk") __attribute__ ((__nothrow__ ))





                        ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) size_t
__attribute__ ((__nothrow__ )) mbsrtowcs (wchar_t *__restrict __dst, const char **__restrict __src, size_t __len, mbstate_t *__restrict __ps)

{
  if (__builtin_object_size (__dst, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __mbsrtowcs_chk (__dst, __src, __len, __ps,
    __builtin_object_size (__dst, 1 > 1) / sizeof (wchar_t));

      if (__len > __builtin_object_size (__dst, 1 > 1) / sizeof (wchar_t))
 return __mbsrtowcs_chk_warn (__dst, __src, __len, __ps,
         __builtin_object_size (__dst, 1 > 1) / sizeof (wchar_t));
    }
  return __mbsrtowcs_alias (__dst, __src, __len, __ps);
}


extern size_t __wcsrtombs_chk (char *__restrict __dst,
          const wchar_t **__restrict __src,
          size_t __len, mbstate_t *__restrict __ps,
          size_t __dstlen) __attribute__ ((__nothrow__ ));
extern size_t __wcsrtombs_alias (char *__restrict __dst, const wchar_t **__restrict __src, size_t __len, mbstate_t *__restrict __ps) __asm__ ("" "wcsrtombs") __attribute__ ((__nothrow__ ));




extern size_t __wcsrtombs_chk_warn (char *__restrict __dst, const wchar_t **__restrict __src, size_t __len, mbstate_t *__restrict __ps, size_t __dstlen) __asm__ ("" "__wcsrtombs_chk") __attribute__ ((__nothrow__ ))




                                                                    ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) size_t
__attribute__ ((__nothrow__ )) wcsrtombs (char *__restrict __dst, const wchar_t **__restrict __src, size_t __len, mbstate_t *__restrict __ps)

{
  if (__builtin_object_size (__dst, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __wcsrtombs_chk (__dst, __src, __len, __ps, __builtin_object_size (__dst, 1 > 1));

      if (__len > __builtin_object_size (__dst, 1 > 1))
 return __wcsrtombs_chk_warn (__dst, __src, __len, __ps, __builtin_object_size (__dst, 1 > 1));
    }
  return __wcsrtombs_alias (__dst, __src, __len, __ps);
}
# 851 "/usr/include/wchar.h" 2 3 4
# 254 "./spell.h" 2
# 293 "./spell.h"
extern slang_T *first_lang ;


extern char_u *int_wordlist ;


extern char e_format[] ;

extern spelltab_T spelltab;
extern int did_set_spelltab;






typedef struct wordcount_S
{
    short_u wc_count;
    char_u wc_word[1];
} wordcount_T;






extern char_u *repl_from ;
extern char_u *repl_to ;
# 2147 "./vim.h" 2

# 1 "./proto.h" 1
# 39 "./proto.h"
# 1 "proto/os_unix.pro" 1

int mch_chdir(char *path);
void mch_write(char_u *s, int len);
int mch_inchar(char_u *buf, int maxlen, long wtime, int tb_change_cnt);
int mch_char_avail(void);
int mch_check_messages(void);
long_u mch_total_mem(int special);
void mch_delay(long msec, int flags);
int mch_stackcheck(char *p);
void mch_suspend(void);
void mch_init(void);
void reset_signals(void);
int vim_handle_signal(int sig);
int mch_check_win(int argc, char **argv);
int mch_input_isatty(void);
void ex_xrestore(exarg_T *eap);
int mch_can_restore_title(void);
int mch_can_restore_icon(void);
void mch_settitle(char_u *title, char_u *icon);
void mch_restore_title(int which);
int vim_is_xterm(char_u *name);
int use_xterm_like_mouse(char_u *name);
int use_xterm_mouse(void);
int vim_is_iris(char_u *name);
int vim_is_vt300(char_u *name);
int vim_is_fastterm(char_u *name);
int mch_get_user_name(char_u *s, int len);
int mch_get_uname(uid_t uid, char_u *s, int len);
void mch_get_host_name(char_u *s, int len);
long mch_get_pid(void);
int mch_process_running(long pid);
int mch_dirname(char_u *buf, int len);
int mch_FullName(char_u *fname, char_u *buf, int len, int force);
int mch_isFullName(char_u *fname);
void fname_case(char_u *name, int len);
long mch_getperm(char_u *name);
int mch_setperm(char_u *name, long perm);
int mch_fsetperm(int fd, long perm);
void mch_copy_sec(char_u *from_file, char_u *to_file);
vim_acl_T mch_get_acl(char_u *fname);
void mch_set_acl(char_u *fname, vim_acl_T aclent);
void mch_free_acl(vim_acl_T aclent);
void mch_hide(char_u *name);
int mch_isdir(char_u *name);
int mch_isrealdir(char_u *name);
int mch_can_exe(char_u *name, char_u **path, int use_path);
int mch_nodetype(char_u *name);
void mch_early_init(void);
void mch_free_mem(void);
void mch_exit(int r);
void mch_settmode(tmode_T tmode);
void get_stty(void);
int get_tty_info(int fd, ttyinfo_T *info);
void mch_setmouse(int on);
void mch_bevalterm_changed(void);
void check_mouse_termcode(void);
int mch_get_shellsize(void);
int mch_report_winsize(int fd, int rows, int cols);
void mch_set_shellsize(void);
void mch_new_shellsize(void);
int unix_build_argv(char_u *cmd, char ***argvp, char_u **sh_tofree, char_u **shcf_tofree);
int mch_call_shell(char_u *cmd, int options);
void mch_job_start(char **argv, job_T *job, jobopt_T *options, int is_terminal);
char *mch_job_status(job_T *job);
job_T *mch_detect_ended_job(job_T *job_list);
int mch_signal_job(job_T *job, char_u *how);
void mch_clear_job(job_T *job);
int mch_create_pty_channel(job_T *job, jobopt_T *options);
void mch_breakcheck(int force);
int mch_expandpath(garray_T *gap, char_u *path, int flags);
int mch_expand_wildcards(int num_pat, char_u **pat, int *num_file, char_u ***file, int flags);
int mch_has_exp_wildcard(char_u *p);
int mch_has_wildcard(char_u *p);
int rename(const char *src, const char *dest);
int gpm_enabled(void);
int mch_libcall(char_u *libname, char_u *funcname, char_u *argstring, int argint, char_u **string_result, int *number_result);
void setup_term_clip(void);
void start_xterm_trace(int button);
void stop_xterm_trace(void);
void clear_xterm_clip(void);
int clip_xterm_own_selection(Clipboard_T *cbd);
void clip_xterm_lose_selection(Clipboard_T *cbd);
void clip_xterm_request_selection(Clipboard_T *cbd);
void clip_xterm_set_selection(Clipboard_T *cbd);
int xsmp_handle_requests(void);
void xsmp_init(void);
void xsmp_close(void);
# 40 "./proto.h" 2
# 57 "./proto.h"
# 1 "proto/blowfish.pro" 1

void crypt_blowfish_encode(cryptstate_T *state, char_u *from, size_t len, char_u *to);
void crypt_blowfish_decode(cryptstate_T *state, char_u *from, size_t len, char_u *to);
int crypt_blowfish_init(cryptstate_T *state, char_u *key, char_u *salt, int salt_len, char_u *seed, int seed_len);
int blowfish_self_test(void);
# 58 "./proto.h" 2
# 1 "proto/crypt.pro" 1

int crypt_method_nr_from_name(char_u *name);
int crypt_method_nr_from_magic(char *ptr, int len);
int crypt_get_method_nr(buf_T *buf);
int crypt_whole_undofile(int method_nr);
int crypt_get_header_len(int method_nr);
void crypt_set_cm_option(buf_T *buf, int method_nr);
int crypt_self_test(void);
cryptstate_T *crypt_create(int method_nr, char_u *key, char_u *salt, int salt_len, char_u *seed, int seed_len);
cryptstate_T *crypt_create_from_header(int method_nr, char_u *key, char_u *header);
cryptstate_T *crypt_create_from_file(FILE *fp, char_u *key);
cryptstate_T *crypt_create_for_writing(int method_nr, char_u *key, char_u **header, int *header_len);
void crypt_free_state(cryptstate_T *state);
void crypt_encode(cryptstate_T *state, char_u *from, size_t len, char_u *to);
void crypt_encode_inplace(cryptstate_T *state, char_u *buf, size_t len);
void crypt_decode_inplace(cryptstate_T *state, char_u *buf, size_t len);
void crypt_free_key(char_u *key);
void crypt_check_method(int method);
void crypt_check_current_method(void);
char_u *crypt_get_key(int store, int twice);
void crypt_append_msg(buf_T *buf);
# 59 "./proto.h" 2
# 1 "proto/crypt_zip.pro" 1

int crypt_zip_init(cryptstate_T *state, char_u *key, char_u *salt, int salt_len, char_u *seed, int seed_len);
void crypt_zip_encode(cryptstate_T *state, char_u *from, size_t len, char_u *to);
void crypt_zip_decode(cryptstate_T *state, char_u *from, size_t len, char_u *to);
# 60 "./proto.h" 2

# 1 "proto/arglist.pro" 1

void alist_clear(alist_T *al);
void alist_init(alist_T *al);
void alist_unlink(alist_T *al);
void alist_new(void);
void alist_expand(int *fnum_list, int fnum_len);
void alist_set(alist_T *al, int count, char_u **files, int use_curbuf, int *fnum_list, int fnum_len);
void alist_add(alist_T *al, char_u *fname, int set_fnum);
void alist_slash_adjust(void);
int get_arglist_exp(char_u *str, int *fcountp, char_u ***fnamesp, int wig);
void set_arglist(char_u *str);
int editing_arg_idx(win_T *win);
void check_arg_idx(win_T *win);
void ex_args(exarg_T *eap);
void ex_previous(exarg_T *eap);
void ex_rewind(exarg_T *eap);
void ex_last(exarg_T *eap);
void ex_argument(exarg_T *eap);
void do_argfile(exarg_T *eap, int argn);
void ex_next(exarg_T *eap);
void ex_argedit(exarg_T *eap);
void ex_argadd(exarg_T *eap);
void ex_argdelete(exarg_T *eap);
char_u *get_arglist_name(expand_T *xp, int idx);
char_u *alist_name(aentry_T *aep);
void ex_all(exarg_T *eap);
char_u *arg_all(void);
void f_argc(typval_T *argvars, typval_T *rettv);
void f_argidx(typval_T *argvars, typval_T *rettv);
void f_arglistid(typval_T *argvars, typval_T *rettv);
void f_argv(typval_T *argvars, typval_T *rettv);
# 62 "./proto.h" 2
# 1 "proto/autocmd.pro" 1

void aubuflocal_remove(buf_T *buf);
int au_has_group(char_u *name);
void do_augroup(char_u *arg, int del_group);
void free_all_autocmds(void);
int check_ei(void);
char_u *au_event_disable(char *what);
void au_event_restore(char_u *old_ei);
void do_autocmd(char_u *arg_in, int forceit);
int do_doautocmd(char_u *arg, int do_msg, int *did_something);
void ex_doautoall(exarg_T *eap);
int check_nomodeline(char_u **argp);
void aucmd_prepbuf(aco_save_T *aco, buf_T *buf);
void aucmd_restbuf(aco_save_T *aco);
int apply_autocmds(event_T event, char_u *fname, char_u *fname_io, int force, buf_T *buf);
int apply_autocmds_exarg(event_T event, char_u *fname, char_u *fname_io, int force, buf_T *buf, exarg_T *eap);
int apply_autocmds_retval(event_T event, char_u *fname, char_u *fname_io, int force, buf_T *buf, int *retval);
int trigger_cursorhold(void);
int has_cursormoved(void);
int has_cursormovedI(void);
int has_textchanged(void);
int has_textchangedI(void);
int has_textchangedP(void);
int has_insertcharpre(void);
int has_cmdundefined(void);
int has_textyankpost(void);
int has_completechanged(void);
void block_autocmds(void);
void unblock_autocmds(void);
int is_autocmd_blocked(void);
char_u *getnextac(int c, void *cookie, int indent, getline_opt_T options);
int has_autocmd(event_T event, char_u *sfname, buf_T *buf);
char_u *get_augroup_name(expand_T *xp, int idx);
char_u *set_context_in_autocmd(expand_T *xp, char_u *arg, int doautocmd);
char_u *get_event_name(expand_T *xp, int idx);
int autocmd_supported(char_u *name);
int au_exists(char_u *arg);
# 63 "./proto.h" 2
# 1 "proto/buffer.pro" 1

int get_highest_fnum(void);
void buffer_ensure_loaded(buf_T *buf);
int open_buffer(int read_stdin, exarg_T *eap, int flags);
void set_bufref(bufref_T *bufref, buf_T *buf);
int bufref_valid(bufref_T *bufref);
int buf_valid(buf_T *buf);
void close_buffer(win_T *win, buf_T *buf, int action, int abort_if_last, int ignore_abort);
void buf_clear_file(buf_T *buf);
void buf_freeall(buf_T *buf, int flags);
void free_wininfo(wininfo_T *wip);
void goto_buffer(exarg_T *eap, int start, int dir, int count);
void handle_swap_exists(bufref_T *old_curbuf);
char *do_bufdel(int command, char_u *arg, int addr_count, int start_bnr, int end_bnr, int forceit);
int do_buffer(int action, int start, int dir, int count, int forceit);
void set_curbuf(buf_T *buf, int action);
void do_autochdir(void);
void no_write_message(void);
void no_write_message_nobang(buf_T *buf);
int curbuf_reusable(void);
buf_T *buflist_new(char_u *ffname_arg, char_u *sfname_arg, linenr_T lnum, int flags);
void free_buf_options(buf_T *buf, int free_p_ff);
int buflist_getfile(int n, linenr_T lnum, int options, int forceit);
buf_T *buflist_findname_exp(char_u *fname);
buf_T *buflist_findname(char_u *ffname);
int buflist_findpat(char_u *pattern, char_u *pattern_end, int unlisted, int diffmode, int curtab_only);
int ExpandBufnames(char_u *pat, int *num_file, char_u ***file, int options);
buf_T *buflist_findnr(int nr);
char_u *buflist_nr2name(int n, int fullname, int helptail);
void buflist_setfpos(buf_T *buf, win_T *win, linenr_T lnum, colnr_T col, int copy_options);
void get_winopts(buf_T *buf);
pos_T *buflist_findfpos(buf_T *buf);
linenr_T buflist_findlnum(buf_T *buf);
void buflist_list(exarg_T *eap);
int buflist_name_nr(int fnum, char_u **fname, linenr_T *lnum);
int setfname(buf_T *buf, char_u *ffname_arg, char_u *sfname_arg, int message);
void buf_set_name(int fnum, char_u *name);
void buf_name_changed(buf_T *buf);
buf_T *setaltfname(char_u *ffname, char_u *sfname, linenr_T lnum);
char_u *getaltfname(int errmsg);
int buflist_add(char_u *fname, int flags);
void buflist_slash_adjust(void);
void buflist_altfpos(win_T *win);
int otherfile(char_u *ffname);
void buf_setino(buf_T *buf);
void fileinfo(int fullname, int shorthelp, int dont_truncate);
void col_print(char_u *buf, size_t buflen, int col, int vcol);
void maketitle(void);
void resettitle(void);
void free_titles(void);
int build_stl_str_hl(win_T *wp, char_u *out, size_t outlen, char_u *fmt, int use_sandbox, int fillchar, int maxwidth, stl_hlrec_T **hltab, stl_hlrec_T **tabtab);
void get_rel_pos(win_T *wp, char_u *buf, int buflen);
char_u *fix_fname(char_u *fname);
void fname_expand(buf_T *buf, char_u **ffname, char_u **sfname);
void ex_buffer_all(exarg_T *eap);
void do_modelines(int flags);
int bt_normal(buf_T *buf);
int bt_quickfix(buf_T *buf);
int bt_terminal(buf_T *buf);
int bt_help(buf_T *buf);
int bt_prompt(buf_T *buf);
int bt_popup(buf_T *buf);
int bt_nofilename(buf_T *buf);
int bt_nofile(buf_T *buf);
int bt_dontwrite(buf_T *buf);
int bt_dontwrite_msg(buf_T *buf);
int buf_hide(buf_T *buf);
char_u *buf_spname(buf_T *buf);
char_u *buf_get_fname(buf_T *buf);
void set_buflisted(int on);
int buf_contents_changed(buf_T *buf);
void wipe_buffer(buf_T *buf, int aucmd);
# 64 "./proto.h" 2
# 1 "proto/bufwrite.pro" 1

char *new_file_message(void);
int buf_write(buf_T *buf, char_u *fname, char_u *sfname, linenr_T start, linenr_T end, exarg_T *eap, int append, int forceit, int reset_changed, int filtering);
# 65 "./proto.h" 2
# 1 "proto/change.pro" 1

void change_warning(int col);
void changed(void);
void changed_internal(void);
void f_listener_add(typval_T *argvars, typval_T *rettv);
void f_listener_flush(typval_T *argvars, typval_T *rettv);
void f_listener_remove(typval_T *argvars, typval_T *rettv);
void may_invoke_listeners(buf_T *buf, linenr_T lnum, linenr_T lnume, int added);
void invoke_listeners(buf_T *buf);
void remove_listeners(buf_T *buf);
void changed_bytes(linenr_T lnum, colnr_T col);
void inserted_bytes(linenr_T lnum, colnr_T col, int added);
void appended_lines(linenr_T lnum, long count);
void appended_lines_mark(linenr_T lnum, long count);
void deleted_lines(linenr_T lnum, long count);
void deleted_lines_mark(linenr_T lnum, long count);
void changed_lines(linenr_T lnum, colnr_T col, linenr_T lnume, long xtra);
void unchanged(buf_T *buf, int ff, int always_inc_changedtick);
void save_file_ff(buf_T *buf);
int file_ff_differs(buf_T *buf, int ignore_empty);
void ins_bytes(char_u *p);
void ins_bytes_len(char_u *p, int len);
void ins_char(int c);
void ins_char_bytes(char_u *buf, int charlen);
void ins_str(char_u *s);
int del_char(int fixpos);
int del_chars(long count, int fixpos);
int del_bytes(long count, int fixpos_arg, int use_delcombine);
int open_line(int dir, int flags, int second_line_indent);
int truncate_line(int fixpos);
void del_lines(long nlines, int undo);
# 66 "./proto.h" 2
# 1 "proto/charset.pro" 1

int init_chartab(void);
int buf_init_chartab(buf_T *buf, int global);
void trans_characters(char_u *buf, int bufsize);
char_u *transstr(char_u *s);
char_u *str_foldcase(char_u *str, int orglen, char_u *buf, int buflen);
char_u *transchar(int c);
char_u *transchar_buf(buf_T *buf, int c);
char_u *transchar_byte(int c);
void transchar_nonprint(buf_T *buf, char_u *charbuf, int c);
void transchar_hex(char_u *buf, int c);
int byte2cells(int b);
int char2cells(int c);
int ptr2cells(char_u *p);
int vim_strsize(char_u *s);
int vim_strnsize(char_u *s, int len);
int chartabsize(char_u *p, colnr_T col);
int linetabsize(char_u *s);
int linetabsize_col(int startcol, char_u *s);
int win_linetabsize(win_T *wp, char_u *line, colnr_T len);
int vim_isIDc(int c);
int vim_iswordc(int c);
int vim_iswordc_buf(int c, buf_T *buf);
int vim_iswordp(char_u *p);
int vim_iswordp_buf(char_u *p, buf_T *buf);
int vim_isfilec(int c);
int vim_isfilec_or_wc(int c);
int vim_isprintc(int c);
int vim_isprintc_strict(int c);
int lbr_chartabsize(char_u *line, unsigned char *s, colnr_T col);
int lbr_chartabsize_adv(char_u *line, char_u **s, colnr_T col);
int win_lbr_chartabsize(win_T *wp, char_u *line, char_u *s, colnr_T col, int *headp);
void getvcol(win_T *wp, pos_T *pos, colnr_T *start, colnr_T *cursor, colnr_T *end);
colnr_T getvcol_nolist(pos_T *posp);
void getvvcol(win_T *wp, pos_T *pos, colnr_T *start, colnr_T *cursor, colnr_T *end);
void getvcols(win_T *wp, pos_T *pos1, pos_T *pos2, colnr_T *left, colnr_T *right);
char_u *skipwhite(char_u *q);
int getwhitecols_curline(void);
int getwhitecols(char_u *p);
char_u *skipdigits(char_u *q);
char_u *skipbin(char_u *q);
char_u *skiphex(char_u *q);
char_u *skiptobin(char_u *q);
char_u *skiptodigit(char_u *q);
char_u *skiptohex(char_u *q);
int vim_isdigit(int c);
int vim_isxdigit(int c);
int vim_isbdigit(int c);
int vim_islower(int c);
int vim_isupper(int c);
int vim_toupper(int c);
int vim_tolower(int c);
char_u *skiptowhite(char_u *p);
char_u *skiptowhite_esc(char_u *p);
long getdigits(char_u **pp);
int vim_isblankline(char_u *lbuf);
void vim_str2nr(char_u *start, int *prep, int *len, int what, varnumber_T *nptr, uvarnumber_T *unptr, int maxlen, int strict);
int hex2nr(int c);
int hexhex2nr(char_u *p);
int rem_backslash(char_u *str);
void backslash_halve(char_u *p);
char_u *backslash_halve_save(char_u *p);
void ebcdic2ascii(char_u *buffer, int len);
# 67 "./proto.h" 2
# 1 "proto/cindent.pro" 1

int cin_is_cinword(char_u *line);
pos_T *find_start_comment(int ind_maxcomment);
int cindent_on(void);
void parse_cino(buf_T *buf);
int get_c_indent(void);
int in_cinkeys(int keytyped, int when, int line_is_empty);
void do_c_expr_indent(void);
void f_cindent(typval_T *argvars, typval_T *rettv);
# 68 "./proto.h" 2
# 1 "proto/clientserver.pro" 1

void server_to_input_buf(char_u *str);
char_u *eval_client_expr_to_string(char_u *expr);
int sendToLocalVim(char_u *cmd, int asExpr, char_u **result);
char_u *serverConvert(char_u *client_enc, char_u *data, char_u **tofree);
void exec_on_server(mparm_T *parmp);
void prepare_server(mparm_T *parmp);
void f_remote_expr(typval_T *argvars, typval_T *rettv);
void f_remote_foreground(typval_T *argvars, typval_T *rettv);
void f_remote_peek(typval_T *argvars, typval_T *rettv);
void f_remote_read(typval_T *argvars, typval_T *rettv);
void f_remote_send(typval_T *argvars, typval_T *rettv);
void f_remote_startserver(typval_T *argvars, typval_T *rettv);
void f_server2client(typval_T *argvars, typval_T *rettv);
void f_serverlist(typval_T *argvars, typval_T *rettv);
# 69 "./proto.h" 2
# 1 "proto/clipboard.pro" 1

void clip_init(int can_use);
void clip_update_selection(Clipboard_T *clip);
void clip_own_selection(Clipboard_T *cbd);
void clip_lose_selection(Clipboard_T *cbd);
void start_global_changes(void);
void end_global_changes(void);
void clip_auto_select(void);
int clip_isautosel_star(void);
int clip_isautosel_plus(void);
void clip_modeless(int button, int is_click, int is_drag);
void clip_start_selection(int col, int row, int repeated_click);
void clip_process_selection(int button, int col, int row, int_u repeated_click);
void clip_may_redraw_selection(int row, int col, int len);
void clip_clear_selection(Clipboard_T *cbd);
void clip_may_clear_selection(int row1, int row2);
void clip_scroll_selection(int rows);
void clip_copy_modeless_selection(int both);
void clip_gen_set_selection(Clipboard_T *cbd);
int clip_gen_owner_exists(Clipboard_T *cbd);
char *check_clipboard_option(void);
void open_app_context(void);
void x11_setup_atoms(Display *dpy);
void x11_setup_selection(Widget w);
void clip_x11_request_selection(Widget myShell, Display *dpy, Clipboard_T *cbd);
void clip_x11_lose_selection(Widget myShell, Clipboard_T *cbd);
int clip_x11_own_selection(Widget myShell, Clipboard_T *cbd);
void clip_x11_set_selection(Clipboard_T *cbd);
void yank_cut_buffer0(Display *dpy, Clipboard_T *cbd);
void x11_export_final_selection(void);
void clip_free_selection(Clipboard_T *cbd);
void clip_get_selection(Clipboard_T *cbd);
void clip_yank_selection(int type, char_u *str, long len, Clipboard_T *cbd);
int clip_convert_selection(char_u **str, long_u *len, Clipboard_T *cbd);
int may_get_selection(int regname);
void may_set_selection(void);
void adjust_clip_reg(int *rp);
# 70 "./proto.h" 2
# 1 "proto/cmdexpand.pro" 1

int nextwild(expand_T *xp, int type, int options, int escape);
char_u *ExpandOne(expand_T *xp, char_u *str, char_u *orig, int options, int mode);
void ExpandInit(expand_T *xp);
void ExpandCleanup(expand_T *xp);
int showmatches(expand_T *xp, int wildmenu);
char_u *sm_gettail(char_u *s);
char_u *addstar(char_u *fname, int len, int context);
void set_cmd_context(expand_T *xp, char_u *str, int len, int col, int use_ccline);
int expand_cmdline(expand_T *xp, char_u *str, int col, int *matchcount, char_u ***matches);
void globpath(char_u *path, char_u *file, garray_T *ga, int expand_options);
int wildmenu_translate_key(cmdline_info_T *cclp, int key, expand_T *xp, int did_wild_list);
int wildmenu_process_key(cmdline_info_T *cclp, int key, expand_T *xp);
void wildmenu_cleanup(cmdline_info_T *cclp);
void f_getcompletion(typval_T *argvars, typval_T *rettv);
# 71 "./proto.h" 2
# 1 "proto/cmdhist.pro" 1

int get_hislen(void);
histentry_T *get_histentry(int hist_type);
void set_histentry(int hist_type, histentry_T *entry);
int *get_hisidx(int hist_type);
int *get_hisnum(int hist_type);
int hist_char2type(int c);
char_u *get_history_arg(expand_T *xp, int idx);
void init_history(void);
void clear_hist_entry(histentry_T *hisptr);
int in_history(int type, char_u *str, int move_to_front, int sep, int writing);
void add_to_history(int histype, char_u *new_entry, int in_map, int sep);
void f_histadd(typval_T *argvars, typval_T *rettv);
void f_histdel(typval_T *argvars, typval_T *rettv);
void f_histget(typval_T *argvars, typval_T *rettv);
void f_histnr(typval_T *argvars, typval_T *rettv);
void remove_key_from_history(void);
void ex_history(exarg_T *eap);
# 72 "./proto.h" 2
# 1 "proto/if_cscope.pro" 1

char_u *get_cscope_name(expand_T *xp, int idx);
void set_context_in_cscope_cmd(expand_T *xp, char_u *arg, cmdidx_T cmdidx);
void ex_cscope(exarg_T *eap);
void ex_scscope(exarg_T *eap);
void ex_cstag(exarg_T *eap);
int cs_fgets(char_u *buf, int size);
void cs_free_tags(void);
void cs_print_tags(void);
void cs_end(void);
void f_cscope_connection(typval_T *argvars, typval_T *rettv);
# 73 "./proto.h" 2
# 1 "proto/debugger.pro" 1

int has_watchexpr(void);
void do_debug(char_u *cmd);
void ex_debug(exarg_T *eap);
void dbg_check_breakpoint(exarg_T *eap);
int dbg_check_skipped(exarg_T *eap);
void ex_breakadd(exarg_T *eap);
void ex_debuggreedy(exarg_T *eap);
void ex_breakdel(exarg_T *eap);
void ex_breaklist(exarg_T *eap);
linenr_T dbg_find_breakpoint(int file, char_u *fname, linenr_T after);
int has_profiling(int file, char_u *fname, int *fp);
void dbg_breakpoint(char_u *name, linenr_T lnum);
# 74 "./proto.h" 2
# 1 "proto/dict.pro" 1

dict_T *dict_alloc(void);
dict_T *dict_alloc_id(alloc_id_T id);
dict_T *dict_alloc_lock(int lock);
int rettv_dict_alloc(typval_T *rettv);
void rettv_dict_set(typval_T *rettv, dict_T *d);
void dict_free_contents(dict_T *d);
void hashtab_free_contents(hashtab_T *ht);
void dict_unref(dict_T *d);
int dict_free_nonref(int copyID);
void dict_free_items(int copyID);
dictitem_T *dictitem_alloc(char_u *key);
void dictitem_remove(dict_T *dict, dictitem_T *item);
void dictitem_free(dictitem_T *item);
dict_T *dict_copy(dict_T *orig, int deep, int copyID);
int dict_add(dict_T *d, dictitem_T *item);
int dict_add_number(dict_T *d, char *key, varnumber_T nr);
int dict_add_bool(dict_T *d, char *key, varnumber_T nr);
int dict_add_string(dict_T *d, char *key, char_u *str);
int dict_add_string_len(dict_T *d, char *key, char_u *str, int len);
int dict_add_list(dict_T *d, char *key, list_T *list);
int dict_add_tv(dict_T *d, char *key, typval_T *tv);
int dict_add_callback(dict_T *d, char *key, callback_T *cb);
void dict_iterate_start(typval_T *var, dict_iterator_T *iter);
char_u *dict_iterate_next(dict_iterator_T *iter, typval_T **tv_result);
int dict_add_dict(dict_T *d, char *key, dict_T *dict);
long dict_len(dict_T *d);
dictitem_T *dict_find(dict_T *d, char_u *key, int len);
int dict_get_tv(dict_T *d, char_u *key, typval_T *rettv);
char_u *dict_get_string(dict_T *d, char_u *key, int save);
varnumber_T dict_get_number(dict_T *d, char_u *key);
varnumber_T dict_get_number_def(dict_T *d, char_u *key, int def);
varnumber_T dict_get_number_check(dict_T *d, char_u *key);
varnumber_T dict_get_bool(dict_T *d, char_u *key, int def);
char_u *dict2string(typval_T *tv, int copyID, int restore_copyID);
int eval_dict(char_u **arg, typval_T *rettv, evalarg_T *evalarg, int literal);
void dict_extend(dict_T *d1, dict_T *d2, char_u *action);
dictitem_T *dict_lookup(hashitem_T *hi);
int dict_equal(dict_T *d1, dict_T *d2, int ic, int recursive);
void f_items(typval_T *argvars, typval_T *rettv);
void f_keys(typval_T *argvars, typval_T *rettv);
void f_values(typval_T *argvars, typval_T *rettv);
void dict_set_items_ro(dict_T *di);
void f_has_key(typval_T *argvars, typval_T *rettv);
void dict_remove(typval_T *argvars, typval_T *rettv, char_u *arg_errmsg);
# 75 "./proto.h" 2
# 1 "proto/diff.pro" 1

void diff_buf_delete(buf_T *buf);
void diff_buf_adjust(win_T *win);
void diff_buf_add(buf_T *buf);
void diff_invalidate(buf_T *buf);
void diff_mark_adjust(linenr_T line1, linenr_T line2, long amount, long amount_after);
void diff_redraw(int dofold);
int diff_internal(void);
void ex_diffupdate(exarg_T *eap);
void ex_diffpatch(exarg_T *eap);
void ex_diffsplit(exarg_T *eap);
void ex_diffthis(exarg_T *eap);
void diff_win_options(win_T *wp, int addbuf);
void ex_diffoff(exarg_T *eap);
void diff_clear(tabpage_T *tp);
int diff_check(win_T *wp, linenr_T lnum);
int diff_check_fill(win_T *wp, linenr_T lnum);
void diff_set_topline(win_T *fromwin, win_T *towin);
int diffopt_changed(void);
int diffopt_horizontal(void);
int diffopt_hiddenoff(void);
int diffopt_closeoff(void);
int diff_find_change(win_T *wp, linenr_T lnum, int *startp, int *endp);
int diff_infold(win_T *wp, linenr_T lnum);
void nv_diffgetput(int put, long count);
void ex_diffgetput(exarg_T *eap);
int diff_mode_buf(buf_T *buf);
int diff_move_to(int dir, long count);
linenr_T diff_get_corresponding_line(buf_T *buf1, linenr_T lnum1);
linenr_T diff_lnum_win(linenr_T lnum, win_T *wp);
void f_diff_filler(typval_T *argvars, typval_T *rettv);
void f_diff_hlID(typval_T *argvars, typval_T *rettv);
# 76 "./proto.h" 2
# 1 "proto/digraph.pro" 1

int do_digraph(int c);
char_u *get_digraph_for_char(int val_arg);
int get_digraph(int cmdline);
int getdigraph(int char1, int char2, int meta_char);
void putdigraph(char_u *str);
void listdigraphs(int use_headers);
char *keymap_init(void);
void ex_loadkeymap(exarg_T *eap);
void keymap_clear(garray_T *kmap);
# 77 "./proto.h" 2
# 1 "proto/drawline.pro" 1

int win_line(win_T *wp, linenr_T lnum, int startrow, int endrow, int nochange, int number_only);
# 78 "./proto.h" 2
# 1 "proto/drawscreen.pro" 1

int update_screen(int type_arg);
void showruler(int always);
void win_redr_ruler(win_T *wp, int always, int ignore_pum);
void after_updating_screen(int may_resize_shell);
void update_curbuf(int type);
void update_debug_sign(buf_T *buf, linenr_T lnum);
void updateWindow(win_T *wp);
int redraw_asap(int type);
void redraw_after_callback(int call_update_screen);
void redraw_later(int type);
void redraw_win_later(win_T *wp, int type);
void redraw_later_clear(void);
void redraw_all_later(int type);
void redraw_curbuf_later(int type);
void redraw_buf_later(buf_T *buf, int type);
void redraw_buf_line_later(buf_T *buf, linenr_T lnum);
void redraw_buf_and_status_later(buf_T *buf, int type);
void status_redraw_all(void);
void status_redraw_curbuf(void);
void redraw_statuslines(void);
void win_redraw_last_status(frame_T *frp);
void redrawWinline(win_T *wp, linenr_T lnum);
# 79 "./proto.h" 2
# 1 "proto/edit.pro" 1

int edit(int cmdchar, int startln, long count);
int ins_need_undo_get(void);
void ins_redraw(int ready);
int decodeModifyOtherKeys(int c);
void edit_putchar(int c, int highlight);
void set_insstart(linenr_T lnum, int col);
void edit_unputchar(void);
void display_dollar(colnr_T col);
void undisplay_dollar(void);
void truncate_spaces(char_u *line);
void backspace_until_column(int col);
int get_literal(void);
void insertchar(int c, int flags, int second_indent);
void start_arrow(pos_T *end_insert_pos);
int stop_arrow(void);
void set_last_insert(int c);
void free_last_insert(void);
char_u *add_char2buf(int c, char_u *s);
void beginline(int flags);
int oneright(void);
int oneleft(void);
int cursor_up(long n, int upd_topline);
int cursor_down(long n, int upd_topline);
int stuff_inserted(int c, long count, int no_esc);
char_u *get_last_insert(void);
char_u *get_last_insert_save(void);
void replace_push(int c);
int replace_push_mb(char_u *p);
void replace_join(int off);
int hkmap(int c);
int bracketed_paste(paste_mode_T mode, int drop, garray_T *gap);
void ins_scroll(void);
void ins_horscroll(void);
int ins_eol(int c);
int ins_copychar(linenr_T lnum);
colnr_T get_nolist_virtcol(void);
int get_can_cindent(void);
void set_can_cindent(int val);
int ins_apply_autocmds(event_T event);
# 80 "./proto.h" 2
# 1 "proto/eval.pro" 1

varnumber_T num_divide(varnumber_T n1, varnumber_T n2);
varnumber_T num_modulus(varnumber_T n1, varnumber_T n2);
void eval_init(void);
void eval_clear(void);
void fill_evalarg_from_eap(evalarg_T *evalarg, exarg_T *eap, int skip);
int eval_to_bool(char_u *arg, int *error, exarg_T *eap, int skip);
int eval_expr_valid_arg(typval_T *tv);
int eval_expr_typval(typval_T *expr, typval_T *argv, int argc, typval_T *rettv);
int eval_expr_to_bool(typval_T *expr, int *error);
char_u *eval_to_string_skip(char_u *arg, exarg_T *eap, int skip);
int skip_expr(char_u **pp, evalarg_T *evalarg);
int skip_expr_concatenate(char_u **arg, char_u **start, char_u **end, evalarg_T *evalarg);
char_u *eval_to_string_eap(char_u *arg, int convert, exarg_T *eap);
char_u *eval_to_string(char_u *arg, int convert);
char_u *eval_to_string_safe(char_u *arg, int use_sandbox);
varnumber_T eval_to_number(char_u *expr);
typval_T *eval_expr(char_u *arg, exarg_T *eap);
int call_vim_function(char_u *func, int argc, typval_T *argv, typval_T *rettv);
varnumber_T call_func_retnr(char_u *func, int argc, typval_T *argv);
void *call_func_retstr(char_u *func, int argc, typval_T *argv);
void *call_func_retlist(char_u *func, int argc, typval_T *argv);
int eval_foldexpr(char_u *arg, int *cp);
char_u *get_lval(char_u *name, typval_T *rettv, lval_T *lp, int unlet, int skip, int flags, int fne_flags);
void clear_lval(lval_T *lp);
void set_var_lval(lval_T *lp, char_u *endp, typval_T *rettv, int copy, int flags, char_u *op);
void *eval_for_line(char_u *arg, int *errp, exarg_T *eap, evalarg_T *evalarg);
void skip_for_lines(void *fi_void, evalarg_T *evalarg);
int next_for_item(void *fi_void, char_u *arg);
void free_for_info(void *fi_void);
void set_context_for_expression(expand_T *xp, char_u *arg, cmdidx_T cmdidx);
int pattern_match(char_u *pat, char_u *text, int ic);
char_u *eval_next_non_blank(char_u *arg, evalarg_T *evalarg, int *getnext);
char_u *eval_next_line(evalarg_T *evalarg);
char_u *skipwhite_and_linebreak(char_u *arg, evalarg_T *evalarg);
void clear_evalarg(evalarg_T *evalarg, exarg_T *eap);
int eval0(char_u *arg, typval_T *rettv, exarg_T *eap, evalarg_T *evalarg);
int eval1(char_u **arg, typval_T *rettv, evalarg_T *evalarg);
void eval_addblob(typval_T *tv1, typval_T *tv2);
int eval_addlist(typval_T *tv1, typval_T *tv2);
int check_can_index(typval_T *rettv, int evaluate, int verbose);
int eval_index_inner(typval_T *rettv, int is_range, typval_T *var1, typval_T *var2, char_u *key, int keylen, int verbose);
char_u *partial_name(partial_T *pt);
void partial_unref(partial_T *pt);
int get_copyID(void);
int garbage_collect(int testing);
int set_ref_in_ht(hashtab_T *ht, int copyID, list_stack_T **list_stack);
int set_ref_in_dict(dict_T *d, int copyID);
int set_ref_in_list(list_T *ll, int copyID);
int set_ref_in_list_items(list_T *l, int copyID, ht_stack_T **ht_stack);
int set_ref_in_item(typval_T *tv, int copyID, ht_stack_T **ht_stack, list_stack_T **list_stack);
char_u *echo_string_core(typval_T *tv, char_u **tofree, char_u *numbuf, int copyID, int echo_style, int restore_copyID, int composite_val);
char_u *echo_string(typval_T *tv, char_u **tofree, char_u *numbuf, int copyID);
char_u *string_quote(char_u *str, int function);
int string2float(char_u *text, float_T *value);
pos_T *var2fpos(typval_T *varp, int dollar_lnum, int *fnum);
int list2fpos(typval_T *arg, pos_T *posp, int *fnump, colnr_T *curswantp);
int get_env_len(char_u **arg);
int get_id_len(char_u **arg);
int get_name_len(char_u **arg, char_u **alias, int evaluate, int verbose);
char_u *find_name_end(char_u *arg, char_u **expr_start, char_u **expr_end, int flags);
int eval_isnamec(int c);
int eval_isnamec1(int c);
int eval_isdictc(int c);
char_u *char_from_string(char_u *str, varnumber_T index);
char_u *string_slice(char_u *str, varnumber_T first, varnumber_T last);
int handle_subscript(char_u **arg, typval_T *rettv, evalarg_T *evalarg, int verbose);
int item_copy(typval_T *from, typval_T *to, int deep, int copyID);
void echo_one(typval_T *rettv, int with_space, int *atstart, int *needclr);
void ex_echo(exarg_T *eap);
void ex_echohl(exarg_T *eap);
int get_echo_attr(void);
void ex_execute(exarg_T *eap);
char_u *find_option_end(char_u **arg, int *opt_flags);
void last_set_msg(sctx_T script_ctx);
char_u *do_string_sub(char_u *str, char_u *pat, char_u *sub, typval_T *expr, char_u *flags);
# 81 "./proto.h" 2
# 1 "proto/evalbuffer.pro" 1

int set_ref_in_buffers(int copyID);
buf_T *buflist_find_by_name(char_u *name, int curtab_only);
buf_T *find_buffer(typval_T *avar);
void f_append(typval_T *argvars, typval_T *rettv);
void f_appendbufline(typval_T *argvars, typval_T *rettv);
void f_bufadd(typval_T *argvars, typval_T *rettv);
void f_bufexists(typval_T *argvars, typval_T *rettv);
void f_buflisted(typval_T *argvars, typval_T *rettv);
void f_bufload(typval_T *argvars, typval_T *rettv);
void f_bufloaded(typval_T *argvars, typval_T *rettv);
void f_bufname(typval_T *argvars, typval_T *rettv);
void f_bufnr(typval_T *argvars, typval_T *rettv);
void f_bufwinid(typval_T *argvars, typval_T *rettv);
void f_bufwinnr(typval_T *argvars, typval_T *rettv);
void f_deletebufline(typval_T *argvars, typval_T *rettv);
void f_getbufinfo(typval_T *argvars, typval_T *rettv);
void f_getbufline(typval_T *argvars, typval_T *rettv);
type_T *ret_f_getline(int argcount, type_T **argtypes);
void f_getline(typval_T *argvars, typval_T *rettv);
void f_setbufline(typval_T *argvars, typval_T *rettv);
void f_setline(typval_T *argvars, typval_T *rettv);
void switch_buffer(bufref_T *save_curbuf, buf_T *buf);
void restore_buffer(bufref_T *save_curbuf);
void switch_to_win_for_buf(buf_T *buf, win_T **save_curwinp, tabpage_T **save_curtabp, bufref_T *save_curbuf);
void restore_win_for_buf(win_T *save_curwin, tabpage_T *save_curtab, bufref_T *save_curbuf);
# 82 "./proto.h" 2
# 1 "proto/evalfunc.pro" 1

char_u *get_function_name(expand_T *xp, int idx);
char_u *get_expr_name(expand_T *xp, int idx);
int find_internal_func(char_u *name);
int has_internal_func(char_u *name);
char *internal_func_name(int idx);
int internal_func_check_arg_types(type_T **types, int idx, int argcount);
type_T *internal_func_ret_type(int idx, int argcount, type_T **argtypes);
int check_internal_func(int idx, int argcount);
int call_internal_func(char_u *name, int argcount, typval_T *argvars, typval_T *rettv);
void call_internal_func_by_idx(int idx, typval_T *argvars, typval_T *rettv);
int call_internal_method(char_u *name, int argcount, typval_T *argvars, typval_T *rettv, typval_T *basetv);
int non_zero_arg(typval_T *argvars);
buf_T *get_buf_arg(typval_T *arg);
win_T *get_optional_window(typval_T *argvars, int idx);
void execute_redir_str(char_u *value, int value_len);
void execute_common(typval_T *argvars, typval_T *rettv, int arg_off);
void f_has(typval_T *argvars, typval_T *rettv);
int dynamic_feature(char_u *feature);
void mzscheme_call_vim(char_u *name, typval_T *args, typval_T *rettv);
void range_list_materialize(list_T *list);
float_T vim_round(float_T f);
long do_searchpair(char_u *spat, char_u *mpat, char_u *epat, int dir, typval_T *skip, int flags, pos_T *match_pos, linenr_T lnum_stop, long time_limit);
void f_string(typval_T *argvars, typval_T *rettv);
# 83 "./proto.h" 2
# 1 "proto/evalvars.pro" 1

void evalvars_init(void);
void evalvars_clear(void);
int garbage_collect_globvars(int copyID);
int garbage_collect_vimvars(int copyID);
int garbage_collect_scriptvars(int copyID);
void set_internal_string_var(char_u *name, char_u *value);
int eval_charconvert(char_u *enc_from, char_u *enc_to, char_u *fname_from, char_u *fname_to);
int eval_printexpr(char_u *fname, char_u *args);
void eval_diff(char_u *origfile, char_u *newfile, char_u *outfile);
void eval_patch(char_u *origfile, char_u *difffile, char_u *outfile);
list_T *eval_spell_expr(char_u *badword, char_u *expr);
int get_spellword(list_T *list, char_u **pp);
void prepare_vimvar(int idx, typval_T *save_tv);
void restore_vimvar(int idx, typval_T *save_tv);
list_T *heredoc_get(exarg_T *eap, char_u *cmd, int script_get);
void ex_var(exarg_T *eap);
void ex_let(exarg_T *eap);
int ex_let_vars(char_u *arg_start, typval_T *tv, int copy, int semicolon, int var_count, int flags, char_u *op);
char_u *skip_var_list(char_u *arg, int include_type, int *var_count, int *semicolon, int silent);
char_u *skip_var_one(char_u *arg, int include_type);
void list_hashtable_vars(hashtab_T *ht, char *prefix, int empty, int *first);
void ex_unlet(exarg_T *eap);
void ex_lockvar(exarg_T *eap);
void ex_unletlock(exarg_T *eap, char_u *argstart, int deep, int glv_flags, int (*callback)(lval_T *, char_u *, exarg_T *, int, void *), void *cookie);
int do_unlet(char_u *name, int forceit);
void item_lock(typval_T *tv, int deep, int lock, int check_refcount);
void del_menutrans_vars(void);
char_u *get_user_var_name(expand_T *xp, int idx);
char *get_var_special_name(int nr);
dict_T *get_globvar_dict(void);
hashtab_T *get_globvar_ht(void);
dict_T *get_vimvar_dict(void);
int find_vim_var(char_u *name, int *di_flags);
void set_vim_var_type(int idx, vartype_T type);
void set_vim_var_nr(int idx, varnumber_T val);
char *get_vim_var_name(int idx);
typval_T *get_vim_var_tv(int idx);
int set_vim_var_tv(int idx, typval_T *tv);
varnumber_T get_vim_var_nr(int idx);
char_u *get_vim_var_str(int idx);
list_T *get_vim_var_list(int idx);
dict_T *get_vim_var_dict(int idx);
void set_vim_var_char(int c);
void set_vcount(long count, long count1, int set_prevcount);
void save_vimvars(vimvars_save_T *vvsave);
void restore_vimvars(vimvars_save_T *vvsave);
void set_vim_var_string(int idx, char_u *val, int len);
void set_vim_var_list(int idx, list_T *val);
void set_vim_var_dict(int idx, dict_T *val);
void set_argv_var(char **argv, int argc);
void reset_reg_var(void);
void set_reg_var(int c);
char_u *v_exception(char_u *oldval);
char_u *v_throwpoint(char_u *oldval);
char_u *set_cmdarg(exarg_T *eap, char_u *oldarg);
int eval_variable(char_u *name, int len, typval_T *rettv, dictitem_T **dip, int verbose, int no_autoload);
void check_vars(char_u *name, int len);
dictitem_T *find_var(char_u *name, hashtab_T **htp, int no_autoload);
dictitem_T *find_var_in_ht(hashtab_T *ht, int htname, char_u *varname, int no_autoload);
hashtab_T *get_script_local_ht(void);
void *lookup_scriptvar(char_u *name, size_t len, cctx_T *dummy);
hashtab_T *find_var_ht(char_u *name, char_u **varname);
char_u *get_var_value(char_u *name);
void new_script_vars(scid_T id);
void init_var_dict(dict_T *dict, dictitem_T *dict_var, int scope);
void unref_var_dict(dict_T *dict);
void vars_clear(hashtab_T *ht);
void vars_clear_ext(hashtab_T *ht, int free_val);
void delete_var(hashtab_T *ht, hashitem_T *hi);
void set_var(char_u *name, typval_T *tv, int copy);
void set_var_const(char_u *name, type_T *type, typval_T *tv_arg, int copy, int flags);
int var_check_ro(int flags, char_u *name, int use_gettext);
int var_check_lock(int flags, char_u *name, int use_gettext);
int var_check_fixed(int flags, char_u *name, int use_gettext);
int var_wrong_func_name(char_u *name, int new_var);
int value_check_lock(int lock, char_u *name, int use_gettext);
int valid_varname(char_u *varname);
void reset_v_option_vars(void);
void assert_error(garray_T *gap);
int var_exists(char_u *var);
int var_redir_start(char_u *name, int append);
void var_redir_str(char_u *value, int value_len);
void var_redir_stop(void);
void f_gettabvar(typval_T *argvars, typval_T *rettv);
void f_gettabwinvar(typval_T *argvars, typval_T *rettv);
void f_getwinvar(typval_T *argvars, typval_T *rettv);
void f_getbufvar(typval_T *argvars, typval_T *rettv);
void f_settabvar(typval_T *argvars, typval_T *rettv);
void f_settabwinvar(typval_T *argvars, typval_T *rettv);
void f_setwinvar(typval_T *argvars, typval_T *rettv);
void f_setbufvar(typval_T *argvars, typval_T *rettv);
callback_T get_callback(typval_T *arg);
void put_callback(callback_T *cb, typval_T *tv);
void set_callback(callback_T *dest, callback_T *src);
void copy_callback(callback_T *dest, callback_T *src);
void free_callback(callback_T *callback);
# 84 "./proto.h" 2
# 1 "proto/evalwindow.pro" 1

win_T *win_id2wp(int id);
win_T *win_id2wp_tp(int id, tabpage_T **tpp);
void win_findbuf(typval_T *argvars, list_T *list);
win_T *find_win_by_nr(typval_T *vp, tabpage_T *tp);
win_T *find_win_by_nr_or_id(typval_T *vp);
win_T *find_tabwin(typval_T *wvp, typval_T *tvp, tabpage_T **ptp);
void f_gettabinfo(typval_T *argvars, typval_T *rettv);
void f_getwininfo(typval_T *argvars, typval_T *rettv);
void f_getwinpos(typval_T *argvars, typval_T *rettv);
void f_getwinposx(typval_T *argvars, typval_T *rettv);
void f_getwinposy(typval_T *argvars, typval_T *rettv);
void f_tabpagenr(typval_T *argvars, typval_T *rettv);
void f_tabpagewinnr(typval_T *argvars, typval_T *rettv);
void f_win_execute(typval_T *argvars, typval_T *rettv);
void f_win_findbuf(typval_T *argvars, typval_T *rettv);
void f_win_getid(typval_T *argvars, typval_T *rettv);
void f_win_gotoid(typval_T *argvars, typval_T *rettv);
void f_win_id2tabwin(typval_T *argvars, typval_T *rettv);
void f_win_id2win(typval_T *argvars, typval_T *rettv);
void f_win_screenpos(typval_T *argvars, typval_T *rettv);
void f_win_splitmove(typval_T *argvars, typval_T *rettv);
void f_win_gettype(typval_T *argvars, typval_T *rettv);
void f_getcmdwintype(typval_T *argvars, typval_T *rettv);
void f_winbufnr(typval_T *argvars, typval_T *rettv);
void f_wincol(typval_T *argvars, typval_T *rettv);
void f_winheight(typval_T *argvars, typval_T *rettv);
void f_winlayout(typval_T *argvars, typval_T *rettv);
void f_winline(typval_T *argvars, typval_T *rettv);
void f_winnr(typval_T *argvars, typval_T *rettv);
void f_winrestcmd(typval_T *argvars, typval_T *rettv);
void f_winrestview(typval_T *argvars, typval_T *rettv);
void f_winsaveview(typval_T *argvars, typval_T *rettv);
void f_winwidth(typval_T *argvars, typval_T *rettv);
int switch_win(win_T **save_curwin, tabpage_T **save_curtab, win_T *win, tabpage_T *tp, int no_display);
int switch_win_noblock(win_T **save_curwin, tabpage_T **save_curtab, win_T *win, tabpage_T *tp, int no_display);
void restore_win(win_T *save_curwin, tabpage_T *save_curtab, int no_display);
void restore_win_noblock(win_T *save_curwin, tabpage_T *save_curtab, int no_display);
# 85 "./proto.h" 2
# 1 "proto/ex_cmds.pro" 1

void do_ascii(exarg_T *eap);
void ex_align(exarg_T *eap);
void ex_sort(exarg_T *eap);
int do_move(linenr_T line1, linenr_T line2, linenr_T dest);
void ex_copy(linenr_T line1, linenr_T line2, linenr_T n);
void free_prev_shellcmd(void);
void do_bang(int addr_count, exarg_T *eap, int forceit, int do_in, int do_out);
void do_shell(char_u *cmd, int flags);
char_u *make_filter_cmd(char_u *cmd, char_u *itmp, char_u *otmp);
void append_redir(char_u *buf, int buflen, char_u *opt, char_u *fname);
void do_fixdel(exarg_T *eap);
void print_line_no_prefix(linenr_T lnum, int use_number, int list);
void print_line(linenr_T lnum, int use_number, int list);
int rename_buffer(char_u *new_fname);
void ex_file(exarg_T *eap);
void ex_update(exarg_T *eap);
void ex_write(exarg_T *eap);
int do_write(exarg_T *eap);
int check_overwrite(exarg_T *eap, buf_T *buf, char_u *fname, char_u *ffname, int other);
void ex_wnext(exarg_T *eap);
void do_wqall(exarg_T *eap);
int getfile(int fnum, char_u *ffname_arg, char_u *sfname_arg, int setpm, linenr_T lnum, int forceit);
int do_ecmd(int fnum, char_u *ffname, char_u *sfname, exarg_T *eap, linenr_T newlnum, int flags, win_T *oldwin);
void ex_append(exarg_T *eap);
void ex_change(exarg_T *eap);
void ex_z(exarg_T *eap);
int check_restricted(void);
int check_secure(void);
void ex_substitute(exarg_T *eap);
int do_sub_msg(int count_only);
void ex_global(exarg_T *eap);
void global_exe(char_u *cmd);
char_u *get_old_sub(void);
void set_old_sub(char_u *val);
void free_old_sub(void);
int prepare_tagpreview(int undo_sync, int use_previewpopup, use_popup_T use_popup);
void ex_smile(exarg_T *eap);
void ex_drop(exarg_T *eap);
char_u *skip_vimgrep_pat(char_u *p, char_u **s, int *flags);
void ex_oldfiles(exarg_T *eap);
# 86 "./proto.h" 2
# 1 "proto/ex_cmds2.pro" 1

int autowrite(buf_T *buf, int forceit);
void autowrite_all(void);
int check_changed(buf_T *buf, int flags);
void browse_save_fname(buf_T *buf);
void dialog_changed(buf_T *buf, int checkall);
int can_abandon(buf_T *buf, int forceit);
int check_changed_any(int hidden, int unload);
int check_fname(void);
int buf_write_all(buf_T *buf, int forceit);
void ex_listdo(exarg_T *eap);
void ex_compiler(exarg_T *eap);
void init_pyxversion(void);
void ex_pyxfile(exarg_T *eap);
void ex_pyx(exarg_T *eap);
void ex_pyxdo(exarg_T *eap);
void ex_checktime(exarg_T *eap);
# 87 "./proto.h" 2
# 1 "proto/ex_docmd.pro" 1

void do_exmode(int improved);
int do_cmdline_cmd(char_u *cmd);
int do_cmdline(char_u *cmdline, char_u *(*fgetline)(int, void *, int, getline_opt_T), void *cookie, int flags);
int getline_equal(char_u *(*fgetline)(int, void *, int, getline_opt_T), void *cookie, char_u *(*func)(int, void *, int, getline_opt_T));
void *getline_cookie(char_u *(*fgetline)(int, void *, int, getline_opt_T), void *cookie);
char_u *getline_peek(char_u *(*fgetline)(int, void *, int, getline_opt_T), void *cookie);
char *ex_errmsg(char *msg, char_u *arg);
int parse_command_modifiers(exarg_T *eap, char **errormsg, cmdmod_T *cmod, int skip_only);
void apply_cmdmod(cmdmod_T *cmod);
void undo_cmdmod(cmdmod_T *cmod);
int parse_cmd_address(exarg_T *eap, char **errormsg, int silent);
int checkforcmd(char_u **pp, char *cmd, int len);
char_u *skip_option_env_lead(char_u *start);
char_u *find_ex_command(exarg_T *eap, int *full, void *(*lookup)(char_u *, size_t, cctx_T *), cctx_T *cctx);
int modifier_len(char_u *cmd);
int cmd_exists(char_u *name);
cmdidx_T excmd_get_cmdidx(char_u *cmd, int len);
long excmd_get_argt(cmdidx_T idx);
char_u *skip_range(char_u *cmd, int skip_star, int *ctx);
void ex_ni(exarg_T *eap);
int expand_filename(exarg_T *eap, char_u **cmdlinep, char **errormsgp);
void separate_nextcmd(exarg_T *eap);
char_u *skip_cmd_arg(char_u *p, int rembs);
int get_bad_opt(char_u *p, exarg_T *eap);
int ends_excmd(int c);
int ends_excmd2(char_u *cmd_start, char_u *cmd);
char_u *find_nextcmd(char_u *p);
char_u *check_nextcmd(char_u *p);
char_u *get_command_name(expand_T *xp, int idx);
void not_exiting(void);
void ex_quit(exarg_T *eap);
void tabpage_close(int forceit);
void tabpage_close_other(tabpage_T *tp, int forceit);
void handle_drop(int filec, char_u **filev, int split, void (*callback)(void *), void *cookie);
void handle_any_postponed_drop(void);
void ex_splitview(exarg_T *eap);
void tabpage_new(void);
void do_exedit(exarg_T *eap, win_T *old_curwin);
void free_cd_dir(void);
void post_chdir(cdscope_T scope);
int changedir_func(char_u *new_dir, int forceit, cdscope_T scope);
void ex_cd(exarg_T *eap);
void do_sleep(long msec);
void ex_may_print(exarg_T *eap);
void ex_redraw(exarg_T *eap);
int vim_mkdir_emsg(char_u *name, int prot);
FILE *open_exfile(char_u *fname, int forceit, char *mode);
void update_topline_cursor(void);
int save_current_state(save_state_T *sst);
void restore_current_state(save_state_T *sst);
void ex_normal(exarg_T *eap);
void exec_normal_cmd(char_u *cmd, int remap, int silent);
void exec_normal(int was_typed, int use_vpeekc, int may_use_terminal_loop);
int find_cmdline_var(char_u *src, int *usedlen);
char_u *eval_vars(char_u *src, char_u *srcstart, int *usedlen, linenr_T *lnump, char **errormsg, int *escaped);
char_u *expand_sfile(char_u *arg);
void dialog_msg(char_u *buff, char *format, char_u *fname);
void set_no_hlsearch(int flag);
int is_loclist_cmd(int cmdidx);
int get_pressedreturn(void);
void set_pressedreturn(int val);
# 88 "./proto.h" 2
# 1 "proto/ex_eval.pro" 1

int aborting(void);
void update_force_abort(void);
int should_abort(int retcode);
int aborted_in_try(void);
int cause_errthrow(char_u *mesg, int severe, int *ignore);
void free_global_msglist(void);
void do_errthrow(cstack_T *cstack, char_u *cmdname);
int do_intthrow(cstack_T *cstack);
char *get_exception_string(void *value, except_type_T type, char_u *cmdname, int *should_free);
int throw_exception(void *value, except_type_T type, char_u *cmdname);
void discard_current_exception(void);
void catch_exception(except_T *excp);
void report_make_pending(int pending, void *value);
void ex_eval(exarg_T *eap);
void ex_if(exarg_T *eap);
void ex_endif(exarg_T *eap);
void ex_else(exarg_T *eap);
void ex_while(exarg_T *eap);
void ex_continue(exarg_T *eap);
void ex_break(exarg_T *eap);
void ex_endwhile(exarg_T *eap);
void ex_block(exarg_T *eap);
void ex_endblock(exarg_T *eap);
void ex_throw(exarg_T *eap);
void do_throw(cstack_T *cstack);
void ex_try(exarg_T *eap);
void ex_catch(exarg_T *eap);
void ex_finally(exarg_T *eap);
void ex_endtry(exarg_T *eap);
void enter_cleanup(cleanup_T *csp);
void leave_cleanup(cleanup_T *csp);
int cleanup_conditionals(cstack_T *cstack, int searched_cond, int inclusive);
void rewind_conditionals(cstack_T *cstack, int idx, int cond_type, int *cond_level);
void ex_endfunction(exarg_T *eap);
int has_loop_cmd(char_u *p);
# 89 "./proto.h" 2
# 1 "proto/ex_getln.pro" 1

void cmdline_init(void);
char_u *getcmdline(int firstc, long count, int indent, int do_concat);
char_u *getcmdline_prompt(int firstc, char_u *prompt, int attr, int xp_context, char_u *xp_arg);
int check_opt_wim(void);
int text_and_win_locked(void);
void text_locked_msg(void);
char *get_text_locked_msg(void);
int text_locked(void);
int curbuf_locked(void);
int allbuf_locked(void);
char_u *getexline(int c, void *cookie, int indent, getline_opt_T options);
char_u *getexmodeline(int promptc, void *cookie, int indent, getline_opt_T options);
int cmdline_overstrike(void);
int cmdline_at_end(void);
colnr_T cmdline_getvcol_cursor(void);
int realloc_cmdbuff(int len);
void free_arshape_buf(void);
void putcmdline(int c, int shift);
void unputcmdline(void);
int put_on_cmdline(char_u *str, int len, int redraw);
void cmdline_paste_str(char_u *s, int literally);
void redrawcmdline(void);
void redrawcmdline_ex(int do_compute_cmdrow);
void redrawcmd(void);
void compute_cmdrow(void);
void cursorcmd(void);
void gotocmdline(int clr);
char_u *vim_strsave_fnameescape(char_u *fname, int shell);
void escape_fname(char_u **pp);
void tilde_replace(char_u *orig_pat, int num_files, char_u **files);
cmdline_info_T *get_cmdline_info(void);
void f_getcmdline(typval_T *argvars, typval_T *rettv);
void f_getcmdpos(typval_T *argvars, typval_T *rettv);
void f_setcmdpos(typval_T *argvars, typval_T *rettv);
void f_getcmdtype(typval_T *argvars, typval_T *rettv);
int get_cmdline_type(void);
int get_cmdline_firstc(void);
int get_list_range(char_u **str, int *num1, int *num2);
char *check_cedit(void);
char_u *script_get(exarg_T *eap, char_u *cmd);
void get_user_input(typval_T *argvars, typval_T *rettv, int inputdialog, int secret);
# 90 "./proto.h" 2
# 1 "proto/fileio.pro" 1

void filemess(buf_T *buf, char_u *name, char_u *s, int attr);
int readfile(char_u *fname, char_u *sfname, linenr_T from, linenr_T lines_to_skip, linenr_T lines_to_read, exarg_T *eap, int flags);
int is_dev_fd_file(char_u *fname);
int prep_exarg(exarg_T *eap, buf_T *buf);
void set_file_options(int set_options, exarg_T *eap);
void set_forced_fenc(exarg_T *eap);
int check_file_readonly(char_u *fname, int perm);
int vim_fsync(int fd);
int set_rw_fname(char_u *fname, char_u *sfname);
void msg_add_fname(buf_T *buf, char_u *fname);
int msg_add_fileformat(int eol_type);
void msg_add_lines(int insert_space, long lnum, off_T nchars);
void msg_add_eol(void);
int time_differs(long t1, long t2);
int need_conversion(char_u *fenc);
int get_fio_flags(char_u *ptr);
int get_win_fio_flags(char_u *ptr);
int get_mac_fio_flags(char_u *ptr);
char_u *shorten_fname1(char_u *full_path);
char_u *shorten_fname(char_u *full_path, char_u *dir_name);
void shorten_buf_fname(buf_T *buf, char_u *dirname, int force);
void shorten_fnames(int force);
void shorten_filenames(char_u **fnames, int count);
char_u *modname(char_u *fname, char_u *ext, int prepend_dot);
char_u *buf_modname(int shortname, char_u *fname, char_u *ext, int prepend_dot);
int vim_fgets(char_u *buf, int size, FILE *fp);
int vim_rename(char_u *from, char_u *to);
int check_timestamps(int focus);
int buf_check_timestamp(buf_T *buf, int focus);
void buf_reload(buf_T *buf, int orig_mode);
void buf_store_time(buf_T *buf, stat_T *st, char_u *fname);
void write_lnum_adjust(linenr_T offset);
int readdir_core(garray_T *gap, char_u *path, int withattr, void *context, int (*checkitem)(void *context, void *item), int sort);
int delete_recursive(char_u *name);
void vim_deltempdir(void);
char_u *vim_tempname(int extra_char, int keep);
void forward_slash(char_u *fname);
int match_file_pat(char_u *pattern, regprog_T **prog, char_u *fname, char_u *sfname, char_u *tail, int allow_dirs);
int match_file_list(char_u *list, char_u *sfname, char_u *ffname);
char_u *file_pat_to_reg_pat(char_u *pat, char_u *pat_end, char *allow_dirs, int no_bslash);
long read_eintr(int fd, void *buf, size_t bufsize);
long write_eintr(int fd, void *buf, size_t bufsize);
# 91 "./proto.h" 2
# 1 "proto/filepath.pro" 1

int modify_fname(char_u *src, int tilde_file, int *usedlen, char_u **fnamep, char_u **bufp, int *fnamelen);
void f_chdir(typval_T *argvars, typval_T *rettv);
void f_delete(typval_T *argvars, typval_T *rettv);
void f_executable(typval_T *argvars, typval_T *rettv);
void f_exepath(typval_T *argvars, typval_T *rettv);
void f_filereadable(typval_T *argvars, typval_T *rettv);
void f_filewritable(typval_T *argvars, typval_T *rettv);
void f_finddir(typval_T *argvars, typval_T *rettv);
void f_findfile(typval_T *argvars, typval_T *rettv);
void f_fnamemodify(typval_T *argvars, typval_T *rettv);
void f_getcwd(typval_T *argvars, typval_T *rettv);
char_u *getfpermst(stat_T *st, char_u *perm);
void f_getfperm(typval_T *argvars, typval_T *rettv);
void f_getfsize(typval_T *argvars, typval_T *rettv);
void f_getftime(typval_T *argvars, typval_T *rettv);
char_u *getftypest(stat_T *st);
void f_getftype(typval_T *argvars, typval_T *rettv);
void f_glob(typval_T *argvars, typval_T *rettv);
void f_glob2regpat(typval_T *argvars, typval_T *rettv);
void f_globpath(typval_T *argvars, typval_T *rettv);
void f_isdirectory(typval_T *argvars, typval_T *rettv);
void f_mkdir(typval_T *argvars, typval_T *rettv);
void shorten_dir(char_u *str);
void f_pathshorten(typval_T *argvars, typval_T *rettv);
void f_readdir(typval_T *argvars, typval_T *rettv);
void f_readdirex(typval_T *argvars, typval_T *rettv);
void f_readfile(typval_T *argvars, typval_T *rettv);
void f_resolve(typval_T *argvars, typval_T *rettv);
void f_tempname(typval_T *argvars, typval_T *rettv);
void f_writefile(typval_T *argvars, typval_T *rettv);
char_u *do_browse(int flags, char_u *title, char_u *dflt, char_u *ext, char_u *initdir, char_u *filter, buf_T *buf);
void f_browse(typval_T *argvars, typval_T *rettv);
void f_browsedir(typval_T *argvars, typval_T *rettv);
void home_replace(buf_T *buf, char_u *src, char_u *dst, int dstlen, int one);
char_u *home_replace_save(buf_T *buf, char_u *src);
int fullpathcmp(char_u *s1, char_u *s2, int checkname, int expandenv);
char_u *gettail(char_u *fname);
char_u *gettail_sep(char_u *fname);
char_u *getnextcomp(char_u *fname);
char_u *get_past_head(char_u *path);
int vim_ispathsep(int c);
int vim_ispathsep_nocolon(int c);
int dir_of_file_exists(char_u *fname);
int vim_fnamecmp(char_u *x, char_u *y);
int vim_fnamencmp(char_u *x, char_u *y, size_t len);
char_u *concat_fnames(char_u *fname1, char_u *fname2, int sep);
void add_pathsep(char_u *p);
char_u *FullName_save(char_u *fname, int force);
int vim_fexists(char_u *fname);
int expand_wildcards_eval(char_u **pat, int *num_file, char_u ***file, int flags);
int expand_wildcards(int num_pat, char_u **pat, int *num_files, char_u ***files, int flags);
int match_suffix(char_u *fname);
int unix_expandpath(garray_T *gap, char_u *path, int wildoff, int flags, int didstar);
int gen_expand_wildcards(int num_pat, char_u **pat, int *num_file, char_u ***file, int flags);
void addfile(garray_T *gap, char_u *f, int flags);
void FreeWild(int count, char_u **files);
int pathcmp(const char *p, const char *q, int maxlen);
int vim_isAbsName(char_u *name);
int vim_FullName(char_u *fname, char_u *buf, int len, int force);
# 92 "./proto.h" 2
# 1 "proto/findfile.pro" 1

void *vim_findfile_init(char_u *path, char_u *filename, char_u *stopdirs, int level, int free_visited, int find_what, void *search_ctx_arg, int tagfile, char_u *rel_fname);
char_u *vim_findfile_stopdir(char_u *buf);
void vim_findfile_cleanup(void *ctx);
char_u *vim_findfile(void *search_ctx_arg);
char_u *find_file_in_path(char_u *ptr, int len, int options, int first, char_u *rel_fname);
void free_findfile(void);
char_u *find_directory_in_path(char_u *ptr, int len, int options, char_u *rel_fname);
char_u *find_file_in_path_option(char_u *ptr, int len, int options, int first, char_u *path_option, int find_what, char_u *rel_fname, char_u *suffixes);
char_u *grab_file_name(long count, linenr_T *file_lnum);
char_u *file_name_at_cursor(int options, long count, linenr_T *file_lnum);
char_u *file_name_in_line(char_u *line, int col, int options, long count, char_u *rel_fname, linenr_T *file_lnum);
char_u *find_file_name_in_path(char_u *ptr, int len, int options, long count, char_u *rel_fname);
int vim_ispathlistsep(int c);
void uniquefy_paths(garray_T *gap, char_u *pattern);
int expand_in_path(garray_T *gap, char_u *pattern, int flags);
void simplify_filename(char_u *filename);
void f_simplify(typval_T *argvars, typval_T *rettv);
# 93 "./proto.h" 2
# 1 "proto/fold.pro" 1

void copyFoldingState(win_T *wp_from, win_T *wp_to);
int hasAnyFolding(win_T *win);
int hasFolding(linenr_T lnum, linenr_T *firstp, linenr_T *lastp);
int hasFoldingWin(win_T *win, linenr_T lnum, linenr_T *firstp, linenr_T *lastp, int cache, foldinfo_T *infop);
int lineFolded(win_T *win, linenr_T lnum);
long foldedCount(win_T *win, linenr_T lnum, foldinfo_T *infop);
int foldmethodIsManual(win_T *wp);
int foldmethodIsIndent(win_T *wp);
int foldmethodIsExpr(win_T *wp);
int foldmethodIsMarker(win_T *wp);
int foldmethodIsSyntax(win_T *wp);
int foldmethodIsDiff(win_T *wp);
void closeFold(linenr_T lnum, long count);
void closeFoldRecurse(linenr_T lnum);
void opFoldRange(linenr_T first, linenr_T last, int opening, int recurse, int had_visual);
void openFold(linenr_T lnum, long count);
void openFoldRecurse(linenr_T lnum);
void foldOpenCursor(void);
void newFoldLevel(void);
void foldCheckClose(void);
int foldManualAllowed(int create);
void foldCreate(linenr_T start, linenr_T end);
void deleteFold(linenr_T start, linenr_T end, int recursive, int had_visual);
void clearFolding(win_T *win);
void foldUpdate(win_T *wp, linenr_T top, linenr_T bot);
void foldUpdateAll(win_T *win);
int foldMoveTo(int updown, int dir, long count);
void foldInitWin(win_T *new_win);
int find_wl_entry(win_T *win, linenr_T lnum);
void foldAdjustVisual(void);
void foldAdjustCursor(void);
void cloneFoldGrowArray(garray_T *from, garray_T *to);
void deleteFoldRecurse(garray_T *gap);
void foldMarkAdjust(win_T *wp, linenr_T line1, linenr_T line2, long amount, long amount_after);
int getDeepestNesting(void);
char_u *get_foldtext(win_T *wp, linenr_T lnum, linenr_T lnume, foldinfo_T *foldinfo, char_u *buf);
void foldMoveRange(garray_T *gap, linenr_T line1, linenr_T line2, linenr_T dest);
int put_folds(FILE *fd, win_T *wp);
void f_foldclosed(typval_T *argvars, typval_T *rettv);
void f_foldclosedend(typval_T *argvars, typval_T *rettv);
void f_foldlevel(typval_T *argvars, typval_T *rettv);
void f_foldtext(typval_T *argvars, typval_T *rettv);
void f_foldtextresult(typval_T *argvars, typval_T *rettv);
# 94 "./proto.h" 2
# 1 "proto/getchar.pro" 1

char_u *get_recorded(void);
char_u *get_inserted(void);
int stuff_empty(void);
int readbuf1_empty(void);
void typeahead_noflush(int c);
void flush_buffers(flush_buffers_T flush_typeahead);
void ResetRedobuff(void);
void CancelRedo(void);
void saveRedobuff(save_redo_T *save_redo);
void restoreRedobuff(save_redo_T *save_redo);
void AppendToRedobuff(char_u *s);
void AppendToRedobuffLit(char_u *str, int len);
void AppendCharToRedobuff(int c);
void AppendNumberToRedobuff(long n);
void stuffReadbuff(char_u *s);
void stuffRedoReadbuff(char_u *s);
void stuffReadbuffLen(char_u *s, long len);
void stuffReadbuffSpec(char_u *s);
void stuffcharReadbuff(int c);
void stuffnumReadbuff(long n);
void stuffescaped(char_u *arg, int literally);
int start_redo(long count, int old_redo);
int start_redo_ins(void);
void stop_redo_ins(void);
int noremap_keys(void);
int ins_typebuf(char_u *str, int noremap, int offset, int nottyped, int silent);
void ins_char_typebuf(int c, int modifier);
int typebuf_changed(int tb_change_cnt);
int typebuf_typed(void);
int typebuf_maplen(void);
void del_typebuf(int len, int offset);
int save_typebuf(void);
void save_typeahead(tasave_T *tp);
void restore_typeahead(tasave_T *tp);
void openscript(char_u *name, int directly);
void close_all_scripts(void);
int using_script(void);
void before_blocking(void);
int merge_modifyOtherKeys(int c_arg, int *modifiers);
int vgetc(void);
int safe_vgetc(void);
int plain_vgetc(void);
int vpeekc(void);
int vpeekc_nomap(void);
int vpeekc_any(void);
int char_avail(void);
void f_getchar(typval_T *argvars, typval_T *rettv);
void f_getcharmod(typval_T *argvars, typval_T *rettv);
void parse_queued_messages(void);
void vungetc(int c);
int fix_input_buffer(char_u *buf, int len);
int input_available(void);
char_u *getcmdkeycmd(int promptc, void *cookie, int indent, getline_opt_T do_concat);
# 95 "./proto.h" 2
# 1 "proto/gui_xim.pro" 1

void im_set_active(int active);
void xim_set_focus(int focus);
void im_set_position(int row, int col);
void xim_set_preedit(void);
int im_get_feedback_attr(int col);
void xim_init(void);
void im_shutdown(void);
int im_xim_isvalid_imactivate(void);
void xim_reset(void);
int xim_queue_key_press_event(int *event, int down);
int im_get_status(void);
int preedit_get_status(void);
int im_is_preediting(void);
void xim_set_status_area(void);
int xim_get_status_area_height(void);
# 96 "./proto.h" 2
# 1 "proto/hardcopy.pro" 1

char *parse_printoptions(void);
char *parse_printmbfont(void);
int prt_header_height(void);
int prt_use_number(void);
int prt_get_unit(int idx);
void ex_hardcopy(exarg_T *eap);
void mch_print_cleanup(void);
int mch_print_init(prt_settings_T *psettings, char_u *jobname, int forceit);
int mch_print_begin(prt_settings_T *psettings);
void mch_print_end(prt_settings_T *psettings);
int mch_print_end_page(void);
int mch_print_begin_page(char_u *str);
int mch_print_blank_page(void);
void mch_print_start_line(int margin, int page_line);
int mch_print_text_out(char_u *textp, int len);
void mch_print_set_font(int iBold, int iItalic, int iUnderline);
void mch_print_set_bg(long_u bgcol);
void mch_print_set_fg(long_u fgcol);
# 97 "./proto.h" 2
# 1 "proto/hashtab.pro" 1

void hash_init(hashtab_T *ht);
void hash_clear(hashtab_T *ht);
void hash_clear_all(hashtab_T *ht, int off);
hashitem_T *hash_find(hashtab_T *ht, char_u *key);
hashitem_T *hash_lookup(hashtab_T *ht, char_u *key, hash_T hash);
void hash_debug_results(void);
int hash_add(hashtab_T *ht, char_u *key);
int hash_add_item(hashtab_T *ht, hashitem_T *hi, char_u *key, hash_T hash);
void hash_remove(hashtab_T *ht, hashitem_T *hi);
void hash_lock(hashtab_T *ht);
void hash_lock_size(hashtab_T *ht, int size);
void hash_unlock(hashtab_T *ht);
hash_T hash_hash(char_u *key);
# 98 "./proto.h" 2
# 1 "proto/help.pro" 1

void ex_help(exarg_T *eap);
void ex_helpclose(exarg_T *eap);
char_u *check_help_lang(char_u *arg);
int help_heuristic(char_u *matched_string, int offset, int wrong_case);
int find_help_tags(char_u *arg, int *num_matches, char_u ***matches, int keep_lang);
void cleanup_help_tags(int num_file, char_u **file);
void prepare_help_buffer(void);
void fix_help_buffer(void);
void ex_exusage(exarg_T *eap);
void ex_viusage(exarg_T *eap);
void ex_helptags(exarg_T *eap);
# 99 "./proto.h" 2
# 1 "proto/highlight.pro" 1

int highlight_num_groups(void);
char_u *highlight_group_name(int id);
int highlight_link_id(int id);
void init_highlight(int both, int reset);
int load_colors(char_u *name);
int lookup_color(int idx, int foreground, int *boldp);
void do_highlight(char_u *line, int forceit, int init);
void free_highlight(void);
void restore_cterm_colors(void);
void set_normal_colors(void);
char_u *hl_get_font_name(void);
void hl_set_font_name(char_u *font_name);
void hl_set_bg_color_name(char_u *name);
void hl_set_fg_color_name(char_u *name);
long color_name2handle(char_u *name);
int get_cterm_attr_idx(int attr, int fg, int bg);
int get_tgc_attr_idx(int attr, long fg, long bg);
int get_gui_attr_idx(int attr, long fg, long bg);
void clear_hl_tables(void);
int hl_combine_attr(int char_attr, int prim_attr);
attrentry_T *syn_gui_attr2entry(int attr);
int syn_attr2attr(int attr);
attrentry_T *syn_term_attr2entry(int attr);
attrentry_T *syn_cterm_attr2entry(int attr);
char_u *highlight_has_attr(int id, int flag, int modec);
char_u *highlight_color(int id, char_u *what, int modec);
long_u highlight_gui_color_rgb(int id, int fg);
int syn_list_header(int did_header, int outlen, int id);
int syn_name2id(char_u *name);
int syn_name2attr(char_u *name);
int highlight_exists(char_u *name);
char_u *syn_id2name(int id);
int syn_namen2id(char_u *linep, int len);
int syn_check_group(char_u *pp, int len);
int syn_id2attr(int hl_id);
int syn_id2colors(int hl_id, long *fgp, long *bgp);
void syn_id2cterm_bg(int hl_id, int *fgp, int *bgp);
int syn_get_final_id(int hl_id);
void highlight_gui_started(void);
int highlight_changed(void);
void set_context_in_highlight_cmd(expand_T *xp, char_u *arg);
char_u *get_highlight_name(expand_T *xp, int idx);
char_u *get_highlight_name_ext(expand_T *xp, int idx, int skip_cleared);
void free_highlight_fonts(void);
# 100 "./proto.h" 2
# 1 "proto/indent.pro" 1

int tabstop_set(char_u *var, int **array);
int tabstop_padding(colnr_T col, int ts_arg, int *vts);
int tabstop_at(colnr_T col, int ts, int *vts);
colnr_T tabstop_start(colnr_T col, int ts, int *vts);
void tabstop_fromto(colnr_T start_col, colnr_T end_col, int ts_arg, int *vts, int *ntabs, int *nspcs);
int *tabstop_copy(int *oldts);
int tabstop_count(int *ts);
int tabstop_first(int *ts);
long get_sw_value(buf_T *buf);
long get_sw_value_indent(buf_T *buf);
long get_sw_value_col(buf_T *buf, colnr_T col);
long get_sts_value(void);
int get_indent(void);
int get_indent_lnum(linenr_T lnum);
int get_indent_buf(buf_T *buf, linenr_T lnum);
int get_indent_str(char_u *ptr, int ts, int list);
int get_indent_str_vtab(char_u *ptr, int ts, int *vts, int list);
int set_indent(int size, int flags);
int get_number_indent(linenr_T lnum);
int briopt_check(win_T *wp);
int get_breakindent_win(win_T *wp, char_u *line);
int inindent(int extra);
void op_reindent(oparg_T *oap, int (*how)(void));
int preprocs_left(void);
void ins_try_si(int c);
void change_indent(int type, int amount, int round, int replaced, int call_changed_bytes);
int copy_indent(int size, char_u *src);
void ex_retab(exarg_T *eap);
int get_expr_indent(void);
int get_lisp_indent(void);
void fixthisline(int (*get_the_indent)(void));
void fix_indent(void);
void f_indent(typval_T *argvars, typval_T *rettv);
void f_lispindent(typval_T *argvars, typval_T *rettv);
# 101 "./proto.h" 2
# 1 "proto/insexpand.pro" 1

void ins_ctrl_x(void);
int ctrl_x_mode_none(void);
int ctrl_x_mode_normal(void);
int ctrl_x_mode_scroll(void);
int ctrl_x_mode_whole_line(void);
int ctrl_x_mode_files(void);
int ctrl_x_mode_tags(void);
int ctrl_x_mode_path_patterns(void);
int ctrl_x_mode_path_defines(void);
int ctrl_x_mode_dictionary(void);
int ctrl_x_mode_thesaurus(void);
int ctrl_x_mode_cmdline(void);
int ctrl_x_mode_function(void);
int ctrl_x_mode_omni(void);
int ctrl_x_mode_spell(void);
int ctrl_x_mode_line_or_eval(void);
int ctrl_x_mode_not_default(void);
int ctrl_x_mode_not_defined_yet(void);
int has_compl_option(int dict_opt);
int vim_is_ctrl_x_key(int c);
int ins_compl_accept_char(int c);
int ins_compl_add_infercase(char_u *str_arg, int len, int icase, char_u *fname, int dir, int cont_s_ipos);
int ins_compl_has_shown_match(void);
int ins_compl_long_shown_match(void);
void completeopt_was_set(void);
int pum_wanted(void);
void ins_compl_show_pum(void);
char_u *find_word_start(char_u *ptr);
char_u *find_word_end(char_u *ptr);
void ins_compl_clear(void);
int ins_compl_active(void);
int ins_compl_used_match(void);
void ins_compl_init_get_longest(void);
int ins_compl_interrupted(void);
int ins_compl_enter_selects(void);
colnr_T ins_compl_col(void);
int ins_compl_bs(void);
void ins_compl_addleader(int c);
void ins_compl_addfrommatch(void);
int ins_compl_prep(int c);
void f_complete(typval_T *argvars, typval_T *rettv);
void f_complete_add(typval_T *argvars, typval_T *rettv);
void f_complete_check(typval_T *argvars, typval_T *rettv);
void f_complete_info(typval_T *argvars, typval_T *rettv);
void ins_compl_delete(void);
void ins_compl_insert(int in_compl_func);
void ins_compl_check_keys(int frequency, int in_compl_func);
int ins_complete(int c, int enable_pum);
void free_insexpand_stuff(void);
# 102 "./proto.h" 2
# 1 "proto/json.pro" 1

char_u *json_encode(typval_T *val, int options);
char_u *json_encode_nr_expr(int nr, typval_T *val, int options);
int json_decode(js_read_T *reader, typval_T *res, int options);
int json_find_end(js_read_T *reader, int options);
void f_js_decode(typval_T *argvars, typval_T *rettv);
void f_js_encode(typval_T *argvars, typval_T *rettv);
void f_json_decode(typval_T *argvars, typval_T *rettv);
void f_json_encode(typval_T *argvars, typval_T *rettv);
# 103 "./proto.h" 2
# 1 "proto/list.pro" 1

void list_add_watch(list_T *l, listwatch_T *lw);
void list_rem_watch(list_T *l, listwatch_T *lwrem);
list_T *list_alloc(void);
list_T *list_alloc_id(alloc_id_T id);
list_T *list_alloc_with_items(int count);
void list_set_item(list_T *l, int idx, typval_T *tv);
int rettv_list_alloc(typval_T *rettv);
int rettv_list_alloc_id(typval_T *rettv, alloc_id_T id);
void rettv_list_set(typval_T *rettv, list_T *l);
void list_unref(list_T *l);
int list_free_nonref(int copyID);
void list_free_items(int copyID);
void list_free(list_T *l);
listitem_T *listitem_alloc(void);
void listitem_free(list_T *l, listitem_T *item);
void listitem_remove(list_T *l, listitem_T *item);
long list_len(list_T *l);
int list_equal(list_T *l1, list_T *l2, int ic, int recursive);
listitem_T *list_find(list_T *l, long n);
long list_find_nr(list_T *l, long idx, int *errorp);
char_u *list_find_str(list_T *l, long idx);
long list_idx_of_item(list_T *l, listitem_T *item);
void list_append(list_T *l, listitem_T *item);
int list_append_tv(list_T *l, typval_T *tv);
int list_append_tv_move(list_T *l, typval_T *tv);
int list_append_dict(list_T *list, dict_T *dict);
int list_append_list(list_T *list1, list_T *list2);
int list_append_string(list_T *l, char_u *str, int len);
int list_append_number(list_T *l, varnumber_T n);
int list_insert_tv(list_T *l, typval_T *tv, listitem_T *item);
void list_insert(list_T *l, listitem_T *ni, listitem_T *item);
void f_flatten(typval_T *argvars, typval_T *rettv);
int list_extend(list_T *l1, list_T *l2, listitem_T *bef);
int list_concat(list_T *l1, list_T *l2, typval_T *tv);
list_T *list_slice(list_T *ol, long n1, long n2);
int list_slice_or_index(list_T *list, int range, long n1_arg, long n2_arg, typval_T *rettv, int verbose);
list_T *list_copy(list_T *orig, int deep, int copyID);
void vimlist_remove(list_T *l, listitem_T *item, listitem_T *item2);
char_u *list2string(typval_T *tv, int copyID, int restore_copyID);
int list_join(garray_T *gap, list_T *l, char_u *sep, int echo_style, int restore_copyID, int copyID);
void f_join(typval_T *argvars, typval_T *rettv);
int eval_list(char_u **arg, typval_T *rettv, evalarg_T *evalarg, int do_error);
int write_list(FILE *fd, list_T *list, int binary);
void init_static_list(staticList10_T *sl);
void f_list2str(typval_T *argvars, typval_T *rettv);
void f_sort(typval_T *argvars, typval_T *rettv);
void f_uniq(typval_T *argvars, typval_T *rettv);
void f_filter(typval_T *argvars, typval_T *rettv);
void f_map(typval_T *argvars, typval_T *rettv);
void f_mapnew(typval_T *argvars, typval_T *rettv);
void f_add(typval_T *argvars, typval_T *rettv);
void f_count(typval_T *argvars, typval_T *rettv);
void f_extend(typval_T *argvars, typval_T *rettv);
void f_insert(typval_T *argvars, typval_T *rettv);
void f_remove(typval_T *argvars, typval_T *rettv);
void f_reverse(typval_T *argvars, typval_T *rettv);
void f_reduce(typval_T *argvars, typval_T *rettv);
# 104 "./proto.h" 2
# 1 "proto/locale.pro" 1

char_u *get_mess_lang(void);
void set_lang_var(void);
void init_locale(void);
void ex_language(exarg_T *eap);
void free_locales(void);
char_u *get_lang_arg(expand_T *xp, int idx);
char_u *get_locales(expand_T *xp, int idx);
# 105 "./proto.h" 2
# 1 "proto/blob.pro" 1

blob_T *blob_alloc(void);
int rettv_blob_alloc(typval_T *rettv);
void rettv_blob_set(typval_T *rettv, blob_T *b);
int blob_copy(blob_T *from, typval_T *to);
void blob_free(blob_T *b);
void blob_unref(blob_T *b);
long blob_len(blob_T *b);
int blob_get(blob_T *b, int idx);
void blob_set(blob_T *b, int idx, char_u c);
int blob_equal(blob_T *b1, blob_T *b2);
int read_blob(FILE *fd, blob_T *blob);
int write_blob(FILE *fd, blob_T *blob);
char_u *blob2string(blob_T *blob, char_u **tofree, char_u *numbuf);
blob_T *string2blob(char_u *str);
void blob_remove(typval_T *argvars, typval_T *rettv);
# 106 "./proto.h" 2
# 1 "proto/main.pro" 1

int vim_main2(void);
void common_init(mparm_T *paramp);
int is_not_a_term(void);
int op_pending(void);
void may_trigger_safestate(int safe);
void state_no_longer_safe(char *reason);
int get_was_safe_state(void);
void may_trigger_safestateagain(void);
void main_loop(int cmdwin, int noexmode);
void getout_preserve_modified(int exitval);
void getout(int exitval);
int process_env(char_u *env, int is_viminit);
void mainerr_arg_missing(char_u *str);
# 107 "./proto.h" 2
# 1 "proto/map.pro" 1

mapblock_T *get_maphash_list(int state, int c);
mapblock_T *get_buf_maphash_list(int state, int c);
int is_maphash_valid(void);
int do_map(int maptype, char_u *arg, int mode, int abbrev);
void map_clear_int(buf_T *buf, int mode, int local, int abbr);
int mode_str2flags(char_u *modechars);
int map_to_exists(char_u *str, char_u *modechars, int abbr);
int map_to_exists_mode(char_u *rhs, int mode, int abbr);
char_u *set_context_in_map_cmd(expand_T *xp, char_u *cmd, char_u *arg, int forceit, int isabbrev, int isunmap, cmdidx_T cmdidx);
int ExpandMappings(regmatch_T *regmatch, int *num_file, char_u ***file);
int check_abbr(int c, char_u *ptr, int col, int mincol);
char_u *eval_map_expr(char_u *str, int c);
char_u *vim_strsave_escape_csi(char_u *p);
void vim_unescape_csi(char_u *p);
int makemap(FILE *fd, buf_T *buf);
int put_escstr(FILE *fd, char_u *strstart, int what);
void check_map_keycodes(void);
char_u *check_map(char_u *keys, int mode, int exact, int ign_mod, int abbr, mapblock_T **mp_ptr, int *local_ptr);
void get_maparg(typval_T *argvars, typval_T *rettv, int exact);
void f_mapset(typval_T *argvars, typval_T *rettv);
void init_mappings(void);
void add_map(char_u *map, int mode);
int langmap_adjust_mb(int c);
void langmap_init(void);
void langmap_set(void);
void ex_abbreviate(exarg_T *eap);
void ex_map(exarg_T *eap);
void ex_unmap(exarg_T *eap);
void ex_mapclear(exarg_T *eap);
void ex_abclear(exarg_T *eap);
# 108 "./proto.h" 2
# 1 "proto/mark.pro" 1

int setmark(int c);
int setmark_pos(int c, pos_T *pos, int fnum);
void setpcmark(void);
void checkpcmark(void);
pos_T *movemark(int count);
pos_T *movechangelist(int count);
pos_T *getmark_buf(buf_T *buf, int c, int changefile);
pos_T *getmark(int c, int changefile);
pos_T *getmark_buf_fnum(buf_T *buf, int c, int changefile, int *fnum);
pos_T *getnextmark(pos_T *startpos, int dir, int begin_line);
void fmarks_check_names(buf_T *buf);
int check_mark(pos_T *pos);
void clrallmarks(buf_T *buf);
char_u *fm_getname(fmark_T *fmark, int lead_len);
void ex_marks(exarg_T *eap);
void ex_delmarks(exarg_T *eap);
void ex_jumps(exarg_T *eap);
void ex_clearjumps(exarg_T *eap);
void ex_changes(exarg_T *eap);
void mark_adjust(linenr_T line1, linenr_T line2, long amount, long amount_after);
void mark_adjust_nofold(linenr_T line1, linenr_T line2, long amount, long amount_after);
void mark_col_adjust(linenr_T lnum, colnr_T mincol, long lnum_amount, long col_amount, int spaces_removed);
void cleanup_jumplist(win_T *wp, int loadfiles);
void copy_jumplist(win_T *from, win_T *to);
void free_jumplist(win_T *wp);
void set_last_cursor(win_T *win);
void free_all_marks(void);
xfmark_T *get_namedfm(void);
void f_getmarklist(typval_T *argvars, typval_T *rettv);
# 109 "./proto.h" 2
# 1 "proto/match.pro" 1

void clear_matches(win_T *wp);
void init_search_hl(win_T *wp, match_T *search_hl);
void prepare_search_hl(win_T *wp, match_T *search_hl, linenr_T lnum);
int prepare_search_hl_line(win_T *wp, linenr_T lnum, colnr_T mincol, char_u **line, match_T *search_hl, int *search_attr);
int update_search_hl(win_T *wp, linenr_T lnum, colnr_T col, char_u **line, match_T *search_hl, int *has_match_conc, int *match_conc, int did_line_attr, int lcs_eol_one);
int get_prevcol_hl_flag(win_T *wp, match_T *search_hl, long curcol);
void get_search_match_hl(win_T *wp, match_T *search_hl, long col, int *char_attr);
void f_clearmatches(typval_T *argvars, typval_T *rettv);
void f_getmatches(typval_T *argvars, typval_T *rettv);
void f_setmatches(typval_T *argvars, typval_T *rettv);
void f_matchadd(typval_T *argvars, typval_T *rettv);
void f_matchaddpos(typval_T *argvars, typval_T *rettv);
void f_matcharg(typval_T *argvars, typval_T *rettv);
void f_matchdelete(typval_T *argvars, typval_T *rettv);
void ex_match(exarg_T *eap);
# 110 "./proto.h" 2
# 1 "proto/memfile.pro" 1

memfile_T *mf_open(char_u *fname, int flags);
int mf_open_file(memfile_T *mfp, char_u *fname);
void mf_close(memfile_T *mfp, int del_file);
void mf_close_file(buf_T *buf, int getlines);
void mf_new_page_size(memfile_T *mfp, unsigned new_size);
bhdr_T *mf_new(memfile_T *mfp, int negative, int page_count);
bhdr_T *mf_get(memfile_T *mfp, blocknr_T nr, int page_count);
void mf_put(memfile_T *mfp, bhdr_T *hp, int dirty, int infile);
void mf_free(memfile_T *mfp, bhdr_T *hp);
int mf_sync(memfile_T *mfp, int flags);
void mf_set_dirty(memfile_T *mfp);
int mf_release_all(void);
blocknr_T mf_trans_del(memfile_T *mfp, blocknr_T old_nr);
void mf_set_ffname(memfile_T *mfp);
void mf_fullname(memfile_T *mfp);
int mf_need_trans(memfile_T *mfp);
# 111 "./proto.h" 2
# 1 "proto/memline.pro" 1

int ml_open(buf_T *buf);
void ml_set_crypt_key(buf_T *buf, char_u *old_key, char_u *old_cm);
void ml_setname(buf_T *buf);
void ml_open_files(void);
void ml_open_file(buf_T *buf);
void check_need_swap(int newfile);
void ml_close(buf_T *buf, int del_file);
void ml_close_all(int del_file);
void ml_close_notmod(void);
void ml_timestamp(buf_T *buf);
void ml_recover(int checkext);
int recover_names(char_u *fname, int list, int nr, char_u **fname_out);
char_u *make_percent_swname(char_u *dir, char_u *name);
void get_b0_dict(char_u *fname, dict_T *d);
void ml_sync_all(int check_file, int check_char);
void ml_preserve(buf_T *buf, int message);
char_u *ml_get(linenr_T lnum);
char_u *ml_get_pos(pos_T *pos);
char_u *ml_get_curline(void);
char_u *ml_get_cursor(void);
char_u *ml_get_buf(buf_T *buf, linenr_T lnum, int will_change);
int ml_line_alloced(void);
int ml_append(linenr_T lnum, char_u *line, colnr_T len, int newfile);
int ml_append_flags(linenr_T lnum, char_u *line, colnr_T len, int flags);
int ml_append_buf(buf_T *buf, linenr_T lnum, char_u *line, colnr_T len, int newfile);
int ml_replace(linenr_T lnum, char_u *line, int copy);
int ml_replace_len(linenr_T lnum, char_u *line_arg, colnr_T len_arg, int has_props, int copy);
int ml_delete(linenr_T lnum);
int ml_delete_flags(linenr_T lnum, int flags);
void ml_setmarked(linenr_T lnum);
linenr_T ml_firstmarked(void);
void ml_clearmarked(void);
int resolve_symlink(char_u *fname, char_u *buf);
char_u *makeswapname(char_u *fname, char_u *ffname, buf_T *buf, char_u *dir_name);
char_u *get_file_in_dir(char_u *fname, char_u *dname);
void ml_setflags(buf_T *buf);
char_u *ml_encrypt_data(memfile_T *mfp, char_u *data, off_T offset, unsigned size);
void ml_decrypt_data(memfile_T *mfp, char_u *data, off_T offset, unsigned size);
long ml_find_line_or_offset(buf_T *buf, linenr_T lnum, long *offp);
void goto_byte(long cnt);
# 112 "./proto.h" 2

# 1 "proto/menu.pro" 1

int winbar_height(win_T *wp);
void ex_menu(exarg_T *eap);
void remove_winbar(win_T *wp);
char_u *set_context_in_menu_cmd(expand_T *xp, char_u *cmd, char_u *arg, int forceit);
char_u *get_menu_name(expand_T *xp, int idx);
char_u *get_menu_names(expand_T *xp, int idx);
int get_menu_index(vimmenu_T *menu, int state);
int menu_is_menubar(char_u *name);
int menu_is_popup(char_u *name);
int menu_is_child_of_popup(vimmenu_T *menu);
int menu_is_toolbar(char_u *name);
int menu_is_separator(char_u *name);
int get_menu_mode_flag(void);
void show_popupmenu(void);
int check_menu_pointer(vimmenu_T *root, vimmenu_T *menu_to_check);
void gui_create_initial_menus(vimmenu_T *menu);
void gui_update_menus(int modes);
int gui_is_menu_shortcut(int key);
void gui_mch_toggle_tearoffs(int enable);
void execute_menu(exarg_T *eap, vimmenu_T *menu, int mode_idx);
void ex_emenu(exarg_T *eap);
void winbar_click(win_T *wp, int col);
vimmenu_T *gui_find_menu(char_u *path_name);
void ex_menutranslate(exarg_T *eap);
void f_menu_info(typval_T *argvars, typval_T *rettv);
# 114 "./proto.h" 2


# 1 "proto/arabic.pro" 1

int arabic_maycombine(int two);
int arabic_combine(int one, int two);
int arabic_shape(int c, int *ccp, int *c1p, int prev_c, int prev_c1, int next_c);
# 117 "./proto.h" 2


# 1 "proto/viminfo.pro" 1

int get_viminfo_parameter(int type);
int buf_compare(const void *s1, const void *s2);
void check_marks_read(void);
int read_viminfo(char_u *file, int flags);
void write_viminfo(char_u *file, int forceit);
void ex_viminfo(exarg_T *eap);
# 120 "./proto.h" 2



int smsg(const char *, ...)

    __attribute__((format(printf, 1, 2)))

    ;

int smsg_attr(int, const char *, ...)

    __attribute__((format(printf, 2, 3)))

    ;

int smsg_attr_keep(int, const char *, ...)

    __attribute__((format(printf, 2, 3)))

    ;


int semsg(const char *, ...)

    __attribute__((format(printf, 1, 2)))

    ;


void siemsg(const char *, ...)

    __attribute__((format(printf, 1, 2)))

    ;

int vim_snprintf_add(char *, size_t, const char *, ...)

    __attribute__((format(printf, 3, 4)))

    ;

int vim_snprintf(char *, size_t, const char *, ...)

    __attribute__((format(printf, 3, 4)))

    ;

int vim_vsnprintf(char *str, size_t str_m, const char *fmt, va_list ap);
int vim_vsnprintf_typval(char *str, size_t str_m, const char *fmt, va_list ap, typval_T *tvs);


# 1 "proto/message.pro" 1

int msg(char *s);
int verb_msg(char *s);
int msg_attr(char *s, int attr);
int msg_attr_keep(char *s, int attr, int keep);
char_u *msg_strtrunc(char_u *s, int force);
void trunc_string(char_u *s, char_u *buf, int room_in, int buflen);
void reset_last_sourcing(void);
void msg_source(int attr);
void ignore_error_for_testing(char_u *error);
void do_perror(char *msg);
int emsg(char *s);
void iemsg(char *s);
void internal_error(char *where);
void internal_error_no_abort(char *where);
void emsg_invreg(int name);
void emsg_namelen(char *msg, char_u *name, int len);
char *msg_trunc_attr(char *s, int force, int attr);
char_u *msg_may_trunc(int force, char_u *s);
int delete_first_msg(void);
void ex_messages(exarg_T *eap);
void msg_end_prompt(void);
void wait_return(int redraw);
void set_keep_msg(char_u *s, int attr);
void set_keep_msg_from_hist(void);
void msg_start(void);
void msg_starthere(void);
void msg_putchar(int c);
void msg_putchar_attr(int c, int attr);
void msg_outnum(long n);
void msg_home_replace(char_u *fname);
void msg_home_replace_hl(char_u *fname);
int msg_outtrans(char_u *str);
int msg_outtrans_attr(char_u *str, int attr);
int msg_outtrans_len(char_u *str, int len);
char_u *msg_outtrans_one(char_u *p, int attr);
int msg_outtrans_len_attr(char_u *msgstr, int len, int attr);
void msg_make(char_u *arg);
int msg_outtrans_special(char_u *strstart, int from, int maxlen);
char_u *str2special_save(char_u *str, int is_lhs);
char_u *str2special(char_u **sp, int from);
void str2specialbuf(char_u *sp, char_u *buf, int len);
void msg_prt_line(char_u *s, int list);
void msg_puts(char *s);
void msg_puts_title(char *s);
void msg_outtrans_long_attr(char_u *longstr, int attr);
void msg_puts_attr(char *s, int attr);
int message_filtered(char_u *msg);
void may_clear_sb_text(void);
void sb_text_start_cmdline(void);
void sb_text_end_cmdline(void);
void clear_sb_text(int all);
void show_sb_text(void);
void msg_sb_eol(void);
int msg_use_printf(void);
void mch_errmsg(char *str);
void mch_msg(char *str);
void repeat_message(void);
void msg_clr_eos(void);
void msg_clr_eos_force(void);
void msg_clr_cmdline(void);
int msg_end(void);
void msg_check(void);
int redirecting(void);
void verbose_enter(void);
void verbose_leave(void);
void verbose_enter_scroll(void);
void verbose_leave_scroll(void);
void verbose_stop(void);
int verbose_open(void);
void give_warning(char_u *message, int hl);
void give_warning2(char_u *message, char_u *a1, int hl);
void msg_advance(int col);
int do_dialog(int type, char_u *title, char_u *message, char_u *buttons, int dfltbutton, char_u *textfield, int ex_cmd);
int vim_dialog_yesno(int type, char_u *title, char_u *message, int dflt);
int vim_dialog_yesnocancel(int type, char_u *title, char_u *message, int dflt);
int vim_dialog_yesnoallcancel(int type, char_u *title, char_u *message, int dflt);
# 171 "./proto.h" 2
# 1 "proto/misc1.pro" 1

int get_leader_len(char_u *line, char_u **flags, int backward, int include_space);
int get_last_leader_offset(char_u *line, char_u **flags);
int plines(linenr_T lnum);
int plines_win(win_T *wp, linenr_T lnum, int winheight);
int plines_nofill(linenr_T lnum);
int plines_win_nofill(win_T *wp, linenr_T lnum, int winheight);
int plines_win_nofold(win_T *wp, linenr_T lnum);
int plines_win_col(win_T *wp, linenr_T lnum, long column);
int plines_m_win(win_T *wp, linenr_T first, linenr_T last);
int gchar_pos(pos_T *pos);
int gchar_cursor(void);
void pchar_cursor(int c);
char_u *skip_to_option_part(char_u *p);
void check_status(buf_T *buf);
int ask_yesno(char_u *str, int direct);
void f_mode(typval_T *argvars, typval_T *rettv);
void f_state(typval_T *argvars, typval_T *rettv);
int get_keystroke(void);
int get_number(int colon, int *mouse_used);
int prompt_for_number(int *mouse_used);
void msgmore(long n);
void beep_flush(void);
void vim_beep(unsigned val);
void init_homedir(void);
void free_homedir(void);
void free_users(void);
char_u *expand_env_save(char_u *src);
char_u *expand_env_save_opt(char_u *src, int one);
void expand_env(char_u *src, char_u *dst, int dstlen);
void expand_env_esc(char_u *srcp, char_u *dst, int dstlen, int esc, int one, char_u *startstr);
char_u *vim_getenv(char_u *name, int *mustfree);
void vim_unsetenv(char_u *var);
void vim_setenv_ext(char_u *name, char_u *val);
void vim_setenv(char_u *name, char_u *val);
char_u *get_env_name(expand_T *xp, int idx);
char_u *get_users(expand_T *xp, int idx);
int match_user(char_u *name);
char_u *concat_str(char_u *str1, char_u *str2);
void preserve_exit(void);
void line_breakcheck(void);
void fast_breakcheck(void);
void veryfast_breakcheck(void);
char_u *get_cmd_output(char_u *cmd, char_u *infile, int flags, int *ret_len);
void f_system(typval_T *argvars, typval_T *rettv);
void f_systemlist(typval_T *argvars, typval_T *rettv);
int goto_im(void);
char_u *get_isolated_shell_name(void);
int path_is_url(char_u *p);
int path_with_url(char_u *fname);
# 172 "./proto.h" 2
# 1 "proto/misc2.pro" 1

int virtual_active(void);
int getviscol(void);
int coladvance_force(colnr_T wcol);
int getviscol2(colnr_T col, colnr_T coladd);
int coladvance(colnr_T wcol);
int getvpos(pos_T *pos, colnr_T wcol);
int inc_cursor(void);
int inc(pos_T *lp);
int incl(pos_T *lp);
int dec_cursor(void);
int dec(pos_T *lp);
int decl(pos_T *lp);
linenr_T get_cursor_rel_lnum(win_T *wp, linenr_T lnum);
void check_pos(buf_T *buf, pos_T *pos);
void check_cursor_lnum(void);
void check_cursor_col(void);
void check_cursor_col_win(win_T *win);
void check_cursor(void);
void adjust_cursor_col(void);
int leftcol_changed(void);
void vim_mem_profile_dump(void);
int alloc_does_fail(size_t size);
void *alloc(size_t size);
void *alloc_id(size_t size, alloc_id_T id);
void *alloc_clear(size_t size);
void *alloc_clear_id(size_t size, alloc_id_T id);
void *lalloc_clear(size_t size, int message);
void *lalloc(size_t size, int message);
void *lalloc_id(size_t size, int message, alloc_id_T id);
void *mem_realloc(void *ptr, size_t size);
void do_outofmem_msg(size_t size);
void free_all_mem(void);
char_u *vim_strsave(char_u *string);
char_u *vim_strnsave(char_u *string, size_t len);
char_u *vim_memsave(char_u *p, size_t len);
char_u *vim_strsave_escaped(char_u *string, char_u *esc_chars);
char_u *vim_strsave_escaped_ext(char_u *string, char_u *esc_chars, int cc, int bsl);
int csh_like_shell(void);
char_u *vim_strsave_shellescape(char_u *string, int do_special, int do_newline);
char_u *vim_strsave_up(char_u *string);
char_u *vim_strnsave_up(char_u *string, size_t len);
void vim_strup(char_u *p);
char_u *strup_save(char_u *orig);
char_u *strlow_save(char_u *orig);
void del_trailing_spaces(char_u *ptr);
void vim_strncpy(char_u *to, char_u *from, size_t len);
void vim_strcat(char_u *to, char_u *from, size_t tosize);
int copy_option_part(char_u **option, char_u *buf, int maxlen, char *sep_chars);
void vim_free(void *x);
int vim_stricmp(char *s1, char *s2);
int vim_strnicmp(char *s1, char *s2, size_t len);
char_u *vim_strchr(char_u *string, int c);
char_u *vim_strbyte(char_u *string, int c);
char_u *vim_strrchr(char_u *string, int c);
int vim_isspace(int x);
void ga_clear(garray_T *gap);
void ga_clear_strings(garray_T *gap);
int ga_copy_strings(garray_T *from, garray_T *to);
void ga_init(garray_T *gap);
void ga_init2(garray_T *gap, int itemsize, int growsize);
int ga_grow(garray_T *gap, int n);
int ga_grow_inner(garray_T *gap, int n);
char_u *ga_concat_strings(garray_T *gap, char *sep);
void ga_add_string(garray_T *gap, char_u *p);
void ga_concat(garray_T *gap, char_u *s);
void ga_append(garray_T *gap, int c);
void append_ga_line(garray_T *gap);
int simplify_key(int key, int *modifiers);
int handle_x_keys(int key);
char_u *get_special_key_name(int c, int modifiers);
int trans_special(char_u **srcp, char_u *dst, int flags, int *did_simplify);
int special_to_buf(int key, int modifiers, int keycode, char_u *dst);
int find_special_key(char_u **srcp, int *modp, int flags, int *did_simplify);
int may_adjust_key_for_ctrl(int modifiers, int key);
int may_remove_shift_modifier(int modifiers, int key);
int extract_modifiers(int key, int *modp, int simplify, int *did_simplify);
int find_special_key_in_table(int c);
int get_special_key_code(char_u *name);
char_u *get_key_name(int i);
int get_fileformat(buf_T *buf);
int get_fileformat_force(buf_T *buf, exarg_T *eap);
void set_fileformat(int t, int opt_flags);
int default_fileformat(void);
int call_shell(char_u *cmd, int opt);
int get_real_state(void);
int after_pathsep(char_u *b, char_u *p);
int same_directory(char_u *f1, char_u *f2);
int vim_chdirfile(char_u *fname, char *trigger_autocmd);
int vim_stat(const char *name, stat_T *stp);
char *parse_shape_opt(int what);
int get_shape_idx(int mouse);
void update_mouseshape(int shape_idx);
int vim_chdir(char_u *new_dir);
int get_user_name(char_u *buf, int len);
void sort_strings(char_u **files, int count);
int filewritable(char_u *fname);
int get2c(FILE *fd);
int get3c(FILE *fd);
int get4c(FILE *fd);
char_u *read_string(FILE *fd, int cnt);
int put_bytes(FILE *fd, long_u nr, int len);
int has_non_ascii(char_u *s);
int mch_parse_cmd(char_u *cmd, int use_shcf, char ***argv, int *argc);
int build_argv_from_string(char_u *cmd, char ***argv, int *argc);
int build_argv_from_list(list_T *l, char ***argv, int *argc);
int get_special_pty_type(void);
# 173 "./proto.h" 2







# 1 "proto/mouse.pro" 1

int do_mouse(oparg_T *oap, int c, int dir, long count, int fixindent);
void ins_mouse(int c);
void ins_mousescroll(int dir);
int is_mouse_key(int c);
int get_mouse_button(int code, int *is_click, int *is_drag);
int get_pseudo_mouse_code(int button, int is_click, int is_drag);
void set_mouse_termcode(int n, char_u *s);
void del_mouse_termcode(int n);
void setmouse(void);
int mouse_has(int c);
int mouse_model_popup(void);
int jump_to_mouse(int flags, int *inclusive, int which_button);
void nv_mousescroll(cmdarg_T *cap);
void nv_mouse(cmdarg_T *cap);
int check_termcode_mouse(char_u *tp, int *slen, char_u *key_name, char_u *modifiers_start, int idx, int *modifiers);
int mouse_comp_pos(win_T *win, int *rowp, int *colp, linenr_T *lnump, int *plines_cache);
win_T *mouse_find_win(int *rowp, int *colp, mouse_find_T popup);
int vcol2col(win_T *wp, linenr_T lnum, int vcol);
void f_getmousepos(typval_T *argvars, typval_T *rettv);
# 181 "./proto.h" 2
# 1 "proto/move.pro" 1

void reset_cursorline(void);
void redraw_for_cursorline(win_T *wp);
void update_topline_redraw(void);
void update_topline(void);
void update_curswant(void);
void check_cursor_moved(win_T *wp);
void changed_window_setting(void);
void changed_window_setting_win(win_T *wp);
void set_topline(win_T *wp, linenr_T lnum);
void changed_cline_bef_curs(void);
void changed_cline_bef_curs_win(win_T *wp);
void changed_line_abv_curs(void);
void changed_line_abv_curs_win(win_T *wp);
void validate_botline(void);
void invalidate_botline(void);
void invalidate_botline_win(win_T *wp);
void approximate_botline_win(win_T *wp);
int cursor_valid(void);
void validate_cursor(void);
void validate_cline_row(void);
void validate_virtcol(void);
void validate_virtcol_win(win_T *wp);
void validate_cheight(void);
void validate_cursor_col(void);
int win_col_off(win_T *wp);
int curwin_col_off(void);
int win_col_off2(win_T *wp);
int curwin_col_off2(void);
void curs_columns(int may_scroll);
void textpos2screenpos(win_T *wp, pos_T *pos, int *rowp, int *scolp, int *ccolp, int *ecolp);
void f_screenpos(typval_T *argvars, typval_T *rettv);
void scrolldown(long line_count, int byfold);
void scrollup(long line_count, int byfold);
void check_topfill(win_T *wp, int down);
void scrolldown_clamp(void);
void scrollup_clamp(void);
void scroll_cursor_top(int min_scroll, int always);
void set_empty_rows(win_T *wp, int used);
void scroll_cursor_bot(int min_scroll, int set_topbot);
void scroll_cursor_halfway(int atend);
void cursor_correct(void);
int onepage(int dir, long count);
void halfpage(int flag, linenr_T Prenum);
void do_check_cursorbind(void);
# 182 "./proto.h" 2
# 1 "proto/mbyte.pro" 1

int enc_canon_props(char_u *name);
char *mb_init(void);
int bomb_size(void);
void remove_bom(char_u *s);
int mb_get_class(char_u *p);
int mb_get_class_buf(char_u *p, buf_T *buf);
int dbcs_class(unsigned lead, unsigned trail);
int latin_char2len(int c);
int latin_char2bytes(int c, char_u *buf);
int latin_ptr2len(char_u *p);
int latin_ptr2len_len(char_u *p, int size);
int utf_uint2cells(UINT32_T c);
int utf_char2cells(int c);
int latin_ptr2cells(char_u *p);
int utf_ptr2cells(char_u *p);
int dbcs_ptr2cells(char_u *p);
int latin_ptr2cells_len(char_u *p, int size);
int latin_char2cells(int c);
int mb_string2cells(char_u *p, int len);
int latin_off2cells(unsigned off, unsigned max_off);
int dbcs_off2cells(unsigned off, unsigned max_off);
int utf_off2cells(unsigned off, unsigned max_off);
int latin_ptr2char(char_u *p);
int utf_ptr2char(char_u *p);
int mb_ptr2char_adv(char_u **pp);
int mb_cptr2char_adv(char_u **pp);
int utf_composinglike(char_u *p1, char_u *p2);
int utfc_ptr2char(char_u *p, int *pcc);
int utfc_ptr2char_len(char_u *p, int *pcc, int maxlen);
int utfc_char2bytes(int off, char_u *buf);
int utf_ptr2len(char_u *p);
int utf_byte2len(int b);
int utf_ptr2len_len(char_u *p, int size);
int utfc_ptr2len(char_u *p);
int utfc_ptr2len_len(char_u *p, int size);
int utf_char2len(int c);
int utf_char2bytes(int c, char_u *buf);
int utf_iscomposing_uint(UINT32_T c);
int utf_iscomposing(int c);
int utf_printable(int c);
int utf_class(int c);
int utf_class_buf(int c, buf_T *buf);
int utf_ambiguous_width(int c);
int utf_fold(int a);
int utf_toupper(int a);
int utf_islower(int a);
int utf_tolower(int a);
int utf_isupper(int a);
int mb_strnicmp(char_u *s1, char_u *s2, size_t nn);
void show_utf8(void);
int latin_head_off(char_u *base, char_u *p);
int dbcs_screen_head_off(char_u *base, char_u *p);
int utf_head_off(char_u *base, char_u *p);
int utf_eat_space(int cc);
int utf_allow_break_before(int cc);
int utf_allow_break(int cc, int ncc);
void mb_copy_char(char_u **fp, char_u **tp);
int mb_off_next(char_u *base, char_u *p);
int mb_tail_off(char_u *base, char_u *p);
void utf_find_illegal(void);
int utf_valid_string(char_u *s, char_u *end);
int dbcs_screen_tail_off(char_u *base, char_u *p);
void mb_adjust_cursor(void);
void mb_adjustpos(buf_T *buf, pos_T *lp);
char_u *mb_prevptr(char_u *line, char_u *p);
int mb_charlen(char_u *str);
int mb_charlen_len(char_u *str, int len);
char_u *mb_unescape(char_u **pp);
int mb_lefthalve(int row, int col);
int mb_fix_col(int col, int row);
char_u *enc_skip(char_u *p);
char_u *enc_canonize(char_u *enc);
char_u *enc_locale_env(char *locale);
char_u *enc_locale(void);
int encname2codepage(char_u *name);
void *my_iconv_open(char_u *to, char_u *from);
int iconv_enabled(int verbose);
void iconv_end(void);
void f_getimstatus(typval_T *argvars, typval_T *rettv);
int convert_setup(vimconv_T *vcp, char_u *from, char_u *to);
int convert_setup_ext(vimconv_T *vcp, char_u *from, int from_unicode_is_utf8, char_u *to, int to_unicode_is_utf8);
int convert_input(char_u *ptr, int len, int maxlen);
int convert_input_safe(char_u *ptr, int len, int maxlen, char_u **restp, int *restlenp);
char_u *string_convert(vimconv_T *vcp, char_u *ptr, int *lenp);
char_u *string_convert_ext(vimconv_T *vcp, char_u *ptr, int *lenp, int *unconvlenp);
void f_setcellwidths(typval_T *argvars, typval_T *rettv);
void f_charclass(typval_T *argvars, typval_T *rettv);
# 183 "./proto.h" 2





# 1 "proto/normal.pro" 1

void init_normal_cmds(void);
void normal_cmd(oparg_T *oap, int toplevel);
void check_visual_highlight(void);
void end_visual_mode(void);
void reset_VIsual_and_resel(void);
void reset_VIsual(void);
void restore_visual_mode(void);
int find_ident_under_cursor(char_u **text, int find_type);
int find_ident_at_pos(win_T *wp, linenr_T lnum, colnr_T startcol, char_u **text, int *textcol, int find_type);
void prep_redo(int regname, long num, int cmd1, int cmd2, int cmd3, int cmd4, int cmd5);
void clearop(oparg_T *oap);
void clearopbeep(oparg_T *oap);
void may_clear_cmdline(void);
void clear_showcmd(void);
int add_to_showcmd(int c);
void add_to_showcmd_c(int c);
void push_showcmd(void);
void pop_showcmd(void);
void do_check_scrollbind(int check);
void check_scrollbind(linenr_T topline_diff, long leftcol_diff);
int find_decl(char_u *ptr, int len, int locally, int thisblock, int flags_arg);
void nv_scroll_line(cmdarg_T *cap);
void scroll_redraw(int up, long count);
void handle_tabmenu(void);
void do_nv_ident(int c1, int c2);
int get_visual_text(cmdarg_T *cap, char_u **pp, int *lenp);
void start_selection(void);
void may_start_select(int c);
int unadjust_for_sel(void);
void set_cursor_for_append_to_line(void);
# 189 "./proto.h" 2
# 1 "proto/ops.pro" 1

int get_op_type(int char1, int char2);
int op_is_change(int op);
int get_op_char(int optype);
int get_extra_op_char(int optype);
void op_shift(oparg_T *oap, int curs_top, int amount);
void shift_line(int left, int round, int amount, int call_changed_bytes);
int op_delete(oparg_T *oap);
int op_replace(oparg_T *oap, int c);
int swapchar(int op_type, pos_T *pos);
void op_insert(oparg_T *oap, long count1);
int op_change(oparg_T *oap);
void adjust_cursor_eol(void);
char_u *skip_comment(char_u *line, int process, int include_space, int *is_comment);
int do_join(long count, int insert_space, int save_undo, int use_formatoptions, int setmark);
void block_prep(oparg_T *oap, struct block_def *bdp, linenr_T lnum, int is_del);
void op_addsub(oparg_T *oap, linenr_T Prenum1, int g_cmd);
void clear_oparg(oparg_T *oap);
void cursor_pos_info(dict_T *dict);
void do_pending_operator(cmdarg_T *cap, int old_col, int gui_yank);
# 190 "./proto.h" 2
# 1 "proto/option.pro" 1

void set_init_1(int clean_arg);
void set_string_default(char *name, char_u *val);
void set_number_default(char *name, long val);
void set_local_options_default(win_T *wp, int do_buffer);
void free_all_options(void);
void set_init_2(void);
void set_init_3(void);
void set_helplang_default(char_u *lang);
void set_title_defaults(void);
void ex_set(exarg_T *eap);
int do_set(char_u *arg, int opt_flags);
void did_set_option(int opt_idx, int opt_flags, int new_value, int value_checked);
int string_to_key(char_u *arg, int multi_byte);
void did_set_title(void);
void set_options_bin(int oldval, int newval, int opt_flags);
void check_options(void);
int get_term_opt_idx(char_u **p);
int set_term_option_alloced(char_u **p);
int was_set_insecurely(char_u *opt, int opt_flags);
void redraw_titles(void);
int valid_name(char_u *val, char *allowed);
void set_option_sctx_idx(int opt_idx, int opt_flags, sctx_T script_ctx);
void set_term_option_sctx_idx(char *name, int opt_idx);
void check_redraw(long_u flags);
int findoption(char_u *arg);
int get_option_value(char_u *name, long *numval, char_u **stringval, int opt_flags);
int get_option_value_strict(char_u *name, long *numval, char_u **stringval, int opt_type, void *from);
char_u *option_iter_next(void **option, int opt_type);
long_u get_option_flags(int opt_idx);
void set_option_flag(int opt_idx, long_u flag);
void clear_option_flag(int opt_idx, long_u flag);
int is_global_option(int opt_idx);
int is_global_local_option(int opt_idx);
int is_window_local_option(int opt_idx);
int is_hidden_option(int opt_idx);
int is_crypt_key_option(int opt_idx);
char *set_option_value(char_u *name, long number, char_u *string, int opt_flags);
char_u *get_term_code(char_u *tname);
char_u *get_highlight_default(void);
char_u *get_encoding_default(void);
int makeset(FILE *fd, int opt_flags, int local_only);
int makefoldset(FILE *fd);
void clear_termoptions(void);
void free_termoptions(void);
void free_one_termoption(char_u *var);
void set_term_defaults(void);
int istermoption_idx(int opt_idx);
void unset_global_local_option(char_u *name, void *from);
char_u *get_option_varp_scope(int opt_idx, int opt_flags);
char_u *get_option_var(int opt_idx);
char_u *get_option_fullname(int opt_idx);
char_u *get_equalprg(void);
void win_copy_options(win_T *wp_from, win_T *wp_to);
void after_copy_winopt(win_T *wp);
void copy_winopt(winopt_T *from, winopt_T *to);
void clear_winopt(winopt_T *wop);
void buf_copy_options(buf_T *buf, int flags);
void reset_modifiable(void);
void set_iminsert_global(void);
void set_imsearch_global(void);
void set_context_in_set_cmd(expand_T *xp, char_u *arg, int opt_flags);
int ExpandSettings(expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file);
int ExpandOldSetting(int *num_file, char_u ***file);
int shortmess(int x);
void vimrc_found(char_u *fname, char_u *envname);
void change_compatible(int on);
int option_was_set(char_u *name);
int reset_option_was_set(char_u *name);
void fill_breakat_flags(void);
int can_bs(int what);
long get_scrolloff_value(void);
long get_sidescrolloff_value(void);
unsigned int get_bkc_value(buf_T *buf);
char_u *get_showbreak_value(win_T *win);
dict_T *get_winbuf_options(int bufopt);
int fill_culopt_flags(char_u *val, win_T *wp);
# 191 "./proto.h" 2
# 1 "proto/optionstr.pro" 1

void didset_string_options(void);
void trigger_optionsset_string(int opt_idx, int opt_flags, char_u *oldval, char_u *oldval_l, char_u *oldval_g, char_u *newval);
void check_buf_options(buf_T *buf);
void free_string_option(char_u *p);
void clear_string_option(char_u **pp);
void check_string_option(char_u **pp);
void set_string_option_direct(char_u *name, int opt_idx, char_u *val, int opt_flags, int set_sid);
void set_string_option_direct_in_win(win_T *wp, char_u *name, int opt_idx, char_u *val, int opt_flags, int set_sid);
void set_string_option_direct_in_buf(buf_T *buf, char_u *name, int opt_idx, char_u *val, int opt_flags, int set_sid);
char *set_string_option(int opt_idx, char_u *value, int opt_flags);
char *did_set_string_option(int opt_idx, char_u **varp, int new_value_alloced, char_u *oldval, char *errbuf, int opt_flags, int *value_checked);
int check_ff_value(char_u *p);
# 192 "./proto.h" 2
# 1 "proto/popupmenu.pro" 1

void pum_display(pumitem_T *array, int size, int selected);
void pum_call_update_screen(void);
int pum_under_menu(int row, int col);
void pum_redraw(void);
void pum_position_info_popup(win_T *wp);
void pum_undisplay(void);
void pum_clear(void);
int pum_visible(void);
void pum_may_redraw(void);
int pum_get_height(void);
void pum_set_event_info(dict_T *dict);
int split_message(char_u *mesg, pumitem_T **array);
void ui_remove_balloon(void);
void ui_post_balloon(char_u *mesg, list_T *list);
void ui_may_remove_balloon(void);
void pum_show_popupmenu(vimmenu_T *menu);
void pum_make_popup(char_u *path_name, int use_mouse_pos);
# 193 "./proto.h" 2

# 1 "proto/profiler.pro" 1

void profile_start(proftime_T *tm);
void profile_end(proftime_T *tm);
void profile_sub(proftime_T *tm, proftime_T *tm2);
char *profile_msg(proftime_T *tm);
float_T profile_float(proftime_T *tm);
void profile_setlimit(long msec, proftime_T *tm);
int profile_passed_limit(proftime_T *tm);
void profile_zero(proftime_T *tm);
void profile_divide(proftime_T *tm, int count, proftime_T *tm2);
void profile_add(proftime_T *tm, proftime_T *tm2);
void profile_self(proftime_T *self, proftime_T *total, proftime_T *children);
void profile_sub_wait(proftime_T *tm, proftime_T *tma);
int profile_cmp(const proftime_T *tm1, const proftime_T *tm2);
void ex_profile(exarg_T *eap);
char_u *get_profile_name(expand_T *xp, int idx);
void set_context_in_profile_cmd(expand_T *xp, char_u *arg);
void prof_inchar_enter(void);
void prof_inchar_exit(void);
int prof_def_func(void);
void func_do_profile(ufunc_T *fp);
void prof_child_enter(proftime_T *tm);
void prof_child_exit(proftime_T *tm);
void func_line_start(void *cookie);
void func_line_exec(void *cookie);
void func_line_end(void *cookie);
void script_do_profile(scriptitem_T *si);
void script_prof_save(proftime_T *tm);
void script_prof_restore(proftime_T *tm);
void profile_dump(void);
void script_line_start(void);
void script_line_exec(void);
void script_line_end(void);
# 195 "./proto.h" 2

# 1 "proto/quickfix.pro" 1

int qf_init(win_T *wp, char_u *efile, char_u *errorformat, int newlist, char_u *qf_title, char_u *enc);
int qf_stack_get_bufnr(void);
void qf_free_all(win_T *wp);
void check_quickfix_busy(void);
void copy_loclist_stack(win_T *from, win_T *to);
void qf_jump(qf_info_T *qi, int dir, int errornr, int forceit);
void qf_list(exarg_T *eap);
void qf_age(exarg_T *eap);
void qf_history(exarg_T *eap);
void qf_mark_adjust(win_T *wp, linenr_T line1, linenr_T line2, long amount, long amount_after);
void qf_view_result(int split);
void ex_cwindow(exarg_T *eap);
void ex_cclose(exarg_T *eap);
void ex_copen(exarg_T *eap);
void ex_cbottom(exarg_T *eap);
linenr_T qf_current_entry(win_T *wp);
int qf_process_qftf_option(void);
int grep_internal(cmdidx_T cmdidx);
void ex_make(exarg_T *eap);
int qf_get_size(exarg_T *eap);
int qf_get_valid_size(exarg_T *eap);
int qf_get_cur_idx(exarg_T *eap);
int qf_get_cur_valid_idx(exarg_T *eap);
void ex_cc(exarg_T *eap);
void ex_cnext(exarg_T *eap);
void ex_cbelow(exarg_T *eap);
void ex_cfile(exarg_T *eap);
void ex_vimgrep(exarg_T *eap);
int set_errorlist(win_T *wp, list_T *list, int action, char_u *title, dict_T *what);
int set_ref_in_quickfix(int copyID);
void ex_cbuffer(exarg_T *eap);
void ex_cexpr(exarg_T *eap);
void ex_helpgrep(exarg_T *eap);
void f_getloclist(typval_T *argvars, typval_T *rettv);
void f_getqflist(typval_T *argvars, typval_T *rettv);
void f_setloclist(typval_T *argvars, typval_T *rettv);
void f_setqflist(typval_T *argvars, typval_T *rettv);
# 197 "./proto.h" 2
# 1 "proto/regexp.pro" 1

int re_multiline(regprog_T *prog);
char_u *skip_regexp(char_u *startp, int delim, int magic);
char_u *skip_regexp_err(char_u *startp, int delim, int magic);
char_u *skip_regexp_ex(char_u *startp, int dirc, int magic, char_u **newp, int *dropped);
reg_extmatch_T *ref_extmatch(reg_extmatch_T *em);
void unref_extmatch(reg_extmatch_T *em);
char_u *regtilde(char_u *source, int magic);
int vim_regsub(regmatch_T *rmp, char_u *source, typval_T *expr, char_u *dest, int copy, int magic, int backslash);
int vim_regsub_multi(regmmatch_T *rmp, linenr_T lnum, char_u *source, char_u *dest, int copy, int magic, int backslash);
char_u *reg_submatch(int no);
list_T *reg_submatch_list(int no);
int vim_regcomp_had_eol(void);
regprog_T *vim_regcomp(char_u *expr_arg, int re_flags);
void vim_regfree(regprog_T *prog);
void free_regexp_stuff(void);
int regprog_in_use(regprog_T *prog);
int vim_regexec_prog(regprog_T **prog, int ignore_case, char_u *line, colnr_T col);
int vim_regexec(regmatch_T *rmp, char_u *line, colnr_T col);
int vim_regexec_nl(regmatch_T *rmp, char_u *line, colnr_T col);
long vim_regexec_multi(regmmatch_T *rmp, win_T *win, buf_T *buf, linenr_T lnum, colnr_T col, proftime_T *tm, int *timed_out);
# 198 "./proto.h" 2
# 1 "proto/register.pro" 1

yankreg_T *get_y_regs(void);
yankreg_T *get_y_register(int reg);
yankreg_T *get_y_current(void);
yankreg_T *get_y_previous(void);
void set_y_current(yankreg_T *yreg);
void set_y_previous(yankreg_T *yreg);
int get_expr_register(void);
void set_expr_line(char_u *new_line, exarg_T *eap);
char_u *get_expr_line(void);
int valid_yank_reg(int regname, int writing);
int get_yank_register(int regname, int writing);
void *get_register(int name, int copy);
void put_register(int name, void *reg);
void free_register(void *reg);
int yank_register_mline(int regname);
int do_record(int c);
int get_execreg_lastc(void);
void set_execreg_lastc(int lastc);
int do_execreg(int regname, int colon, int addcr, int silent);
int insert_reg(int regname, int literally_arg);
int get_spec_reg(int regname, char_u **argp, int *allocated, int errmsg);
int cmdline_paste_reg(int regname, int literally_arg, int remcr);
void shift_delete_registers(void);
void yank_do_autocmd(oparg_T *oap, yankreg_T *reg);
void init_yank(void);
void clear_registers(void);
void free_yank_all(void);
int op_yank(oparg_T *oap, int deleting, int mess);
void do_put(int regname, char_u *expr_result, int dir, long count, int flags);
int get_register_name(int num);
int get_unname_register(void);
void ex_display(exarg_T *eap);
void dnd_yank_drag_data(char_u *str, long len);
char_u get_reg_type(int regname, long *reglen);
char_u *get_reg_contents(int regname, int flags);
void write_reg_contents(int name, char_u *str, int maxlen, int must_append);
void write_reg_contents_lst(int name, char_u **strings, int maxlen, int must_append, int yank_type, long block_len);
void write_reg_contents_ex(int name, char_u *str, int maxlen, int must_append, int yank_type, long block_len);
void str_to_reg(yankreg_T *y_ptr, int yank_type, char_u *str, long len, long blocklen, int str_list);
# 199 "./proto.h" 2
# 1 "proto/scriptfile.pro" 1

void estack_init(void);
estack_T *estack_push(etype_T type, char_u *name, long lnum);
estack_T *estack_push_ufunc(ufunc_T *ufunc, long lnum);
int estack_top_is_ufunc(ufunc_T *ufunc, long lnum);
estack_T *estack_pop(void);
char_u *estack_sfile(estack_arg_T which);
void ex_runtime(exarg_T *eap);
int do_in_path(char_u *path, char_u *name, int flags, void (*callback)(char_u *fname, void *ck), void *cookie);
int do_in_runtimepath(char_u *name, int flags, void (*callback)(char_u *fname, void *ck), void *cookie);
int source_runtime(char_u *name, int flags);
int source_in_path(char_u *path, char_u *name, int flags, int *ret_sid);
void add_pack_start_dirs(void);
void load_start_packages(void);
void ex_packloadall(exarg_T *eap);
void ex_packadd(exarg_T *eap);
void remove_duplicates(garray_T *gap);
int ExpandRTDir(char_u *pat, int flags, int *num_file, char_u ***file, char *dirnames[]);
int ExpandPackAddDir(char_u *pat, int *num_file, char_u ***file);
void ex_source(exarg_T *eap);
void ex_options(exarg_T *eap);
linenr_T *source_breakpoint(void *cookie);
int *source_dbg_tick(void *cookie);
int source_level(void *cookie);
char_u *source_nextline(void *cookie);
int do_source(char_u *fname, int check_other, int is_vimrc, int *ret_sid);
void ex_scriptnames(exarg_T *eap);
void scriptnames_slash_adjust(void);
char_u *get_scriptname(scid_T id);
void free_scriptnames(void);
void free_autoload_scriptnames(void);
linenr_T get_sourced_lnum(char_u *(*fgetline)(int, void *, int, getline_opt_T), void *cookie);
char_u *getsourceline(int c, void *cookie, int indent, getline_opt_T options);
void ex_scriptencoding(exarg_T *eap);
void ex_scriptversion(exarg_T *eap);
void ex_finish(exarg_T *eap);
void do_finish(exarg_T *eap, int reanimate);
int source_finished(char_u *(*fgetline)(int, void *, int, getline_opt_T), void *cookie);
char_u *autoload_name(char_u *name);
int script_autoload(char_u *name, int reload);
# 200 "./proto.h" 2
# 1 "proto/screen.pro" 1

int conceal_cursor_line(win_T *wp);
void conceal_check_cursor_line(void);
int get_wcr_attr(win_T *wp);
void win_draw_end(win_T *wp, int c1, int c2, int draw_margin, int row, int endrow, hlf_T hl);
int compute_foldcolumn(win_T *wp, int col);
void fill_foldcolumn(char_u *p, win_T *wp, int closed, linenr_T lnum);
int screen_get_current_line_off(void);
void reset_screen_attr(void);
void screen_line(int row, int coloff, int endcol, int clear_width, int flags);
void rl_mirror(char_u *str);
void draw_vsep_win(win_T *wp, int row);
void win_redr_status_matches(expand_T *xp, int num_matches, char_u **matches, int match, int showtail);
int stl_connected(win_T *wp);
int get_keymap_str(win_T *wp, char_u *fmt, char_u *buf, int len);
void win_redr_custom(win_T *wp, int draw_ruler);
void screen_putchar(int c, int row, int col, int attr);
void screen_getbytes(int row, int col, char_u *bytes, int *attrp);
void screen_puts(char_u *text, int row, int col, int attr);
void screen_puts_len(char_u *text, int textlen, int row, int col, int attr);
void start_search_hl(void);
void end_search_hl(void);
void screen_stop_highlight(void);
void reset_cterm_colors(void);
void screen_char(unsigned off, int row, int col);
void screen_draw_rectangle(int row, int col, int height, int width, int invert);
void space_to_screenline(int off, int attr);
void screen_fill(int start_row, int end_row, int start_col, int end_col, int c1, int c2, int attr);
void check_for_delay(int check_msg_scroll);
int screen_valid(int doclear);
void screenalloc(int doclear);
void free_screenlines(void);
void screenclear(void);
void line_was_clobbered(int screen_lnum);
int can_clear(char_u *p);
void screen_start(void);
void windgoto(int row, int col);
void setcursor(void);
void setcursor_mayforce(int force);
int win_ins_lines(win_T *wp, int row, int line_count, int invalid, int mayclear);
int win_del_lines(win_T *wp, int row, int line_count, int invalid, int mayclear, int clear_attr);
int screen_ins_lines(int off, int row, int line_count, int end, int clear_attr, win_T *wp);
int screen_del_lines(int off, int row, int line_count, int end, int force, int clear_attr, win_T *wp);
int skip_showmode(void);
int showmode(void);
void unshowmode(int force);
void clearmode(void);
void draw_tabline(void);
void get_trans_bufname(buf_T *buf);
int fillchar_status(int *attr, win_T *wp);
int fillchar_vsep(int *attr);
int redrawing(void);
int messaging(void);
void comp_col(void);
int number_width(win_T *wp);
int screen_screencol(void);
int screen_screenrow(void);
char *set_chars_option(char_u **varp);
# 201 "./proto.h" 2
# 1 "proto/session.pro" 1

void ex_loadview(exarg_T *eap);
int write_session_file(char_u *filename);
void ex_mkrc(exarg_T *eap);
var_flavour_T var_flavour(char_u *varname);
int put_eol(FILE *fd);
int put_line(FILE *fd, char *s);
# 202 "./proto.h" 2

# 1 "proto/sha256.pro" 1

void sha256_start(context_sha256_T *ctx);
void sha256_update(context_sha256_T *ctx, char_u *input, UINT32_T length);
void sha256_finish(context_sha256_T *ctx, char_u digest[32]);
char_u *sha256_bytes(char_u *buf, int buf_len, char_u *salt, int salt_len);
char_u *sha256_key(char_u *buf, char_u *salt, int salt_len);
int sha256_self_test(void);
void sha2_seed(char_u *header, int header_len, char_u *salt, int salt_len);
# 204 "./proto.h" 2

# 1 "proto/search.pro" 1

int search_regcomp(char_u *pat, int pat_save, int pat_use, int options, regmmatch_T *regmatch);
char_u *get_search_pat(void);
char_u *reverse_text(char_u *s);
void save_re_pat(int idx, char_u *pat, int magic);
void save_search_patterns(void);
void restore_search_patterns(void);
void free_search_patterns(void);
void save_last_search_pattern(void);
void restore_last_search_pattern(void);
char_u *last_search_pattern(void);
int ignorecase(char_u *pat);
int ignorecase_opt(char_u *pat, int ic_in, int scs);
int pat_has_uppercase(char_u *pat);
char_u *last_csearch(void);
int last_csearch_forward(void);
int last_csearch_until(void);
void set_last_csearch(int c, char_u *s, int len);
void set_csearch_direction(int cdir);
void set_csearch_until(int t_cmd);
char_u *last_search_pat(void);
void reset_search_dir(void);
void set_last_search_pat(char_u *s, int idx, int magic, int setlast);
void last_pat_prog(regmmatch_T *regmatch);
int searchit(win_T *win, buf_T *buf, pos_T *pos, pos_T *end_pos, int dir, char_u *pat, long count, int options, int pat_use, searchit_arg_T *extra_arg);
void set_search_direction(int cdir);
int do_search(oparg_T *oap, int dirc, int search_delim, char_u *pat, long count, int options, searchit_arg_T *sia);
int search_for_exact_line(buf_T *buf, pos_T *pos, int dir, char_u *pat);
int searchc(cmdarg_T *cap, int t_cmd);
pos_T *findmatch(oparg_T *oap, int initc);
pos_T *findmatchlimit(oparg_T *oap, int initc, int flags, int maxtravel);
void showmatch(int c);
int current_search(long count, int forward);
int linewhite(linenr_T lnum);
void find_pattern_in_path(char_u *ptr, int dir, int len, int whole, int skip_comments, int type, long count, int action, linenr_T start_lnum, linenr_T end_lnum);
spat_T *get_spat(int idx);
int get_spat_last_idx(void);
void f_searchcount(typval_T *argvars, typval_T *rettv);
void f_matchfuzzy(typval_T *argvars, typval_T *rettv);
void f_matchfuzzypos(typval_T *argvars, typval_T *rettv);
# 206 "./proto.h" 2

# 1 "proto/sign.pro" 1

void init_signs(void);
int buf_get_signattrs(win_T *wp, linenr_T lnum, sign_attrs_T *sattr);
linenr_T buf_delsign(buf_T *buf, linenr_T atlnum, int id, char_u *group);
int buf_findsign(buf_T *buf, int id, char_u *group);
int buf_findsign_id(buf_T *buf, linenr_T lnum, char_u *groupname);
int buf_findsigntype_id(buf_T *buf, linenr_T lnum, int typenr);
int buf_signcount(buf_T *buf, linenr_T lnum);
void buf_delete_signs(buf_T *buf, char_u *group);
void sign_mark_adjust(linenr_T line1, linenr_T line2, long amount, long amount_after);
int sign_define_by_name(char_u *name, char_u *icon, char_u *linehl, char_u *text, char_u *texthl);
int sign_exists_by_name(char_u *name);
int sign_undefine_by_name(char_u *name, int give_error);
int sign_place(int *sign_id, char_u *sign_group, char_u *sign_name, buf_T *buf, linenr_T lnum, int prio);
void ex_sign(exarg_T *eap);
void get_buffer_signs(buf_T *buf, list_T *l);
void sign_gui_started(void);
void *sign_get_image(int typenr);
void free_signs(void);
char_u *get_sign_name(expand_T *xp, int idx);
void set_context_in_sign_cmd(expand_T *xp, char_u *arg);
void f_sign_define(typval_T *argvars, typval_T *rettv);
void f_sign_getdefined(typval_T *argvars, typval_T *rettv);
void f_sign_getplaced(typval_T *argvars, typval_T *rettv);
void f_sign_jump(typval_T *argvars, typval_T *rettv);
void f_sign_place(typval_T *argvars, typval_T *rettv);
void f_sign_placelist(typval_T *argvars, typval_T *rettv);
void f_sign_undefine(typval_T *argvars, typval_T *rettv);
sign_entry_T *get_first_valid_sign(win_T *wp);
int signcolumn_on(win_T *wp);
void f_sign_unplace(typval_T *argvars, typval_T *rettv);
void f_sign_unplacelist(typval_T *argvars, typval_T *rettv);
# 208 "./proto.h" 2

# 1 "proto/sound.pro" 1

int has_any_sound_callback(void);
int has_sound_callback_in_queue(void);
void invoke_sound_callback(void);
void f_sound_playevent(typval_T *argvars, typval_T *rettv);
void f_sound_playfile(typval_T *argvars, typval_T *rettv);
void f_sound_stop(typval_T *argvars, typval_T *rettv);
void f_sound_clear(typval_T *argvars, typval_T *rettv);
void sound_free(void);
# 210 "./proto.h" 2
# 1 "proto/spell.pro" 1

int spell_check(win_T *wp, char_u *ptr, hlf_T *attrp, int *capcol, int docount);
int match_checkcompoundpattern(char_u *ptr, int wlen, garray_T *gap);
int can_compound(slang_T *slang, char_u *word, char_u *flags);
int match_compoundrule(slang_T *slang, char_u *compflags);
int valid_word_prefix(int totprefcnt, int arridx, int flags, char_u *word, slang_T *slang, int cond_req);
int spell_valid_case(int wordflags, int treeflags);
int no_spell_checking(win_T *wp);
int spell_move_to(win_T *wp, int dir, int allwords, int curline, hlf_T *attrp);
void spell_cat_line(char_u *buf, char_u *line, int maxlen);
char_u *spell_enc(void);
slang_T *slang_alloc(char_u *lang);
void slang_free(slang_T *lp);
void slang_clear(slang_T *lp);
void slang_clear_sug(slang_T *lp);
void count_common_word(slang_T *lp, char_u *word, int len, int count);
int byte_in_str(char_u *str, int n);
int init_syl_tab(slang_T *slang);
char *did_set_spelllang(win_T *wp);
int captype(char_u *word, char_u *end);
void spell_delete_wordlist(void);
void spell_free_all(void);
void spell_reload(void);
buf_T *open_spellbuf(void);
void close_spellbuf(buf_T *buf);
void clear_spell_chartab(spelltab_T *sp);
void init_spell_chartab(void);
int spell_iswordp(char_u *p, win_T *wp);
int spell_iswordp_nmw(char_u *p, win_T *wp);
int spell_casefold(char_u *str, int len, char_u *buf, int buflen);
int check_need_cap(linenr_T lnum, colnr_T col);
void ex_spellrepall(exarg_T *eap);
void onecap_copy(char_u *word, char_u *wcopy, int upper);
void allcap_copy(char_u *word, char_u *wcopy);
int nofold_len(char_u *fword, int flen, char_u *word);
void make_case_word(char_u *fword, char_u *cword, int flags);
char_u *eval_soundfold(char_u *word);
void spell_soundfold(slang_T *slang, char_u *inword, int folded, char_u *res);
void ex_spellinfo(exarg_T *eap);
void ex_spelldump(exarg_T *eap);
void spell_dump_compl(char_u *pat, int ic, int *dir, int dumpflags_arg);
char_u *spell_to_word_end(char_u *start, win_T *win);
int spell_word_start(int startcol);
void spell_expand_check_cap(colnr_T col);
int expand_spelling(linenr_T lnum, char_u *pat, char_u ***matchp);
int valid_spelllang(char_u *val);
int valid_spellfile(char_u *val);
char *did_set_spell_option(int is_spellfile);
char *compile_cap_prog(synblock_T *synblock);
# 211 "./proto.h" 2
# 1 "proto/spellfile.pro" 1

slang_T *spell_load_file(char_u *fname, char_u *lang, slang_T *old_lp, int silent);
void suggest_load_files(void);
int spell_check_msm(void);
void ex_mkspell(exarg_T *eap);
void mkspell(int fcount, char_u **fnames, int ascii, int over_write, int added_word);
void ex_spell(exarg_T *eap);
void spell_add_word(char_u *word, int len, int what, int idx, int undo);
# 212 "./proto.h" 2
# 1 "proto/spellsuggest.pro" 1

int spell_check_sps(void);
void spell_suggest(int count);
void spell_suggest_list(garray_T *gap, char_u *word, int maxcount, int need_cap, int interactive);
# 213 "./proto.h" 2
# 1 "proto/syntax.pro" 1

void syn_set_timeout(proftime_T *tm);
void syntax_start(win_T *wp, linenr_T lnum);
void syn_stack_free_all(synblock_T *block);
void syn_stack_apply_changes(buf_T *buf);
void syntax_end_parsing(linenr_T lnum);
int syntax_check_changed(linenr_T lnum);
int get_syntax_attr(colnr_T col, int *can_spell, int keep_state);
void syntax_clear(synblock_T *block);
void reset_synblock(win_T *wp);
void ex_syntax(exarg_T *eap);
void ex_ownsyntax(exarg_T *eap);
int syntax_present(win_T *win);
void reset_expand_highlight(void);
void set_context_in_echohl_cmd(expand_T *xp, char_u *arg);
void set_context_in_syntax_cmd(expand_T *xp, char_u *arg);
char_u *get_syntax_name(expand_T *xp, int idx);
int syn_get_id(win_T *wp, long lnum, colnr_T col, int trans, int *spellp, int keep_state);
int get_syntax_info(int *seqnrp);
int syn_get_sub_char(void);
int syn_get_stack_item(int i);
int syn_get_foldlevel(win_T *wp, long lnum);
void ex_syntime(exarg_T *eap);
char_u *get_syntime_arg(expand_T *xp, int idx);
# 214 "./proto.h" 2
# 1 "proto/tag.pro" 1

int do_tag(char_u *tag, int type, int count, int forceit, int verbose);
void tag_freematch(void);
void do_tags(exarg_T *eap);
int find_tags(char_u *pat, int *num_matches, char_u ***matchesp, int flags, int mincount, char_u *buf_ffname);
void free_tag_stuff(void);
int get_tagfname(tagname_T *tnp, int first, char_u *buf);
void tagname_free(tagname_T *tnp);
int expand_tags(int tagnames, char_u *pat, int *num_file, char_u ***file);
int get_tags(list_T *list, char_u *pat, char_u *buf_fname);
void get_tagstack(win_T *wp, dict_T *retdict);
int set_tagstack(win_T *wp, dict_T *d, int action);
# 215 "./proto.h" 2
# 1 "proto/term.pro" 1

long termgui_get_color(char_u *name);
long termgui_mch_get_rgb(long color);
void init_term_props(int all);
void f_terminalprops(typval_T *argvars, typval_T *rettv);
void set_color_count(int nr);
int set_termname(char_u *term);
void getlinecol(long *cp, long *rp);
int add_termcap_entry(char_u *name, int force);
int term_is_8bit(char_u *name);
int term_is_gui(char_u *name);
char_u *tltoa(unsigned long i);
void termcapinit(char_u *name);
void out_flush(void);
void out_flush_cursor(int force, int clear_selection);
void out_flush_check(void);
void out_trash(void);
void out_char(unsigned c);
void out_str_nf(char_u *s);
void out_str_cf(char_u *s);
void out_str(char_u *s);
void term_windgoto(int row, int col);
void term_cursor_right(int i);
void term_append_lines(int line_count);
void term_delete_lines(int line_count);
void term_set_winpos(int x, int y);
int term_get_winpos(int *x, int *y, varnumber_T timeout);
void term_set_winsize(int height, int width);
void term_fg_color(int n);
void term_bg_color(int n);
void term_ul_color(int n);
char_u *term_bg_default(void);
void term_fg_rgb_color(long rgb);
void term_bg_rgb_color(long rgb);
void term_ul_rgb_color(long rgb);
void term_settitle(char_u *title);
void term_push_title(int which);
void term_pop_title(int which);
void ttest(int pairs);
void add_long_to_buf(long_u val, char_u *dst);
int get_bytes_from_buf(char_u *buf, char_u *bytes, int num_bytes);
void check_shellsize(void);
void limit_screen_size(void);
void win_new_shellsize(void);
void shell_resized(void);
void shell_resized_check(void);
void set_shellsize(int width, int height, int mustset);
void settmode(tmode_T tmode);
void starttermcap(void);
void stoptermcap(void);
void may_req_termresponse(void);
void check_terminal_behavior(void);
void may_req_bg_color(void);
int swapping_screen(void);
void scroll_start(void);
void cursor_on_force(void);
void cursor_on(void);
void cursor_off(void);
void term_cursor_mode(int forced);
void term_cursor_color(char_u *color);
int blink_state_is_inverted(void);
void term_cursor_shape(int shape, int blink);
void scroll_region_set(win_T *wp, int off);
void scroll_region_reset(void);
void clear_termcodes(void);
void add_termcode(char_u *name, char_u *string, int flags);
char_u *find_termcode(char_u *name);
char_u *get_termcode(int i);
int get_termcode_len(int idx);
void del_termcode(char_u *name);
void set_mouse_topline(win_T *wp);
int is_mouse_topline(win_T *wp);
int put_string_in_typebuf(int offset, int slen, char_u *string, int new_slen, char_u *buf, int bufsize, int *buflen);
int decode_modifiers(int n);
int check_termcode(int max_offset, char_u *buf, int bufsize, int *buflen);
void term_get_fg_color(char_u *r, char_u *g, char_u *b);
void term_get_bg_color(char_u *r, char_u *g, char_u *b);
char_u *replace_termcodes(char_u *from, char_u **bufp, int flags, int *did_simplify);
void show_termcodes(void);
int show_one_termcode(char_u *name, char_u *code, int printit);
void update_tcap(int attr);
void swap_tcap(void);
long gui_get_color_cmn(char_u *name);
long gui_get_rgb_color_cmn(int r, int g, int b);
void cterm_color2rgb(int nr, char_u *r, char_u *g, char_u *b, char_u *ansi_idx);
void term_replace_bs_del_keycode(char_u *ta_buf, int ta_len, int len);
# 216 "./proto.h" 2

# 1 "proto/terminal.pro" 1

void init_job_options(jobopt_T *opt);
buf_T *term_start(typval_T *argvar, char **argv, jobopt_T *opt, int flags);
void ex_terminal(exarg_T *eap);
int term_write_session(FILE *fd, win_T *wp, hashtab_T *terminal_bufs);
int term_should_restore(buf_T *buf);
void free_terminal(buf_T *buf);
void free_unused_terminals(void);
void write_to_term(buf_T *buffer, char_u *msg, channel_T *channel);
int term_job_running(term_T *term);
int term_none_open(term_T *term);
int term_try_stop_job(buf_T *buf);
int term_check_timers(int next_due_arg, proftime_T *now);
int term_in_normal_mode(void);
void term_enter_job_mode(void);
int send_keys_to_term(term_T *term, int c, int modmask, int typed);
int terminal_is_active(void);
cursorentry_T *term_get_cursor_shape(long *fg, long *bg);
int term_use_loop(void);
void term_win_entered(void);
int terminal_loop(int blocking);
int may_close_term_popup(void);
void term_channel_closed(channel_T *ch);
void term_check_channel_closed_recently(void);
int term_do_update_window(win_T *wp);
void term_update_window(win_T *wp);
int term_is_finished(buf_T *buf);
int term_show_buffer(buf_T *buf);
void term_change_in_curbuf(void);
int term_get_attr(win_T *wp, linenr_T lnum, int col);
void term_update_colors(void);
char_u *term_get_status_text(term_T *term);
int set_ref_in_term(int copyID);
void set_terminal_default_colors(int cterm_fg, int cterm_bg);
void f_term_dumpwrite(typval_T *argvars, typval_T *rettv);
int term_swap_diff(void);
void f_term_dumpdiff(typval_T *argvars, typval_T *rettv);
void f_term_dumpload(typval_T *argvars, typval_T *rettv);
void f_term_getaltscreen(typval_T *argvars, typval_T *rettv);
void f_term_getattr(typval_T *argvars, typval_T *rettv);
void f_term_getcursor(typval_T *argvars, typval_T *rettv);
void f_term_getjob(typval_T *argvars, typval_T *rettv);
void f_term_getline(typval_T *argvars, typval_T *rettv);
void f_term_getscrolled(typval_T *argvars, typval_T *rettv);
void f_term_getsize(typval_T *argvars, typval_T *rettv);
void f_term_setsize(typval_T *argvars, typval_T *rettv);
void f_term_getstatus(typval_T *argvars, typval_T *rettv);
void f_term_gettitle(typval_T *argvars, typval_T *rettv);
void f_term_gettty(typval_T *argvars, typval_T *rettv);
void f_term_list(typval_T *argvars, typval_T *rettv);
void f_term_scrape(typval_T *argvars, typval_T *rettv);
void f_term_sendkeys(typval_T *argvars, typval_T *rettv);
void f_term_getansicolors(typval_T *argvars, typval_T *rettv);
void f_term_setansicolors(typval_T *argvars, typval_T *rettv);
void f_term_setapi(typval_T *argvars, typval_T *rettv);
void f_term_setrestore(typval_T *argvars, typval_T *rettv);
void f_term_setkill(typval_T *argvars, typval_T *rettv);
void f_term_start(typval_T *argvars, typval_T *rettv);
void f_term_wait(typval_T *argvars, typval_T *rettv);
void term_send_eof(channel_T *ch);
job_T *term_getjob(term_T *term);
int use_conpty(void);
int terminal_enabled(void);
# 218 "./proto.h" 2





# 1 "proto/popupwin.pro" 1

int popup_on_border(win_T *wp, int row, int col);
int popup_close_if_on_X(win_T *wp, int row, int col);
void popup_start_drag(win_T *wp, int row, int col);
void popup_drag(win_T *wp);
void popup_set_firstline(win_T *wp);
int popup_is_in_scrollbar(win_T *wp, int row, int col);
void popup_handle_scrollbar_click(win_T *wp, int row, int col);
int popup_top_extra(win_T *wp);
int popup_left_extra(win_T *wp);
int popup_height(win_T *wp);
int popup_width(win_T *wp);
int popup_extra_width(win_T *wp);
int parse_previewpopup(win_T *wp);
int parse_completepopup(win_T *wp);
void popup_set_wantpos_cursor(win_T *wp, int width, dict_T *d);
void popup_set_wantpos_rowcol(win_T *wp, int row, int col);
void f_popup_clear(typval_T *argvars, typval_T *rettv);
void f_popup_create(typval_T *argvars, typval_T *rettv);
void f_popup_atcursor(typval_T *argvars, typval_T *rettv);
void f_popup_beval(typval_T *argvars, typval_T *rettv);
void popup_close_with_retval(win_T *wp, int retval);
void popup_close_for_mouse_click(win_T *wp);
void popup_handle_mouse_moved(void);
void f_popup_filter_menu(typval_T *argvars, typval_T *rettv);
void f_popup_filter_yesno(typval_T *argvars, typval_T *rettv);
void f_popup_dialog(typval_T *argvars, typval_T *rettv);
void f_popup_menu(typval_T *argvars, typval_T *rettv);
void f_popup_notification(typval_T *argvars, typval_T *rettv);
void f_popup_close(typval_T *argvars, typval_T *rettv);
void popup_hide(win_T *wp);
void f_popup_hide(typval_T *argvars, typval_T *rettv);
void popup_show(win_T *wp);
void f_popup_show(typval_T *argvars, typval_T *rettv);
void f_popup_settext(typval_T *argvars, typval_T *rettv);
int error_if_popup_window(int also_with_term);
int popup_close(int id, int force);
int popup_close_tabpage(tabpage_T *tp, int id, int force);
void close_all_popups(int force);
void f_popup_move(typval_T *argvars, typval_T *rettv);
void f_popup_setoptions(typval_T *argvars, typval_T *rettv);
void f_popup_getpos(typval_T *argvars, typval_T *rettv);
void f_popup_list(typval_T *argvars, typval_T *rettv);
void f_popup_locate(typval_T *argvars, typval_T *rettv);
void f_popup_getoptions(typval_T *argvars, typval_T *rettv);
int error_if_term_popup_window(void);
void popup_reset_handled(int handled_flag);
win_T *find_next_popup(int lowest, int handled_flag);
int popup_do_filter(int c);
int popup_no_mapping(void);
void popup_check_cursor_pos(void);
void may_update_popup_mask(int type);
void may_update_popup_position(void);
void update_popups(void (*win_update)(win_T *wp));
int set_ref_in_popups(int copyID);
int popup_is_popup(win_T *wp);
win_T *popup_find_preview_window(void);
win_T *popup_find_info_window(void);
void f_popup_findinfo(typval_T *argvars, typval_T *rettv);
void f_popup_findpreview(typval_T *argvars, typval_T *rettv);
int popup_create_preview_window(int info);
void popup_close_preview(void);
void popup_hide_info(void);
void popup_close_info(void);
int popup_win_closed(win_T *win);
void popup_set_title(win_T *wp);
void popup_update_preview_title(void);
# 224 "./proto.h" 2
# 1 "proto/textprop.pro" 1

int find_prop_type_id(char_u *name, buf_T *buf);
void f_prop_add(typval_T *argvars, typval_T *rettv);
void prop_add_common(linenr_T start_lnum, colnr_T start_col, dict_T *dict, buf_T *default_buf, typval_T *dict_arg);
int get_text_props(buf_T *buf, linenr_T lnum, char_u **props, int will_change);
int count_props(linenr_T lnum, int only_starting);
int find_visible_prop(win_T *wp, int type_id, int id, textprop_T *prop, linenr_T *found_lnum);
proptype_T *text_prop_type_by_id(buf_T *buf, int id);
void f_prop_clear(typval_T *argvars, typval_T *rettv);
void f_prop_find(typval_T *argvars, typval_T *rettv);
void f_prop_list(typval_T *argvars, typval_T *rettv);
void f_prop_remove(typval_T *argvars, typval_T *rettv);
void f_prop_type_add(typval_T *argvars, typval_T *rettv);
void f_prop_type_change(typval_T *argvars, typval_T *rettv);
void f_prop_type_delete(typval_T *argvars, typval_T *rettv);
void f_prop_type_get(typval_T *argvars, typval_T *rettv);
void f_prop_type_list(typval_T *argvars, typval_T *rettv);
void clear_global_prop_types(void);
void clear_buf_prop_types(buf_T *buf);
int adjust_prop_columns(linenr_T lnum, colnr_T col, int bytes_added, int flags);
void adjust_props_for_split(linenr_T lnum_props, linenr_T lnum_top, int kept, int deleted);
void prepend_joined_props(char_u *new_props, int propcount, int *props_remaining, linenr_T lnum, int add_all, long col, int removed);
# 225 "./proto.h" 2

# 1 "proto/testing.pro" 1

void f_assert_beeps(typval_T *argvars, typval_T *rettv);
void f_assert_equal(typval_T *argvars, typval_T *rettv);
void f_assert_equalfile(typval_T *argvars, typval_T *rettv);
void f_assert_notequal(typval_T *argvars, typval_T *rettv);
void f_assert_exception(typval_T *argvars, typval_T *rettv);
void f_assert_fails(typval_T *argvars, typval_T *rettv);
void f_assert_false(typval_T *argvars, typval_T *rettv);
void f_assert_inrange(typval_T *argvars, typval_T *rettv);
void f_assert_match(typval_T *argvars, typval_T *rettv);
void f_assert_notmatch(typval_T *argvars, typval_T *rettv);
void f_assert_report(typval_T *argvars, typval_T *rettv);
void f_assert_true(typval_T *argvars, typval_T *rettv);
void f_test_alloc_fail(typval_T *argvars, typval_T *rettv);
void f_test_autochdir(typval_T *argvars, typval_T *rettv);
void f_test_feedinput(typval_T *argvars, typval_T *rettv);
void f_test_getvalue(typval_T *argvars, typval_T *rettv);
void f_test_option_not_set(typval_T *argvars, typval_T *rettv);
void f_test_override(typval_T *argvars, typval_T *rettv);
void f_test_refcount(typval_T *argvars, typval_T *rettv);
void f_test_garbagecollect_now(typval_T *argvars, typval_T *rettv);
void f_test_garbagecollect_soon(typval_T *argvars, typval_T *rettv);
void f_test_ignore_error(typval_T *argvars, typval_T *rettv);
void f_test_null_blob(typval_T *argvars, typval_T *rettv);
void f_test_null_channel(typval_T *argvars, typval_T *rettv);
void f_test_null_dict(typval_T *argvars, typval_T *rettv);
void f_test_null_job(typval_T *argvars, typval_T *rettv);
void f_test_null_list(typval_T *argvars, typval_T *rettv);
void f_test_null_function(typval_T *argvars, typval_T *rettv);
void f_test_null_partial(typval_T *argvars, typval_T *rettv);
void f_test_null_string(typval_T *argvars, typval_T *rettv);
void f_test_unknown(typval_T *argvars, typval_T *rettv);
void f_test_void(typval_T *argvars, typval_T *rettv);
void f_test_scrollbar(typval_T *argvars, typval_T *rettv);
void f_test_setmouse(typval_T *argvars, typval_T *rettv);
void f_test_settime(typval_T *argvars, typval_T *rettv);
# 227 "./proto.h" 2
# 1 "proto/textobject.pro" 1

int findsent(int dir, long count);
int findpar(int *pincl, int dir, long count, int what, int both);
int startPS(linenr_T lnum, int para, int both);
int fwd_word(long count, int bigword, int eol);
int bck_word(long count, int bigword, int stop);
int end_word(long count, int bigword, int stop, int empty);
int bckend_word(long count, int bigword, int eol);
int current_word(oparg_T *oap, long count, int include, int bigword);
int current_sent(oparg_T *oap, long count, int include);
int current_block(oparg_T *oap, long count, int include, int what, int other);
int current_tagblock(oparg_T *oap, long count_arg, int include);
int current_par(oparg_T *oap, long count, int include, int type);
int current_quote(oparg_T *oap, long count, int include, int quotechar);
# 228 "./proto.h" 2
# 1 "proto/textformat.pro" 1

int has_format_option(int x);
void internal_format(int textwidth, int second_indent, int flags, int format_only, int c);
void auto_format(int trailblank, int prev_line);
void check_auto_format(int);
int comp_textwidth(int ff);
void op_format(oparg_T *oap, int keep_cursor);
void op_formatexpr(oparg_T *oap);
int fex_format(linenr_T lnum, long count, int c);
void format_lines(linenr_T line_count, int avoid_fex);
# 229 "./proto.h" 2
# 1 "proto/time.pro" 1

char *get_ctime(time_t thetime, int add_newline);
time_T vim_time(void);
void f_localtime(typval_T *argvars, typval_T *rettv);
void f_reltime(typval_T *argvars, typval_T *rettv);
void f_reltimefloat(typval_T *argvars, typval_T *rettv);
void f_reltimestr(typval_T *argvars, typval_T *rettv);
void f_strftime(typval_T *argvars, typval_T *rettv);
void f_strptime(typval_T *argvars, typval_T *rettv);
long proftime_time_left(proftime_T *due, proftime_T *now);
timer_T *create_timer(long msec, int repeat);
long check_due_timer(void);
void stop_timer(timer_T *timer);
int set_ref_in_timer(int copyID);
void timer_free_all(void);
void f_timer_info(typval_T *argvars, typval_T *rettv);
void f_timer_pause(typval_T *argvars, typval_T *rettv);
void f_timer_start(typval_T *argvars, typval_T *rettv);
void f_timer_stop(typval_T *argvars, typval_T *rettv);
void f_timer_stopall(typval_T *argvars, typval_T *rettv);
void time_push(void *tv_rel, void *tv_start);
void time_pop(void *tp);
void time_msg(char *mesg, void *tv_start);
time_T get8ctime(FILE *fd);
int put_time(FILE *fd, time_T the_time);
void time_to_bytes(time_T the_time, char_u *buf);
void add_time(char_u *buf, size_t buflen, time_t tt);
# 230 "./proto.h" 2
# 1 "proto/typval.pro" 1

typval_T *alloc_tv(void);
typval_T *alloc_string_tv(char_u *s);
void free_tv(typval_T *varp);
void clear_tv(typval_T *varp);
void init_tv(typval_T *varp);
varnumber_T tv_get_number(typval_T *varp);
varnumber_T tv_get_number_chk(typval_T *varp, int *denote);
varnumber_T tv_get_bool(typval_T *varp);
varnumber_T tv_get_bool_chk(typval_T *varp, int *denote);
float_T tv_get_float(typval_T *varp);
char_u *tv_get_string(typval_T *varp);
char_u *tv_get_string_buf(typval_T *varp, char_u *buf);
char_u *tv_get_string_chk(typval_T *varp);
char_u *tv_get_string_buf_chk(typval_T *varp, char_u *buf);
char_u *tv_stringify(typval_T *varp, char_u *buf);
int tv_check_lock(typval_T *tv, char_u *name, int use_gettext);
void copy_tv(typval_T *from, typval_T *to);
int typval_compare(typval_T *typ1, typval_T *typ2, exptype_T type, int ic);
char_u *typval_tostring(typval_T *arg);
int tv_islocked(typval_T *tv);
int tv_equal(typval_T *tv1, typval_T *tv2, int ic, int recursive);
int eval_option(char_u **arg, typval_T *rettv, int evaluate);
int eval_number(char_u **arg, typval_T *rettv, int evaluate, int want_string);
int eval_string(char_u **arg, typval_T *rettv, int evaluate);
int eval_lit_string(char_u **arg, typval_T *rettv, int evaluate);
char_u *tv2string(typval_T *tv, char_u **tofree, char_u *numbuf, int copyID);
int eval_env_var(char_u **arg, typval_T *rettv, int evaluate);
linenr_T tv_get_lnum(typval_T *argvars);
linenr_T tv_get_lnum_buf(typval_T *argvars, buf_T *buf);
buf_T *tv_get_buf(typval_T *tv, int curtab_only);
buf_T *tv_get_buf_from_arg(typval_T *tv);
# 231 "./proto.h" 2
# 1 "proto/ui.pro" 1

void ui_write(char_u *s, int len);
void ui_inchar_undo(char_u *s, int len);
int ui_inchar(char_u *buf, int maxlen, long wtime, int tb_change_cnt);
int inchar_loop(char_u *buf, int maxlen, long wtime, int tb_change_cnt, int (*wait_func)(long wtime, int *interrupted, int ignore_input), int (*resize_func)(int check_only));
int ui_wait_for_chars_or_timer(long wtime, int (*wait_func)(long wtime, int *interrupted, int ignore_input), int *interrupted, int ignore_input);
int ui_char_avail(void);
void ui_delay(long msec, int ignoreinput);
void ui_suspend(void);
void suspend_shell(void);
int ui_get_shellsize(void);
void ui_set_shellsize(int mustset);
void ui_new_shellsize(void);
int ui_get_winpos(int *x, int *y, varnumber_T timeout);
void ui_breakcheck(void);
void ui_breakcheck_force(int force);
int vim_is_input_buf_full(void);
int vim_is_input_buf_empty(void);
int vim_free_in_input_buf(void);
int vim_used_in_input_buf(void);
char_u *get_input_buf(void);
void set_input_buf(char_u *p);
void add_to_input_buf(char_u *s, int len);
void add_to_input_buf_csi(char_u *str, int len);
void trash_input_buf(void);
int read_from_input_buf(char_u *buf, long maxlen);
void fill_input_buf(int exit_on_error);
void read_error_exit(void);
void ui_cursor_shape_forced(int forced);
void ui_cursor_shape(void);
int check_col(int col);
int check_row(int row);
void ui_focus_change(int in_focus);
void im_save_status(long *psave);
# 232 "./proto.h" 2
# 1 "proto/undo.pro" 1

int u_save_cursor(void);
int u_save(linenr_T top, linenr_T bot);
int u_savesub(linenr_T lnum);
int u_inssub(linenr_T lnum);
int u_savedel(linenr_T lnum, long nlines);
int undo_allowed(void);
int u_savecommon(linenr_T top, linenr_T bot, linenr_T newbot, int reload);
void u_compute_hash(char_u *hash);
void u_write_undo(char_u *name, int forceit, buf_T *buf, char_u *hash);
void u_read_undo(char_u *name, char_u *hash, char_u *orig_name);
void u_undo(int count);
void u_redo(int count);
void undo_time(long step, int sec, int file, int absolute);
void u_sync(int force);
void ex_undolist(exarg_T *eap);
void ex_undojoin(exarg_T *eap);
void u_unchanged(buf_T *buf);
void u_find_first_changed(void);
void u_update_save_nr(buf_T *buf);
void u_clearall(buf_T *buf);
void u_clearline(void);
void u_undoline(void);
void u_blockfree(buf_T *buf);
int bufIsChanged(buf_T *buf);
int anyBufIsChanged(void);
int bufIsChangedNotTerm(buf_T *buf);
int curbufIsChanged(void);
void f_undofile(typval_T *argvars, typval_T *rettv);
void f_undotree(typval_T *argvars, typval_T *rettv);
# 233 "./proto.h" 2
# 1 "proto/usercmd.pro" 1

char_u *find_ucmd(exarg_T *eap, char_u *p, int *full, expand_T *xp, int *complp);
char_u *set_context_in_user_cmd(expand_T *xp, char_u *arg_in);
char_u *get_user_command_name(int idx);
char_u *get_user_commands(expand_T *xp, int idx);
char_u *get_user_cmd_addr_type(expand_T *xp, int idx);
char_u *get_user_cmd_flags(expand_T *xp, int idx);
char_u *get_user_cmd_nargs(expand_T *xp, int idx);
char_u *get_user_cmd_complete(expand_T *xp, int idx);
int cmdcomplete_str_to_type(char_u *complete_str);
char *uc_fun_cmd(void);
int parse_compl_arg(char_u *value, int vallen, int *complp, long *argt, char_u **compl_arg);
void ex_command(exarg_T *eap);
void ex_comclear(exarg_T *eap);
void uc_clear(garray_T *gap);
void ex_delcommand(exarg_T *eap);
size_t add_win_cmd_modifers(char_u *buf, cmdmod_T *cmod, int *multi_mods);
size_t produce_cmdmods(char_u *buf, cmdmod_T *cmod, int quote);
void do_ucmd(exarg_T *eap);
# 234 "./proto.h" 2
# 1 "proto/userfunc.pro" 1

void func_init(void);
hashtab_T *func_tbl_get(void);
int get_function_args(char_u **argp, char_u endchar, garray_T *newargs, garray_T *argtypes, int types_optional, int *varargs, garray_T *default_args, int skip, exarg_T *eap, char_u **line_to_free);
char_u *get_lambda_name(void);
char_u *register_cfunc(cfunc_T cb, cfunc_free_T cb_free, void *state);
int get_lambda_tv(char_u **arg, typval_T *rettv, int types_optional, evalarg_T *evalarg);
char_u *deref_func_name(char_u *name, int *lenp, partial_T **partialp, int no_autoload);
void emsg_funcname(char *ermsg, char_u *name);
int get_func_tv(char_u *name, int len, typval_T *rettv, char_u **arg, evalarg_T *evalarg, funcexe_T *funcexe);
char_u *fname_trans_sid(char_u *name, char_u *fname_buf, char_u **tofree, int *error);
ufunc_T *find_func_even_dead(char_u *name, int is_global, cctx_T *cctx);
ufunc_T *find_func(char_u *name, int is_global, cctx_T *cctx);
int func_is_global(ufunc_T *ufunc);
int func_name_refcount(char_u *name);
void copy_func(char_u *lambda, char_u *global);
int funcdepth_increment(void);
void funcdepth_decrement(void);
int funcdepth_get(void);
void funcdepth_restore(int depth);
int call_user_func_check(ufunc_T *fp, int argcount, typval_T *argvars, typval_T *rettv, funcexe_T *funcexe, dict_T *selfdict);
void save_funccal(funccal_entry_T *entry);
void restore_funccal(void);
funccall_T *get_current_funccal(void);
void delete_script_functions(int sid);
void free_all_functions(void);
int builtin_function(char_u *name, int len);
int func_call(char_u *name, typval_T *args, partial_T *partial, dict_T *selfdict, typval_T *rettv);
int get_callback_depth(void);
int call_callback(callback_T *callback, int len, typval_T *rettv, int argcount, typval_T *argvars);
void user_func_error(int error, char_u *name);
int call_func(char_u *funcname, int len, typval_T *rettv, int argcount_in, typval_T *argvars_in, funcexe_T *funcexe);
char_u *printable_func_name(ufunc_T *fp);
char_u *trans_function_name(char_u **pp, int *is_global, int skip, int flags, funcdict_T *fdp, partial_T **partial);
char_u *untrans_function_name(char_u *name);
void list_functions(regmatch_T *regmatch);
ufunc_T *define_function(exarg_T *eap, char_u *name_arg);
void ex_function(exarg_T *eap);
void ex_defcompile(exarg_T *eap);
int eval_fname_script(char_u *p);
int translated_function_exists(char_u *name, int is_global);
int has_varargs(ufunc_T *ufunc);
int function_exists(char_u *name, int no_deref);
char_u *get_expanded_name(char_u *name, int check);
char_u *get_user_func_name(expand_T *xp, int idx);
void ex_delfunction(exarg_T *eap);
void func_unref(char_u *name);
void func_ptr_unref(ufunc_T *fp);
void func_ref(char_u *name);
void func_ptr_ref(ufunc_T *fp);
void ex_return(exarg_T *eap);
void ex_call(exarg_T *eap);
int do_return(exarg_T *eap, int reanimate, int is_cmd, void *rettv);
void discard_pending_return(void *rettv);
char_u *get_return_cmd(void *rettv);
char_u *get_func_line(int c, void *cookie, int indent, getline_opt_T options);
int func_has_ended(void *cookie);
int func_has_abort(void *cookie);
dict_T *make_partial(dict_T *selfdict_in, typval_T *rettv);
char_u *func_name(void *cookie);
linenr_T *func_breakpoint(void *cookie);
int *func_dbg_tick(void *cookie);
int func_level(void *cookie);
int current_func_returned(void);
int free_unref_funccal(int copyID, int testing);
hashtab_T *get_funccal_local_ht(void);
dictitem_T *get_funccal_local_var(void);
hashtab_T *get_funccal_args_ht(void);
dictitem_T *get_funccal_args_var(void);
void list_func_vars(int *first);
dict_T *get_current_funccal_dict(hashtab_T *ht);
hashitem_T *find_hi_in_scoped_ht(char_u *name, hashtab_T **pht);
dictitem_T *find_var_in_scoped_ht(char_u *name, int no_autoload);
int set_ref_in_previous_funccal(int copyID);
int set_ref_in_call_stack(int copyID);
int set_ref_in_functions(int copyID);
int set_ref_in_func_args(int copyID);
int set_ref_in_func(char_u *name, ufunc_T *fp_in, int copyID);
# 235 "./proto.h" 2
# 1 "proto/version.pro" 1

void init_longVersion(void);
int highest_patch(void);
int has_patch(int n);
void ex_version(exarg_T *eap);
void list_in_columns(char_u **items, int size, int current);
void list_version(void);
void maybe_intro_message(void);
void ex_intro(exarg_T *eap);
# 236 "./proto.h" 2

# 1 "proto/vim9compile.pro" 1

int check_defined(char_u *p, size_t len, cctx_T *cctx);
int check_compare_types(exptype_T type, typval_T *tv1, typval_T *tv2);
int use_typecheck(type_T *actual, type_T *expected);
int get_script_item_idx(int sid, char_u *name, int check_writable, cctx_T *cctx);
imported_T *find_imported(char_u *name, size_t len, cctx_T *cctx);
imported_T *find_imported_in_script(char_u *name, size_t len, int sid);
int vim9_comment_start(char_u *p);
char_u *peek_next_line_from_context(cctx_T *cctx);
char_u *next_line_from_context(cctx_T *cctx, int skip_comment);
char_u *to_name_end(char_u *arg, int use_namespace);
char_u *to_name_const_end(char_u *arg);
exptype_T get_compare_type(char_u *p, int *len, int *type_is);
void error_white_both(char_u *op, int len);
int assignment_len(char_u *p, int *heredoc);
void vim9_declare_error(char_u *name);
int check_vim9_unlet(char_u *name);
int compile_def_function(ufunc_T *ufunc, int set_return_type, cctx_T *outer_cctx);
void set_function_type(ufunc_T *ufunc);
void delete_instr(isn_T *isn);
void clear_def_function(ufunc_T *ufunc);
void unlink_def_function(ufunc_T *ufunc);
void free_def_functions(void);
# 238 "./proto.h" 2
# 1 "proto/vim9execute.pro" 1

void to_string_error(vartype_T vartype);
void funcstack_check_refcount(funcstack_T *funcstack);
int call_def_function(ufunc_T *ufunc, int argc_arg, typval_T *argv, partial_T *partial, typval_T *rettv);
void ex_disassemble(exarg_T *eap);
int tv2bool(typval_T *tv);
void emsg_using_string_as(typval_T *tv, int as_number);
int check_not_string(typval_T *tv);
# 239 "./proto.h" 2
# 1 "proto/vim9script.pro" 1

int in_vim9script(void);
void ex_vim9script(exarg_T *eap);
int not_in_vim9(exarg_T *eap);
void ex_export(exarg_T *eap);
void free_imports_and_script_vars(int sid);
void ex_import(exarg_T *eap);
int find_exported(int sid, char_u *name, ufunc_T **ufunc, type_T **type, cctx_T *cctx);
char_u *handle_import(char_u *arg_start, garray_T *gap, int import_sid, evalarg_T *evalarg, void *cctx);
char_u *vim9_declare_scriptvar(exarg_T *eap, char_u *arg);
void add_vim9_script_var(dictitem_T *di, typval_T *tv, type_T *type);
void hide_script_var(scriptitem_T *si, int idx, int func_defined);
void free_all_script_vars(scriptitem_T *si);
svar_T *find_typval_in_script(typval_T *dest);
int check_script_var_type(typval_T *dest, typval_T *value, char_u *name);
# 240 "./proto.h" 2
# 1 "proto/vim9type.pro" 1

type_T *get_type_ptr(garray_T *type_gap);
void clear_type_list(garray_T *gap);
type_T *alloc_type(type_T *type);
void free_type(type_T *type);
type_T *get_list_type(type_T *member_type, garray_T *type_gap);
type_T *get_dict_type(type_T *member_type, garray_T *type_gap);
type_T *alloc_func_type(type_T *ret_type, int argcount, garray_T *type_gap);
type_T *get_func_type(type_T *ret_type, int argcount, garray_T *type_gap);
int func_type_add_arg_types(type_T *functype, int argcount, garray_T *type_gap);
int need_convert_to_bool(type_T *type, typval_T *tv);
type_T *typval2type(typval_T *tv, garray_T *type_gap);
type_T *typval2type_vimvar(typval_T *tv, garray_T *type_gap);
int check_typval_type(type_T *expected, typval_T *actual_tv, int argidx);
void type_mismatch(type_T *expected, type_T *actual);
void arg_type_mismatch(type_T *expected, type_T *actual, int argidx);
int check_type(type_T *expected, type_T *actual, int give_msg, int argidx);
int check_arg_type(type_T *expected, type_T *actual, int argidx);
char_u *skip_type(char_u *start, int optional);
type_T *parse_type(char_u **arg, garray_T *type_gap);
void common_type(type_T *type1, type_T *type2, type_T **dest, garray_T *type_gap);
type_T *get_member_type_from_stack(type_T **stack_top, int count, int skip, garray_T *type_gap);
char *vartype_name(vartype_T type);
char *type_name(type_T *type, char **tofree);
# 241 "./proto.h" 2

# 1 "proto/window.pro" 1

void do_window(int nchar, long Prenum, int xchar);
void get_wincmd_addr_type(char_u *arg, exarg_T *eap);
int win_split(int size, int flags);
int win_split_ins(int size, int flags, win_T *new_wp, int dir);
int win_valid_popup(win_T *win);
int win_valid(win_T *win);
win_T *win_find_by_id(int id);
int win_valid_any_tab(win_T *win);
int win_count(void);
int make_windows(int count, int vertical);
void win_move_after(win_T *win1, win_T *win2);
void win_equal(win_T *next_curwin, int current, int dir);
void entering_window(win_T *win);
void close_windows(buf_T *buf, int keep_curwin);
int one_window(void);
int win_close(win_T *win, int free_buf);
void win_close_othertab(win_T *win, int free_buf, tabpage_T *tp);
void win_free_all(void);
win_T *winframe_remove(win_T *win, int *dirp, tabpage_T *tp);
void close_others(int message, int forceit);
void curwin_init(void);
int win_alloc_first(void);
win_T *win_alloc_popup_win(void);
void win_init_popup_win(win_T *wp, buf_T *buf);
void win_init_size(void);
void free_tabpage(tabpage_T *tp);
int win_new_tabpage(int after);
int make_tabpages(int maxcount);
int valid_tabpage(tabpage_T *tpc);
int valid_tabpage_win(tabpage_T *tpc);
void close_tabpage(tabpage_T *tab);
tabpage_T *find_tabpage(int n);
int tabpage_index(tabpage_T *ftp);
void goto_tabpage(int n);
void goto_tabpage_tp(tabpage_T *tp, int trigger_enter_autocmds, int trigger_leave_autocmds);
int goto_tabpage_lastused(void);
void goto_tabpage_win(tabpage_T *tp, win_T *wp);
void tabpage_move(int nr);
void win_goto(win_T *wp);
win_T *win_find_nr(int winnr);
tabpage_T *win_find_tabpage(win_T *win);
win_T *win_vert_neighbor(tabpage_T *tp, win_T *wp, int up, long count);
win_T *win_horz_neighbor(tabpage_T *tp, win_T *wp, int left, long count);
void win_enter(win_T *wp, int undo_sync);
win_T *buf_jump_open_win(buf_T *buf);
win_T *buf_jump_open_tab(buf_T *buf);
void win_free_popup(win_T *win);
void win_remove(win_T *wp, tabpage_T *tp);
int win_alloc_lines(win_T *wp);
void win_free_lsize(win_T *wp);
void shell_new_rows(void);
void shell_new_columns(void);
void win_size_save(garray_T *gap);
void win_size_restore(garray_T *gap);
int win_comp_pos(void);
void win_setheight(int height);
void win_setheight_win(int height, win_T *win);
void win_setwidth(int width);
void win_setwidth_win(int width, win_T *wp);
void win_setminheight(void);
void win_setminwidth(void);
void win_drag_status_line(win_T *dragwin, int offset);
void win_drag_vsep_line(win_T *dragwin, int offset);
void set_fraction(win_T *wp);
void win_new_height(win_T *wp, int height);
void scroll_to_fraction(win_T *wp, int prev_height);
void win_new_width(win_T *wp, int width);
void win_comp_scroll(win_T *wp);
void command_height(void);
void last_status(int morewin);
int tabline_height(void);
int min_rows(void);
int only_one_window(void);
void check_lnums(int do_curwin);
void reset_lnums(void);
void make_snapshot(int idx);
void restore_snapshot(int idx, int close_curwin);
int win_hasvertsplit(void);
int get_win_number(win_T *wp, win_T *first_win);
int get_tab_number(tabpage_T *tp);
char *check_colorcolumn(win_T *wp);
# 243 "./proto.h" 2
# 274 "./proto.h"
# 1 "proto/beval.pro" 1

int find_word_under_cursor(int mouserow, int mousecol, int getword, int flags, win_T **winp, linenr_T *lnump, char_u **textp, int *colp, int *startcolp);
int get_beval_info(BalloonEval *beval, int getword, win_T **winp, linenr_T *lnump, char_u **textp, int *colp);
void post_balloon(BalloonEval *beval, char_u *mesg, list_T *list);
int can_use_beval(void);
void general_beval_cb(BalloonEval *beval, int state);
# 275 "./proto.h" 2



# 1 "proto/netbeans.pro" 1

void netbeans_parse_messages(void);
int isNetbeansBuffer(buf_T *bufp);
int isNetbeansModified(buf_T *bufp);
void netbeans_end(void);
void ex_nbclose(exarg_T *eap);
void ex_nbkey(exarg_T *eap);
void ex_nbstart(exarg_T *eap);
void netbeans_beval_cb(BalloonEval *beval, int state);
int netbeans_active(void);
void netbeans_open(char *params, int doabort);
void netbeans_send_disconnect(void);
int set_ref_in_nb_channel(int copyID);
void netbeans_frame_moved(int new_x, int new_y);
void netbeans_file_activated(buf_T *bufp);
void netbeans_file_opened(buf_T *bufp);
void netbeans_file_killed(buf_T *bufp);
void netbeans_inserted(buf_T *bufp, linenr_T linenr, colnr_T col, char_u *txt, int newlen);
void netbeans_removed(buf_T *bufp, linenr_T linenr, colnr_T col, long len);
void netbeans_unmodified(buf_T *bufp);
void netbeans_button_release(int button);
int netbeans_keycommand(int key);
void netbeans_save_buffer(buf_T *bufp);
void netbeans_deleted_all_lines(buf_T *bufp);
int netbeans_is_guarded(linenr_T top, linenr_T bot);
void netbeans_draw_multisign_indicator(int row);
void netbeans_gutter_click(linenr_T lnum);
# 279 "./proto.h" 2


# 1 "proto/job.pro" 1

void clear_job_options(jobopt_T *opt);
void free_job_options(jobopt_T *opt);
int get_job_options(typval_T *tv, jobopt_T *opt, int supported, int supported2);
void job_free_all(void);
int job_any_running(void);
int win32_build_cmd(list_T *l, garray_T *gap);
void job_cleanup(job_T *job);
int set_ref_in_job(int copyID);
void job_unref(job_T *job);
int free_unused_jobs_contents(int copyID, int mask);
void free_unused_jobs(int copyID, int mask);
job_T *job_alloc(void);
void job_set_options(job_T *job, jobopt_T *opt);
void job_stop_on_exit(void);
int has_pending_job(void);
int job_check_ended(void);
job_T *job_start(typval_T *argvars, char **argv_arg, jobopt_T *opt_arg, job_T **term_job);
char *job_status(job_T *job);
int job_stop(job_T *job, typval_T *argvars, char *type);
void invoke_prompt_callback(void);
int invoke_prompt_interrupt(void);
char_u *buf_prompt_text(buf_T *buf);
char_u *prompt_text(void);
void init_prompt(int cmdchar_todo);
int prompt_curpos_editable(void);
void f_prompt_setcallback(typval_T *argvars, typval_T *rettv);
void f_prompt_setinterrupt(typval_T *argvars, typval_T *rettv);
void f_prompt_getprompt(typval_T *argvars, typval_T *rettv);
void f_prompt_setprompt(typval_T *argvars, typval_T *rettv);
void f_job_getchannel(typval_T *argvars, typval_T *rettv);
void f_job_info(typval_T *argvars, typval_T *rettv);
void f_job_setoptions(typval_T *argvars, typval_T *rettv);
void f_job_start(typval_T *argvars, typval_T *rettv);
void f_job_status(typval_T *argvars, typval_T *rettv);
void f_job_stop(typval_T *argvars, typval_T *rettv);
# 282 "./proto.h" 2
# 1 "proto/channel.pro" 1

void ch_logfile(char_u *fname, char_u *opt);
int ch_log_active(void);
channel_T *add_channel(void);
int has_any_channel(void);
int channel_still_useful(channel_T *channel);
int channel_can_close(channel_T *channel);
int channel_unref(channel_T *channel);
int free_unused_channels_contents(int copyID, int mask);
void free_unused_channels(int copyID, int mask);
void channel_gui_register_all(void);
channel_T *channel_open(const char *hostname, int port, int waittime, void (*nb_close_cb)(void));
void ch_close_part(channel_T *channel, ch_part_T part);
void channel_set_pipes(channel_T *channel, sock_T in, sock_T out, sock_T err);
void channel_set_job(channel_T *channel, job_T *job, jobopt_T *options);
void channel_write_in(channel_T *channel);
void channel_buffer_free(buf_T *buf);
void channel_write_any_lines(void);
void channel_write_new_lines(buf_T *buf);
readq_T *channel_peek(channel_T *channel, ch_part_T part);
char_u *channel_first_nl(readq_T *node);
char_u *channel_get(channel_T *channel, ch_part_T part, int *outlen);
void channel_consume(channel_T *channel, ch_part_T part, int len);
int channel_collapse(channel_T *channel, ch_part_T part, int want_nl);
int channel_can_write_to(channel_T *channel);
int channel_is_open(channel_T *channel);
char *channel_status(channel_T *channel, int req_part);
void channel_close(channel_T *channel, int invoke_close_cb);
void channel_clear(channel_T *channel);
void channel_free_all(void);
int channel_in_blocking_wait(void);
void channel_handle_events(int only_keep_open);
int channel_any_keep_open(void);
void channel_set_nonblock(channel_T *channel, ch_part_T part);
int channel_send(channel_T *channel, ch_part_T part, char_u *buf_arg, int len_arg, char *fun);
int channel_poll_setup(int nfd_in, void *fds_in, int *towait);
int channel_poll_check(int ret_in, void *fds_in);
int channel_select_setup(int maxfd_in, void *rfds_in, void *wfds_in, struct timeval *tv, struct timeval **tvp);
int channel_select_check(int ret_in, void *rfds_in, void *wfds_in);
int channel_parse_messages(void);
int channel_any_readahead(void);
int set_ref_in_channel(int copyID);
void f_ch_canread(typval_T *argvars, typval_T *rettv);
void f_ch_close(typval_T *argvars, typval_T *rettv);
void f_ch_close_in(typval_T *argvars, typval_T *rettv);
void f_ch_getbufnr(typval_T *argvars, typval_T *rettv);
void f_ch_getjob(typval_T *argvars, typval_T *rettv);
void f_ch_info(typval_T *argvars, typval_T *rettv);
void f_ch_log(typval_T *argvars, typval_T *rettv);
void f_ch_logfile(typval_T *argvars, typval_T *rettv);
void f_ch_open(typval_T *argvars, typval_T *rettv);
void f_ch_read(typval_T *argvars, typval_T *rettv);
void f_ch_readblob(typval_T *argvars, typval_T *rettv);
void f_ch_readraw(typval_T *argvars, typval_T *rettv);
void f_ch_evalexpr(typval_T *argvars, typval_T *rettv);
void f_ch_sendexpr(typval_T *argvars, typval_T *rettv);
void f_ch_evalraw(typval_T *argvars, typval_T *rettv);
void f_ch_sendraw(typval_T *argvars, typval_T *rettv);
void f_ch_setoptions(typval_T *argvars, typval_T *rettv);
void f_ch_status(typval_T *argvars, typval_T *rettv);
# 283 "./proto.h" 2


void ch_log(channel_T *ch, const char *fmt, ...)

    __attribute__((format(printf, 2, 3)))

    ;






# 1 "proto/pty.pro" 1

int setup_slavepty(int fd);
int mch_openpty(char **ttyn);
int mch_isatty(int fd);
# 296 "./proto.h" 2
# 339 "./proto.h"
# 1 "proto/if_xcmdsrv.pro" 1

int serverRegisterName(Display *dpy, char_u *name);
void serverChangeRegisteredWindow(Display *dpy, Window newwin);
int serverSendToVim(Display *dpy, char_u *name, char_u *cmd, char_u **result, Window *server, int asExpr, int timeout, int localLoop, int silent);
char_u *serverGetVimNames(Display *dpy);
Window serverStrToWin(char_u *str);
int serverSendReply(char_u *name, char_u *str);
int serverReadReply(Display *dpy, Window win, char_u **str, int localLoop, int timeout);
int serverPeekReply(Display *dpy, Window win, char_u **str);
void serverEventProc(Display *dpy, XEvent *eventPtr, int immediate);
void server_parse_messages(void);
int server_waiting(void);
# 340 "./proto.h" 2
# 2149 "./vim.h" 2
# 2191 "./vim.h"
# 1 "./globals.h" 1
# 20 "./globals.h"
extern long Rows







       ;
extern long Columns ;
# 42 "./globals.h"
extern schar_T *ScreenLines ;
extern sattr_T *ScreenAttrs ;
extern unsigned *LineOffset ;
extern char_u *LineWraps ;
# 55 "./globals.h"
extern u8char_T *ScreenLinesUC ;
extern u8char_T *ScreenLinesC[6];
extern int Screen_mco ;




extern schar_T *ScreenLines2 ;




extern schar_T *current_ScreenLine ;






extern int screen_cur_row ;
extern int screen_cur_col ;


extern match_T screen_search_hl;



extern foldinfo_T win_foldinfo;




extern int redrawing_for_callback ;
# 96 "./globals.h"
extern short *TabPageIdxs ;



extern short *popup_mask ;
extern short *popup_mask_next ;

extern char *popup_transparent ;


extern int popup_mask_refresh ;


extern tabpage_T *popup_mask_tab ;



extern int screen_zindex ;


extern int screen_Rows ;
extern int screen_Columns ;





extern int mod_mask ;



extern int vgetc_mod_mask ;
extern int vgetc_char ;
# 139 "./globals.h"
extern int cmdline_row;

extern int redraw_cmdline ;
extern int redraw_mode ;
extern int clear_cmdline ;
extern int mode_displayed ;
extern int no_win_do_lines_ins ;

extern int cmdline_star ;


extern int exec_from_reg ;

extern int screen_cleared ;







extern colnr_T dollar_vcol ;







extern int compl_length ;


extern int compl_cont_status ;
# 183 "./globals.h"
extern char_u *edit_submode ;
extern char_u *edit_submode_pre ;
extern char_u *edit_submode_extra ;
extern hlf_T edit_submode_highl;






extern int cmdmsg_rl ;

extern int msg_col;
extern int msg_row;
extern int msg_scrolled;

extern int msg_scrolled_ign ;




extern char_u *keep_msg ;
extern int keep_msg_attr ;
extern int keep_msg_more ;
extern int need_fileinfo ;
extern int msg_scroll ;
extern int msg_didout ;
extern int msg_didany ;
extern int msg_nowait ;
extern int emsg_off ;

extern int info_message ;
extern int msg_hist_off ;

extern int need_clr_eos ;

extern int emsg_skip ;

extern int emsg_severe ;


extern char_u *emsg_assert_fails_msg ;
extern long emsg_assert_fails_lnum ;
extern char_u *emsg_assert_fails_context ;

extern int did_endif ;

extern int did_emsg;


extern int did_emsg_cumul;

extern int called_vim_beep;
extern int did_uncaught_emsg;


extern int did_emsg_syntax;

extern int called_emsg;
extern int ex_exitval ;
extern int emsg_on_display ;
extern int rc_did_emsg ;

extern int no_wait_return ;
extern int need_wait_return ;
extern int did_wait_return ;


extern int need_maketitle ;


extern int quit_more ;

extern int newline_on_exit ;
extern int intr_char ;


extern int x_no_connect ;

extern int x_force_connect ;




extern int ex_keep_indent ;
extern int vgetc_busy ;

extern int didset_vim ;
extern int didset_vimruntime ;





extern int lines_left ;
extern int msg_no_more ;






extern garray_T exestack ;







extern int estack_compiling ;

extern int ex_nesting_level ;
extern int debug_break_level ;
extern int debug_did_msg ;
extern int debug_tick ;
extern int debug_backtrace_level ;

extern int do_profiling ;

extern garray_T script_items ;
# 316 "./globals.h"
extern except_T *current_exception;





extern int did_throw ;





extern int need_rethrow ;






extern int check_cstack ;





extern int trylevel ;
# 351 "./globals.h"
extern int force_abort ;
# 363 "./globals.h"
extern msglist_T **msg_list ;







extern int suppress_errthrow ;







extern except_T *caught_stack ;
# 389 "./globals.h"
extern int may_garbage_collect ;
extern int want_garbage_collect ;
extern int garbage_collect_at_exit ;


extern sctx_T current_sctx ;



extern type_T t_unknown ;
extern type_T t_any ;
extern type_T t_void ;
extern type_T t_bool ;
extern type_T t_special ;
extern type_T t_number ;
extern type_T t_float ;
extern type_T t_string ;
extern type_T t_blob ;
extern type_T t_job ;
extern type_T t_channel ;

extern type_T t_func_unknown ;
extern type_T t_func_void ;
extern type_T t_func_any ;
extern type_T t_func_number ;
extern type_T t_func_string ;
extern type_T t_func_0_void ;
extern type_T t_func_0_any ;
extern type_T t_func_0_number ;
extern type_T t_func_0_string ;

extern type_T t_list_any ;
extern type_T t_dict_any ;
extern type_T t_list_empty ;
extern type_T t_dict_empty ;

extern type_T t_list_bool ;
extern type_T t_list_number ;
extern type_T t_list_string ;
extern type_T t_list_dict_any ;

extern type_T t_dict_bool ;
extern type_T t_dict_number ;
extern type_T t_dict_string ;



extern int did_source_packages ;



extern char_u hash_removed;


extern int scroll_region ;
extern int t_colors ;


extern int include_none ;
extern int include_default ;
extern int include_link ;







extern int highlight_match ;
extern linenr_T search_match_lines;
extern colnr_T search_match_endcol;

extern linenr_T search_first_line ;
extern linenr_T search_last_line ;


extern int no_smartcase ;

extern int need_check_timestamps ;

extern int did_check_timestamps ;

extern int no_check_timestamps ;

extern int highlight_attr[HLF_COUNT];




extern int highlight_user[9];

extern int highlight_stlnc[9];

extern int highlight_stlterm[9];
extern int highlight_stltermnc[9];






extern int skip_term_loop ;




extern int cterm_normal_fg_color ;
extern int cterm_normal_fg_bold ;
extern int cterm_normal_bg_color ;
extern int cterm_normal_ul_color ;

extern long cterm_normal_fg_gui_color ;
extern long cterm_normal_bg_gui_color ;
extern long cterm_normal_ul_gui_color ;


extern int is_mac_terminal ;


extern int autocmd_busy ;
extern int autocmd_no_enter ;
extern int autocmd_no_leave ;

extern int modified_was_set;
extern int did_filetype ;
extern int keep_filetype ;
# 524 "./globals.h"
extern int au_did_filetype ;



extern bufref_T au_new_curbuf ;





extern buf_T *au_pending_free_buf ;
extern win_T *au_pending_free_win ;




extern int mouse_row;
extern int mouse_col;
extern int mouse_past_bottom ;
extern int mouse_past_eol ;
extern int mouse_dragging ;






extern int WantQueryMouse ;
# 577 "./globals.h"
extern int diff_context ;
extern int diff_foldcolumn ;
extern int diff_need_scrollbind ;




extern int updating_screen ;




extern int dont_parse_messages ;




extern vimmenu_T *root_menu ;




extern int sys_menu ;
# 664 "./globals.h"
extern Clipboard_T clip_star;

extern Clipboard_T clip_plus;







extern int clip_unnamed ;

extern int clip_autoselect_star ;
extern int clip_autoselect_plus ;
extern int clip_autoselectml ;
extern int clip_html ;
extern regprog_T *clip_exclude_prog ;
extern int clip_unnamed_saved ;
# 690 "./globals.h"
extern win_T *firstwin;
extern win_T *lastwin;
extern win_T *prevwin ;
# 717 "./globals.h"
extern win_T *curwin;

extern win_T *aucmd_win;
extern int aucmd_win_used ;


extern win_T *first_popupwin;
extern win_T *popup_dragwin ;


extern int popup_visible ;

extern int text_prop_frozen ;






extern frame_T *topframe;






extern tabpage_T *first_tabpage;
extern tabpage_T *curtab;
extern tabpage_T *lastused_tabpage;
extern int redraw_tabline ;





extern buf_T *firstbuf ;
extern buf_T *lastbuf ;
extern buf_T *curbuf ;
# 768 "./globals.h"
extern int mf_dont_release ;





extern alist_T global_alist;
extern int max_alist_id ;
extern int arg_had_last ;


extern int ru_col;

extern int ru_wid;

extern int sc_col;




extern DIR *vim_tempdir_dp ;

extern char_u *vim_tempdir ;







extern int starting ;


extern int exiting ;



extern int really_exiting ;


extern int v_dying ;
extern int stdout_isatty ;


extern int test_autochdir ;






extern volatile sig_atomic_t full_screen ;



extern int restricted ;

extern int secure ;




extern int textwinlock ;




extern int textlock ;




extern int curbuf_lock ;


extern int allbuf_lock ;





extern int sandbox ;





extern int silent_mode ;



extern pos_T VIsual;
extern int VIsual_active ;

extern int VIsual_select ;

extern int VIsual_reselect;



extern int VIsual_mode ;


extern int redo_VIsual_busy ;





extern int resel_VIsual_mode ;
extern linenr_T resel_VIsual_line_count;
extern colnr_T resel_VIsual_vcol;





extern pos_T where_paste_started;







extern int did_ai ;





extern colnr_T ai_col ;







extern int end_comment_pending ;







extern int did_syncbind ;






extern int did_si ;





extern int can_si ;





extern int can_si_back ;


extern int old_indent ;

extern pos_T saved_cursor



 ;




extern pos_T Insstart;





extern pos_T Insstart_orig;




extern int orig_line_count ;
extern int vr_lines_changed ;



extern jmp_buf x_jump_env;
# 983 "./globals.h"
extern int enc_dbcs ;

extern int enc_unicode ;
extern int enc_utf8 ;
extern int enc_latin1like ;






extern int has_mbyte ;





extern char mb_bytelen_tab[256];



extern vimconv_T input_conv;
extern vimconv_T output_conv;
# 1014 "./globals.h"
extern int (*mb_ptr2len)(char_u *p) ;

extern int (*mb_ptr2len_len)(char_u *p, int size) ;

extern int (*mb_char2len)(int c) ;

extern int (*mb_char2bytes)(int c, char_u *buf) ;
extern int (*mb_ptr2cells)(char_u *p) ;
extern int (*mb_ptr2cells_len)(char_u *p, int size) ;
extern int (*mb_char2cells)(int c) ;
extern int (*mb_off2cells)(unsigned off, unsigned max_off) ;
extern int (*mb_ptr2char)(char_u *p) ;
extern int (*mb_head_off)(char_u *base, char_u *p) ;
# 1072 "./globals.h"
extern int State ;


extern int debug_mode ;


extern int finish_op ;
extern long opcount ;
extern int motion_force ;




extern int exmode_active ;


extern int pending_exmode_active ;

extern int ex_no_reprint ;

extern int reg_recording ;
extern int reg_executing ;



extern int seenModifyOtherKeys ;

extern int no_mapping ;
extern int no_zero_mapping ;
extern int allow_keys ;

extern int no_reduce_keys ;

extern int no_u_sync ;

extern int u_sync_once ;



extern int restart_edit ;
extern int arrow_used;



extern int ins_at_eol ;


extern int no_abbr ;
# 1128 "./globals.h"
extern int mapped_ctrl_c ;
extern int ctrl_c_interrupts ;

extern cmdmod_T cmdmod;

extern int is_export ;

extern int msg_silent ;
extern int emsg_silent ;
extern int emsg_noredir ;
extern int cmd_silent ;

extern int in_assert_fails ;

extern int swap_exists_action ;


extern int swap_exists_did_quit ;


extern char_u *IObuff;

extern char_u *NameBuff;

extern char msg_buf[480];


extern int RedrawingDisabled ;

extern int readonlymode ;
extern int recoverymode ;

extern typebuf_T typebuf



      ;
extern int ex_normal_busy ;
extern int in_feedkeys ;
extern int ex_normal_lock ;


extern int ignore_script ;

extern int stop_insert_mode;

extern int KeyTyped;
extern int KeyStuffed;

extern int vgetc_im_active;


extern int maptick ;

extern int must_redraw ;
extern int skip_redraw ;
extern int do_redraw ;

extern int need_diff_redraw ;


extern int need_highlight_changed ;


extern FILE *scriptin[15];
extern int curscript ;
extern FILE *scriptout ;
extern int read_cmd_fd ;



extern volatile sig_atomic_t got_int ;



extern volatile sig_atomic_t got_sigusr1 ;




extern int termcap_active ;
extern tmode_T cur_tmode ;
extern int bangredo ;
extern int searchcmdlen;

extern int reg_do_extmatch ;


extern reg_extmatch_T *re_extmatch_in ;

extern reg_extmatch_T *re_extmatch_out ;



extern int did_outofmem_msg ;

extern int did_swapwrite_msg ;

extern int undo_off ;
extern int global_busy ;
extern int listcmd_busy ;

extern int need_start_insertmode ;

extern char_u *last_cmdline ;
extern char_u *repeat_cmdline ;
extern char_u *new_last_cmdline ;
extern char_u *autocmd_fname ;
extern int autocmd_fname_full;
extern int autocmd_bufnr ;
extern char_u *autocmd_match ;
extern int did_cursorhold ;
extern pos_T last_cursormoved



   ;

extern int postponed_split ;
extern int postponed_split_flags ;
extern int postponed_split_tab ;

extern int g_do_tagpreview ;


extern int g_tag_at_cursor ;



extern int replace_offset ;

extern char_u *escape_chars ;


extern int keep_help_flag ;






extern char_u *empty_option ;

extern int redir_off ;
extern FILE *redir_fd ;

extern int redir_reg ;
extern int redir_vname ;
extern int redir_execute ;



extern char_u langmap_mapchar[256];



extern int save_p_ls ;
extern int save_p_wmh ;
extern int wild_menu_showing ;
# 1297 "./globals.h"
extern char breakat_flags[256];



extern char *Version;



extern char *longVersion ;







extern char_u *default_vim_dir;
extern char_u *default_vimruntime_dir;
extern char_u *all_cflags;
extern char_u *all_lflags;




extern char_u *compiled_user;
extern char_u *compiled_sys;


extern char_u *homedir ;




extern char_u *globaldir ;


extern int lcs_eol ;
extern int lcs_ext ;
extern int lcs_prec ;
extern int lcs_nbsp ;
extern int lcs_space ;
extern int lcs_tab1 ;
extern int lcs_tab2 ;
extern int lcs_tab3 ;
extern int lcs_trail ;

extern int lcs_conceal ;



extern int fill_stl ;
extern int fill_stlnc ;
extern int fill_vert ;
extern int fill_fold ;
extern int fill_diff ;


extern int disable_fold_update ;



extern int km_stopsel ;
extern int km_startsel ;


extern int cmdwin_type ;
extern int cmdwin_result ;


extern char_u no_lines_msg[] ;






extern long sub_nsubs;
extern linenr_T sub_nlines;


extern char_u wim_flags[4];





extern int stl_syntax ;




extern int no_hlsearch ;



extern BalloonEval *balloonEval ;
extern int balloonEvalForTerm ;

extern int bevalServers ;






extern cursorentry_T shape_table[17];
# 1426 "./globals.h"
extern option_table_T printer_opts[14]
# 1446 "./globals.h"
;
# 1460 "./globals.h"
extern linenr_T printer_page_num;




extern char *xterm_display ;


extern int xterm_display_allocated ;


extern Display *xterm_dpy ;


extern XtAppContext app_context ;
# 1491 "./globals.h"
extern int typebuf_was_filled ;




extern char_u *serverName ;

extern Window commWindow ;
extern Window clientWindow ;
extern Atom commProperty ;
extern char_u *serverDelayedStartName ;
# 1511 "./globals.h"
extern int term_is_xterm ;
# 1523 "./globals.h"
extern int virtual_op ;



extern disptick_T display_tick ;





extern linenr_T spell_redraw_lnum ;







extern int need_cursor_line_redraw ;
# 1554 "./globals.h"
extern char *netbeansArg ;
extern int netbeansFireChanges ;
extern int netbeansForcedQuit ;
extern int netbeansReadFile ;
extern int netbeansSuppressNoLines ;






extern char e_abort[] ;
extern char e_argreq[] ;
extern char e_backslash[] ;

extern char e_cmdwin[] ;

extern char e_curdir[] ;

extern char e_endif[] ;
extern char e_catch[] ;
extern char e_finally[] ;
extern char e_finally_dup[] ;
extern char e_endtry[] ;
extern char e_no_endtry[] ;
extern char e_endwhile[] ;
extern char e_endfor[] ;
extern char e_while[] ;
extern char e_for[] ;

extern char e_exists[] ;
extern char e_failed[] ;
# 1596 "./globals.h"
extern char e_internal[] ;
extern char e_intern2[] ;
extern char e_interr[] ;
extern char e_invarg[] ;
extern char e_invarg2[] ;
extern char e_duparg2[] ;
extern char e_invargval[] ;
extern char e_invargNval[] ;

extern char e_invexpr2[] ;

extern char e_invrange[] ;

extern char e_isadir2[] ;


extern char e_no_spell[] ;


extern char e_libcall[] ;


extern char e_fsync[] ;
# 1629 "./globals.h"
extern char e_loadlib[] ;
extern char e_loadfunc[] ;

extern char e_markinval[] ;
extern char e_marknotset[] ;
extern char e_modifiable[] ;
extern char e_nesting[] ;
extern char e_noalt[] ;
extern char e_noabbr[] ;
extern char e_nobang[] ;

extern char e_nogvim[] ;




extern char e_nofarsi[] ;




extern char e_nogroup[] ;

extern char e_noinstext[] ;
extern char e_nolastcmd[] ;
extern char e_nomap[] ;
extern char e_nomatch[] ;
extern char e_nomatch2[] ;
extern char e_noname[] ;
extern char e_nopresub[] ;
extern char e_noprev[] ;
extern char e_noprevre[] ;
extern char e_norange[] ;
extern char e_noroom[] ;

extern char e_noserver[] ;

extern char e_notcreate[] ;
extern char e_notmp[] ;
extern char e_notopen[] ;
extern char e_notread[] ;
extern char e_null[] ;

extern char e_number_exp[] ;


extern char e_openerrf[] ;




extern char e_outofmem[] ;
extern char e_patnotf[] ;
extern char e_patnotf2[] ;
extern char e_positive[] ;

extern char e_prev_dir[] ;



extern char e_quickfix[] ;
extern char e_loclist[] ;

extern char e_re_damg[] ;
extern char e_re_corr[] ;
extern char e_readonly[] ;

extern char e_letwrong[] ;
extern char e_illvar[] ;
extern char e_cannot_mod[] ;
extern char e_readonlyvar[] ;
extern char e_readonlysbx[] ;
extern char e_stringreq[] ;
extern char e_emptykey[] ;
extern char e_dictreq[] ;
extern char e_listidx[] ;
extern char e_blobidx[] ;
extern char e_invalblob[] ;
extern char e_toomanyarg[] ;
extern char e_toofewarg[] ;
extern char e_func_deleted[] ;
extern char e_dictkey[] ;
extern char e_listreq[] ;
extern char e_listblobreq[] ;
extern char e_list_end[] ;
extern char e_listdictarg[] ;
extern char e_listdictblobarg[] ;
extern char e_modulus[] ;
extern char e_inval_string[] ;
extern char e_const_option[] ;
extern char e_unknown_option[] ;
extern char e_letunexp[] ;
extern char e_reduceempty[] ;
extern char e_no_dict_key[] ;


extern char e_readerrf[] ;


extern char e_sandbox[] ;

extern char e_secure[] ;
extern char e_textlock[] ;
extern char e_textwinlock[] ;


extern char e_screenmode[] ;

extern char e_scroll[] ;
extern char e_shellempty[] ;



extern char e_swapclose[] ;
extern char e_tagstack[] ;
extern char e_toocompl[] ;
extern char e_longname[] ;
extern char e_toomsbra[] ;
extern char e_toomany[] ;
extern char e_trailing[] ;
extern char e_trailing_arg[] ;
extern char e_umark[] ;
extern char e_wildexpand[] ;
extern char e_winheight[] ;
extern char e_winwidth[] ;
extern char e_write[] ;
extern char e_zerocount[] ;

extern char e_usingsid[] ;
extern char e_missing_paren[] ;
extern char e_missing_close[] ;
extern char e_missing_dict_colon[] ;
extern char e_duplicate_key[] ;
extern char e_missing_dict_comma[] ;
extern char e_missing_dict_end[] ;


extern char e_invexprmsg[] ;


extern char e_guarded[] ;
extern char e_nbreadonly[] ;

extern char e_maxmempat[] ;
extern char e_emptybuf[] ;
extern char e_nobufnr[] ;

extern char e_invalpat[] ;
extern char e_bufloaded[] ;

extern char e_notset[] ;





extern char e_float_as_string[] ;

extern char e_dirnotf[] ;
extern char e_au_recursive[] ;
extern char e_autocmd_close[] ;

extern char e_menuothermode[] ;

extern char e_invalwindow[] ;
extern char e_listarg[] ;

extern char e_missing_colon[] ;
extern char e_missing_in[] ;
extern char e_unknownfunc[] ;
extern char e_missbrac[] ;
extern char e_else_without_if[] ;
extern char e_elseif_without_if[] ;
extern char e_endif_without_if[] ;
extern char e_continue[] ;
extern char e_break[] ;
extern char e_nowhitespace[] ;

extern char e_lock_unlock[] ;


extern char e_alloc_color[] ;


extern char top_bot_msg[] ;
extern char bot_top_msg[] ;

extern char line_msg[] ;


extern char need_key_msg[] ;






extern int xsmp_icefd ;



extern time_T starttime;


extern FILE *time_fd ;







extern int vim_ignored;
extern char *vim_ignoredp;



extern alloc_id_T alloc_fail_id ;

extern int alloc_fail_countdown ;

extern int alloc_fail_repeat ;


extern int disable_char_avail_for_testing ;
extern int disable_redraw_for_testing ;
extern int ignore_redraw_flag_for_testing ;
extern int nfa_fail_for_testing ;
extern int no_query_mouse_for_testing ;
extern int ui_delay_for_testing ;
extern int reset_term_props_on_termresponse ;

extern int in_free_unref_items ;



extern int did_add_timer ;
extern int timer_busy ;


extern int input_busy ;



extern int bevalexpr_due_set ;
extern proftime_T bevalexpr_due;



extern time_T time_for_testing ;

extern int echo_attr ;


extern int did_echo_string_emsg ;


extern int *eval_lavars_used ;


extern char windowsVersion[20] ;


extern listitem_T range_list_item;


extern evalarg_T EVALARG_EVALUATE



 ;
# 1911 "./globals.h"
extern int did_repeated_msg ;





extern int ch_log_output ;


extern int channel_need_redraw ;
# 2192 "./vim.h" 2
# 1 "./errors.h" 1
# 14 "./errors.h"
extern char e_undefined_variable_str[]
                                           ;
extern char e_undefined_variable_char_str[]
                                              ;

extern char e_invalid_command[]
                                    ;

extern char e_invalid_command_str[]
                                        ;
extern char e_cannot_slice_dictionary[]
                                              ;
extern char e_assert_fails_second_arg[]
                                                                                                          ;
extern char e_cannot_index_special_variable[]
                                                    ;
extern char e_missing_var_str[]
                                      ;
extern char e_variable_not_found_str[]
                                            ;
extern char e_syntax_error_at_str[]
                                        ;
extern char e_missing_return_value[]
                                          ;
extern char e_white_space_required_before_and_after_str[]
                                                                ;
extern char e_too_many_argument_types[]
                                             ;
extern char e_str_is_used_as_argument[]
                                               ;
extern char e_mandatory_argument_after_optional_argument[]
                                                                ;
extern char e_missing_type[]
                                    ;
extern char e_missing_gt_after_type[]
                                          ;
extern char e_type_not_recognized_str[]
                                             ;
extern char e_name_too_long_str[]
                                       ;
extern char e_type_mismatch_expected_str_but_got_str[]
                                                           ;
extern char e_argument_nr_type_mismatch_expected_str_but_got_str[]
                                                                        ;
extern char e_invalid_key_str[]
                                     ;
extern char e_name_expected[]
                                       ;
extern char e_cannot_declare_a_scope_variable[]
                                                      ;
extern char e_cannot_declare_an_environment_variable[]
                                                                ;
extern char e_variable_already_declared[]
                                                   ;
extern char e_cannot_assign_to_constant[]
                                                     ;
extern char e_can_only_concatenate_to_string[]
                                                    ;
extern char e_cannot_use_operator_on_new_variable[]
                                                                  ;
extern char e_const_requires_a_value[]
                                            ;
extern char e_type_or_initialization_required[]
                                                     ;
extern char e_using_number_as_bool_nr[]
                                                  ;
extern char e_using_number_as_string[]
                                                ;
extern char e_using_rcurly_outside_if_block_scope[]
                                                      ;
extern char e_missing_rcurly[]
                               ;
extern char e_missing_return_statement[]
                                              ;
extern char e_compiling_def_function_failed[]
                                                    ;
extern char e_expected_str_but_got_str[]
                                            ;
extern char e_using_string_as_number_str[]
                                                        ;
extern char e_cannot_use_void_value[]
                                           ;
extern char e_missing_catch_or_finally[]
                                                ;
extern char e_catch_unreachable_after_catch_all[]
                                                       ;
extern char e_cannot_use_reserved_name[]
                                                 ;
extern char e_percent_requires_number_arguments[]
                                                 ;
extern char e_char_requires_number_or_float_arguments[]
                                                           ;
extern char e_cannot_use_str_with_str[]
                                               ;
extern char e_vim9script_can_only_be_used_in_script[]
                                                                 ;
extern char e_vim9script_must_be_first_command_in_script[]
                                                                          ;
extern char e_cannot_use_scriptversion_after_vim9script[]
                                                                 ;
extern char e_redefining_script_item_str[]
                                               ;
extern char e_export_can_only_be_used_in_vim9script[]
                                                           ;
extern char e_invalid_command_after_export[]
                                                   ;
extern char e_export_with_invalid_argument[]
                                                  ;
extern char e_missing_as_after_star[]
                                            ;
extern char e_missing_comma_in_import[]
                                             ;
extern char e_syntax_error_in_import[]
                                            ;
extern char e_item_not_found_in_script_str[]
                                                  ;
extern char e_item_not_exported_in_script_str[]
                                                     ;
extern char e_colon_required_before_a_range[]
                                                   ;
extern char e_wrong_argument_type_for_plus[]
                                               ;
extern char e_cannot_declare_an_option[]
                                                  ;
extern char e_could_not_import_str[]
                                             ;
extern char e_variable_already_declared_in_script[]
                                                                 ;
extern char e_missing_name_after_dots[]
                                            ;
extern char e_expected_type_str[]
                                         ;
extern char e_missing_enddef[]
                                     ;
extern char e_function_nesting_too_deep[]
                                               ;
extern char e_no_white_space_allowed_before_colon_str[]
                                                             ;
extern char e_expected_dot_after_name_str[]
                                                 ;
extern char e_cannot_find_function_str[]
                                             ;
extern char e_cannot_index_number[]
                                           ;
extern char e_type_mismatch_for_v_variable[]
                                                   ;


extern char e_cannot_declare_a_register_str[]
                                                   ;
extern char e_separator_mismatch_str[]
                                            ;
extern char e_no_white_space_allowed_before_str[]
                                                        ;
extern char e_white_space_required_after_str[]
                                                     ;
extern char e_missing_from[]
                                      ;
extern char e_invalid_string_after_from[]
                                                   ;
extern char e_cannot_compare_str_with_str[]
                                               ;
extern char e_name_already_defined_str[]
                                              ;
extern char e_no_white_space_allowed_after_dot[]
                                                      ;
extern char e_namespace_not_supported_str[]
                                                 ;
extern char e_this_vim_is_not_compiled_with_float_support[]
                                                                 ;
extern char e_missing_argument_type_for_str[]
                                                  ;



extern char e_cannot_unlet_str[]
                                     ;
extern char e_cannot_use_namespaced_variable[]
                                                          ;
extern char e_missing_backtick[]
                                      ;
extern char e_cannot_delete_vim9_script_function_str[]
                                                           ;
extern char e_not_callable_type_str[]
                                             ;
extern char e_cannot_use_function_inside_def[]
                                                      ;
extern char e_cannot_use_index_when_declaring_variable[]
                                                                   ;

extern char e_unknown_variable_str[]
                                          ;
extern char e_cannot_assign_to_argument[]
                                                  ;
extern char e_function_is_not_compiled_str[]
                                                  ;
extern char e_cannot_use_list_for_declaration[]
                                                         ;
extern char e_expected_nr_items_but_got_nr[]
                                                  ;
extern char e_import_can_only_be_used_in_script[]
                                                         ;
extern char e_unreachable_code_after_return[]
                                                    ;
extern char e_returning_value_in_function_without_return_type[]
                                                                           ;
extern char e_line_incomplete[]
                                     ;

extern char e_unknown_error_while_executing_str[]
                                                      ;
extern char e_cannot_declare_script_variable_in_function[]
                                                                        ;
extern char e_lambda_function_not_found_str[]
                                                   ;
extern char e_dictionary_not_set[]
                                        ;
extern char e_missing_gt[]
                               ;
extern char e_cannot_convert_str_to_string[]
                                                 ;
extern char e_one_argument_too_many[]
                                           ;
extern char e_nr_arguments_too_many[]
                                           ;
extern char e_string_list_dict_or_blob_required[]
                                                         ;
extern char e_item_not_found_str[]
                                        ;
extern char e_list_item_nr_is_not_list[]
                                                ;
extern char e_list_item_nr_does_not_contain_3_numbers[]
                                                             ;
extern char e_list_item_nr_range_invalid[]
                                                ;
extern char e_list_item_nr_cell_width_invalid[]
                                                     ;
extern char e_overlapping_ranges_for_nr[]
                                                  ;
extern char e_only_values_of_0x100_and_higher_supported[]
                                                               ;
extern char e_assert_fails_fourth_argument[]
                                                                         ;
extern char e_assert_fails_fifth_argument[]
                                                                        ;
extern char e_cannot_use_bang_with_nested_def[]
                                                   ;
extern char e_cannot_change_list[]
                                        ;
extern char e_cannot_change_list_item[]
                                             ;
extern char e_cannot_change_dict[]
                                        ;
extern char e_cannot_change_dict_item[]
                                             ;
extern char e_variable_is_locked_str[]
                                            ;
extern char e_missing_comma_before_argument_str[]
                                                       ;
extern char e_str_cannot_be_used_in_legacy_vim_script[]
                                                                ;
extern char e_final_requires_a_value[]
                                            ;
extern char e_cannot_use_let_in_vim9_script[]
                                                    ;
extern char e_missing_name_after_dot[]
                                            ;
extern char e_endblock_without_block[]
                                 ;
extern char e_throw_with_empty_string[]
                                             ;
extern char e_cannot_add_to_null_list[]
                                             ;
extern char e_cannot_add_to_null_blob[]
                                             ;
extern char e_missing_function_argument[]
                                               ;
extern char e_cannot_extend_null_dict[]
                                               ;
extern char e_cannot_extend_null_list[]
                                               ;
extern char e_using_string_as_bool_str[]
                                                      ;

extern char e_cmd_mapping_must_end_with_cr[]
                                                     ;
extern char e_cmd_mapping_must_end_with_cr_before_second_cmd[]
                                                                         ;
extern char e_cmd_maping_must_not_include_str_key[]
                                                           ;
extern char e_using_bool_as_number[]
                                              ;
extern char e_missing_matching_bracket_after_dict_key[]
                                                             ;
# 2193 "./vim.h" 2
# 2628 "./vim.h"
typedef struct timeval elapsed_T;
long elapsed(struct timeval *start_tv);
# 29 "buffer.c" 2

static void enter_buffer(buf_T *buf);
static void buflist_getfpos(void);
static char_u *buflist_match(regmatch_T *rmp, buf_T *buf, int ignore_case);
static char_u *fname_match(regmatch_T *rmp, char_u *name, int ignore_case);

static buf_T *buflist_findname_stat(char_u *ffname, stat_T *st);
static int otherfile_buf(buf_T *buf, char_u *ffname, stat_T *stp);
static int buf_same_ino(buf_T *buf, stat_T *stp);




static int value_changed(char_u *str, char_u **last);

static int append_arg_number(win_T *wp, char_u *buf, int buflen, int add_file);
static void free_buffer(buf_T *);
static void free_buffer_stuff(buf_T *buf, int free_options);
static void clear_wininfo(buf_T *buf);
# 59 "buffer.c"
static char *msg_loclist = "[Location List]";
static char *msg_qflist = "[Quickfix List]";

static char *e_auabort = "E855: Autocommands caused command to abort";


static int buf_free_count = 0;

static int top_file_num = 1;
static garray_T buf_reuse = {0, 0, 0, 0, ((void*)0)};




    int
get_highest_fnum(void)
{
    return top_file_num - 1;
}




    static int
read_buffer(
    int read_stdin,
    exarg_T *eap,
    int flags)
{
    int retval = 1;
    linenr_T line_count;






    line_count = curbuf->b_ml.ml_line_count;
    retval = readfile(
     read_stdin ? ((void*)0) : curbuf->b_ffname,
     read_stdin ? ((void*)0) : curbuf->b_fname,
     (linenr_T)line_count, (linenr_T)0, (linenr_T)9223372036854775807L, eap,
     flags | 0x08);
    if (retval == 1)
    {

 while (--line_count >= 0)
     ml_delete((linenr_T)1);
    }
    else
    {

 while (curbuf->b_ml.ml_line_count > line_count)
     ml_delete(line_count);
    }

    curwin->w_cursor.lnum = 1;
    curwin->w_cursor.col = 0;

    if (read_stdin)
    {


 if (!readonlymode && !(curbuf->b_ml.ml_line_count == 1 && *ml_get((linenr_T)1) == '\000'))
     changed();
 else if (retval == 1)
     unchanged(curbuf, 0, 1);

 if (retval == 1)
 {

     apply_autocmds_retval(EVENT_STDINREADPOST, ((void*)0), ((void*)0), 0,
             curbuf, &retval);



 }
    }
    return retval;
}




    void
buffer_ensure_loaded(buf_T *buf)
{
    if (buf->b_ml.ml_mfp == ((void*)0))
    {
 aco_save_T aco;

 aucmd_prepbuf(&aco, buf);
 swap_exists_action = 0;
 open_buffer(0, ((void*)0), 0);
 aucmd_restbuf(&aco);
    }
}






    int
open_buffer(
    int read_stdin,
    exarg_T *eap,
    int flags)
{
    int retval = 1;
    bufref_T old_curbuf;

    long old_tw = curbuf->b_p_tw;

    int read_fifo = 0;






    if (readonlymode && curbuf->b_ffname != ((void*)0)
     && (curbuf->b_flags & 0x04))
 curbuf->b_p_ro = 1;

    if (ml_open(curbuf) == 0)
    {




 close_buffer(((void*)0), curbuf, 0, 0, 0);
 for ((curbuf) = firstbuf; (curbuf) != ((void*)0); (curbuf) = (curbuf)->b_next)
     if (curbuf->b_ml.ml_mfp != ((void*)0))
  break;




 if (curbuf == ((void*)0))
 {
     emsg(dcgettext (((void*)0), (char *)("E82: Cannot allocate any buffer, exiting..."), 5));



     v_dying = 2;
     getout(2);
 }

 emsg(dcgettext (((void*)0), (char *)("E83: Cannot allocate buffer, using other one..."), 5));
 enter_buffer(curbuf);

 if (old_tw != curbuf->b_p_tw)
     check_colorcolumn(curwin);

 return 0;
    }



    set_bufref(&old_curbuf, curbuf);
    modified_was_set = 0;


    curwin->w_valid = 0;

    if (curbuf->b_ffname != ((void*)0)

     && netbeansReadFile

       )
    {
 int old_msg_silent = msg_silent;

 int save_bin = curbuf->b_p_bin;
 int perm;


 int oldFire = netbeansFireChanges;

 netbeansFireChanges = 0;


 perm = mch_getperm(curbuf->b_ffname);
 if (perm >= 0 && (((((perm)) & 0170000) == (0010000))
        || ((((perm)) & 0170000) == (0140000))



      ))
  read_fifo = 1;
 if (read_fifo)
     curbuf->b_p_bin = 1;

 if (shortmess('F'))
     msg_silent = 1;
 retval = readfile(curbuf->b_ffname, curbuf->b_fname,
    (linenr_T)0, (linenr_T)0, (linenr_T)9223372036854775807L, eap,
    flags | 0x01 | (read_fifo ? 0x40 : 0));

 if (read_fifo)
 {
     curbuf->b_p_bin = save_bin;
     if (retval == 1)
  retval = read_buffer(0, eap, flags);
 }

 msg_silent = old_msg_silent;

 netbeansFireChanges = oldFire;


 if (bt_help(curbuf))
     fix_help_buffer();
    }
    else if (read_stdin)
    {
 int save_bin = curbuf->b_p_bin;







 curbuf->b_p_bin = 1;
 retval = readfile(((void*)0), ((void*)0), (linenr_T)0,
    (linenr_T)0, (linenr_T)9223372036854775807L, ((void*)0),
    flags | (0x01 + 0x04));
 curbuf->b_p_bin = save_bin;
 if (retval == 1)
     retval = read_buffer(1, eap, flags);
    }


    if (curbuf->b_flags & 0x04)
    {
 (void)buf_init_chartab(curbuf, 0);

 parse_cino(curbuf);

    }
# 310 "buffer.c"
    if ((got_int && vim_strchr(p_cpo, 'i') != ((void*)0))
  || modified_was_set

  || (aborting() && vim_strchr(p_cpo, 'i') != ((void*)0))

       )
 changed();
    else if (retval == 1 && !read_stdin && !read_fifo)
 unchanged(curbuf, 0, 1);
    save_file_ff(curbuf);



    curbuf->b_last_changedtick = ((curbuf)->b_ct_di.di_tv.vval.v_number);
    curbuf->b_last_changedtick_pum = ((curbuf)->b_ct_di.di_tv.vval.v_number);



    if (aborting())



 curbuf->b_flags |= 0x40;




    foldUpdateAll(curwin);



    if (!(curwin->w_valid & 0x80))
    {
 curwin->w_topline = 1;

 curwin->w_topfill = 0;

    }

    apply_autocmds_retval(EVENT_BUFENTER, ((void*)0), ((void*)0), 0, curbuf, &retval);




    if (retval == 1)
    {




 if (bufref_valid(&old_curbuf) && old_curbuf.br_buf->b_ml.ml_mfp != ((void*)0))
 {
     aco_save_T aco;


     aucmd_prepbuf(&aco, old_curbuf.br_buf);
     do_modelines(0);
     curbuf->b_flags &= ~(0x02 | 0x04);


     apply_autocmds_retval(EVENT_BUFWINENTER, ((void*)0), ((void*)0), 0, curbuf,
              &retval);





     aucmd_restbuf(&aco);
 }
    }

    return retval;
}




    void
set_bufref(bufref_T *bufref, buf_T *buf)
{
    bufref->br_buf = buf;
    bufref->br_fnum = buf == ((void*)0) ? 0 : buf->b_fnum;
    bufref->br_buf_free_count = buf_free_count;
}
# 402 "buffer.c"
    int
bufref_valid(bufref_T *bufref)
{
    return bufref->br_buf_free_count == buf_free_count
 ? 1 : buf_valid(bufref->br_buf)
      && bufref->br_fnum == bufref->br_buf->b_fnum;
}





    int
buf_valid(buf_T *buf)
{
    buf_T *bp;



    for ((bp) = lastbuf; (bp) != ((void*)0); (bp) = (bp)->b_prev)
 if (bp == buf)
     return 1;
    return 0;
}




static hashtab_T buf_hashtab;

    static void
buf_hashtab_add(buf_T *buf)
{
    __builtin___sprintf_chk ((char *)buf->b_key, 1 - 1, __builtin_object_size ((char *)buf->b_key, 1 > 1), "%x", buf->b_fnum);
    if (hash_add(&buf_hashtab, buf->b_key) == 0)
 emsg(dcgettext (((void*)0), (char *)("E931: Buffer cannot be registered"), 5));
}

    static void
buf_hashtab_remove(buf_T *buf)
{
    hashitem_T *hi = hash_find(&buf_hashtab, buf->b_key);

    if (!((hi)->hi_key == ((void*)0) || (hi)->hi_key == &hash_removed))
 hash_remove(&buf_hashtab, hi);
}






    static int
can_unload_buffer(buf_T *buf)
{
    int can_unload = !buf->b_locked;

    if (can_unload && updating_screen)
    {
 win_T *wp;

 for (wp = firstwin; wp != ((void*)0); wp = wp->w_next)
     if (wp->w_buffer == buf)
     {
  can_unload = 0;
  break;
     }
    }
    if (!can_unload)
 semsg(dcgettext (((void*)0), (char *)("E937: Attempt to delete a buffer that is in use: %s"), 5),
         buf->b_fname);
    return can_unload;
}
# 496 "buffer.c"
    void
close_buffer(
    win_T *win,
    buf_T *buf,
    int action,
    int abort_if_last,
    int ignore_abort)
{
    int is_curbuf;
    int nwindows;
    bufref_T bufref;
    int is_curwin = (curwin != ((void*)0) && curwin->w_buffer == buf);
    win_T *the_curwin = curwin;
    tabpage_T *the_curtab = curtab;
    int unload_buf = (action != 0);
    int wipe_buf = (action == 4 || action == 5);
    int del_buf = (action == 3 || wipe_buf);

                ;





    if (buf->b_p_bh[0] == 'd')
    {
 del_buf = 1;
 unload_buf = 1;
    }
    else if (buf->b_p_bh[0] == 'w')
    {
 del_buf = 1;
 unload_buf = 1;
 wipe_buf = 1;
    }
    else if (buf->b_p_bh[0] == 'u')
 unload_buf = 1;


    if (bt_terminal(buf) && (buf->b_nwindows == 1 || del_buf))
    {
             ;
 if (term_job_running(buf->b_term))
 {
     if (wipe_buf || unload_buf)
     {
  if (!can_unload_buffer(buf))
      return;


  free_terminal(buf);
     }
     else
     {

  del_buf = 0;
  unload_buf = 0;
     }
 }
 else
 {

     del_buf = 1;
     unload_buf = 1;
     wipe_buf = 1;
 }
             ;
    }




    if ((del_buf || wipe_buf) && !can_unload_buffer(buf))
 return;


    if (win != ((void*)0) && win_valid_any_tab(win))
    {




 if (buf->b_nwindows == 1)
     set_last_cursor(win);
 buflist_setfpos(buf, win,
      win->w_cursor.lnum == 1 ? 0 : win->w_cursor.lnum,
      win->w_cursor.col, 1);
    }

    set_bufref(&bufref, buf);


    if (buf->b_nwindows == 1)
    {
 ++buf->b_locked;
 if (apply_autocmds(EVENT_BUFWINLEAVE, buf->b_fname, buf->b_fname,
          0, buf)
  && !bufref_valid(&bufref))
 {

aucmd_abort:
     emsg(dcgettext (((void*)0), (char *)(e_auabort), 5));
     return;
 }
 --buf->b_locked;
 if (abort_if_last && one_window())

     goto aucmd_abort;



 if (!unload_buf)
 {
     ++buf->b_locked;
     if (apply_autocmds(EVENT_BUFHIDDEN, buf->b_fname, buf->b_fname,
          0, buf)
      && !bufref_valid(&bufref))

  goto aucmd_abort;
     --buf->b_locked;
     if (abort_if_last && one_window())

  goto aucmd_abort;
 }


 if (!ignore_abort && aborting())
     return;

    }




    if (is_curwin && curwin != the_curwin && win_valid_any_tab(the_curwin))
    {
 block_autocmds();
 goto_tabpage_win(the_curtab, the_curwin);
 unblock_autocmds();
    }

    nwindows = buf->b_nwindows;


    if (buf->b_nwindows > 0)
 --buf->b_nwindows;


    if (diffopt_hiddenoff() && !unload_buf && buf->b_nwindows == 0)
 diff_buf_delete(buf);




    if (buf->b_nwindows > 0 || !unload_buf)
 return;


    if (buf->b_ffname == ((void*)0))
 del_buf = 1;



    if (buf == curbuf && VIsual_active



     )
 end_visual_mode();







    is_curbuf = (buf == curbuf);
    buf->b_nwindows = nwindows;

    buf_freeall(buf, (del_buf ? 1 : 0)
     + (wipe_buf ? 2 : 0)
     + (ignore_abort ? 8 : 0));


    if (!bufref_valid(&bufref))
 return;


    if (!ignore_abort && aborting())
 return;
# 695 "buffer.c"
    if (buf == curbuf && !is_curbuf)
 return;

    if (win_valid_any_tab(win) && win->w_buffer == buf)
 win->w_buffer = ((void*)0);



    if (buf->b_nwindows > 0)
 --buf->b_nwindows;




    if (wipe_buf)
    {
 if (action == 5)
 {

     if (buf_reuse.ga_itemsize == 0)
  ga_init2(&buf_reuse, sizeof(int), 50);
     if (ga_grow(&buf_reuse, 1) == 1)
  ((int *)buf_reuse.ga_data)[buf_reuse.ga_len++] = buf->b_fnum;
 }
 if (buf->b_sfname != buf->b_ffname)
     do { if ((buf->b_sfname) != ((void*)0)) { vim_free(buf->b_sfname); (buf->b_sfname) = ((void*)0); } } while (0);
 else
     buf->b_sfname = ((void*)0);
 do { if ((buf->b_ffname) != ((void*)0)) { vim_free(buf->b_ffname); (buf->b_ffname) = ((void*)0); } } while (0);
 if (buf->b_prev == ((void*)0))
     firstbuf = buf->b_next;
 else
     buf->b_prev->b_next = buf->b_next;
 if (buf->b_next == ((void*)0))
     lastbuf = buf->b_prev;
 else
     buf->b_next->b_prev = buf->b_prev;
 free_buffer(buf);
    }
    else
    {
 if (del_buf)
 {


     free_buffer_stuff(buf, 1);


     buf->b_flags = 0x02 | 0x04;


     buf->b_p_initialized = 0;
 }
 buf_clear_file(buf);
 if (del_buf)
     buf->b_p_bl = 0;
    }

}




    void
buf_clear_file(buf_T *buf)
{
    buf->b_ml.ml_line_count = 1;
    unchanged(buf, 1, 1);
    buf->b_shortname = 0;
    buf->b_p_eol = 1;
    buf->b_start_eol = 1;
    buf->b_p_bomb = 0;
    buf->b_start_bomb = 0;
    buf->b_ml.ml_mfp = ((void*)0);
    buf->b_ml.ml_flags = 1;

    netbeans_deleted_all_lines(buf);

}
# 784 "buffer.c"
    void
buf_freeall(buf_T *buf, int flags)
{
    int is_curbuf = (buf == curbuf);
    bufref_T bufref;
    int is_curwin = (curwin != ((void*)0) && curwin->w_buffer == buf);
    win_T *the_curwin = curwin;
    tabpage_T *the_curtab = curtab;


    ++buf->b_locked;
    set_bufref(&bufref, buf);
    if (buf->b_ml.ml_mfp != ((void*)0))
    {
 if (apply_autocmds(EVENT_BUFUNLOAD, buf->b_fname, buf->b_fname,
          0, buf)
  && !bufref_valid(&bufref))

     return;
    }
    if ((flags & 1) && buf->b_p_bl)
    {
 if (apply_autocmds(EVENT_BUFDELETE, buf->b_fname, buf->b_fname,
           0, buf)
  && !bufref_valid(&bufref))

     return;
    }
    if (flags & 2)
    {
 if (apply_autocmds(EVENT_BUFWIPEOUT, buf->b_fname, buf->b_fname,
          0, buf)
  && !bufref_valid(&bufref))

     return;
    }
    --buf->b_locked;




    if (is_curwin && curwin != the_curwin && win_valid_any_tab(the_curwin))
    {
 block_autocmds();
 goto_tabpage_win(the_curtab, the_curwin);
 unblock_autocmds();
    }



    if ((flags & 8) == 0 && aborting())
 return;
# 844 "buffer.c"
    if (buf == curbuf && !is_curbuf)
 return;

    diff_buf_delete(buf);



    if (curwin != ((void*)0) && curwin->w_buffer == buf)
 reset_synblock(curwin);




    {
 win_T *win;
 tabpage_T *tp;

 for ((tp) = first_tabpage; (tp) != ((void*)0); (tp) = (tp)->tp_next) for ((win) = ((tp) == curtab) ? firstwin : (tp)->tp_firstwin; (win); (win) = (win)->w_next)
     if (win->w_buffer == buf)
  clearFolding(win);
    }





    ml_close(buf, 1);
    buf->b_ml.ml_line_count = 0;
    if ((flags & 4) == 0)
    {
 u_blockfree(buf);
 u_clearall(buf);
    }

    syntax_clear(&buf->b_s);


    clear_buf_prop_types(buf);

    buf->b_flags &= ~0x40;
}





    static void
free_buffer(buf_T *buf)
{
    ++buf_free_count;
    free_buffer_stuff(buf, 1);


    dictitem_remove(buf->b_vars, (dictitem_T *)&buf->b_ct_di);
    unref_var_dict(buf->b_vars);
    remove_listeners(buf);
# 920 "buffer.c"
    channel_buffer_free(buf);


    free_terminal(buf);


    vim_free(buf->b_prompt_text);
    free_callback(&buf->b_prompt_callback);
    free_callback(&buf->b_prompt_interrupt);


    buf_hashtab_remove(buf);

    aubuflocal_remove(buf);

    if (autocmd_busy)
    {


 buf->b_next = au_pending_free_buf;
 au_pending_free_buf = buf;
    }
    else
    {
 vim_free(buf);
 if (curbuf == buf)
     curbuf = ((void*)0);
    }
}




    static void
init_changedtick(buf_T *buf)
{
    dictitem_T *di = (dictitem_T *)&buf->b_ct_di;

    di->di_flags = 0x04 | 0x01;
    di->di_tv.v_type = VAR_NUMBER;
    di->di_tv.v_lock = 2;
    di->di_tv.vval.v_number = 0;


    strcpy((char *)(buf->b_ct_di.di_key), (char *)("changedtick"));
    (void)dict_add(buf->b_vars, di);

}




    static void
free_buffer_stuff(
    buf_T *buf,
    int free_options)
{
    if (free_options)
    {
 clear_wininfo(buf);
 free_buf_options(buf, 1);

 ga_clear(&buf->b_s.b_langp);

    }

    {
 varnumber_T tick = ((buf)->b_ct_di.di_tv.vval.v_number);

 vars_clear(&buf->b_vars->dv_hashtab);
 hash_init(&buf->b_vars->dv_hashtab);
 init_changedtick(buf);
 ((buf)->b_ct_di.di_tv.vval.v_number) = tick;
 remove_listeners(buf);
    }

    uc_clear(&buf->b_ucmds);

    buf_delete_signs(buf, (char_u *)"*");


    netbeans_file_killed(buf);

    map_clear_int(buf, (0x3f | 0x1000 | 0x2000), 1, 0);
    map_clear_int(buf, (0x3f | 0x1000 | 0x2000), 1, 1);
    do { if ((buf->b_start_fenc) != ((void*)0)) { vim_free(buf->b_start_fenc); (buf->b_start_fenc) = ((void*)0); } } while (0);
}




    void
free_wininfo(wininfo_T *wip)
{
    if (wip->wi_optset)
    {
 clear_winopt(&wip->wi_opt);

 deleteFoldRecurse(&wip->wi_folds);

    }
    vim_free(wip);
}




    static void
clear_wininfo(buf_T *buf)
{
    wininfo_T *wip;

    while (buf->b_wininfo != ((void*)0))
    {
 wip = buf->b_wininfo;
 buf->b_wininfo = wip->wi_next;
 free_wininfo(wip);
    }
}




    void
goto_buffer(
    exarg_T *eap,
    int start,
    int dir,
    int count)
{
    bufref_T old_curbuf;

    set_bufref(&old_curbuf, curbuf);

    swap_exists_action = 1;
    (void)do_buffer(*eap->cmd == 's' ? 1 : 0,
          start, dir, count, eap->forceit);
    if (swap_exists_action == 2 && *eap->cmd == 's')
    {

 cleanup_T cs;



 enter_cleanup(&cs);



 win_close(curwin, 1);
 swap_exists_action = 0;
 swap_exists_did_quit = 1;




 leave_cleanup(&cs);

    }
    else
 handle_swap_exists(&old_curbuf);
}





    void
handle_swap_exists(bufref_T *old_curbuf)
{

    cleanup_T cs;


    long old_tw = curbuf->b_p_tw;

    buf_T *buf;

    if (swap_exists_action == 2)
    {



 enter_cleanup(&cs);





 swap_exists_action = 0;
 swap_exists_did_quit = 1;
 close_buffer(curwin, curbuf, 2, 0, 0);
 if (old_curbuf == ((void*)0) || !bufref_valid(old_curbuf)
           || old_curbuf->br_buf == curbuf)
     buf = buflist_new(((void*)0), ((void*)0), 1L, 1 | 2);
 else
     buf = old_curbuf->br_buf;
 if (buf != ((void*)0))
 {
     int old_msg_silent = msg_silent;

     if (shortmess('F'))
  msg_silent = 1;
     enter_buffer(buf);

     msg_silent = old_msg_silent;


     if (old_tw != curbuf->b_p_tw)
  check_colorcolumn(curwin);

 }





 leave_cleanup(&cs);

    }
    else if (swap_exists_action == 3)
    {



 enter_cleanup(&cs);



 msg_scroll = 1;
 ml_recover(0);
 msg_puts("\n");
 cmdline_row = msg_row;
 do_modelines(0);




 leave_cleanup(&cs);

    }
    swap_exists_action = 0;
}
# 1176 "buffer.c"
    char *
do_bufdel(
    int command,
    char_u *arg,
    int addr_count,
    int start_bnr,
    int end_bnr,
    int forceit)
{
    int do_current = 0;
    int deleted = 0;
    char *errormsg = ((void*)0);
    int bnr;
    char_u *p;

    if (addr_count == 0)
    {
 (void)do_buffer(command, 0, 1, 0, forceit);
    }
    else
    {
 if (addr_count == 2)
 {
     if (*arg)
  return ex_errmsg(e_trailing_arg, arg);
     bnr = start_bnr;
 }
 else
     bnr = end_bnr;

 for ( ;!got_int; ui_breakcheck())
 {






     if (bnr == curbuf->b_fnum)
  do_current = bnr;
     else if (do_buffer(command, 1, 1, (int)bnr,
              forceit) == 1)
  ++deleted;




     if (addr_count == 2)
     {
  if (++bnr > end_bnr)
      break;
     }
     else
     {
  arg = skipwhite(arg);
  if (*arg == '\000')
      break;
  if (!((unsigned)(*arg) - '0' < 10))
  {
      p = skiptowhite_esc(arg);
      bnr = buflist_findpat(arg, p,
     command == 4 || command == 5,
        0, 0);
      if (bnr < 0)
   break;
      arg = p;
  }
  else
      bnr = getdigits(&arg);
     }
 }
 if (!got_int && do_current && do_buffer(command, 1,
       1, do_current, forceit) == 1)
     ++deleted;

 if (deleted == 0)
 {
     if (command == 2)
  strcpy((char *)(IObuff), (char *)(dcgettext (((void*)0), (char *)("E515: No buffers were unloaded"), 5)));
     else if (command == 3)
  strcpy((char *)(IObuff), (char *)(dcgettext (((void*)0), (char *)("E516: No buffers were deleted"), 5)));
     else
  strcpy((char *)(IObuff), (char *)(dcgettext (((void*)0), (char *)("E517: No buffers were wiped out"), 5)));
     errormsg = (char *)IObuff;
 }
 else if (deleted >= p_report)
 {
     if (command == 2)
  smsg(dcngettext (((void*)0), ("%d buffer unloaded"), ("%d buffers unloaded"), (deleted), 5), deleted);

     else if (command == 3)
  smsg(dcngettext (((void*)0), ("%d buffer deleted"), ("%d buffers deleted"), (deleted), 5), deleted);

     else
  smsg(dcngettext (((void*)0), ("%d buffer wiped out"), ("%d buffers wiped out"), (deleted), 5), deleted);

 }
    }


    return errormsg;
}





    static int
empty_curbuf(
    int close_others,
    int forceit,
    int action)
{
    int retval;
    buf_T *buf = curbuf;
    bufref_T bufref;

    if (action == 2)
    {
 emsg(dcgettext (((void*)0), (char *)("E90: Cannot unload last buffer"), 5));
 return 0;
    }

    set_bufref(&bufref, buf);
    if (close_others)

 close_windows(buf, 1);

    setpcmark();
    retval = do_ecmd(0, ((void*)0), ((void*)0), ((void*)0), (linenr_T)1,
       forceit ? 0x08 : 0, curwin);






    if (buf != curbuf && bufref_valid(&bufref) && buf->b_nwindows == 0)
 close_buffer(((void*)0), buf, action, 0, 0);
    if (!close_others)
 need_fileinfo = 0;
    return retval;
}
# 1337 "buffer.c"
    int
do_buffer(
    int action,
    int start,
    int dir,
    int count,
    int forceit)
{
    buf_T *buf;
    buf_T *bp;
    int unload = (action == 2 || action == 3
   || action == 4 || action == 5);

    switch (start)
    {
 case 1: buf = firstbuf; break;
 case 2: buf = lastbuf; break;
 default: buf = curbuf; break;
    }
    if (start == 3)
    {
 while (count-- > 0)
 {
     do
     {
  buf = buf->b_next;
  if (buf == ((void*)0))
      buf = firstbuf;
     }
     while (buf != curbuf && !bufIsChanged(buf));
 }
 if (!bufIsChanged(buf))
 {
     emsg(dcgettext (((void*)0), (char *)("E84: No modified buffer found"), 5));
     return 0;
 }
    }
    else if (start == 1 && count)
    {
 while (buf != ((void*)0) && buf->b_fnum != count)
     buf = buf->b_next;
    }
    else
    {
 bp = ((void*)0);
 while (count > 0 || (!unload && !buf->b_p_bl && bp != buf))
 {


     if (bp == ((void*)0))
  bp = buf;
     if (dir == 1)
     {
  buf = buf->b_next;
  if (buf == ((void*)0))
      buf = firstbuf;
     }
     else
     {
  buf = buf->b_prev;
  if (buf == ((void*)0))
      buf = lastbuf;
     }

     if (unload || buf->b_p_bl)
     {
   --count;
   bp = ((void*)0);
     }
     if (bp == buf)
     {

  emsg(dcgettext (((void*)0), (char *)("E85: There is no listed buffer"), 5));
  return 0;
     }
 }
    }

    if (buf == ((void*)0))
    {
 if (start == 1)
 {

     if (!unload)
  semsg(dcgettext (((void*)0), (char *)(e_nobufnr), 5), count);
 }
 else if (dir == 1)
     emsg(dcgettext (((void*)0), (char *)("E87: Cannot go beyond last buffer"), 5));
 else
     emsg(dcgettext (((void*)0), (char *)("E88: Cannot go before first buffer"), 5));
 return 0;
    }
# 1437 "buffer.c"
    if (unload)
    {
 int forward;
 bufref_T bufref;

 if (!can_unload_buffer(buf))
     return 0;

 set_bufref(&bufref, buf);



 if (action != 4 && action != 5
       && buf->b_ml.ml_mfp == ((void*)0) && !buf->b_p_bl)
     return 0;

 if (!forceit && bufIsChanged(buf))
 {

     if ((p_confirm || (cmdmod.cmod_flags & 0x0080)) && p_write)
     {
  dialog_changed(buf, 0);
  if (!bufref_valid(&bufref))


      return 0;


  if (bufIsChanged(buf))
      return 0;
     }
     else

     {
  semsg(dcgettext (((void*)0), (char *)("E89: No write since last change for buffer %d (add ! to override)"), 5),
         buf->b_fnum);
  return 0;
     }
 }


 if (buf == curbuf && VIsual_active)
     end_visual_mode();





 for ((bp) = firstbuf; (bp) != ((void*)0); (bp) = (bp)->b_next)
     if (bp->b_p_bl && bp != buf)
  break;
 if (bp == ((void*)0) && buf == curbuf)
     return empty_curbuf(1, forceit, action);






 while (buf == curbuf
     && !(curwin->w_closing || curwin->w_buffer->b_locked > 0)
     && (!(firstwin == lastwin) || first_tabpage->tp_next != ((void*)0)))
 {
     if (win_close(curwin, 0) == 0)
  break;
 }




 if (buf != curbuf)
 {
     close_windows(buf, 0);
     if (buf != curbuf && bufref_valid(&bufref) && buf->b_nwindows <= 0)
      close_buffer(((void*)0), buf, action, 0, 0);
     return 1;
 }
# 1525 "buffer.c"
 buf = ((void*)0);
 bp = ((void*)0);
 if (au_new_curbuf.br_buf != ((void*)0) && bufref_valid(&au_new_curbuf))
     buf = au_new_curbuf.br_buf;

 else if (curwin->w_jumplistlen > 0)
 {
     int jumpidx;

     jumpidx = curwin->w_jumplistidx - 1;
     if (jumpidx < 0)
  jumpidx = curwin->w_jumplistlen - 1;

     forward = jumpidx;
     while (jumpidx != curwin->w_jumplistidx)
     {
  buf = buflist_findnr(curwin->w_jumplist[jumpidx].fmark.fnum);
  if (buf != ((void*)0))
  {
      if (buf == curbuf || !buf->b_p_bl)
   buf = ((void*)0);
      else if (buf->b_ml.ml_mfp == ((void*)0))
      {

   if (bp == ((void*)0))
       bp = buf;
   buf = ((void*)0);
      }
  }
  if (buf != ((void*)0))
      break;

  if (!jumpidx && curwin->w_jumplistidx == curwin->w_jumplistlen)
      break;
  if (--jumpidx < 0)
      jumpidx = curwin->w_jumplistlen - 1;
  if (jumpidx == forward)
      break;
     }
 }


 if (buf == ((void*)0))
 {
     forward = 1;
     buf = curbuf->b_next;
     for (;;)
     {
  if (buf == ((void*)0))
  {
      if (!forward)
   break;
      buf = curbuf->b_prev;
      forward = 0;
      continue;
  }

  if (buf->b_help == curbuf->b_help && buf->b_p_bl)
  {
      if (buf->b_ml.ml_mfp != ((void*)0))
   break;
      if (bp == ((void*)0))
   bp = buf;
  }
  if (forward)
      buf = buf->b_next;
  else
      buf = buf->b_prev;
     }
 }
 if (buf == ((void*)0))
     buf = bp;
 if (buf == ((void*)0))
 {
     for ((buf) = firstbuf; (buf) != ((void*)0); (buf) = (buf)->b_next)
  if (buf->b_p_bl && buf != curbuf)
      break;
 }
 if (buf == ((void*)0))
 {
     if (curbuf->b_next != ((void*)0))
  buf = curbuf->b_next;
     else
  buf = curbuf->b_prev;
 }
    }

    if (buf == ((void*)0))
    {


 return empty_curbuf(0, forceit, action);
    }




    if (action == 1)
    {


 if ((swb_flags & 0x001) && buf_jump_open_win(buf))
     return 1;


 if ((swb_flags & 0x002) && buf_jump_open_tab(buf))
     return 1;
 if (win_split(0, 0) == 0)
     return 0;
    }


    if (buf == curbuf)
 return 1;




    if (action == 0 && !can_abandon(curbuf, forceit))
    {

 if ((p_confirm || (cmdmod.cmod_flags & 0x0080)) && p_write)
 {
     bufref_T bufref;

     set_bufref(&bufref, buf);
     dialog_changed(curbuf, 0);
     if (!bufref_valid(&bufref))

  return 0;
 }
 if (bufIsChanged(curbuf))

 {
     no_write_message();
     return 0;
 }
    }


    set_curbuf(buf, action);

    if (action == 1)
 do { (curwin)->w_onebuf_opt.wo_scb = 0; (curwin)->w_onebuf_opt.wo_crb = 0; } while (0);


    if (aborting())
 return 0;


    return 1;
}
# 1688 "buffer.c"
    void
set_curbuf(buf_T *buf, int action)
{
    buf_T *prevbuf;
    int unload = (action == 2 || action == 3
   || action == 4 || action == 5);

    long old_tw = curbuf->b_p_tw;

    bufref_T newbufref;
    bufref_T prevbufref;

    setpcmark();
    if ((cmdmod.cmod_flags & 0x0100) == 0)
 curwin->w_alt_fnum = curbuf->b_fnum;
    buflist_altfpos(curwin);


    VIsual_reselect = 0;


    prevbuf = curbuf;
    set_bufref(&prevbufref, prevbuf);
    set_bufref(&newbufref, buf);



    if (!apply_autocmds(EVENT_BUFLEAVE, ((void*)0), ((void*)0), 0, curbuf)
     || (bufref_valid(&prevbufref)
  && bufref_valid(&newbufref)

  && !aborting()

        ))
    {

 if (prevbuf == curwin->w_buffer)
     reset_synblock(curwin);

 if (unload)
     close_windows(prevbuf, 0);

 if (bufref_valid(&prevbufref) && !aborting())



 {
     win_T *previouswin = curwin;

     if (prevbuf == curbuf)
  u_sync(0);
     close_buffer(prevbuf == curwin->w_buffer ? curwin : ((void*)0), prevbuf,
      unload ? action : (action == 0
   && !buf_hide(prevbuf)
   && !bufIsChanged(prevbuf)) ? 2 : 0,
      0, 0);
     if (curwin != previouswin && win_valid(previouswin))

       curwin = previouswin;
 }
    }



    if ((buf_valid(buf) && buf != curbuf

  && !aborting()

 ) || curwin->w_buffer == ((void*)0))
    {
 enter_buffer(buf);

 if (old_tw != curbuf->b_p_tw)
     check_colorcolumn(curwin);

    }
}






    static void
enter_buffer(buf_T *buf)
{

    curwin->w_buffer = buf;
    curbuf = buf;
    ++curbuf->b_nwindows;


    buf_copy_options(buf, 1 | 4);
    if (!buf->b_help)
 get_winopts(buf);

    else

 clearFolding(curwin);
    foldUpdateAll(curwin);



    if (curwin->w_onebuf_opt.wo_diff)
 diff_buf_add(curbuf);



    curwin->w_s = &(curbuf->b_s);



    curwin->w_cursor.lnum = 1;
    curwin->w_cursor.col = 0;
    curwin->w_cursor.coladd = 0;
    curwin->w_set_curswant = 1;
    curwin->w_topline_was_set = 0;


    curwin->w_valid = 0;

    buflist_setfpos(curbuf, curwin, curbuf->b_last_cursor.lnum,
           curbuf->b_last_cursor.col, 1);


    if (curbuf->b_ml.ml_mfp == ((void*)0))
    {



 if (*curbuf->b_p_ft == '\000')
     did_filetype = 0;

 open_buffer(0, ((void*)0), 0);
    }
    else
    {
 if (!msg_silent && !shortmess('F'))
     need_fileinfo = 1;


 (void)buf_check_timestamp(curbuf, 0);

 curwin->w_topline = 1;

 curwin->w_topfill = 0;

 apply_autocmds(EVENT_BUFENTER, ((void*)0), ((void*)0), 0, curbuf);
 apply_autocmds(EVENT_BUFWINENTER, ((void*)0), ((void*)0), 0, curbuf);
    }



    if (curwin->w_cursor.lnum == 1 && inindent(0))
 buflist_getfpos();

    check_arg_idx(curwin);

    maketitle();


    if (curwin->w_topline == 1 && !curwin->w_topline_was_set)
 scroll_cursor_halfway(0);



    netbeans_file_activated(curbuf);



    do { if (p_acd) do_autochdir(); } while (0);


    if (curbuf->b_kmap_state & 1)
 (void)keymap_init();




    if (!curbuf->b_help && curwin->w_onebuf_opt.wo_spell && *curwin->w_s->b_p_spl != '\000')
 (void)did_set_spelllang(curwin);


    curbuf->b_last_used = vim_time();


    redraw_later(40);
}






    void
do_autochdir(void)
{
    if ((starting == 0 || test_autochdir)
     && curbuf->b_ffname != ((void*)0)
     && vim_chdirfile(curbuf->b_ffname, "auto") == 1)
 shorten_fnames(1);
}


    void
no_write_message(void)
{

    if (term_job_running(curbuf->b_term))
 emsg(dcgettext (((void*)0), (char *)("E948: Job still running (add ! to end the job)"), 5));
    else

 emsg(dcgettext (((void*)0), (char *)("E37: No write since last change (add ! to override)"), 5));
}

    void
no_write_message_nobang(buf_T *buf __attribute__((unused)))
{

    if (term_job_running(buf->b_term))
 emsg(dcgettext (((void*)0), (char *)("E948: Job still running"), 5));
    else

 emsg(dcgettext (((void*)0), (char *)("E37: No write since last change"), 5));
}
# 1922 "buffer.c"
    int
curbuf_reusable(void)
{
    return (curbuf != ((void*)0)
 && curbuf->b_ffname == ((void*)0)
 && curbuf->b_nwindows <= 1
 && (curbuf->b_ml.ml_mfp == ((void*)0) || (curbuf->b_ml.ml_line_count == 1 && *ml_get((linenr_T)1) == '\000'))

 && !bt_quickfix(curbuf)

 && !curbufIsChanged());
}
# 1948 "buffer.c"
    buf_T *
buflist_new(
    char_u *ffname_arg,
    char_u *sfname_arg,
    linenr_T lnum,
    int flags)
{
    char_u *ffname = ffname_arg;
    char_u *sfname = sfname_arg;
    buf_T *buf;

    stat_T st;


    if (top_file_num == 1)
 hash_init(&buf_hashtab);

    fname_expand(curbuf, &ffname, &sfname);







    if (sfname == ((void*)0) || stat(((char *)sfname), (&st)) < 0)
 st.st_dev = (dev_t)-1;

    if (ffname != ((void*)0) && !(flags & (4 | 8)) && (buf =

  buflist_findname_stat(ffname, &st)



  ) != ((void*)0))
    {
 vim_free(ffname);
 if (lnum != 0)
     buflist_setfpos(buf, (flags & 128) ? ((void*)0) : curwin,
            lnum, (colnr_T)0, 0);

 if ((flags & 16) == 0)


     buf_copy_options(buf, 0);

 if ((flags & 2) && !buf->b_p_bl)
 {
     bufref_T bufref;

     buf->b_p_bl = 1;
     set_bufref(&bufref, buf);
     if (!(flags & 4))
     {
  if (apply_autocmds(EVENT_BUFADD, ((void*)0), ((void*)0), 0, buf)
   && !bufref_valid(&bufref))
      return ((void*)0);
     }
 }
 return buf;
    }
# 2018 "buffer.c"
    buf = ((void*)0);
    if ((flags & 1) && curbuf_reusable())
    {
 buf = curbuf;


 if (curbuf->b_p_bl)
     apply_autocmds(EVENT_BUFDELETE, ((void*)0), ((void*)0), 0, curbuf);
 if (buf == curbuf)
     apply_autocmds(EVENT_BUFWIPEOUT, ((void*)0), ((void*)0), 0, curbuf);

 if (aborting())
 {
     vim_free(ffname);
     return ((void*)0);
 }

 if (buf == curbuf)
 {

     clear_string_option(&buf->b_p_bh);
     clear_string_option(&buf->b_p_bt);
 }
    }
    if (buf != curbuf || curbuf == ((void*)0))
    {
 buf = (buf_T *)alloc_clear(sizeof(buf_T));
 if (buf == ((void*)0))
 {
     vim_free(ffname);
     return ((void*)0);
 }


 buf->b_vars = dict_alloc();
 if (buf->b_vars == ((void*)0))
 {
     vim_free(ffname);
     vim_free(buf);
     return ((void*)0);
 }
 init_var_dict(buf->b_vars, &buf->b_bufvar, 1);

 init_changedtick(buf);
    }

    if (ffname != ((void*)0))
    {
 buf->b_ffname = ffname;
 buf->b_sfname = vim_strsave(sfname);
    }

    clear_wininfo(buf);
    buf->b_wininfo = (wininfo_T *)alloc_clear(sizeof(wininfo_T));

    if ((ffname != ((void*)0) && (buf->b_ffname == ((void*)0) || buf->b_sfname == ((void*)0)))
     || buf->b_wininfo == ((void*)0))
    {
 if (buf->b_sfname != buf->b_ffname)
     do { if ((buf->b_sfname) != ((void*)0)) { vim_free(buf->b_sfname); (buf->b_sfname) = ((void*)0); } } while (0);
 else
     buf->b_sfname = ((void*)0);
 do { if ((buf->b_ffname) != ((void*)0)) { vim_free(buf->b_ffname); (buf->b_ffname) = ((void*)0); } } while (0);
 if (buf != curbuf)
     free_buffer(buf);
 return ((void*)0);
    }

    if (buf == curbuf)
    {

 buf_freeall(buf, 0);
 if (buf != curbuf)
     return ((void*)0);

 if (aborting())
     return ((void*)0);

 free_buffer_stuff(buf, 0);


 buf->b_p_initialized = 0;
 buf_copy_options(buf, 1);



 curbuf->b_kmap_state |= 1;

    }
    else
    {



 buf->b_next = ((void*)0);
 if (firstbuf == ((void*)0))
 {
     buf->b_prev = ((void*)0);
     firstbuf = buf;
 }
 else
 {
     lastbuf->b_next = buf;
     buf->b_prev = lastbuf;
 }
 lastbuf = buf;

 if ((flags & 64) && buf_reuse.ga_len > 0)
 {



     --buf_reuse.ga_len;
     buf->b_fnum = ((int *)buf_reuse.ga_data)[buf_reuse.ga_len];


     while (buf->b_prev != ((void*)0) && buf->b_fnum < buf->b_prev->b_fnum)
     {
  buf_T *prev = buf->b_prev;

  prev->b_next = buf->b_next;
  if (prev->b_next != ((void*)0))
      prev->b_next->b_prev = prev;
  buf->b_next = prev;
  buf->b_prev = prev->b_prev;
  if (buf->b_prev != ((void*)0))
      buf->b_prev->b_next = buf;
  prev->b_prev = buf;
  if (lastbuf == buf)
      lastbuf = prev;
  if (firstbuf == prev)
      firstbuf = buf;
     }
 }
 else
     buf->b_fnum = top_file_num++;
 if (top_file_num < 0)
 {
     emsg(dcgettext (((void*)0), (char *)("W14: Warning: List of file names overflow"), 5));
     if (emsg_silent == 0 && !in_assert_fails)
     {
  out_flush();
  ui_delay(3001L, 1);
     }
     top_file_num = 1;
 }
 buf_hashtab_add(buf);




 buf_copy_options(buf, 2);
    }

    buf->b_wininfo->wi_fpos.lnum = lnum;
    buf->b_wininfo->wi_win = curwin;


    hash_init(&buf->b_s.b_keywtab);
    hash_init(&buf->b_s.b_keywtab_ic);


    buf->b_fname = buf->b_sfname;

    if (st.st_dev == (dev_t)-1)
 buf->b_dev_valid = 0;
    else
    {
 buf->b_dev_valid = 1;
 buf->b_dev = st.st_dev;
 buf->b_ino = st.st_ino;
    }

    buf->b_u_synced = 1;
    buf->b_flags = 0x02 | 0x04;
    if (flags & 4)
 buf->b_flags |= 0x80;
    buf_clear_file(buf);
    clrallmarks(buf);
    fmarks_check_names(buf);
    buf->b_p_bl = (flags & 2) ? 1 : 0;
    if (!(flags & 4))
    {
 bufref_T bufref;




 set_bufref(&bufref, buf);
 if (apply_autocmds(EVENT_BUFNEW, ((void*)0), ((void*)0), 0, buf)
  && !bufref_valid(&bufref))
     return ((void*)0);
 if (flags & 2)
 {
     if (apply_autocmds(EVENT_BUFADD, ((void*)0), ((void*)0), 0, buf)
      && !bufref_valid(&bufref))
  return ((void*)0);
 }

 if (aborting())
     return ((void*)0);

    }

    return buf;
}






    void
free_buf_options(
    buf_T *buf,
    int free_p_ff)
{
    if (free_p_ff)
    {
 clear_string_option(&buf->b_p_fenc);
 clear_string_option(&buf->b_p_ff);
 clear_string_option(&buf->b_p_bh);
 clear_string_option(&buf->b_p_bt);
    }

    clear_string_option(&buf->b_p_def);
    clear_string_option(&buf->b_p_inc);

    clear_string_option(&buf->b_p_inex);



    clear_string_option(&buf->b_p_inde);
    clear_string_option(&buf->b_p_indk);


    clear_string_option(&buf->b_p_bexpr);


    clear_string_option(&buf->b_p_cm);

    clear_string_option(&buf->b_p_fp);

    clear_string_option(&buf->b_p_fex);


    clear_string_option(&buf->b_p_key);

    clear_string_option(&buf->b_p_kp);
    clear_string_option(&buf->b_p_mps);
    clear_string_option(&buf->b_p_fo);
    clear_string_option(&buf->b_p_flp);
    clear_string_option(&buf->b_p_isk);

    clear_string_option(&buf->b_p_vsts);
    vim_free(buf->b_p_vsts_nopaste);
    buf->b_p_vsts_nopaste = ((void*)0);
    vim_free(buf->b_p_vsts_array);
    buf->b_p_vsts_array = ((void*)0);
    clear_string_option(&buf->b_p_vts);
    do { if ((buf->b_p_vts_array) != ((void*)0)) { vim_free(buf->b_p_vts_array); (buf->b_p_vts_array) = ((void*)0); } } while (0);


    clear_string_option(&buf->b_p_keymap);
    keymap_clear(&buf->b_kmap_ga);
    ga_clear(&buf->b_kmap_ga);

    clear_string_option(&buf->b_p_com);

    clear_string_option(&buf->b_p_cms);

    clear_string_option(&buf->b_p_nf);

    clear_string_option(&buf->b_p_syn);
    clear_string_option(&buf->b_s.b_syn_isk);


    clear_string_option(&buf->b_s.b_p_spc);
    clear_string_option(&buf->b_s.b_p_spf);
    vim_regfree(buf->b_s.b_cap_prog);
    buf->b_s.b_cap_prog = ((void*)0);
    clear_string_option(&buf->b_s.b_p_spl);
    clear_string_option(&buf->b_s.b_p_spo);


    clear_string_option(&buf->b_p_sua);

    clear_string_option(&buf->b_p_ft);

    clear_string_option(&buf->b_p_cink);
    clear_string_option(&buf->b_p_cino);


    clear_string_option(&buf->b_p_cinw);

    clear_string_option(&buf->b_p_cpt);

    clear_string_option(&buf->b_p_cfu);
    clear_string_option(&buf->b_p_ofu);


    clear_string_option(&buf->b_p_gp);
    clear_string_option(&buf->b_p_mp);
    clear_string_option(&buf->b_p_efm);

    clear_string_option(&buf->b_p_ep);
    clear_string_option(&buf->b_p_path);
    clear_string_option(&buf->b_p_tags);
    clear_string_option(&buf->b_p_tc);

    clear_string_option(&buf->b_p_tfu);

    clear_string_option(&buf->b_p_dict);
    clear_string_option(&buf->b_p_tsr);

    clear_string_option(&buf->b_p_qe);

    buf->b_p_ar = -1;
    buf->b_p_ul = -123456;

    clear_string_option(&buf->b_p_lw);

    clear_string_option(&buf->b_p_bkc);
    clear_string_option(&buf->b_p_menc);
}
# 2354 "buffer.c"
    int
buflist_getfile(
    int n,
    linenr_T lnum,
    int options,
    int forceit)
{
    buf_T *buf;
    win_T *wp = ((void*)0);
    pos_T *fpos;
    colnr_T col;

    buf = buflist_findnr(n);
    if (buf == ((void*)0))
    {
 if ((options & 0x02) && n == 0)
     emsg(dcgettext (((void*)0), (char *)(e_noalt), 5));
 else
     semsg(dcgettext (((void*)0), (char *)("E92: Buffer %d not found"), 5), n);
 return 0;
    }


    if (buf == curbuf)
 return 1;

    if (text_locked())
    {
 text_locked_msg();
 return 0;
    }
    if (curbuf_locked())
 return 0;


    if (lnum == 0)
    {
 fpos = buflist_findfpos(buf);
 lnum = fpos->lnum;
 col = fpos->col;
    }
    else
 col = 0;

    if (options & 0x04)
    {


 if (swb_flags & 0x001)
     wp = buf_jump_open_win(buf);



 if (wp == ((void*)0) && (swb_flags & 0x002))
     wp = buf_jump_open_tab(buf);



 if (wp == ((void*)0) && (swb_flags & (0x010 | 0x004 | 0x008))
              && !(curbuf->b_ml.ml_line_count == 1 && *ml_get((linenr_T)1) == '\000'))
 {
     if (swb_flags & 0x008)
  tabpage_new();
     else if (win_split(0, (swb_flags & 0x010) ? 2 : 0)
              == 0)
  return 0;
     do { (curwin)->w_onebuf_opt.wo_scb = 0; (curwin)->w_onebuf_opt.wo_crb = 0; } while (0);
 }
    }

    ++RedrawingDisabled;
    if (((getfile(buf->b_fnum, ((void*)0), ((void*)0), (options & 0x01), lnum, forceit)) <= 0))

    {
 --RedrawingDisabled;


 if (!p_sol && col != 0)
 {
     curwin->w_cursor.col = col;
     check_cursor_col();
     curwin->w_cursor.coladd = 0;
     curwin->w_set_curswant = 1;
 }
 return 1;
    }
    --RedrawingDisabled;
    return 0;
}




    static void
buflist_getfpos(void)
{
    pos_T *fpos;

    fpos = buflist_findfpos(curbuf);

    curwin->w_cursor.lnum = fpos->lnum;
    check_cursor_lnum();

    if (p_sol)
 curwin->w_cursor.col = 0;
    else
    {
 curwin->w_cursor.col = fpos->col;
 check_cursor_col();
 curwin->w_cursor.coladd = 0;
 curwin->w_set_curswant = 1;
    }
}






    buf_T *
buflist_findname_exp(char_u *fname)
{
    char_u *ffname;
    buf_T *buf = ((void*)0);


    ffname = FullName_save(fname,

     1



     );
    if (ffname != ((void*)0))
    {
 buf = buflist_findname(ffname);
 vim_free(ffname);
    }
    return buf;
}
# 2502 "buffer.c"
    buf_T *
buflist_findname(char_u *ffname)
{

    stat_T st;

    if (stat(((char *)ffname), (&st)) < 0)
 st.st_dev = (dev_t)-1;
    return buflist_findname_stat(ffname, &st);
}






    static buf_T *
buflist_findname_stat(
    char_u *ffname,
    stat_T *stp)
{

    buf_T *buf;


    for ((buf) = lastbuf; (buf) != ((void*)0); (buf) = (buf)->b_prev)
 if ((buf->b_flags & 0x80) == 0 && !otherfile_buf(buf, ffname

      , stp

      ))
     return buf;
    return ((void*)0);
}






    int
buflist_findpat(
    char_u *pattern,
    char_u *pattern_end,
    int unlisted,
    int diffmode __attribute__((unused)),
    int curtab_only)
{
    buf_T *buf;
    int match = -1;
    int find_listed;
    char_u *pat;
    char_u *patend;
    int attempt;
    char_u *p;
    int toggledollar;

    if (pattern_end == pattern + 1 && (*pattern == '%' || *pattern == '#'))
    {
 if (*pattern == '%')
     match = curbuf->b_fnum;
 else
     match = curwin->w_alt_fnum;

 if (diffmode && !diff_mode_buf(buflist_findnr(match)))
     match = -1;

    }
# 2580 "buffer.c"
    else
    {
 pat = file_pat_to_reg_pat(pattern, pattern_end, ((void*)0), 0);
 if (pat == ((void*)0))
     return -1;
 patend = pat + strlen((char *)(pat)) - 1;
 toggledollar = (patend > pat && *patend == '$');



 find_listed = 1;
 for (;;)
 {
     for (attempt = 0; attempt <= 3; ++attempt)
     {
  regmatch_T regmatch;


  if (toggledollar)
      *patend = (attempt < 2) ? '\000' : '$';
  p = pat;
  if (*p == '^' && !(attempt & 1))
      ++p;
  regmatch.regprog = vim_regcomp(p, p_magic ? 1 : 0);
  if (regmatch.regprog == ((void*)0))
  {
      vim_free(pat);
      return -1;
  }

  for ((buf) = lastbuf; (buf) != ((void*)0); (buf) = (buf)->b_prev)
      if (buf->b_p_bl == find_listed

       && (!diffmode || diff_mode_buf(buf))

       && buflist_match(&regmatch, buf, 0) != ((void*)0))
      {
   if (curtab_only)
   {


       win_T *wp;

       for (wp = firstwin; wp != ((void*)0); wp = wp->w_next)
    if (wp->w_buffer == buf)
        break;
       if (wp == ((void*)0))
    continue;
   }
   if (match >= 0)
   {
       match = -2;
       break;
   }
   match = buf->b_fnum;
      }

  vim_regfree(regmatch.regprog);
  if (match >= 0)
      break;
     }



     if (!unlisted || !find_listed || match != -1)
  break;
     find_listed = 0;
 }

 vim_free(pat);
    }

    if (match == -2)
 semsg(dcgettext (((void*)0), (char *)("E93: More than one match for %s"), 5), pattern);
    else if (match < 0)
 semsg(dcgettext (((void*)0), (char *)("E94: No matching buffer for %s"), 5), pattern);
    return match;
}


typedef struct {
    buf_T *buf;
    char_u *match;
} bufmatch_T;







    int
ExpandBufnames(
    char_u *pat,
    int *num_file,
    char_u ***file,
    int options)
{
    int count = 0;
    buf_T *buf;
    int round;
    char_u *p;
    int attempt;
    char_u *patc;

    bufmatch_T *matches = ((void*)0);


    *num_file = 0;
    *file = ((void*)0);


    if ((options & 0x2000) && !curwin->w_onebuf_opt.wo_diff)
 return 0;



    if (*pat == '^')
    {
 patc = alloc(strlen((char *)(pat)) + 11);
 if (patc == ((void*)0))
     return 0;
 strcpy((char *)(patc), (char *)("\\(^\\|[\\/]\\)"));
 strcpy((char *)(patc + 11), (char *)(pat + 1));
    }
    else
 patc = pat;





    for (attempt = 0; attempt <= 1; ++attempt)
    {
 regmatch_T regmatch;

 if (attempt > 0 && patc == pat)
     break;
 regmatch.regprog = vim_regcomp(patc + attempt * 11, 1);
 if (regmatch.regprog == ((void*)0))
 {
     if (patc != pat)
  vim_free(patc);
     return 0;
 }





 for (round = 1; round <= 2; ++round)
 {
     count = 0;
     for ((buf) = firstbuf; (buf) != ((void*)0); (buf) = (buf)->b_next)
     {
  if (!buf->b_p_bl)
      continue;

  if (options & 0x2000)


      if (buf == curbuf || !diff_mode_buf(buf))
   continue;


  p = buflist_match(&regmatch, buf, p_wic);
  if (p != ((void*)0))
  {
      if (round == 1)
   ++count;
      else
      {
   if (options & 0x02)
       p = home_replace_save(buf, p);
   else
       p = vim_strsave(p);

   if (matches != ((void*)0))
   {
       matches[count].buf = buf;
       matches[count].match = p;
       count++;
   }
   else

       (*file)[count++] = p;
      }
  }
     }
     if (count == 0)
  break;
     if (round == 1)
     {
  *file = (char_u * *)alloc(sizeof(char_u *) * (count));
  if (*file == ((void*)0))
  {
      vim_regfree(regmatch.regprog);
      if (patc != pat)
   vim_free(patc);
      return 0;
  }

  if (options & 0x1000)
      matches = (bufmatch_T *)alloc(sizeof(bufmatch_T) * (count));

     }
 }
 vim_regfree(regmatch.regprog);
 if (count)
     break;
    }

    if (patc != pat)
 vim_free(patc);


    if (matches != ((void*)0))
    {
 int i;
 if (count > 1)
     qsort(matches, count, sizeof(bufmatch_T), buf_compare);

 if (matches[0].buf == curbuf)
 {
     for (i = 1; i < count; i++)
  (*file)[i-1] = matches[i].match;
     (*file)[count-1] = matches[0].match;
 }
 else
 {
     for (i = 0; i < count; i++)
  (*file)[i] = matches[i].match;
 }
 vim_free(matches);
    }


    *num_file = count;
    return (count == 0 ? 0 : 1);
}




    static char_u *
buflist_match(
    regmatch_T *rmp,
    buf_T *buf,
    int ignore_case)
{
    char_u *match;


    match = fname_match(rmp, buf->b_sfname, ignore_case);
    if (match == ((void*)0))
 match = fname_match(rmp, buf->b_ffname, ignore_case);

    return match;
}





    static char_u *
fname_match(
    regmatch_T *rmp,
    char_u *name,
    int ignore_case)
{
    char_u *match = ((void*)0);
    char_u *p;

    if (name != ((void*)0))
    {

 rmp->rm_ic = p_fic || ignore_case;
 if (vim_regexec(rmp, name, (colnr_T)0))
     match = name;
 else
 {

     p = home_replace_save(((void*)0), name);
     if (p != ((void*)0) && vim_regexec(rmp, p, (colnr_T)0))
  match = name;
     vim_free(p);
 }
    }

    return match;
}




    buf_T *
buflist_findnr(int nr)
{
    char_u key[4 * 2 + 1];
    hashitem_T *hi;

    if (nr == 0)
 nr = curwin->w_alt_fnum;
    __builtin___sprintf_chk ((char *)key, 1 - 1, __builtin_object_size ((char *)key, 1 > 1), "%x", nr);
    hi = hash_find(&buf_hashtab, key);

    if (!((hi)->hi_key == ((void*)0) || (hi)->hi_key == &hash_removed))
 return (buf_T *)(hi->hi_key
        - ((unsigned)(curbuf->b_key - (char_u *)curbuf)));
    return ((void*)0);
}







    char_u *
buflist_nr2name(
    int n,
    int fullname,
    int helptail)
{
    buf_T *buf;

    buf = buflist_findnr(n);
    if (buf == ((void*)0))
 return ((void*)0);
    return home_replace_save(helptail ? buf : ((void*)0),
         fullname ? buf->b_ffname : buf->b_fname);
}






    void
buflist_setfpos(
    buf_T *buf,
    win_T *win,
    linenr_T lnum,
    colnr_T col,
    int copy_options)
{
    wininfo_T *wip;

    for ((wip) = (buf)->b_wininfo; (wip) != ((void*)0); (wip) = (wip)->wi_next)
 if (wip->wi_win == win)
     break;
    if (wip == ((void*)0))
    {

 wip = (wininfo_T *)alloc_clear(sizeof(wininfo_T));
 if (wip == ((void*)0))
     return;
 wip->wi_win = win;
 if (lnum == 0)
     lnum = 1;
    }
    else
    {

 if (wip->wi_prev)
     wip->wi_prev->wi_next = wip->wi_next;
 else
     buf->b_wininfo = wip->wi_next;
 if (wip->wi_next)
     wip->wi_next->wi_prev = wip->wi_prev;
 if (copy_options && wip->wi_optset)
 {
     clear_winopt(&wip->wi_opt);

     deleteFoldRecurse(&wip->wi_folds);

 }
    }
    if (lnum != 0)
    {
 wip->wi_fpos.lnum = lnum;
 wip->wi_fpos.col = col;
    }
    if (copy_options && win != ((void*)0))
    {

 copy_winopt(&win->w_onebuf_opt, &wip->wi_opt);

 wip->wi_fold_manual = win->w_fold_manual;
 cloneFoldGrowArray(&win->w_folds, &wip->wi_folds);

 wip->wi_optset = 1;
    }


    wip->wi_next = buf->b_wininfo;
    buf->b_wininfo = wip;
    wip->wi_prev = ((void*)0);
    if (wip->wi_next)
 wip->wi_next->wi_prev = wip;

    return;
}






    static int
wininfo_other_tab_diff(wininfo_T *wip)
{
    win_T *wp;

    if (wip->wi_opt.wo_diff)
    {
 for (wp = firstwin; wp != ((void*)0); wp = wp->w_next)


     if (wip->wi_win == wp)
  return 0;
 return 1;
    }
    return 0;
}
# 3015 "buffer.c"
    static wininfo_T *
find_wininfo(
    buf_T *buf,
    int need_options,
    int skip_diff_buffer __attribute__((unused)))
{
    wininfo_T *wip;

    for ((wip) = (buf)->b_wininfo; (wip) != ((void*)0); (wip) = (wip)->wi_next)
 if (wip->wi_win == curwin

  && (!skip_diff_buffer || !wininfo_other_tab_diff(wip))


  && (!need_options || wip->wi_optset))
     break;






    if (wip == ((void*)0))
    {

 if (skip_diff_buffer)
 {
     for ((wip) = (buf)->b_wininfo; (wip) != ((void*)0); (wip) = (wip)->wi_next)
  if (!wininfo_other_tab_diff(wip)
   && (!need_options || wip->wi_optset
       || (wip->wi_win != ((void*)0)
          && wip->wi_win->w_buffer == buf)))
      break;
 }
 else

     wip = buf->b_wininfo;
    }
    return wip;
}







    void
get_winopts(buf_T *buf)
{
    wininfo_T *wip;

    clear_winopt(&curwin->w_onebuf_opt);

    clearFolding(curwin);


    wip = find_wininfo(buf, 1, 1);
    if (wip != ((void*)0) && wip->wi_win != ((void*)0)
     && wip->wi_win != curwin && wip->wi_win->w_buffer == buf)
    {


 win_T *wp = wip->wi_win;

 copy_winopt(&wp->w_onebuf_opt, &curwin->w_onebuf_opt);

 curwin->w_fold_manual = wp->w_fold_manual;
 curwin->w_foldinvalid = 1;
 cloneFoldGrowArray(&wp->w_folds, &curwin->w_folds);

    }
    else if (wip != ((void*)0) && wip->wi_optset)
    {

 copy_winopt(&wip->wi_opt, &curwin->w_onebuf_opt);

 curwin->w_fold_manual = wip->wi_fold_manual;
 curwin->w_foldinvalid = 1;
 cloneFoldGrowArray(&wip->wi_folds, &curwin->w_folds);

    }
    else
 copy_winopt(&curwin->w_allbuf_opt, &curwin->w_onebuf_opt);



    if (p_fdls >= 0)
 curwin->w_onebuf_opt.wo_fdl = p_fdls;

    after_copy_winopt(curwin);
}






    pos_T *
buflist_findfpos(buf_T *buf)
{
    wininfo_T *wip;
    static pos_T no_position = {1, 0, 0};

    wip = find_wininfo(buf, 0, 0);
    if (wip != ((void*)0))
 return &(wip->wi_fpos);
    else
 return &no_position;
}




    linenr_T
buflist_findlnum(buf_T *buf)
{
    return buflist_findfpos(buf)->lnum;
}




    void
buflist_list(exarg_T *eap)
{
    buf_T *buf = firstbuf;
    int len;
    int i;
    int ro_char;
    int changed_char;

    int job_running;
    int job_none_open;



    garray_T buflist;
    buf_T **buflist_data = ((void*)0), **p;

    if (vim_strchr(eap->arg, 't'))
    {
 ga_init2(&buflist, sizeof(buf_T *), 50);
 for ((buf) = firstbuf; (buf) != ((void*)0); (buf) = (buf)->b_next)
 {
     if (ga_grow(&buflist, 1) == 1)
  ((buf_T **)buflist.ga_data)[buflist.ga_len++] = buf;
 }

 qsort(buflist.ga_data, (size_t)buflist.ga_len,
  sizeof(buf_T *), buf_compare);

 buflist_data = (buf_T **)buflist.ga_data;
 buf = *buflist_data;
    }
    p = buflist_data;

    for (; buf != ((void*)0) && !got_int; buf = buflist_data != ((void*)0)
     ? (++p < buflist_data + buflist.ga_len ? *p : ((void*)0))
     : buf->b_next)



    {

 job_running = term_job_running(buf->b_term);
 job_none_open = job_running && term_none_open(buf->b_term);


 if ((!buf->b_p_bl && !eap->forceit && !vim_strchr(eap->arg, 'u'))
  || (vim_strchr(eap->arg, 'u') && buf->b_p_bl)
  || (vim_strchr(eap->arg, '+')
   && ((buf->b_flags & 0x40) || !bufIsChanged(buf)))
  || (vim_strchr(eap->arg, 'a')
   && (buf->b_ml.ml_mfp == ((void*)0) || buf->b_nwindows == 0))
  || (vim_strchr(eap->arg, 'h')
   && (buf->b_ml.ml_mfp == ((void*)0) || buf->b_nwindows != 0))

  || (vim_strchr(eap->arg, 'R')
   && (!job_running || (job_running && job_none_open)))
  || (vim_strchr(eap->arg, '?')
   && (!job_running || (job_running && !job_none_open)))
  || (vim_strchr(eap->arg, 'F')
   && (job_running || buf->b_term == ((void*)0)))

  || (vim_strchr(eap->arg, '-') && buf->b_p_ma)
  || (vim_strchr(eap->arg, '=') && !buf->b_p_ro)
  || (vim_strchr(eap->arg, 'x') && !(buf->b_flags & 0x40))
  || (vim_strchr(eap->arg, '%') && buf != curbuf)
  || (vim_strchr(eap->arg, '#')
        && (buf == curbuf || curwin->w_alt_fnum != buf->b_fnum)))
     continue;
 if (buf_spname(buf) != ((void*)0))
     vim_strncpy(NameBuff, buf_spname(buf), 4096 - 1);
 else
     home_replace(buf, buf->b_fname, NameBuff, 4096, 1);
 if (message_filtered(NameBuff))
     continue;

 changed_char = (buf->b_flags & 0x40) ? 'x'
          : (bufIsChanged(buf) ? '+' : ' ');

 if (term_job_running(buf->b_term))
 {
     if (term_none_open(buf->b_term))
  ro_char = '?';
     else
  ro_char = 'R';
     changed_char = ' ';

 }
 else if (buf->b_term != ((void*)0))
     ro_char = 'F';
 else

     ro_char = !buf->b_p_ma ? '-' : (buf->b_p_ro ? '=' : ' ');

 msg_putchar('\n');
 len = vim_snprintf((char *)IObuff, (1024+1) - 20, "%3d%c%c%c%c%c \"%s\"",
  buf->b_fnum,
  buf->b_p_bl ? ' ' : 'u',
  buf == curbuf ? '%' :
   (curwin->w_alt_fnum == buf->b_fnum ? '#' : ' '),
  buf->b_ml.ml_mfp == ((void*)0) ? ' ' :
   (buf->b_nwindows == 0 ? 'h' : 'a'),
  ro_char,
  changed_char,
  NameBuff);
 if (len > (1024+1) - 20)
     len = (1024+1) - 20;


 i = 40 - vim_strsize(IObuff);
 do
     IObuff[len++] = ' ';
 while (--i > 0 && len < (1024+1) - 18);

 if (vim_strchr(eap->arg, 't') && buf->b_last_used)
     add_time(IObuff + len, (size_t)((1024+1) - len), buf->b_last_used);
 else

     vim_snprintf((char *)IObuff + len, (size_t)((1024+1) - len),
      dcgettext (((void*)0), (char *)("line %ld"), 5), buf == curbuf ? curwin->w_cursor.lnum
            : (long)buflist_findlnum(buf));
 msg_outtrans(IObuff);
 out_flush();
 ui_breakcheck();
    }


    if (buflist_data)
 ga_clear(&buflist);

}







    int
buflist_name_nr(
    int fnum,
    char_u **fname,
    linenr_T *lnum)
{
    buf_T *buf;

    buf = buflist_findnr(fnum);
    if (buf == ((void*)0) || buf->b_fname == ((void*)0))
 return 0;

    *fname = buf->b_fname;
    *lnum = buflist_findlnum(buf);

    return 1;
}
# 3301 "buffer.c"
    int
setfname(
    buf_T *buf,
    char_u *ffname_arg,
    char_u *sfname_arg,
    int message)
{
    char_u *ffname = ffname_arg;
    char_u *sfname = sfname_arg;
    buf_T *obuf = ((void*)0);

    stat_T st;


    if (ffname == ((void*)0) || *ffname == '\000')
    {

 if (buf->b_sfname != buf->b_ffname)
     do { if ((buf->b_sfname) != ((void*)0)) { vim_free(buf->b_sfname); (buf->b_sfname) = ((void*)0); } } while (0);
 else
     buf->b_sfname = ((void*)0);
 do { if ((buf->b_ffname) != ((void*)0)) { vim_free(buf->b_ffname); (buf->b_ffname) = ((void*)0); } } while (0);

 st.st_dev = (dev_t)-1;

    }
    else
    {
 fname_expand(buf, &ffname, &sfname);
 if (ffname == ((void*)0))
     return 0;







 if (stat(((char *)ffname), (&st)) < 0)
     st.st_dev = (dev_t)-1;

 if (!(buf->b_flags & 0x80))

     obuf = buflist_findname_stat(ffname, &st);



 if (obuf != ((void*)0) && obuf != buf)
 {
     if (obuf->b_ml.ml_mfp != ((void*)0))
     {
  if (message)
      emsg(dcgettext (((void*)0), (char *)("E95: Buffer with this name already exists"), 5));
  vim_free(ffname);
  return 0;
     }

     close_buffer(((void*)0), obuf, 4, 0, 0);
 }
 sfname = vim_strsave(sfname);
 if (ffname == ((void*)0) || sfname == ((void*)0))
 {
     vim_free(sfname);
     vim_free(ffname);
     return 0;
 }



 if (buf->b_sfname != buf->b_ffname)
     vim_free(buf->b_sfname);
 vim_free(buf->b_ffname);
 buf->b_ffname = ffname;
 buf->b_sfname = sfname;
    }
    buf->b_fname = buf->b_sfname;

    if (st.st_dev == (dev_t)-1)
 buf->b_dev_valid = 0;
    else
    {
 buf->b_dev_valid = 1;
 buf->b_dev = st.st_dev;
 buf->b_ino = st.st_ino;
    }


    buf->b_shortname = 0;

    buf_name_changed(buf);
    return 1;
}





    void
buf_set_name(int fnum, char_u *name)
{
    buf_T *buf;

    buf = buflist_findnr(fnum);
    if (buf != ((void*)0))
    {
 if (buf->b_sfname != buf->b_ffname)
     vim_free(buf->b_sfname);
 vim_free(buf->b_ffname);
 buf->b_ffname = vim_strsave(name);
 buf->b_sfname = ((void*)0);


 fname_expand(buf, &buf->b_ffname, &buf->b_sfname);
 buf->b_fname = buf->b_sfname;
    }
}





    void
buf_name_changed(buf_T *buf)
{



    if (buf->b_ml.ml_mfp != ((void*)0))
 ml_setname(buf);

    if (curwin->w_buffer == buf)
 check_arg_idx(curwin);

    maketitle();

    status_redraw_all();
    fmarks_check_names(buf);
    ml_timestamp(buf);
}







    buf_T *
setaltfname(
    char_u *ffname,
    char_u *sfname,
    linenr_T lnum)
{
    buf_T *buf;


    buf = buflist_new(ffname, sfname, lnum, 0);
    if (buf != ((void*)0) && (cmdmod.cmod_flags & 0x0100) == 0)
 curwin->w_alt_fnum = buf->b_fnum;
    return buf;
}





    char_u *
getaltfname(
    int errmsg)
{
    char_u *fname;
    linenr_T dummy;

    if (buflist_name_nr(0, &fname, &dummy) == 0)
    {
 if (errmsg)
     emsg(dcgettext (((void*)0), (char *)(e_noalt), 5));
 return ((void*)0);
    }
    return fname;
}







    int
buflist_add(char_u *fname, int flags)
{
    buf_T *buf;

    buf = buflist_new(fname, ((void*)0), (linenr_T)0, flags);
    if (buf != ((void*)0))
 return buf->b_fnum;
    return 0;
}
# 3522 "buffer.c"
    void
buflist_altfpos(win_T *win)
{
    buflist_setfpos(curbuf, win, win->w_cursor.lnum, win->w_cursor.col, 1);
}





    int
otherfile(char_u *ffname)
{
    return otherfile_buf(curbuf, ffname

     , ((void*)0)

     );
}

    static int
otherfile_buf(
    buf_T *buf,
    char_u *ffname

    , stat_T *stp

    )
{

    if (ffname == ((void*)0) || *ffname == '\000' || buf->b_ffname == ((void*)0))
 return 1;
    if (vim_fnamecmp((char_u *)(ffname), (char_u *)(buf->b_ffname)) == 0)
 return 0;

    {
 stat_T st;


 if (stp == ((void*)0))
 {
     if (!buf->b_dev_valid || stat(((char *)ffname), (&st)) < 0)
  st.st_dev = (dev_t)-1;
     stp = &st;
 }
# 3576 "buffer.c"
 if (buf_same_ino(buf, stp))
 {
     buf_setino(buf);
     if (buf_same_ino(buf, stp))
  return 0;
 }
    }

    return 1;
}






    void
buf_setino(buf_T *buf)
{
    stat_T st;

    if (buf->b_fname != ((void*)0) && stat(((char *)buf->b_fname), (&st)) >= 0)
    {
 buf->b_dev_valid = 1;
 buf->b_dev = st.st_dev;
 buf->b_ino = st.st_ino;
    }
    else
 buf->b_dev_valid = 0;
}




    static int
buf_same_ino(
    buf_T *buf,
    stat_T *stp)
{
    return (buf->b_dev_valid
     && stp->st_dev == buf->b_dev
     && stp->st_ino == buf->b_ino);
}





    void
fileinfo(
    int fullname,
    int shorthelp,
    int dont_truncate)
{
    char_u *name;
    int n;
    char *p;
    char *buffer;
    size_t len;

    buffer = alloc((1024+1));
    if (buffer == ((void*)0))
 return;

    if (fullname > 1)
    {
 vim_snprintf(buffer, (1024+1), "buf %d: ", curbuf->b_fnum);
 p = buffer + strlen((char *)(buffer));
    }
    else
 p = buffer;

    *p++ = '"';
    if (buf_spname(curbuf) != ((void*)0))
 vim_strncpy((char_u *)p, buf_spname(curbuf), (1024+1) - (p - buffer) - 1);
    else
    {
 if (!fullname && curbuf->b_fname != ((void*)0))
     name = curbuf->b_fname;
 else
     name = curbuf->b_ffname;
 home_replace(shorthelp ? curbuf : ((void*)0), name, (char_u *)p,
       (int)((1024+1) - (p - buffer)), 1);
    }

    vim_snprintf_add(buffer, (1024+1), "\"%s%s%s%s%s%s",
     curbufIsChanged() ? (shortmess('m')
       ? " [+]" : dcgettext (((void*)0), (char *)(" [Modified]"), 5)) : " ",
     (curbuf->b_flags & 0x08)

      && !bt_dontwrite(curbuf)

     ? dcgettext (((void*)0), (char *)("[Not edited]"), 5) : "",
     (curbuf->b_flags & 0x10)

      && !bt_dontwrite(curbuf)

        ? new_file_message() : "",
     (curbuf->b_flags & 0x40) ? dcgettext (((void*)0), (char *)("[Read errors]"), 5) : "",
     curbuf->b_p_ro ? (shortmess('r') ? dcgettext (((void*)0), (char *)("[RO]"), 5)
            : dcgettext (((void*)0), (char *)("[readonly]"), 5)) : "",
     (curbufIsChanged() || (curbuf->b_flags & (0x08 + 0x10 + 0x40))
         || curbuf->b_p_ro) ?
            " " : "");


    if (curwin->w_cursor.lnum > 1000000L)
 n = (int)(((long)curwin->w_cursor.lnum) /
       ((long)curbuf->b_ml.ml_line_count / 100L));
    else
 n = (int)(((long)curwin->w_cursor.lnum * 100L) /
         (long)curbuf->b_ml.ml_line_count);
    if (curbuf->b_ml.ml_flags & 1)
 vim_snprintf_add(buffer, (1024+1), "%s", dcgettext (((void*)0), (char *)(no_lines_msg), 5));

    else if (p_ru)

 vim_snprintf_add(buffer, (1024+1),
  dcngettext (((void*)0), ("%ld line --%d%%--"), ("%ld lines --%d%%--"), (curbuf->b_ml.ml_line_count), 5),

  (long)curbuf->b_ml.ml_line_count, n);

    else
    {
 vim_snprintf_add(buffer, (1024+1),
  dcgettext (((void*)0), (char *)("line %ld of %ld --%d%%-- col "), 5),
  (long)curwin->w_cursor.lnum,
  (long)curbuf->b_ml.ml_line_count,
  n);
 validate_virtcol();
 len = strlen((char *)(buffer));
 col_print((char_u *)buffer + len, (1024+1) - len,
     (int)curwin->w_cursor.col + 1, (int)curwin->w_virtcol + 1);
    }

    (void)append_arg_number(curwin, (char_u *)buffer, (1024+1),
        !shortmess('f'));

    if (dont_truncate)
    {


 msg_start();
 n = msg_scroll;
 msg_scroll = 1;
 msg(buffer);
 msg_scroll = n;
    }
    else
    {
 p = (char *)msg_trunc_attr(buffer, 0, 0);
 if (restart_edit != 0 || (msg_scrolled && !need_wait_return))





     set_keep_msg((char_u *)p, 0);
    }

    vim_free(buffer);
}

    void
col_print(
    char_u *buf,
    size_t buflen,
    int col,
    int vcol)
{
    if (col == vcol)
 vim_snprintf((char *)buf, buflen, "%d", col);
    else
 vim_snprintf((char *)buf, buflen, "%d-%d", col, vcol);
}


static char_u *lasttitle = ((void*)0);
static char_u *lasticon = ((void*)0);




    void
maketitle(void)
{
    char_u *p;
    char_u *title_str = ((void*)0);
    char_u *icon_str = ((void*)0);
    int maxlen = 0;
    int len;
    int mustset;
    char_u buf[(1024+1)];
    int off;

    if (!redrawing())
    {

 need_maketitle = 1;
 return;
    }

    need_maketitle = 0;
    if (!p_title && !p_icon && lasttitle == ((void*)0) && lasticon == ((void*)0))
 return;

    if (p_title)
    {
 if (p_titlelen > 0)
 {
     maxlen = p_titlelen * Columns / 100;
     if (maxlen < 10)
  maxlen = 10;
 }

 title_str = buf;
 if (*p_titlestring != '\000')
 {

     if (stl_syntax & 2)
     {
  int use_sandbox = 0;
  int called_emsg_before = called_emsg;


  use_sandbox = was_set_insecurely((char_u *)"titlestring", 0);

  build_stl_str_hl(curwin, title_str, sizeof(buf),
           p_titlestring, use_sandbox,
           0, maxlen, ((void*)0), ((void*)0));
  if (called_emsg > called_emsg_before)
      set_string_option_direct((char_u *)"titlestring", -1,
        (char_u *)"", 0x01, -5);
     }
     else

  title_str = p_titlestring;
 }
 else
 {





     if (curbuf->b_fname == ((void*)0))
  vim_strncpy(buf, (char_u *)dcgettext (((void*)0), (char *)("[No Name]"), 5), ((1024+1) - 100));

     else if (curbuf->b_term != ((void*)0))
     {
  vim_strncpy(buf, term_get_status_text(curbuf->b_term),
             ((1024+1) - 100));
     }

     else
     {
  p = transstr(gettail(curbuf->b_fname));
  vim_strncpy(buf, p, ((1024+1) - 100));
  vim_free(p);
     }


     if (curbuf->b_term == ((void*)0))

  switch (bufIsChanged(curbuf)
   + (curbuf->b_p_ro * 2)
   + (!curbuf->b_p_ma * 4))
  {
      case 1: strcat((char *)(buf), (char *)(" +")); break;
      case 2: strcat((char *)(buf), (char *)(" =")); break;
      case 3: strcat((char *)(buf), (char *)(" =+")); break;
      case 4:
      case 6: strcat((char *)(buf), (char *)(" -")); break;
      case 5:
      case 7: strcat((char *)(buf), (char *)(" -+")); break;
  }

     if (curbuf->b_fname != ((void*)0)

      && curbuf->b_term == ((void*)0)

      )
     {

  off = (int)strlen((char *)(buf));
  buf[off++] = ' ';
  buf[off++] = '(';
  home_replace(curbuf, curbuf->b_ffname,
     buf + off, ((1024+1) - 20) - off, 1);






  p = gettail_sep(buf + off);
  if (p == buf + off)
  {

      vim_strncpy(buf + off, (char_u *)dcgettext (((void*)0), (char *)("help"), 5),
        (size_t)(((1024+1) - 20) - off - 1));
  }
  else
      *p = '\000';




  if (off < ((1024+1) - 20))
  {
      p = transstr(buf + off);
      vim_strncpy(buf + off, p, (size_t)(((1024+1) - 20) - off));
      vim_free(p);
  }
  else
  {
      vim_strncpy(buf + off, (char_u *)"...",
          (size_t)(((1024+1) - 10) - off));
  }
  strcat((char *)(buf), (char *)(")"));
     }

     append_arg_number(curwin, buf, ((1024+1) - 10), 0);


     if (serverName != ((void*)0))
     {
  strcat((char *)(buf), (char *)(" - "));
  vim_strcat(buf, serverName, (1024+1));
     }
     else

  strcat((char *)(buf), (char *)(" - VIM"));

     if (maxlen > 0)
     {

  if (vim_strsize(buf) > maxlen)
      trunc_string(buf, buf, maxlen, (1024+1));
     }
 }
    }
    mustset = value_changed(title_str, &lasttitle);

    if (p_icon)
    {
 icon_str = buf;
 if (*p_iconstring != '\000')
 {

     if (stl_syntax & 1)
     {
  int use_sandbox = 0;
  int called_emsg_before = called_emsg;


  use_sandbox = was_set_insecurely((char_u *)"iconstring", 0);

  build_stl_str_hl(curwin, icon_str, sizeof(buf),
          p_iconstring, use_sandbox,
          0, 0, ((void*)0), ((void*)0));
  if (called_emsg > called_emsg_before)
      set_string_option_direct((char_u *)"iconstring", -1,
        (char_u *)"", 0x01, -5);
     }
     else

  icon_str = p_iconstring;
 }
 else
 {
     if (buf_spname(curbuf) != ((void*)0))
  p = buf_spname(curbuf);
     else
  p = gettail(curbuf->b_ffname);
     *icon_str = '\000';

     len = (int)strlen((char *)(p));
     if (len > 100)
     {
  len -= 100;
  if (has_mbyte)
      len += (*mb_tail_off)(p, p + len) + 1;
  p += len;
     }
     strcpy((char *)(icon_str), (char *)(p));
     trans_characters(icon_str, (1024+1));
 }
    }

    mustset |= value_changed(icon_str, &lasticon);

    if (mustset)
 resettitle();
}






    static int
value_changed(char_u *str, char_u **last)
{
    if ((str == ((void*)0)) != (*last == ((void*)0))
     || (str != ((void*)0) && *last != ((void*)0) && strcmp((char *)(str), (char *)(*last)) != 0))
    {
 vim_free(*last);
 if (str == ((void*)0))
 {
     *last = ((void*)0);
     mch_restore_title(
    last == &lasttitle ? 1 : 2);
 }
 else
 {
     *last = vim_strsave(str);
     return 1;
 }
    }
    return 0;
}




    void
resettitle(void)
{
    mch_settitle(lasttitle, lasticon);
}
# 4024 "buffer.c"
typedef struct
{
    char_u *stl_start;
    int stl_minwid;
    int stl_maxwid;
    enum {
 Normal,
 Empty,
 Group,
 Middle,
 Highlight,
 TabPage,
 Trunc
    } stl_type;
} stl_item_T;

static size_t stl_items_len = 20;
static stl_item_T *stl_items = ((void*)0);
static int *stl_groupitem = ((void*)0);
static stl_hlrec_T *stl_hltab = ((void*)0);
static stl_hlrec_T *stl_tabtab = ((void*)0);
# 4060 "buffer.c"
    int
build_stl_str_hl(
    win_T *wp,
    char_u *out,
    size_t outlen,
    char_u *fmt,
    int use_sandbox __attribute__((unused)),
    int fillchar,
    int maxwidth,
    stl_hlrec_T **hltab,
    stl_hlrec_T **tabtab)
{
    linenr_T lnum;
    size_t len;
    char_u *p;
    char_u *s;
    char_u *t;
    int byteval;

    win_T *save_curwin;
    buf_T *save_curbuf;
    int save_VIsual_active;

    int empty_line;
    colnr_T virtcol;
    long l;
    long n;
    int prevchar_isflag;
    int prevchar_isitem;
    int itemisflag;
    int fillable;
    char_u *str;
    long num;
    int width;
    int itemcnt;
    int curitem;
    int group_end_userhl;
    int group_start_userhl;
    int groupdepth;
    int minwid;
    int maxwid;
    int zeropad;
    char_u base;
    char_u opt;

    char_u buf_tmp[70];
    char_u win_tmp[70];
    char_u *usefmt = fmt;
    stl_hlrec_T *sp;
    int save_must_redraw = must_redraw;
    int save_redr_type = curwin->w_redr_type;

    if (stl_items == ((void*)0))
    {
 stl_items = (stl_item_T *)alloc(sizeof(stl_item_T) * (stl_items_len));
 stl_groupitem = (int *)alloc(sizeof(int) * (stl_items_len));
 stl_hltab = (stl_hlrec_T *)alloc(sizeof(stl_hlrec_T) * (stl_items_len));
 stl_tabtab = (stl_hlrec_T *)alloc(sizeof(stl_hlrec_T) * (stl_items_len));
    }






    if (fmt[0] == '%' && fmt[1] == '!')
    {
 typval_T tv;

 tv.v_type = VAR_NUMBER;
 tv.vval.v_number = wp->w_id;
 set_var((char_u *)"g:statusline_winid", &tv, 0);

 usefmt = eval_to_string_safe(fmt + 2, use_sandbox);
 if (usefmt == ((void*)0))
     usefmt = fmt;

 do_unlet((char_u *)"g:statusline_winid", 1);
    }


    if (fillchar == 0)
 fillchar = ' ';

    else if (mb_char2len(fillchar) > 1)
 fillchar = '-';



    lnum = wp->w_cursor.lnum;
    if (lnum > wp->w_buffer->b_ml.ml_line_count)
    {
 lnum = wp->w_buffer->b_ml.ml_line_count;
 wp->w_cursor.lnum = lnum;
    }



    p = ml_get_buf(wp->w_buffer, lnum, 0);
    empty_line = (*p == '\000');



    len = strlen((char *)(p));
    if (wp->w_cursor.col > (colnr_T)len)
    {


 wp->w_cursor.col = (colnr_T)len;
 wp->w_cursor.coladd = 0;
 byteval = 0;
    }
    else
 byteval = (*mb_ptr2char)(p + wp->w_cursor.col);

    groupdepth = 0;
    p = out;
    curitem = 0;
    prevchar_isflag = 1;
    prevchar_isitem = 0;
    for (s = usefmt; *s; )
    {
 if (curitem == (int)stl_items_len)
 {
     size_t new_len = stl_items_len * 3 / 2;
     stl_item_T *new_items;
     int *new_groupitem;
     stl_hlrec_T *new_hlrec;

     new_items = realloc((stl_items), (sizeof(stl_item_T) * new_len));
     if (new_items == ((void*)0))
  break;
     stl_items = new_items;
     new_groupitem = realloc((stl_groupitem), (sizeof(int) * new_len));
     if (new_groupitem == ((void*)0))
  break;
     stl_groupitem = new_groupitem;
     new_hlrec = realloc((stl_hltab), (sizeof(stl_hlrec_T) * new_len));
     if (new_hlrec == ((void*)0))
  break;
     stl_hltab = new_hlrec;
     new_hlrec = realloc((stl_tabtab), (sizeof(stl_hlrec_T) * new_len));
     if (new_hlrec == ((void*)0))
  break;
     stl_tabtab = new_hlrec;
     stl_items_len = new_len;
 }

 if (*s != '\000' && *s != '%')
     prevchar_isflag = prevchar_isitem = 0;




 while (*s != '\000' && *s != '%' && p + 1 < out + outlen)
     *p++ = *s++;
 if (*s == '\000' || p + 1 >= out + outlen)
     break;




 s++;
 if (*s == '\000')
     break;
 if (*s == '%')
 {
     if (p + 1 >= out + outlen)
  break;
     *p++ = *s++;
     prevchar_isflag = prevchar_isitem = 0;
     continue;
 }
 if (*s == '=')
 {
     s++;
     if (groupdepth > 0)
  continue;
     stl_items[curitem].stl_type = Middle;
     stl_items[curitem++].stl_start = p;
     continue;
 }
 if (*s == '<')
 {
     s++;
     stl_items[curitem].stl_type = Trunc;
     stl_items[curitem++].stl_start = p;
     continue;
 }
 if (*s == ')')
 {
     s++;
     if (groupdepth < 1)
  continue;
     groupdepth--;

     t = stl_items[stl_groupitem[groupdepth]].stl_start;
     *p = '\000';
     l = vim_strsize(t);
     if (curitem > stl_groupitem[groupdepth] + 1
      && stl_items[stl_groupitem[groupdepth]].stl_minwid == 0)
     {


  group_start_userhl = group_end_userhl = 0;
  for (n = stl_groupitem[groupdepth] - 1; n >= 0; n--)
  {
      if (stl_items[n].stl_type == Highlight)
      {
   group_start_userhl = group_end_userhl =
             stl_items[n].stl_minwid;
   break;
      }
  }
  for (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)
  {
      if (stl_items[n].stl_type == Normal)
   break;
      if (stl_items[n].stl_type == Highlight)
   group_end_userhl = stl_items[n].stl_minwid;
  }
  if (n == curitem && group_start_userhl == group_end_userhl)
  {

      p = t;
      l = 0;
      for (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)
      {

   if (stl_items[n].stl_type == Highlight)
       stl_items[n].stl_type = Empty;


   if (stl_items[n].stl_type == TabPage)
       stl_items[n].stl_start = p;
      }
  }
     }
     if (l > stl_items[stl_groupitem[groupdepth]].stl_maxwid)
     {

  if (has_mbyte)
  {

      n = 0;
      while (l >= stl_items[stl_groupitem[groupdepth]].stl_maxwid)
      {
   l -= ptr2cells(t + n);
   n += (*mb_ptr2len)(t + n);
      }
  }
  else
      n = (long)(p - t) - stl_items[stl_groupitem[groupdepth]]
              .stl_maxwid + 1;

  *t = '<';
  memmove((char *)(t + 1), (char *)(t + n), (size_t)(p - (t + n)));
  p = p - n + 1;


  while (++l < stl_items[stl_groupitem[groupdepth]].stl_minwid)
      *p++ = fillchar;


  for (l = stl_groupitem[groupdepth] + 1; l < curitem; l++)
  {
      stl_items[l].stl_start -= n;
      if (stl_items[l].stl_start < t)
   stl_items[l].stl_start = t;
  }
     }
     else if (abs(stl_items[stl_groupitem[groupdepth]].stl_minwid) > l)
     {

  n = stl_items[stl_groupitem[groupdepth]].stl_minwid;
  if (n < 0)
  {

      n = 0 - n;
      while (l++ < n && p + 1 < out + outlen)
   *p++ = fillchar;
  }
  else
  {

      memmove((char *)(t + n - l), (char *)(t), (size_t)(p - t));
      l = n - l;
      if (p + l >= out + outlen)
   l = (long)((out + outlen) - p - 1);
      p += l;
      for (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)
   stl_items[n].stl_start += l;
      for ( ; l > 0; l--)
   *t++ = fillchar;
  }
     }
     continue;
 }
 minwid = 0;
 maxwid = 9999;
 zeropad = 0;
 l = 1;
 if (*s == '0')
 {
     s++;
     zeropad = 1;
 }
 if (*s == '-')
 {
     s++;
     l = -1;
 }
 if (((unsigned)(*s) - '0' < 10))
 {
     minwid = (int)getdigits(&s);
     if (minwid < 0)
  minwid = 0;
 }
 if (*s == '*')
 {
     stl_items[curitem].stl_type = Highlight;
     stl_items[curitem].stl_start = p;
     stl_items[curitem].stl_minwid = minwid > 9 ? 1 : minwid;
     s++;
     curitem++;
     continue;
 }
 if (*s == 'T' || *s == 'X')
 {
     if (*s == 'X')
     {
  if (minwid == 0)
  {


      for (n = curitem - 1; n >= 0; --n)
   if (stl_items[n].stl_type == TabPage
            && stl_items[n].stl_minwid >= 0)
   {
       minwid = stl_items[n].stl_minwid;
       break;
   }
  }
  else

      minwid = - minwid;
     }
     stl_items[curitem].stl_type = TabPage;
     stl_items[curitem].stl_start = p;
     stl_items[curitem].stl_minwid = minwid;
     s++;
     curitem++;
     continue;
 }
 if (*s == '.')
 {
     s++;
     if (((unsigned)(*s) - '0' < 10))
     {
  maxwid = (int)getdigits(&s);
  if (maxwid <= 0)
      maxwid = 50;
     }
 }
 minwid = (minwid > 50 ? 50 : minwid) * l;
 if (*s == '(')
 {
     stl_groupitem[groupdepth++] = curitem;
     stl_items[curitem].stl_type = Group;
     stl_items[curitem].stl_start = p;
     stl_items[curitem].stl_minwid = minwid;
     stl_items[curitem].stl_maxwid = maxwid;
     s++;
     curitem++;
     continue;
 }
 if (vim_strchr(((char_u *) "fFtcvVlLknoObBrRhHmYyWwMqpPaN{#"), *s) == ((void*)0))
 {
     s++;
     continue;
 }
 opt = *s++;


 base = 'D';
 itemisflag = 0;
 fillable = 1;
 num = -1;
 str = ((void*)0);
 switch (opt)
 {
 case 'f':
 case 'F':
 case 't':
     fillable = 0;
     if (buf_spname(wp->w_buffer) != ((void*)0))
  vim_strncpy(NameBuff, buf_spname(wp->w_buffer), 4096 - 1);
     else
     {
  t = (opt == 'F') ? wp->w_buffer->b_ffname
       : wp->w_buffer->b_fname;
  home_replace(wp->w_buffer, t, NameBuff, 4096, 1);
     }
     trans_characters(NameBuff, 4096);
     if (opt != 't')
  str = NameBuff;
     else
  str = gettail(NameBuff);
     break;

 case '{':
     itemisflag = 1;
     t = p;
     while (*s != '}' && *s != '\000' && p + 1 < out + outlen)
  *p++ = *s++;
     if (*s != '}')
  break;
     s++;
     *p = 0;
     p = t;


     vim_snprintf((char *)buf_tmp, sizeof(buf_tmp),
        "%d", curbuf->b_fnum);
     set_internal_string_var((char_u *)"g:actual_curbuf", buf_tmp);
     vim_snprintf((char *)win_tmp, sizeof(win_tmp), "%d", curwin->w_id);
     set_internal_string_var((char_u *)"g:actual_curwin", win_tmp);

     save_curbuf = curbuf;
     save_curwin = curwin;
     save_VIsual_active = VIsual_active;
     curwin = wp;
     curbuf = wp->w_buffer;

     if (curwin != save_curwin)
  VIsual_active = 0;

     str = eval_to_string_safe(p, use_sandbox);

     curwin = save_curwin;
     curbuf = save_curbuf;
     VIsual_active = save_VIsual_active;
     do_unlet((char_u *)"g:actual_curbuf", 1);
     do_unlet((char_u *)"g:actual_curwin", 1);

     if (str != ((void*)0) && *str != 0)
     {
  if (*skipdigits(str) == '\000')
  {
      num = atoi((char *)str);
      do { if ((str) != ((void*)0)) { vim_free(str); (str) = ((void*)0); } } while (0);
      itemisflag = 0;
  }
     }

     break;

 case 'l':
     num = (wp->w_buffer->b_ml.ml_flags & 1)
    ? 0L : (long)(wp->w_cursor.lnum);
     break;

 case 'L':
     num = wp->w_buffer->b_ml.ml_line_count;
     break;

 case 'c':
     num = !(State & 0x10) && empty_line
    ? 0 : (int)wp->w_cursor.col + 1;
     break;

 case 'v':
 case 'V':

     virtcol = wp->w_virtcol;
     if (wp->w_onebuf_opt.wo_list && lcs_tab1 == '\000')
     {
  wp->w_onebuf_opt.wo_list = 0;
  getvcol(wp, &wp->w_cursor, ((void*)0), &virtcol, ((void*)0));
  wp->w_onebuf_opt.wo_list = 1;
     }
     ++virtcol;

     if (opt == 'V'
      && (virtcol == (colnr_T)(!(State & 0x10) && empty_line
       ? 0 : (int)wp->w_cursor.col + 1)))
  break;
     num = (long)virtcol;
     break;

 case 'p':
     num = (int)(((long)wp->w_cursor.lnum * 100L) /
   (long)wp->w_buffer->b_ml.ml_line_count);
     break;

 case 'P':
     str = buf_tmp;
     get_rel_pos(wp, str, 70);
     break;

 case 'a':
     fillable = 0;
     buf_tmp[0] = 0;
     if (append_arg_number(wp, buf_tmp, (int)sizeof(buf_tmp), 0))
  str = buf_tmp;
     break;

 case 'k':
     fillable = 0;
     if (get_keymap_str(wp, (char_u *)"<%s>", buf_tmp, 70))
  str = buf_tmp;
     break;
 case 'N':

     num = printer_page_num;



     break;

 case 'n':
     num = wp->w_buffer->b_fnum;
     break;

 case 'O':
     base = 'X';

 case 'o':

     l = ml_find_line_or_offset(wp->w_buffer, wp->w_cursor.lnum, ((void*)0));
     num = (wp->w_buffer->b_ml.ml_flags & 1) || l < 0 ?
    0L : l + 1 + (!(State & 0x10) && empty_line ?
    0 : (int)wp->w_cursor.col);

     break;

 case 'B':
     base = 'X';

 case 'b':
     num = byteval;
     if (num == '\012')
  num = 0;
     else if (num == '\015' && get_fileformat(wp->w_buffer) == 2)
  num = '\012';
     break;

 case 'r':
 case 'R':
     itemisflag = 1;
     if (wp->w_buffer->b_p_ro)
  str = (char_u *)((opt == 'R') ? ",RO" : dcgettext (((void*)0), (char *)("[RO]"), 5));
     break;

 case 'h':
 case 'H':
     itemisflag = 1;
     if (wp->w_buffer->b_help)
  str = (char_u *)((opt == 'H') ? ",HLP"
              : dcgettext (((void*)0), (char *)("[Help]"), 5));
     break;

 case 'y':
     if (*wp->w_buffer->b_p_ft != '\000'
      && strlen((char *)(wp->w_buffer->b_p_ft)) < 70 - 3)
     {
  vim_snprintf((char *)buf_tmp, sizeof(buf_tmp), "[%s]",
       wp->w_buffer->b_p_ft);
  str = buf_tmp;
     }
     break;

 case 'Y':
     itemisflag = 1;
     if (*wp->w_buffer->b_p_ft != '\000'
      && strlen((char *)(wp->w_buffer->b_p_ft)) < 70 - 2)
     {
  vim_snprintf((char *)buf_tmp, sizeof(buf_tmp), ",%s",
       wp->w_buffer->b_p_ft);
  for (t = buf_tmp; *t != 0; t++)
      *t = (__extension__ ({ int __res; if (sizeof (*t) > 1) { if (__builtin_constant_p (*t)) { int __c = (*t); __res = __c < -128 || __c > 255 ? __c : (*__ctype_toupper_loc ())[__c]; } else __res = toupper (*t); } else __res = (*__ctype_toupper_loc ())[(int) (*t)]; __res; }));
  str = buf_tmp;
     }
     break;


 case 'w':
 case 'W':
     itemisflag = 1;
     if (wp->w_onebuf_opt.wo_pvw)
  str = (char_u *)((opt == 'W') ? ",PRV"
           : dcgettext (((void*)0), (char *)("[Preview]"), 5));
     break;

 case 'q':
     if (bt_quickfix(wp->w_buffer))
  str = (char_u *)(wp->w_llist_ref
       ? dcgettext (((void*)0), (char *)(msg_loclist), 5)
       : dcgettext (((void*)0), (char *)(msg_qflist), 5));
     break;


 case 'm':
 case 'M':
     itemisflag = 1;
     switch ((opt == 'M')
      + bufIsChanged(wp->w_buffer) * 2
      + (!wp->w_buffer->b_p_ma) * 4)
     {
  case 2: str = (char_u *)"[+]"; break;
  case 3: str = (char_u *)",+"; break;
  case 4: str = (char_u *)"[-]"; break;
  case 5: str = (char_u *)",-"; break;
  case 6: str = (char_u *)"[+-]"; break;
  case 7: str = (char_u *)",+-"; break;
     }
     break;

 case '#':
     t = s;
     while (*s != '#' && *s != '\000')
  ++s;
     if (*s == '#')
     {
  stl_items[curitem].stl_type = Highlight;
  stl_items[curitem].stl_start = p;
  stl_items[curitem].stl_minwid = -syn_namen2id(t, (int)(s - t));
  curitem++;
     }
     if (*s != '\000')
  ++s;
     continue;
 }

 stl_items[curitem].stl_start = p;
 stl_items[curitem].stl_type = Normal;
 if (str != ((void*)0) && *str)
 {
     t = str;
     if (itemisflag)
     {
  if ((t[0] && t[1])
   && ((!prevchar_isitem && *t == ',')
         || (prevchar_isflag && *t == ' ')))
      t++;
  prevchar_isflag = 1;
     }
     l = vim_strsize(t);
     if (l > 0)
  prevchar_isitem = 1;
     if (l > maxwid)
     {
  while (l >= maxwid)
      if (has_mbyte)
      {
   l -= ptr2cells(t);
   t += (*mb_ptr2len)(t);
      }
      else
   l -= byte2cells(*t++);
  if (p + 1 >= out + outlen)
      break;
  *p++ = '<';
     }
     if (minwid > 0)
     {
  for (; l < minwid && p + 1 < out + outlen; l++)
  {

      if (l + 1 == minwid && fillchar == '-' && ((unsigned)(*t) - '0' < 10))
   *p++ = ' ';
      else
   *p++ = fillchar;
  }
  minwid = 0;
     }
     else
  minwid *= -1;
     while (*t && p + 1 < out + outlen)
     {
  *p++ = *t++;


  if (fillable && p[-1] == ' '
         && (!((unsigned)(*t) - '0' < 10) || fillchar != '-'))
      p[-1] = fillchar;
     }
     for (; l < minwid && p + 1 < out + outlen; l++)
  *p++ = fillchar;
 }
 else if (num >= 0)
 {
     int nbase = (base == 'D' ? 10 : (base == 'O' ? 8 : 16));
     char_u nstr[20];

     if (p + 20 >= out + outlen)
  break;
     prevchar_isitem = 1;
     t = nstr;
     if (opt == 'V')
     {
  *t++ = '-';
  minwid--;
     }
     *t++ = '%';
     if (zeropad)
  *t++ = '0';
     *t++ = '*';
     *t++ = nbase == 16 ? base : (char_u)(nbase == 8 ? 'o' : 'd');
     *t = 0;

     for (n = num, l = 1; n >= nbase; n /= nbase)
  l++;
     if (opt == 'V')
  l++;
     if (l > maxwid)
     {
  l += 2;
  n = l - maxwid;
  while (l-- > maxwid)
      num /= nbase;
  *t++ = '>';
  *t++ = '%';
  *t = t[-3];
  *++t = 0;
  vim_snprintf((char *)p, outlen - (p - out), (char *)nstr,
           0, num, n);
     }
     else
  vim_snprintf((char *)p, outlen - (p - out), (char *)nstr,
         minwid, num);
     p += strlen((char *)(p));
 }
 else
     stl_items[curitem].stl_type = Empty;

 if (opt == '{')
     vim_free(str);

 if (num >= 0 || (!itemisflag && str && *str))
     prevchar_isflag = 0;
 curitem++;
    }
    *p = '\000';
    itemcnt = curitem;


    if (usefmt != fmt)
 vim_free(usefmt);


    width = vim_strsize(out);
    if (maxwidth > 0 && width > maxwidth)
    {

 l = 0;
 if (itemcnt == 0)
     s = out;
 else
 {
     for ( ; l < itemcnt; l++)
  if (stl_items[l].stl_type == Trunc)
  {

      s = stl_items[l].stl_start;
      break;
  }
     if (l == itemcnt)
     {

  s = stl_items[0].stl_start;
  l = 0;
     }
 }

 if (width - vim_strsize(s) >= maxwidth)
 {

     if (has_mbyte)
     {
  s = out;
  width = 0;
  for (;;)
  {
      width += ptr2cells(s);
      if (width >= maxwidth)
   break;
      s += (*mb_ptr2len)(s);
  }

  while (++width < maxwidth)
      *s++ = fillchar;
     }
     else
  s = out + maxwidth - 1;
     for (l = 0; l < itemcnt; l++)
  if (stl_items[l].stl_start > s)
      break;
     itemcnt = l;
     *s++ = '>';
     *s = 0;
 }
 else
 {
     if (has_mbyte)
     {
  n = 0;
  while (width >= maxwidth)
  {
      width -= ptr2cells(s + n);
      n += (*mb_ptr2len)(s + n);
  }
     }
     else
  n = width - maxwidth + 1;
     p = s + n;
     memmove((char *)((s + 1)), (char *)((p)), strlen((char *)(p)) + 1);
     *s = '<';


     while (++width < maxwidth)
     {
  s = s + strlen((char *)(s));
  *s++ = fillchar;
  *s = '\000';
     }

     --n;
     for (; l < itemcnt; l++)
     {
  if (stl_items[l].stl_start - n >= s)
      stl_items[l].stl_start -= n;
  else
      stl_items[l].stl_start = s;
     }
 }
 width = maxwidth;
    }
    else if (width < maxwidth && strlen((char *)(out)) + maxwidth - width + 1 < outlen)
    {

 for (l = 0; l < itemcnt; l++)
     if (stl_items[l].stl_type == Middle)
  break;
 if (l < itemcnt)
 {
     p = stl_items[l].stl_start + maxwidth - width;
     memmove((char *)((p)), (char *)((stl_items[l].stl_start)), strlen((char *)(stl_items[l].stl_start)) + 1);
     for (s = stl_items[l].stl_start; s < p; s++)
  *s = fillchar;
     for (l++; l < itemcnt; l++)
  stl_items[l].stl_start += maxwidth - width;
     width = maxwidth;
 }
    }


    if (hltab != ((void*)0))
    {
 *hltab = stl_hltab;
 sp = stl_hltab;
 for (l = 0; l < itemcnt; l++)
 {
     if (stl_items[l].stl_type == Highlight)
     {
  sp->start = stl_items[l].stl_start;
  sp->userhl = stl_items[l].stl_minwid;
  sp++;
     }
 }
 sp->start = ((void*)0);
 sp->userhl = 0;
    }


    if (tabtab != ((void*)0))
    {
 *tabtab = stl_tabtab;
 sp = stl_tabtab;
 for (l = 0; l < itemcnt; l++)
 {
     if (stl_items[l].stl_type == TabPage)
     {
  sp->start = stl_items[l].stl_start;
  sp->userhl = stl_items[l].stl_minwid;
  sp++;
     }
 }
 sp->start = ((void*)0);
 sp->userhl = 0;
    }



    if (updating_screen)
    {
 must_redraw = save_must_redraw;
 curwin->w_redr_type = save_redr_type;
    }

    return width;
}
# 4970 "buffer.c"
    void
get_rel_pos(
    win_T *wp,
    char_u *buf,
    int buflen)
{
    long above;
    long below;

    if (buflen < 3)
 return;
    above = wp->w_topline - 1;

    above += diff_check_fill(wp, wp->w_topline) - wp->w_topfill;
    if (wp->w_topline == 1 && wp->w_topfill >= 1)
 above = 0;



    below = wp->w_buffer->b_ml.ml_line_count - wp->w_botline + 1;
    if (below <= 0)
 vim_strncpy(buf, (char_u *)(above == 0 ? dcgettext (((void*)0), (char *)("All"), 5) : dcgettext (((void*)0), (char *)("Bot"), 5)),
       (size_t)(buflen - 1));
    else if (above <= 0)
 vim_strncpy(buf, (char_u *)dcgettext (((void*)0), (char *)("Top"), 5), (size_t)(buflen - 1));
    else
 vim_snprintf((char *)buf, (size_t)buflen, "%2d%%", above > 1000000L
        ? (int)(above / ((above + below) / 100L))
        : (int)(above * 100L / (above + below)));
}






    static int
append_arg_number(
    win_T *wp,
    char_u *buf,
    int buflen,
    int add_file)
{
    char_u *p;

    if (((curwin)->w_alist->al_ga.ga_len) <= 1)
 return 0;

    p = buf + strlen((char *)(buf));
    if (p - buf + 35 >= buflen)
 return 0;
    *p++ = ' ';
    *p++ = '(';
    if (add_file)
    {
 strcpy((char *)(p), (char *)("file "));
 p += 5;
    }
    vim_snprintf((char *)p, (size_t)(buflen - (p - buf)),
  wp->w_arg_idx_invalid ? "(%d) of %d)"
      : "%d of %d)", wp->w_arg_idx + 1, ((curwin)->w_alist->al_ga.ga_len));
    return 1;
}





    char_u *
fix_fname(char_u *fname)
{
# 5050 "buffer.c"
    return FullName_save(fname, 1);
# 5073 "buffer.c"
}
# 5083 "buffer.c"
    void
fname_expand(
    buf_T *buf __attribute__((unused)),
    char_u **ffname,
    char_u **sfname)
{
    if (*ffname == ((void*)0))
 return;
    if (*sfname == ((void*)0))
 *sfname = *ffname;
    *ffname = fix_fname(*ffname);
# 5110 "buffer.c"
}




    void
ex_buffer_all(exarg_T *eap)
{
    buf_T *buf;
    win_T *wp, *wpnext;
    int split_ret = 1;
    int p_ea_save;
    int open_wins = 0;
    int r;
    int count;
    int all;
    int had_tab = cmdmod.cmod_tab;
    tabpage_T *tpnext;

    if (eap->addr_count == 0)
 count = 9999;
    else
 count = eap->line2;
    if (eap->cmdidx == CMD_unhide || eap->cmdidx == CMD_sunhide)
 all = 0;
    else
 all = 1;

    setpcmark();
# 5148 "buffer.c"
    if (had_tab > 0)
 goto_tabpage_tp(first_tabpage, 1, 1);
    for (;;)
    {
 tpnext = curtab->tp_next;
 for (wp = firstwin; wp != ((void*)0); wp = wpnext)
 {
     wpnext = wp->w_next;
     if ((wp->w_buffer->b_nwindows > 1
      || ((cmdmod.cmod_split & 2)
   ? wp->w_height + wp->w_status_height < Rows - p_ch
           - tabline_height()
   : wp->w_width != Columns)
      || (had_tab > 0 && wp != firstwin)) && !(firstwin == lastwin)
        && !(wp->w_closing || wp->w_buffer->b_locked > 0))
     {
  win_close(wp, 0);
  wpnext = firstwin;

  tpnext = first_tabpage;
  open_wins = 0;
     }
     else
  ++open_wins;
 }


 if (had_tab == 0 || tpnext == ((void*)0))
     break;
 goto_tabpage_tp(tpnext, 1, 1);
    }







    ++autocmd_no_enter;
    win_enter(lastwin, 0);
    ++autocmd_no_leave;
    for (buf = firstbuf; buf != ((void*)0) && open_wins < count; buf = buf->b_next)
    {

 if ((!all && buf->b_ml.ml_mfp == ((void*)0)) || !buf->b_p_bl)
     continue;

 if (had_tab != 0)
 {

     if (buf->b_nwindows > 0)
  wp = lastwin;
     else
  wp = ((void*)0);
 }
 else
 {

     for (wp = firstwin; wp != ((void*)0); wp = wp->w_next)
  if (wp->w_buffer == buf)
      break;

     if (wp != ((void*)0))
  win_move_after(wp, curwin);
 }

 if (wp == ((void*)0) && split_ret == 1)
 {
     bufref_T bufref;

     set_bufref(&bufref, buf);


     p_ea_save = p_ea;
     p_ea = 1;
     split_ret = win_split(0, 1 | 32);
     ++open_wins;
     p_ea = p_ea_save;
     if (split_ret == 0)
  continue;


     swap_exists_action = 1;
     set_curbuf(buf, 0);
     if (!bufref_valid(&bufref))
     {

  swap_exists_action = 0;
  break;
     }
     if (swap_exists_action == 2)
     {

  cleanup_T cs;



  enter_cleanup(&cs);



  win_close(curwin, 1);
  --open_wins;
  swap_exists_action = 0;
  swap_exists_did_quit = 1;





  leave_cleanup(&cs);

     }
     else
  handle_swap_exists(((void*)0));
 }

 ui_breakcheck();
 if (got_int)
 {
     (void)vgetc();
     break;
 }


 if (aborting())
     break;


 if (had_tab > 0 && tabpage_index(((void*)0)) <= p_tpm)
     cmdmod.cmod_tab = 9999;
    }
    --autocmd_no_enter;
    win_enter(firstwin, 0);
    --autocmd_no_leave;




    for (wp = lastwin; open_wins > count; )
    {
 r = (buf_hide(wp->w_buffer) || !bufIsChanged(wp->w_buffer)
         || autowrite(wp->w_buffer, 0) == 1);
 if (!win_valid(wp))
 {

     wp = lastwin;
 }
 else if (r)
 {
     win_close(wp, !buf_hide(wp->w_buffer));
     --open_wins;
     wp = lastwin;
 }
 else
 {
     wp = wp->w_prev;
     if (wp == ((void*)0))
  break;
 }
    }
}


static int chk_modeline(linenr_T, int);
# 5323 "buffer.c"
    void
do_modelines(int flags)
{
    linenr_T lnum;
    int nmlines;
    static int entered = 0;

    if (!curbuf->b_p_ml || (nmlines = (int)p_mls) == 0)
 return;



    if (entered)
 return;

    ++entered;
    for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count && lnum <= nmlines;
               ++lnum)
 if (chk_modeline(lnum, flags) == 0)
     nmlines = 0;

    for (lnum = curbuf->b_ml.ml_line_count; lnum > 0 && lnum > nmlines
         && lnum > curbuf->b_ml.ml_line_count - nmlines; --lnum)
 if (chk_modeline(lnum, flags) == 0)
     nmlines = 0;
    --entered;
}


# 1 "./version.h" 1
# 5352 "buffer.c" 2





    static int
chk_modeline(
    linenr_T lnum,
    int flags)
{
    char_u *s;
    char_u *e;
    char_u *linecopy;
    int prev;
    int vers;
    int end;
    int retval = 1;

    sctx_T save_current_sctx;



    prev = -1;
    for (s = ml_get(lnum); *s != '\000'; ++s)
    {
 if (prev == -1 || vim_isspace(prev))
 {
     if ((prev != -1 && strncmp((char *)(s), (char *)("ex:"), (size_t)((size_t)3)) == 0)
      || strncmp((char *)(s), (char *)("vi:"), (size_t)((size_t)3)) == 0)
  break;

     if ((s[0] == 'v' || s[0] == 'V') && s[1] == 'i' && s[2] == 'm')
     {
  if (s[3] == '<' || s[3] == '=' || s[3] == '>')
      e = s + 4;
  else
      e = s + 3;
  vers = getdigits(&e);
  if (*e == ':'
   && (s[0] != 'V'
      || strncmp((char *)(skipwhite(e + 1)), (char *)("set"), (size_t)(3)) == 0)
   && (s[3] == ':'
       || ((8 * 100 + 2) >= vers && ((*__ctype_b_loc ())[(int) ((s[3]))] & (unsigned short int) _ISdigit))
       || ((8 * 100 + 2) < vers && s[3] == '<')
       || ((8 * 100 + 2) > vers && s[3] == '>')
       || ((8 * 100 + 2) == vers && s[3] == '=')))
      break;
     }
 }
 prev = *s;
    }

    if (*s)
    {
 do
     ++s;
 while (s[-1] != ':');

 s = linecopy = vim_strsave(s);
 if (linecopy == ((void*)0))
     return 0;


 estack_push(ETYPE_MODELINE, (char_u *)"modelines", lnum);


 end = 0;
 while (end == 0)
 {
     s = skipwhite(s);
     if (*s == '\000')
  break;





     for (e = s; *e != ':' && *e != '\000'; ++e)
  if (e[0] == '\\' && e[1] == ':')
      memmove((char *)((e)), (char *)((e + 1)), strlen((char *)(e + 1)) + 1);
     if (*e == '\000')
  end = 1;
# 5442 "buffer.c"
     if (strncmp((char *)(s), (char *)("set "), (size_t)((size_t)4)) == 0
      || strncmp((char *)(s), (char *)("se "), (size_t)((size_t)3)) == 0)
     {
  if (*e != ':')
      break;
  end = 1;
  s = vim_strchr(s, ' ') + 1;
     }
     *e = '\000';

     if (*s != '\000')
     {
  int secure_save = secure;

  save_current_sctx = current_sctx;
  current_sctx.sc_sid = -1;
  current_sctx.sc_seq = 0;
  current_sctx.sc_lnum = lnum;
  current_sctx.sc_version = 1;


  secure = 1;

  retval = do_set(s, 0x08 | 0x04 | flags);

  secure = secure_save;

  current_sctx = save_current_sctx;

  if (retval == 0)
      break;
     }
     s = e + 1;
 }


 estack_pop();
 vim_free(linecopy);
    }
    return retval;
}




    int
bt_normal(buf_T *buf)
{
    return buf != ((void*)0) && buf->b_p_bt[0] == '\000';
}





    int
bt_quickfix(buf_T *buf)
{
    return buf != ((void*)0) && buf->b_p_bt[0] == 'q';
}






    int
bt_terminal(buf_T *buf)
{
    return buf != ((void*)0) && buf->b_p_bt[0] == 't';
}





    int
bt_help(buf_T *buf)
{
    return buf != ((void*)0) && buf->b_help;
}




    int
bt_prompt(buf_T *buf)
{
    return buf != ((void*)0) && buf->b_p_bt[0] == 'p' && buf->b_p_bt[1] == 'r';
}




    int
bt_popup(buf_T *buf)
{
    return buf != ((void*)0) && buf->b_p_bt != ((void*)0)
 && buf->b_p_bt[0] == 'p' && buf->b_p_bt[1] == 'o';
}





    int
bt_nofilename(buf_T *buf)
{
    return buf != ((void*)0) && ((buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f')
     || buf->b_p_bt[0] == 'a'
     || buf->b_p_bt[0] == 't'
     || buf->b_p_bt[0] == 'p');
}




    int
bt_nofile(buf_T *buf)
{
    return buf != ((void*)0) && buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f';
}





    int
bt_dontwrite(buf_T *buf)
{
    return buf != ((void*)0) && (buf->b_p_bt[0] == 'n'
   || buf->b_p_bt[0] == 't'
   || buf->b_p_bt[0] == 'p');
}


    int
bt_dontwrite_msg(buf_T *buf)
{
    if (bt_dontwrite(buf))
    {
 emsg(dcgettext (((void*)0), (char *)("E382: Cannot write, 'buftype' option is set"), 5));
 return 1;
    }
    return 0;
}






    int
buf_hide(buf_T *buf)
{

    switch (buf->b_p_bh[0])
    {
 case 'u':
 case 'w':
 case 'd': return 0;
 case 'h': return 1;
    }
    return (p_hid || (cmdmod.cmod_flags & 0x0020));
}





    char_u *
buf_spname(buf_T *buf)
{

    if (bt_quickfix(buf))
    {




 if (buf->b_fnum == qf_stack_get_bufnr())
     return (char_u *)dcgettext (((void*)0), (char *)(msg_qflist), 5);
 else
     return (char_u *)dcgettext (((void*)0), (char *)(msg_loclist), 5);
    }




    if (bt_nofilename(buf))
    {

 if (buf->b_term != ((void*)0))
     return term_get_status_text(buf->b_term);

 if (buf->b_fname != ((void*)0))
     return buf->b_fname;

 if (bt_prompt(buf))
     return (char_u *)dcgettext (((void*)0), (char *)("[Prompt]"), 5);


 if (bt_popup(buf))
     return (char_u *)dcgettext (((void*)0), (char *)("[Popup]"), 5);

 return (char_u *)dcgettext (((void*)0), (char *)("[Scratch]"), 5);
    }

    if (buf->b_fname == ((void*)0))
 return buf_get_fname(buf);
    return ((void*)0);
}




    char_u *
buf_get_fname(buf_T *buf)
{
    if (buf->b_fname == ((void*)0))
 return (char_u *)dcgettext (((void*)0), (char *)("[No Name]"), 5);
    return buf->b_fname;
}




    void
set_buflisted(int on)
{
    if (on != curbuf->b_p_bl)
    {
 curbuf->b_p_bl = on;
 if (on)
     apply_autocmds(EVENT_BUFADD, ((void*)0), ((void*)0), 0, curbuf);
 else
     apply_autocmds(EVENT_BUFDELETE, ((void*)0), ((void*)0), 0, curbuf);
    }
}





    int
buf_contents_changed(buf_T *buf)
{
    buf_T *newbuf;
    int differ = 1;
    linenr_T lnum;
    aco_save_T aco;
    exarg_T ea;


    newbuf = buflist_new(((void*)0), ((void*)0), (linenr_T)1, 4);
    if (newbuf == ((void*)0))
 return 1;


    if (prep_exarg(&ea, buf) == 0)
    {
 wipe_buffer(newbuf, 0);
 return 1;
    }


    aucmd_prepbuf(&aco, newbuf);

    if (ml_open(curbuf) == 1
     && readfile(buf->b_ffname, buf->b_fname,
      (linenr_T)0, (linenr_T)0, (linenr_T)9223372036854775807L,
         &ea, 0x01 | 0x10) == 1)
    {

 if (buf->b_ml.ml_line_count == curbuf->b_ml.ml_line_count)
 {
     differ = 0;
     for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)
  if (strcmp((char *)(ml_get_buf(buf, lnum, 0)), (char *)(ml_get(lnum))) != 0)
  {
      differ = 1;
      break;
  }
 }
    }
    vim_free(ea.cmd);


    aucmd_restbuf(&aco);

    if (curbuf != newbuf)
 wipe_buffer(newbuf, 0);

    return differ;
}






    void
wipe_buffer(
    buf_T *buf,
    int aucmd)
{
    if (buf->b_fnum == top_file_num - 1)
 --top_file_num;

    if (!aucmd)
 block_autocmds();

    close_buffer(((void*)0), buf, 4, 0, 1);

    if (!aucmd)
 unblock_autocmds();
}
