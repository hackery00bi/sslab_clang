<!doctype html>
<html>
<head>
<title>spell.c</title>

<style type="text/css">
body { color:#000000; background-color:#ffffff }
body { font-family:Helvetica, sans-serif; font-size:10pt }
h1 { font-size:14pt }
.FileName { margin-top: 5px; margin-bottom: 5px; display: inline; }
.FileNav { margin-left: 5px; margin-right: 5px; display: inline; }
.FileNav a { text-decoration:none; font-size: larger; }
.divider { margin-top: 30px; margin-bottom: 30px; height: 15px; }
.divider { background-color: gray; }
.code { border-collapse:collapse; width:100%; }
.code { font-family: "Monospace", monospace; font-size:10pt }
.code { line-height: 1.2em }
.comment { color: green; font-style: oblique }
.keyword { color: blue }
.string_literal { color: red }
.directive { color: darkmagenta }

/* Macros and variables could have pop-up notes hidden by default.
  - Macro pop-up:    expansion of the macro
  - Variable pop-up: value (table) of the variable */
.macro_popup, .variable_popup { display: none; }

/* Pop-up appears on mouse-hover event. */
.macro:hover .macro_popup, .variable:hover .variable_popup {
  display: block;
  padding: 2px;
  -webkit-border-radius:5px;
  -webkit-box-shadow:1px 1px 7px #000;
  border-radius:5px;
  box-shadow:1px 1px 7px #000;
  position: absolute;
  top: -1em;
  left:10em;
  z-index: 1
}

.macro_popup {
  border: 2px solid red;
  background-color:#FFF0F0;
  font-weight: normal;
}

.variable_popup {
  border: 2px solid blue;
  background-color:#F0F0FF;
  font-weight: bold;
  font-family: Helvetica, sans-serif;
  font-size: 9pt;
}

/* Pop-up notes needs a relative position as a base where they pops up. */
.macro, .variable {
  background-color: PaleGoldenRod;
  position: relative;
}
.macro { color: DarkMagenta; }

#tooltiphint {
  position: fixed;
  width: 50em;
  margin-left: -25em;
  left: 50%;
  padding: 10px;
  border: 1px solid #b0b0b0;
  border-radius: 2px;
  box-shadow: 1px 1px 7px black;
  background-color: #c0c0c0;
  z-index: 2;
}

.num { width:2.5em; padding-right:2ex; background-color:#eeeeee }
.num { text-align:right; font-size:8pt }
.num { color:#444444 }
.line { padding-left: 1ex; border-left: 3px solid #ccc }
.line { white-space: pre }
.msg { -webkit-box-shadow:1px 1px 7px #000 }
.msg { box-shadow:1px 1px 7px #000 }
.msg { -webkit-border-radius:5px }
.msg { border-radius:5px }
.msg { font-family:Helvetica, sans-serif; font-size:8pt }
.msg { float:left }
.msg { padding:0.25em 1ex 0.25em 1ex }
.msg { margin-top:10px; margin-bottom:10px }
.msg { font-weight:bold }
.msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }
.msgT { padding:0x; spacing:0x }
.msgEvent { background-color:#fff8b4; color:#000000 }
.msgControl { background-color:#bbbbbb; color:#000000 }
.msgNote { background-color:#ddeeff; color:#000000 }
.mrange { background-color:#dfddf3 }
.mrange { border-bottom:1px solid #6F9DBE }
.PathIndex { font-weight: bold; padding:0px 5px; margin-right:5px; }
.PathIndex { -webkit-border-radius:8px }
.PathIndex { border-radius:8px }
.PathIndexEvent { background-color:#bfba87 }
.PathIndexControl { background-color:#8c8c8c }
.PathIndexPopUp { background-color: #879abc; }
.PathNav a { text-decoration:none; font-size: larger }
.CodeInsertionHint { font-weight: bold; background-color: #10dd10 }
.CodeRemovalHint { background-color:#de1010 }
.CodeRemovalHint { border-bottom:1px solid #6F9DBE }
.selected{ background-color:orange !important; }

table.simpletable {
  padding: 5px;
  font-size:12pt;
  margin:20px;
  border-collapse: collapse; border-spacing: 0px;
}
td.rowname {
  text-align: right;
  vertical-align: top;
  font-weight: bold;
  color:#444444;
  padding-right:2ex;
}

/* Hidden text. */
input.spoilerhider + label {
  cursor: pointer;
  text-decoration: underline;
  display: block;
}
input.spoilerhider {
 display: none;
}
input.spoilerhider ~ .spoiler {
  overflow: hidden;
  margin: 10px auto 0;
  height: 0;
  opacity: 0;
}
input.spoilerhider:checked + label + .spoiler{
  height: auto;
  opacity: 1;
}
</style>
</head>
<body>
<!-- BUGDESC Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 -->

<!-- BUGTYPE Potential insecure memory buffer bounds restriction in call 'memset' -->

<!-- BUGCATEGORY Security -->

<!-- BUGFILE /tmp/sslab_clang/c_vim/vim/src/spell.c -->

<!-- FILENAME spell.c -->

<!-- FUNCTIONNAME clear_midword -->

<!-- ISSUEHASHCONTENTOFLINEINCONTEXT 3c4f6ad3fc832a069d6309a5c2b3f41b -->

<!-- BUGLINE 2297 -->

<!-- BUGCOLUMN 5 -->

<!-- BUGPATHLENGTH 1 -->

<!-- BUGMETAEND -->
<!-- REPORTHEADER -->
<h3>Bug Summary</h3>
<table class="simpletable">
<tr><td class="rowname">File:</td><td>spell.c</td></tr>
<tr><td class="rowname">Warning:</td><td><a href="#EndPath">line 2297, column 5</a><br />Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11</td></tr>

</table>
<!-- REPORTSUMMARYEXTRA -->
<h3>Annotated Source Code</h3>
<p>Press <a href="#" onclick="toggleHelp(); return false;">'?'</a>
   to see keyboard shortcuts</p>
<input type="checkbox" class="spoilerhider" id="showinvocation" />
<label for="showinvocation" >Show analyzer invocation</label>
<div class="spoiler">clang -cc1 -cc1 -triple x86_64-unknown-linux-gnu -analyze -disable-free -main-file-name spell.c -analyzer-store=region -analyzer-opt-analyze-nested-blocks -analyzer-checker=core -analyzer-checker=apiModeling -analyzer-checker=unix -analyzer-checker=deadcode -analyzer-checker=security.insecureAPI.UncheckedReturn -analyzer-checker=security.insecureAPI.getpw -analyzer-checker=security.insecureAPI.gets -analyzer-checker=security.insecureAPI.mktemp -analyzer-checker=security.insecureAPI.mkstemp -analyzer-checker=security.insecureAPI.vfork -analyzer-checker=nullability.NullPassedToNonnull -analyzer-checker=nullability.NullReturnedFromNonnull -analyzer-output plist -w -setup-static-analyzer -mrelocation-model static -mframe-pointer=none -fmath-errno -fno-rounding-math -mconstructor-aliases -munwind-tables -target-cpu x86-64 -fno-split-dwarf-inlining -debugger-tuning=gdb -resource-dir /llvm-project/build/lib/clang/12.0.0 -I . -I proto -D HAVE_CONFIG_H -U _FORTIFY_SOURCE -D _FORTIFY_SOURCE=1 -internal-isystem /usr/local/include -internal-isystem /llvm-project/build/lib/clang/12.0.0/include -internal-externc-isystem /usr/include/x86_64-linux-gnu -internal-externc-isystem /include -internal-externc-isystem /usr/include -O2 -fdebug-compilation-dir /tmp/sslab_clang/c_vim/vim/src -ferror-limit 19 -fgnuc-version=4.2.1 -vectorize-loops -vectorize-slp -analyzer-checker core -analyzer-checker cplusplus -analyzer-checker nullability -analyzer-checker optin -analyzer-checker security -analyzer-checker unix -analyzer-checker osx -analyzer-checker fuchsia -analyzer-checker webkit -analyzer-output=html -faddrsig -o /tmp/scan-build-2020-11-24-134443-313-1 -x c spell.c
</div>
<div id='tooltiphint' hidden="true">
  <p>Keyboard shortcuts: </p>
  <ul>
    <li>Use 'j/k' keys for keyboard navigation</li>
    <li>Use 'Shift+S' to show/hide relevant lines</li>
    <li>Use '?' to toggle this window</li>
  </ul>
  <a href="#" onclick="toggleHelp(); return false;">Close</a>
</div>
<script type='text/javascript'>
var relevant_lines = {"1": {"2297": 1}};

var filterCounterexample = function (hide) {
  var tables = document.getElementsByClassName("code");
  for (var t=0; t<tables.length; t++) {
    var table = tables[t];
    var file_id = table.getAttribute("data-fileid");
    var lines_in_fid = relevant_lines[file_id];
    if (!lines_in_fid) {
      lines_in_fid = {};
    }
    var lines = table.getElementsByClassName("codeline");
    for (var i=0; i<lines.length; i++) {
        var el = lines[i];
        var lineNo = el.getAttribute("data-linenumber");
        if (!lines_in_fid[lineNo]) {
          if (hide) {
            el.setAttribute("hidden", "");
          } else {
            el.removeAttribute("hidden");
          }
        }
    }
  }
}

window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.key == "S") {
    var checked = document.getElementsByName("showCounterexample")[0].checked;
    filterCounterexample(!checked);
    document.getElementsByName("showCounterexample")[0].checked = !checked;
  } else {
    return;
  }
  event.preventDefault();
}, true);

document.addEventListener("DOMContentLoaded", function() {
    document.querySelector('input[name="showCounterexample"]').onchange=
        function (event) {
      filterCounterexample(this.checked);
    };
});
</script>

<form>
    <input type="checkbox" name="showCounterexample" id="showCounterexample" />
    <label for="showCounterexample">
       Show only relevant lines
    </label>
</form>

<script type='text/javascript'>
var digitMatcher = new RegExp("[0-9]+");

var querySelectorAllArray = function(selector) {
  return Array.prototype.slice.call(
    document.querySelectorAll(selector));
}

document.addEventListener("DOMContentLoaded", function() {
    querySelectorAllArray(".PathNav > a").forEach(
        function(currentValue, currentIndex) {
            var hrefValue = currentValue.getAttribute("href");
            currentValue.onclick = function() {
                scrollTo(document.querySelector(hrefValue));
                return false;
            };
        });
});

var findNum = function() {
    var s = document.querySelector(".selected");
    if (!s || s.id == "EndPath") {
        return 0;
    }
    var out = parseInt(digitMatcher.exec(s.id)[0]);
    return out;
};

var scrollTo = function(el) {
    querySelectorAllArray(".selected").forEach(function(s) {
        s.classList.remove("selected");
    });
    el.classList.add("selected");
    window.scrollBy(0, el.getBoundingClientRect().top -
        (window.innerHeight / 2));
}

var move = function(num, up, numItems) {
  if (num == 1 && up || num == numItems - 1 && !up) {
    return 0;
  } else if (num == 0 && up) {
    return numItems - 1;
  } else if (num == 0 && !up) {
    return 1 % numItems;
  }
  return up ? num - 1 : num + 1;
}

var numToId = function(num) {
  if (num == 0) {
    return document.getElementById("EndPath")
  }
  return document.getElementById("Path" + num);
};

var navigateTo = function(up) {
  var numItems = document.querySelectorAll(
      ".line > .msgEvent, .line > .msgControl").length;
  var currentSelected = findNum();
  var newSelected = move(currentSelected, up, numItems);
  var newEl = numToId(newSelected, numItems);

  // Scroll element into center.
  scrollTo(newEl);
};

window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.key == "j") {
    navigateTo(/*up=*/false);
  } else if (event.key == "k") {
    navigateTo(/*up=*/true);
  } else {
    return;
  }
  event.preventDefault();
}, true);
</script>
  
<script type='text/javascript'>

var toggleHelp = function() {
    var hint = document.querySelector("#tooltiphint");
    var attributeName = "hidden";
    if (hint.hasAttribute(attributeName)) {
      hint.removeAttribute(attributeName);
    } else {
      hint.setAttribute("hidden", "true");
    }
};
window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.key == "?") {
    toggleHelp();
  } else {
    return;
  }
  event.preventDefault();
});
</script>
<table class="code" data-fileid="1">
<tr class="codeline" data-linenumber="1"><td class="num" id="LN1">1</td><td class="line"><span class='comment'>/* vi:set ts=8 sts=4 sw=4 noet:</span></td></tr>
<tr class="codeline" data-linenumber="2"><td class="num" id="LN2">2</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="3"><td class="num" id="LN3">3</td><td class="line"> <span class='comment'>* VIM - Vi IMproved	by Bram Moolenaar</span></td></tr>
<tr class="codeline" data-linenumber="4"><td class="num" id="LN4">4</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="5"><td class="num" id="LN5">5</td><td class="line"> <span class='comment'>* Do ":help uganda"  in Vim to read copying and usage conditions.</span></td></tr>
<tr class="codeline" data-linenumber="6"><td class="num" id="LN6">6</td><td class="line"> <span class='comment'>* Do ":help credits" in Vim to see a list of people who contributed.</span></td></tr>
<tr class="codeline" data-linenumber="7"><td class="num" id="LN7">7</td><td class="line"> <span class='comment'>* See README.txt for an overview of the Vim source code.</span></td></tr>
<tr class="codeline" data-linenumber="8"><td class="num" id="LN8">8</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="9"><td class="num" id="LN9">9</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="10"><td class="num" id="LN10">10</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="11"><td class="num" id="LN11">11</td><td class="line"> <span class='comment'>* spell.c: code for spell checking</span></td></tr>
<tr class="codeline" data-linenumber="12"><td class="num" id="LN12">12</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="13"><td class="num" id="LN13">13</td><td class="line"> <span class='comment'>* See spellfile.c for the Vim spell file format.</span></td></tr>
<tr class="codeline" data-linenumber="14"><td class="num" id="LN14">14</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="15"><td class="num" id="LN15">15</td><td class="line"> <span class='comment'>* The spell checking mechanism uses a tree (aka trie).  Each node in the tree</span></td></tr>
<tr class="codeline" data-linenumber="16"><td class="num" id="LN16">16</td><td class="line"> <span class='comment'>* has a list of bytes that can appear (siblings).  For each byte there is a</span></td></tr>
<tr class="codeline" data-linenumber="17"><td class="num" id="LN17">17</td><td class="line"> <span class='comment'>* pointer to the node with the byte that follows in the word (child).</span></td></tr>
<tr class="codeline" data-linenumber="18"><td class="num" id="LN18">18</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="19"><td class="num" id="LN19">19</td><td class="line"> <span class='comment'>* A NUL byte is used where the word may end.  The bytes are sorted, so that</span></td></tr>
<tr class="codeline" data-linenumber="20"><td class="num" id="LN20">20</td><td class="line"> <span class='comment'>* binary searching can be used and the NUL bytes are at the start.  The</span></td></tr>
<tr class="codeline" data-linenumber="21"><td class="num" id="LN21">21</td><td class="line"> <span class='comment'>* number of possible bytes is stored before the list of bytes.</span></td></tr>
<tr class="codeline" data-linenumber="22"><td class="num" id="LN22">22</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="23"><td class="num" id="LN23">23</td><td class="line"> <span class='comment'>* The tree uses two arrays: "byts" stores the characters, "idxs" stores</span></td></tr>
<tr class="codeline" data-linenumber="24"><td class="num" id="LN24">24</td><td class="line"> <span class='comment'>* either the next index or flags.  The tree starts at index 0.  For example,</span></td></tr>
<tr class="codeline" data-linenumber="25"><td class="num" id="LN25">25</td><td class="line"> <span class='comment'>* to lookup "vi" this sequence is followed:</span></td></tr>
<tr class="codeline" data-linenumber="26"><td class="num" id="LN26">26</td><td class="line"> <span class='comment'>*	i = 0</span></td></tr>
<tr class="codeline" data-linenumber="27"><td class="num" id="LN27">27</td><td class="line"> <span class='comment'>*	len = byts[i]</span></td></tr>
<tr class="codeline" data-linenumber="28"><td class="num" id="LN28">28</td><td class="line"> <span class='comment'>*	n = where "v" appears in byts[i + 1] to byts[i + len]</span></td></tr>
<tr class="codeline" data-linenumber="29"><td class="num" id="LN29">29</td><td class="line"> <span class='comment'>*	i = idxs[n]</span></td></tr>
<tr class="codeline" data-linenumber="30"><td class="num" id="LN30">30</td><td class="line"> <span class='comment'>*	len = byts[i]</span></td></tr>
<tr class="codeline" data-linenumber="31"><td class="num" id="LN31">31</td><td class="line"> <span class='comment'>*	n = where "i" appears in byts[i + 1] to byts[i + len]</span></td></tr>
<tr class="codeline" data-linenumber="32"><td class="num" id="LN32">32</td><td class="line"> <span class='comment'>*	i = idxs[n]</span></td></tr>
<tr class="codeline" data-linenumber="33"><td class="num" id="LN33">33</td><td class="line"> <span class='comment'>*	len = byts[i]</span></td></tr>
<tr class="codeline" data-linenumber="34"><td class="num" id="LN34">34</td><td class="line"> <span class='comment'>*	find that byts[i + 1] is 0, idxs[i + 1] has flags for "vi".</span></td></tr>
<tr class="codeline" data-linenumber="35"><td class="num" id="LN35">35</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="36"><td class="num" id="LN36">36</td><td class="line"> <span class='comment'>* There are two word trees: one with case-folded words and one with words in</span></td></tr>
<tr class="codeline" data-linenumber="37"><td class="num" id="LN37">37</td><td class="line"> <span class='comment'>* original case.  The second one is only used for keep-case words and is</span></td></tr>
<tr class="codeline" data-linenumber="38"><td class="num" id="LN38">38</td><td class="line"> <span class='comment'>* usually small.</span></td></tr>
<tr class="codeline" data-linenumber="39"><td class="num" id="LN39">39</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="40"><td class="num" id="LN40">40</td><td class="line"> <span class='comment'>* There is one additional tree for when not all prefixes are applied when</span></td></tr>
<tr class="codeline" data-linenumber="41"><td class="num" id="LN41">41</td><td class="line"> <span class='comment'>* generating the .spl file.  This tree stores all the possible prefixes, as</span></td></tr>
<tr class="codeline" data-linenumber="42"><td class="num" id="LN42">42</td><td class="line"> <span class='comment'>* if they were words.  At each word (prefix) end the prefix nr is stored, the</span></td></tr>
<tr class="codeline" data-linenumber="43"><td class="num" id="LN43">43</td><td class="line"> <span class='comment'>* following word must support this prefix nr.  And the condition nr is</span></td></tr>
<tr class="codeline" data-linenumber="44"><td class="num" id="LN44">44</td><td class="line"> <span class='comment'>* stored, used to lookup the condition that the word must match with.</span></td></tr>
<tr class="codeline" data-linenumber="45"><td class="num" id="LN45">45</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="46"><td class="num" id="LN46">46</td><td class="line"> <span class='comment'>* Thanks to Olaf Seibert for providing an example implementation of this tree</span></td></tr>
<tr class="codeline" data-linenumber="47"><td class="num" id="LN47">47</td><td class="line"> <span class='comment'>* and the compression mechanism.</span></td></tr>
<tr class="codeline" data-linenumber="48"><td class="num" id="LN48">48</td><td class="line"> <span class='comment'>* LZ trie ideas:</span></td></tr>
<tr class="codeline" data-linenumber="49"><td class="num" id="LN49">49</td><td class="line"> <span class='comment'>*	http://www.irb.hr/hr/home/ristov/papers/RistovLZtrieRevision1.pdf</span></td></tr>
<tr class="codeline" data-linenumber="50"><td class="num" id="LN50">50</td><td class="line"> <span class='comment'>* More papers: http://www-igm.univ-mlv.fr/~laporte/publi_en.html</span></td></tr>
<tr class="codeline" data-linenumber="51"><td class="num" id="LN51">51</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="52"><td class="num" id="LN52">52</td><td class="line"> <span class='comment'>* Matching involves checking the caps type: Onecap ALLCAP KeepCap.</span></td></tr>
<tr class="codeline" data-linenumber="53"><td class="num" id="LN53">53</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="54"><td class="num" id="LN54">54</td><td class="line"> <span class='comment'>* Why doesn't Vim use aspell/ispell/myspell/etc.?</span></td></tr>
<tr class="codeline" data-linenumber="55"><td class="num" id="LN55">55</td><td class="line"> <span class='comment'>* See ":help develop-spell".</span></td></tr>
<tr class="codeline" data-linenumber="56"><td class="num" id="LN56">56</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="57"><td class="num" id="LN57">57</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="58"><td class="num" id="LN58">58</td><td class="line"><span class='directive'>#define IN_SPELL_C</span></td></tr>
<tr class="codeline" data-linenumber="59"><td class="num" id="LN59">59</td><td class="line"><span class='directive'>#include "vim.h"</span></td></tr>
<tr class="codeline" data-linenumber="60"><td class="num" id="LN60">60</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="61"><td class="num" id="LN61">61</td><td class="line"><span class='directive'>#if defined(FEAT_SPELL) || defined(PROTO)</span></td></tr>
<tr class="codeline" data-linenumber="62"><td class="num" id="LN62">62</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="63"><td class="num" id="LN63">63</td><td class="line"><span class='directive'>#ifndef <span class='macro'>UNIX<span class='macro_popup'>1</span></span>		// it's in os_unix.h for Unix</span></td></tr>
<tr class="codeline" data-linenumber="64"><td class="num" id="LN64">64</td><td class="line"><span class='directive'># include &lt;time.h&gt;	// for time_t</span></td></tr>
<tr class="codeline" data-linenumber="65"><td class="num" id="LN65">65</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="66"><td class="num" id="LN66">66</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="67"><td class="num" id="LN67">67</td><td class="line"><span class='directive'>#define <span class='macro'>REGION_ALL<span class='macro_popup'>0xff</span></span> 0xff		// word valid in all regions</span></td></tr>
<tr class="codeline" data-linenumber="68"><td class="num" id="LN68">68</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="69"><td class="num" id="LN69">69</td><td class="line"><span class='comment'>// Result values.  Lower number is accepted over higher one.</span></td></tr>
<tr class="codeline" data-linenumber="70"><td class="num" id="LN70">70</td><td class="line"><span class='directive'>#define <span class='macro'>SP_BANNED<span class='macro_popup'>-1</span></span>	-1</span></td></tr>
<tr class="codeline" data-linenumber="71"><td class="num" id="LN71">71</td><td class="line"><span class='directive'>#define <span class='macro'>SP_OK<span class='macro_popup'>0</span></span>		0</span></td></tr>
<tr class="codeline" data-linenumber="72"><td class="num" id="LN72">72</td><td class="line"><span class='directive'>#define <span class='macro'>SP_RARE<span class='macro_popup'>1</span></span>		1</span></td></tr>
<tr class="codeline" data-linenumber="73"><td class="num" id="LN73">73</td><td class="line"><span class='directive'>#define <span class='macro'>SP_LOCAL<span class='macro_popup'>2</span></span>	2</span></td></tr>
<tr class="codeline" data-linenumber="74"><td class="num" id="LN74">74</td><td class="line"><span class='directive'>#define <span class='macro'>SP_BAD<span class='macro_popup'>3</span></span>		3</span></td></tr>
<tr class="codeline" data-linenumber="75"><td class="num" id="LN75">75</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="76"><td class="num" id="LN76">76</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="77"><td class="num" id="LN77">77</td><td class="line"> <span class='comment'>* Structure to store info for word matching.</span></td></tr>
<tr class="codeline" data-linenumber="78"><td class="num" id="LN78">78</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="79"><td class="num" id="LN79">79</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> matchinf_S</td></tr>
<tr class="codeline" data-linenumber="80"><td class="num" id="LN80">80</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="81"><td class="num" id="LN81">81</td><td class="line">    langp_T	*mi_lp;			<span class='comment'>// info for language and region</span></td></tr>
<tr class="codeline" data-linenumber="82"><td class="num" id="LN82">82</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="83"><td class="num" id="LN83">83</td><td class="line">    <span class='comment'>// pointers to original text to be checked</span></td></tr>
<tr class="codeline" data-linenumber="84"><td class="num" id="LN84">84</td><td class="line">    char_u	*mi_word;		<span class='comment'>// start of word being checked</span></td></tr>
<tr class="codeline" data-linenumber="85"><td class="num" id="LN85">85</td><td class="line">    char_u	*mi_end;		<span class='comment'>// end of matching word so far</span></td></tr>
<tr class="codeline" data-linenumber="86"><td class="num" id="LN86">86</td><td class="line">    char_u	*mi_fend;		<span class='comment'>// next char to be added to mi_fword</span></td></tr>
<tr class="codeline" data-linenumber="87"><td class="num" id="LN87">87</td><td class="line">    char_u	*mi_cend;		<span class='comment'>// char after what was used for</span></td></tr>
<tr class="codeline" data-linenumber="88"><td class="num" id="LN88">88</td><td class="line">					<span class='comment'>// mi_capflags</span></td></tr>
<tr class="codeline" data-linenumber="89"><td class="num" id="LN89">89</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="90"><td class="num" id="LN90">90</td><td class="line">    <span class='comment'>// case-folded text</span></td></tr>
<tr class="codeline" data-linenumber="91"><td class="num" id="LN91">91</td><td class="line">    char_u	mi_fword[<span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span> + 1];	<span class='comment'>// mi_word case-folded</span></td></tr>
<tr class="codeline" data-linenumber="92"><td class="num" id="LN92">92</td><td class="line">    <span class='keyword'>int</span>		mi_fwordlen;		<span class='comment'>// nr of valid bytes in mi_fword</span></td></tr>
<tr class="codeline" data-linenumber="93"><td class="num" id="LN93">93</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="94"><td class="num" id="LN94">94</td><td class="line">    <span class='comment'>// for when checking word after a prefix</span></td></tr>
<tr class="codeline" data-linenumber="95"><td class="num" id="LN95">95</td><td class="line">    <span class='keyword'>int</span>		mi_prefarridx;		<span class='comment'>// index in sl_pidxs with list of</span></td></tr>
<tr class="codeline" data-linenumber="96"><td class="num" id="LN96">96</td><td class="line">					<span class='comment'>// affixID/condition</span></td></tr>
<tr class="codeline" data-linenumber="97"><td class="num" id="LN97">97</td><td class="line">    <span class='keyword'>int</span>		mi_prefcnt;		<span class='comment'>// number of entries at mi_prefarridx</span></td></tr>
<tr class="codeline" data-linenumber="98"><td class="num" id="LN98">98</td><td class="line">    <span class='keyword'>int</span>		mi_prefixlen;		<span class='comment'>// byte length of prefix</span></td></tr>
<tr class="codeline" data-linenumber="99"><td class="num" id="LN99">99</td><td class="line">    <span class='keyword'>int</span>		mi_cprefixlen;		<span class='comment'>// byte length of prefix in original</span></td></tr>
<tr class="codeline" data-linenumber="100"><td class="num" id="LN100">100</td><td class="line">					<span class='comment'>// case</span></td></tr>
<tr class="codeline" data-linenumber="101"><td class="num" id="LN101">101</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="102"><td class="num" id="LN102">102</td><td class="line">    <span class='comment'>// for when checking a compound word</span></td></tr>
<tr class="codeline" data-linenumber="103"><td class="num" id="LN103">103</td><td class="line">    <span class='keyword'>int</span>		mi_compoff;		<span class='comment'>// start of following word offset</span></td></tr>
<tr class="codeline" data-linenumber="104"><td class="num" id="LN104">104</td><td class="line">    char_u	mi_compflags[<span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>];	<span class='comment'>// flags for compound words used</span></td></tr>
<tr class="codeline" data-linenumber="105"><td class="num" id="LN105">105</td><td class="line">    <span class='keyword'>int</span>		mi_complen;		<span class='comment'>// nr of compound words used</span></td></tr>
<tr class="codeline" data-linenumber="106"><td class="num" id="LN106">106</td><td class="line">    <span class='keyword'>int</span>		mi_compextra;		<span class='comment'>// nr of COMPOUNDROOT words</span></td></tr>
<tr class="codeline" data-linenumber="107"><td class="num" id="LN107">107</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="108"><td class="num" id="LN108">108</td><td class="line">    <span class='comment'>// others</span></td></tr>
<tr class="codeline" data-linenumber="109"><td class="num" id="LN109">109</td><td class="line">    <span class='keyword'>int</span>		mi_result;		<span class='comment'>// result so far: SP_BAD, SP_OK, etc.</span></td></tr>
<tr class="codeline" data-linenumber="110"><td class="num" id="LN110">110</td><td class="line">    <span class='keyword'>int</span>		mi_capflags;		<span class='comment'>// WF_ONECAP WF_ALLCAP WF_KEEPCAP</span></td></tr>
<tr class="codeline" data-linenumber="111"><td class="num" id="LN111">111</td><td class="line">    win_T	*mi_win;		<span class='comment'>// buffer being checked</span></td></tr>
<tr class="codeline" data-linenumber="112"><td class="num" id="LN112">112</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="113"><td class="num" id="LN113">113</td><td class="line">    <span class='comment'>// for NOBREAK</span></td></tr>
<tr class="codeline" data-linenumber="114"><td class="num" id="LN114">114</td><td class="line">    <span class='keyword'>int</span>		mi_result2;		<span class='comment'>// "mi_resul" without following word</span></td></tr>
<tr class="codeline" data-linenumber="115"><td class="num" id="LN115">115</td><td class="line">    char_u	*mi_end2;		<span class='comment'>// "mi_end" without following word</span></td></tr>
<tr class="codeline" data-linenumber="116"><td class="num" id="LN116">116</td><td class="line">} matchinf_T;</td></tr>
<tr class="codeline" data-linenumber="117"><td class="num" id="LN117">117</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="118"><td class="num" id="LN118">118</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="119"><td class="num" id="LN119">119</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> spell_mb_isword_class(<span class='keyword'>int</span> cl, win_T *wp);</td></tr>
<tr class="codeline" data-linenumber="120"><td class="num" id="LN120">120</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="121"><td class="num" id="LN121">121</td><td class="line"><span class='comment'>// mode values for find_word</span></td></tr>
<tr class="codeline" data-linenumber="122"><td class="num" id="LN122">122</td><td class="line"><span class='directive'>#define <span class='macro'>FIND_FOLDWORD<span class='macro_popup'>0</span></span>	    0	// find word case-folded</span></td></tr>
<tr class="codeline" data-linenumber="123"><td class="num" id="LN123">123</td><td class="line"><span class='directive'>#define <span class='macro'>FIND_KEEPWORD<span class='macro_popup'>1</span></span>	    1	// find keep-case word</span></td></tr>
<tr class="codeline" data-linenumber="124"><td class="num" id="LN124">124</td><td class="line"><span class='directive'>#define <span class='macro'>FIND_PREFIX<span class='macro_popup'>2</span></span>	    2	// find word after prefix</span></td></tr>
<tr class="codeline" data-linenumber="125"><td class="num" id="LN125">125</td><td class="line"><span class='directive'>#define <span class='macro'>FIND_COMPOUND<span class='macro_popup'>3</span></span>	    3	// find case-folded compound word</span></td></tr>
<tr class="codeline" data-linenumber="126"><td class="num" id="LN126">126</td><td class="line"><span class='directive'>#define <span class='macro'>FIND_KEEPCOMPOUND<span class='macro_popup'>4</span></span>   4	// find keep-case compound word</span></td></tr>
<tr class="codeline" data-linenumber="127"><td class="num" id="LN127">127</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="128"><td class="num" id="LN128">128</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> find_word(matchinf_T *mip, <span class='keyword'>int</span> mode);</td></tr>
<tr class="codeline" data-linenumber="129"><td class="num" id="LN129">129</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> find_prefix(matchinf_T *mip, <span class='keyword'>int</span> mode);</td></tr>
<tr class="codeline" data-linenumber="130"><td class="num" id="LN130">130</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> fold_more(matchinf_T *mip);</td></tr>
<tr class="codeline" data-linenumber="131"><td class="num" id="LN131">131</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> spell_load_cb(char_u *fname, <span class='keyword'>void</span> *cookie);</td></tr>
<tr class="codeline" data-linenumber="132"><td class="num" id="LN132">132</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> count_syllables(slang_T *slang, char_u *word);</td></tr>
<tr class="codeline" data-linenumber="133"><td class="num" id="LN133">133</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> clear_midword(win_T *buf);</td></tr>
<tr class="codeline" data-linenumber="134"><td class="num" id="LN134">134</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> use_midword(slang_T *lp, win_T *buf);</td></tr>
<tr class="codeline" data-linenumber="135"><td class="num" id="LN135">135</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> find_region(char_u *rp, char_u *region);</td></tr>
<tr class="codeline" data-linenumber="136"><td class="num" id="LN136">136</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> spell_soundfold_sofo(slang_T *slang, char_u *inword, char_u *res);</td></tr>
<tr class="codeline" data-linenumber="137"><td class="num" id="LN137">137</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> spell_soundfold_sal(slang_T *slang, char_u *inword, char_u *res);</td></tr>
<tr class="codeline" data-linenumber="138"><td class="num" id="LN138">138</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> spell_soundfold_wsal(slang_T *slang, char_u *inword, char_u *res);</td></tr>
<tr class="codeline" data-linenumber="139"><td class="num" id="LN139">139</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> dump_word(slang_T *slang, char_u *word, char_u *pat, <span class='keyword'>int</span> *dir, <span class='keyword'>int</span> round, <span class='keyword'>int</span> flags, linenr_T lnum);</td></tr>
<tr class="codeline" data-linenumber="140"><td class="num" id="LN140">140</td><td class="line"><span class='keyword'>static</span> linenr_T dump_prefixes(slang_T *slang, char_u *word, char_u *pat, <span class='keyword'>int</span> *dir, <span class='keyword'>int</span> round, <span class='keyword'>int</span> flags, linenr_T startlnum);</td></tr>
<tr class="codeline" data-linenumber="141"><td class="num" id="LN141">141</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="142"><td class="num" id="LN142">142</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="143"><td class="num" id="LN143">143</td><td class="line"> <span class='comment'>* Main spell-checking function.</span></td></tr>
<tr class="codeline" data-linenumber="144"><td class="num" id="LN144">144</td><td class="line"> <span class='comment'>* "ptr" points to a character that could be the start of a word.</span></td></tr>
<tr class="codeline" data-linenumber="145"><td class="num" id="LN145">145</td><td class="line"> <span class='comment'>* "*attrp" is set to the highlight index for a badly spelled word.  For a</span></td></tr>
<tr class="codeline" data-linenumber="146"><td class="num" id="LN146">146</td><td class="line"> <span class='comment'>* non-word or when it's OK it remains unchanged.</span></td></tr>
<tr class="codeline" data-linenumber="147"><td class="num" id="LN147">147</td><td class="line"> <span class='comment'>* This must only be called when 'spelllang' is not empty.</span></td></tr>
<tr class="codeline" data-linenumber="148"><td class="num" id="LN148">148</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="149"><td class="num" id="LN149">149</td><td class="line"> <span class='comment'>* "capcol" is used to check for a Capitalised word after the end of a</span></td></tr>
<tr class="codeline" data-linenumber="150"><td class="num" id="LN150">150</td><td class="line"> <span class='comment'>* sentence.  If it's zero then perform the check.  Return the column where to</span></td></tr>
<tr class="codeline" data-linenumber="151"><td class="num" id="LN151">151</td><td class="line"> <span class='comment'>* check next, or -1 when no sentence end was found.  If it's NULL then don't</span></td></tr>
<tr class="codeline" data-linenumber="152"><td class="num" id="LN152">152</td><td class="line"> <span class='comment'>* worry.</span></td></tr>
<tr class="codeline" data-linenumber="153"><td class="num" id="LN153">153</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="154"><td class="num" id="LN154">154</td><td class="line"> <span class='comment'>* Returns the length of the word in bytes, also when it's OK, so that the</span></td></tr>
<tr class="codeline" data-linenumber="155"><td class="num" id="LN155">155</td><td class="line"> <span class='comment'>* caller can skip over the word.</span></td></tr>
<tr class="codeline" data-linenumber="156"><td class="num" id="LN156">156</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="157"><td class="num" id="LN157">157</td><td class="line">    <span class='keyword'>int</span></td></tr>
<tr class="codeline" data-linenumber="158"><td class="num" id="LN158">158</td><td class="line">spell_check(</td></tr>
<tr class="codeline" data-linenumber="159"><td class="num" id="LN159">159</td><td class="line">    win_T	*wp,		<span class='comment'>// current window</span></td></tr>
<tr class="codeline" data-linenumber="160"><td class="num" id="LN160">160</td><td class="line">    char_u	*ptr,</td></tr>
<tr class="codeline" data-linenumber="161"><td class="num" id="LN161">161</td><td class="line">    hlf_T	*attrp,</td></tr>
<tr class="codeline" data-linenumber="162"><td class="num" id="LN162">162</td><td class="line">    <span class='keyword'>int</span>		*capcol,	<span class='comment'>// column to check for Capital</span></td></tr>
<tr class="codeline" data-linenumber="163"><td class="num" id="LN163">163</td><td class="line">    <span class='keyword'>int</span>		docount)	<span class='comment'>// count good words</span></td></tr>
<tr class="codeline" data-linenumber="164"><td class="num" id="LN164">164</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="165"><td class="num" id="LN165">165</td><td class="line">    matchinf_T	mi;		<span class='comment'>// Most things are put in "mi" so that it can</span></td></tr>
<tr class="codeline" data-linenumber="166"><td class="num" id="LN166">166</td><td class="line">				<span class='comment'>// be passed to functions quickly.</span></td></tr>
<tr class="codeline" data-linenumber="167"><td class="num" id="LN167">167</td><td class="line">    <span class='keyword'>int</span>		nrlen = 0;	<span class='comment'>// found a number first</span></td></tr>
<tr class="codeline" data-linenumber="168"><td class="num" id="LN168">168</td><td class="line">    <span class='keyword'>int</span>		c;</td></tr>
<tr class="codeline" data-linenumber="169"><td class="num" id="LN169">169</td><td class="line">    <span class='keyword'>int</span>		wrongcaplen = 0;</td></tr>
<tr class="codeline" data-linenumber="170"><td class="num" id="LN170">170</td><td class="line">    <span class='keyword'>int</span>		lpi;</td></tr>
<tr class="codeline" data-linenumber="171"><td class="num" id="LN171">171</td><td class="line">    <span class='keyword'>int</span>		count_word = docount;</td></tr>
<tr class="codeline" data-linenumber="172"><td class="num" id="LN172">172</td><td class="line">    <span class='keyword'>int</span>		use_camel_case = *wp-&gt;w_s-&gt;b_p_spo != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>;</td></tr>
<tr class="codeline" data-linenumber="173"><td class="num" id="LN173">173</td><td class="line">    <span class='keyword'>int</span>		camel_case = 0;</td></tr>
<tr class="codeline" data-linenumber="174"><td class="num" id="LN174">174</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="175"><td class="num" id="LN175">175</td><td class="line">    <span class='comment'>// A word never starts at a space or a control character.  Return quickly</span></td></tr>
<tr class="codeline" data-linenumber="176"><td class="num" id="LN176">176</td><td class="line">    <span class='comment'>// then, skipping over the character.</span></td></tr>
<tr class="codeline" data-linenumber="177"><td class="num" id="LN177">177</td><td class="line">    <span class='keyword'>if</span> (*ptr &lt;= ' ')</td></tr>
<tr class="codeline" data-linenumber="178"><td class="num" id="LN178">178</td><td class="line">	<span class='keyword'>return</span> 1;</td></tr>
<tr class="codeline" data-linenumber="179"><td class="num" id="LN179">179</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="180"><td class="num" id="LN180">180</td><td class="line">    <span class='comment'>// Return here when loading language files failed.</span></td></tr>
<tr class="codeline" data-linenumber="181"><td class="num" id="LN181">181</td><td class="line">    <span class='keyword'>if</span> (wp-&gt;w_s-&gt;b_langp.ga_len == 0)</td></tr>
<tr class="codeline" data-linenumber="182"><td class="num" id="LN182">182</td><td class="line">	<span class='keyword'>return</span> 1;</td></tr>
<tr class="codeline" data-linenumber="183"><td class="num" id="LN183">183</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="184"><td class="num" id="LN184">184</td><td class="line">    <span class='macro'>CLEAR_FIELD(mi)<span class='macro_popup'>memset((&amp;(mi)), (0), (sizeof(mi)))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="185"><td class="num" id="LN185">185</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="186"><td class="num" id="LN186">186</td><td class="line">    <span class='comment'>// A number is always OK.  Also skip hexadecimal numbers 0xFF99 and</span></td></tr>
<tr class="codeline" data-linenumber="187"><td class="num" id="LN187">187</td><td class="line">    <span class='comment'>// 0X99FF.  But always do check spelling to find "3GPP" and "11</span></td></tr>
<tr class="codeline" data-linenumber="188"><td class="num" id="LN188">188</td><td class="line">    <span class='comment'>// julifeest".</span></td></tr>
<tr class="codeline" data-linenumber="189"><td class="num" id="LN189">189</td><td class="line">    <span class='keyword'>if</span> (*ptr &gt;= '0' &amp;&amp; *ptr &lt;= '9')</td></tr>
<tr class="codeline" data-linenumber="190"><td class="num" id="LN190">190</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="191"><td class="num" id="LN191">191</td><td class="line">	<span class='keyword'>if</span> (*ptr == '0' &amp;&amp; (ptr[1] == 'b' || ptr[1] == 'B'))</td></tr>
<tr class="codeline" data-linenumber="192"><td class="num" id="LN192">192</td><td class="line">	    mi.mi_end = skipbin(ptr + 2);</td></tr>
<tr class="codeline" data-linenumber="193"><td class="num" id="LN193">193</td><td class="line">	<span class='keyword'>else</span> <span class='keyword'>if</span> (*ptr == '0' &amp;&amp; (ptr[1] == 'x' || ptr[1] == 'X'))</td></tr>
<tr class="codeline" data-linenumber="194"><td class="num" id="LN194">194</td><td class="line">	    mi.mi_end = skiphex(ptr + 2);</td></tr>
<tr class="codeline" data-linenumber="195"><td class="num" id="LN195">195</td><td class="line">	<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="196"><td class="num" id="LN196">196</td><td class="line">	    mi.mi_end = skipdigits(ptr);</td></tr>
<tr class="codeline" data-linenumber="197"><td class="num" id="LN197">197</td><td class="line">	nrlen = (<span class='keyword'>int</span>)(mi.mi_end - ptr);</td></tr>
<tr class="codeline" data-linenumber="198"><td class="num" id="LN198">198</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="199"><td class="num" id="LN199">199</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="200"><td class="num" id="LN200">200</td><td class="line">    <span class='comment'>// Find the normal end of the word (until the next non-word character).</span></td></tr>
<tr class="codeline" data-linenumber="201"><td class="num" id="LN201">201</td><td class="line">    mi.mi_word = ptr;</td></tr>
<tr class="codeline" data-linenumber="202"><td class="num" id="LN202">202</td><td class="line">    mi.mi_fend = ptr;</td></tr>
<tr class="codeline" data-linenumber="203"><td class="num" id="LN203">203</td><td class="line">    <span class='keyword'>if</span> (spell_iswordp(mi.mi_fend, wp))</td></tr>
<tr class="codeline" data-linenumber="204"><td class="num" id="LN204">204</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="205"><td class="num" id="LN205">205</td><td class="line">	<span class='keyword'>int</span> prev_upper;</td></tr>
<tr class="codeline" data-linenumber="206"><td class="num" id="LN206">206</td><td class="line">	<span class='keyword'>int</span> this_upper = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;  <span class='comment'>// init for gcc</span></td></tr>
<tr class="codeline" data-linenumber="207"><td class="num" id="LN207">207</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="208"><td class="num" id="LN208">208</td><td class="line">	<span class='keyword'>if</span> (use_camel_case)</td></tr>
<tr class="codeline" data-linenumber="209"><td class="num" id="LN209">209</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="210"><td class="num" id="LN210">210</td><td class="line">	    c = <span class='macro'>PTR2CHAR(mi.mi_fend)<span class='macro_popup'>(has_mbyte ? mb_ptr2char(mi.mi_fend) : (int)*(mi.mi_fend))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="211"><td class="num" id="LN211">211</td><td class="line">	    this_upper = <span class='macro'>SPELL_ISUPPER(c)<span class='macro_popup'>(enc_utf8 &amp;&amp; (c) &gt;= 128 ? utf_isupper(c) : (c) &lt;<br> 256 ? spelltab.st_isu[c] : iswupper(c))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="212"><td class="num" id="LN212">212</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="213"><td class="num" id="LN213">213</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="214"><td class="num" id="LN214">214</td><td class="line">	<span class='keyword'>do</span></td></tr>
<tr class="codeline" data-linenumber="215"><td class="num" id="LN215">215</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="216"><td class="num" id="LN216">216</td><td class="line">	    <span class='macro'>MB_PTR_ADV(mi.mi_fend)<span class='macro_popup'>mi.mi_fend += (*mb_ptr2len)(mi.mi_fend)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="217"><td class="num" id="LN217">217</td><td class="line">	    <span class='keyword'>if</span> (use_camel_case)</td></tr>
<tr class="codeline" data-linenumber="218"><td class="num" id="LN218">218</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="219"><td class="num" id="LN219">219</td><td class="line">		prev_upper = this_upper;</td></tr>
<tr class="codeline" data-linenumber="220"><td class="num" id="LN220">220</td><td class="line">		c = <span class='macro'>PTR2CHAR(mi.mi_fend)<span class='macro_popup'>(has_mbyte ? mb_ptr2char(mi.mi_fend) : (int)*(mi.mi_fend))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="221"><td class="num" id="LN221">221</td><td class="line">		this_upper = <span class='macro'>SPELL_ISUPPER(c)<span class='macro_popup'>(enc_utf8 &amp;&amp; (c) &gt;= 128 ? utf_isupper(c) : (c) &lt;<br> 256 ? spelltab.st_isu[c] : iswupper(c))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="222"><td class="num" id="LN222">222</td><td class="line">		camel_case = !prev_upper &amp;&amp; this_upper;</td></tr>
<tr class="codeline" data-linenumber="223"><td class="num" id="LN223">223</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="224"><td class="num" id="LN224">224</td><td class="line">	} <span class='keyword'>while</span> (*mi.mi_fend != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span> &amp;&amp; spell_iswordp(mi.mi_fend, wp)</td></tr>
<tr class="codeline" data-linenumber="225"><td class="num" id="LN225">225</td><td class="line">							       &amp;&amp; !camel_case);</td></tr>
<tr class="codeline" data-linenumber="226"><td class="num" id="LN226">226</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="227"><td class="num" id="LN227">227</td><td class="line">	<span class='keyword'>if</span> (capcol != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span> &amp;&amp; *capcol == 0 &amp;&amp; wp-&gt;w_s-&gt;b_cap_prog != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="228"><td class="num" id="LN228">228</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="229"><td class="num" id="LN229">229</td><td class="line">	    <span class='comment'>// Check word starting with capital letter.</span></td></tr>
<tr class="codeline" data-linenumber="230"><td class="num" id="LN230">230</td><td class="line">	    c = <span class='macro'>PTR2CHAR(ptr)<span class='macro_popup'>(has_mbyte ? mb_ptr2char(ptr) : (int)*(ptr))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="231"><td class="num" id="LN231">231</td><td class="line">	    <span class='keyword'>if</span> (!<span class='macro'>SPELL_ISUPPER(c)<span class='macro_popup'>(enc_utf8 &amp;&amp; (c) &gt;= 128 ? utf_isupper(c) : (c) &lt;<br> 256 ? spelltab.st_isu[c] : iswupper(c))</span></span>)</td></tr>
<tr class="codeline" data-linenumber="232"><td class="num" id="LN232">232</td><td class="line">		wrongcaplen = (<span class='keyword'>int</span>)(mi.mi_fend - ptr);</td></tr>
<tr class="codeline" data-linenumber="233"><td class="num" id="LN233">233</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="234"><td class="num" id="LN234">234</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="235"><td class="num" id="LN235">235</td><td class="line">    <span class='keyword'>if</span> (capcol != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="236"><td class="num" id="LN236">236</td><td class="line">	*capcol = -1;</td></tr>
<tr class="codeline" data-linenumber="237"><td class="num" id="LN237">237</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="238"><td class="num" id="LN238">238</td><td class="line">    <span class='comment'>// We always use the characters up to the next non-word character,</span></td></tr>
<tr class="codeline" data-linenumber="239"><td class="num" id="LN239">239</td><td class="line">    <span class='comment'>// also for bad words.</span></td></tr>
<tr class="codeline" data-linenumber="240"><td class="num" id="LN240">240</td><td class="line">    mi.mi_end = mi.mi_fend;</td></tr>
<tr class="codeline" data-linenumber="241"><td class="num" id="LN241">241</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="242"><td class="num" id="LN242">242</td><td class="line">    <span class='comment'>// Check caps type later.</span></td></tr>
<tr class="codeline" data-linenumber="243"><td class="num" id="LN243">243</td><td class="line">    mi.mi_capflags = 0;</td></tr>
<tr class="codeline" data-linenumber="244"><td class="num" id="LN244">244</td><td class="line">    mi.mi_cend = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="245"><td class="num" id="LN245">245</td><td class="line">    mi.mi_win = wp;</td></tr>
<tr class="codeline" data-linenumber="246"><td class="num" id="LN246">246</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="247"><td class="num" id="LN247">247</td><td class="line">    <span class='comment'>// case-fold the word with one non-word character, so that we can check</span></td></tr>
<tr class="codeline" data-linenumber="248"><td class="num" id="LN248">248</td><td class="line">    <span class='comment'>// for the word end.</span></td></tr>
<tr class="codeline" data-linenumber="249"><td class="num" id="LN249">249</td><td class="line">    <span class='keyword'>if</span> (*mi.mi_fend != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="250"><td class="num" id="LN250">250</td><td class="line">	<span class='macro'>MB_PTR_ADV(mi.mi_fend)<span class='macro_popup'>mi.mi_fend += (*mb_ptr2len)(mi.mi_fend)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="251"><td class="num" id="LN251">251</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="252"><td class="num" id="LN252">252</td><td class="line">    (<span class='keyword'>void</span>)spell_casefold(ptr, (<span class='keyword'>int</span>)(mi.mi_fend - ptr), mi.mi_fword,</td></tr>
<tr class="codeline" data-linenumber="253"><td class="num" id="LN253">253</td><td class="line">							     <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span> + 1);</td></tr>
<tr class="codeline" data-linenumber="254"><td class="num" id="LN254">254</td><td class="line">    mi.mi_fwordlen = (<span class='keyword'>int</span>)<span class='macro'>STRLEN(mi.mi_fword)<span class='macro_popup'>strlen((char *)(mi.mi_fword))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="255"><td class="num" id="LN255">255</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="256"><td class="num" id="LN256">256</td><td class="line">    <span class='keyword'>if</span> (camel_case)</td></tr>
<tr class="codeline" data-linenumber="257"><td class="num" id="LN257">257</td><td class="line">	<span class='comment'>// Introduce a fake word end space into the folded word.</span></td></tr>
<tr class="codeline" data-linenumber="258"><td class="num" id="LN258">258</td><td class="line">	mi.mi_fword[mi.mi_fwordlen - 1] = ' ';</td></tr>
<tr class="codeline" data-linenumber="259"><td class="num" id="LN259">259</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="260"><td class="num" id="LN260">260</td><td class="line">    <span class='comment'>// The word is bad unless we recognize it.</span></td></tr>
<tr class="codeline" data-linenumber="261"><td class="num" id="LN261">261</td><td class="line">    mi.mi_result = <span class='macro'>SP_BAD<span class='macro_popup'>3</span></span>;</td></tr>
<tr class="codeline" data-linenumber="262"><td class="num" id="LN262">262</td><td class="line">    mi.mi_result2 = <span class='macro'>SP_BAD<span class='macro_popup'>3</span></span>;</td></tr>
<tr class="codeline" data-linenumber="263"><td class="num" id="LN263">263</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="264"><td class="num" id="LN264">264</td><td class="line">    <span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="265"><td class="num" id="LN265">265</td><td class="line">     <span class='comment'>* Loop over the languages specified in 'spelllang'.</span></td></tr>
<tr class="codeline" data-linenumber="266"><td class="num" id="LN266">266</td><td class="line">     <span class='comment'>* We check them all, because a word may be matched longer in another</span></td></tr>
<tr class="codeline" data-linenumber="267"><td class="num" id="LN267">267</td><td class="line">     <span class='comment'>* language.</span></td></tr>
<tr class="codeline" data-linenumber="268"><td class="num" id="LN268">268</td><td class="line">     <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="269"><td class="num" id="LN269">269</td><td class="line">    <span class='keyword'>for</span> (lpi = 0; lpi &lt; wp-&gt;w_s-&gt;b_langp.ga_len; ++lpi)</td></tr>
<tr class="codeline" data-linenumber="270"><td class="num" id="LN270">270</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="271"><td class="num" id="LN271">271</td><td class="line">	mi.mi_lp = <span class='macro'>LANGP_ENTRY(wp-&gt;w_s-&gt;b_langp, lpi)<span class='macro_popup'>(((langp_T *)(wp-&gt;w_s-&gt;b_langp).ga_data) + (lpi))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="272"><td class="num" id="LN272">272</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="273"><td class="num" id="LN273">273</td><td class="line">	<span class='comment'>// If reloading fails the language is still in the list but everything</span></td></tr>
<tr class="codeline" data-linenumber="274"><td class="num" id="LN274">274</td><td class="line">	<span class='comment'>// has been cleared.</span></td></tr>
<tr class="codeline" data-linenumber="275"><td class="num" id="LN275">275</td><td class="line">	<span class='keyword'>if</span> (mi.mi_lp-&gt;lp_slang-&gt;sl_fidxs == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="276"><td class="num" id="LN276">276</td><td class="line">	    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="277"><td class="num" id="LN277">277</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="278"><td class="num" id="LN278">278</td><td class="line">	<span class='comment'>// Check for a matching word in case-folded words.</span></td></tr>
<tr class="codeline" data-linenumber="279"><td class="num" id="LN279">279</td><td class="line">	find_word(&amp;mi, <span class='macro'>FIND_FOLDWORD<span class='macro_popup'>0</span></span>);</td></tr>
<tr class="codeline" data-linenumber="280"><td class="num" id="LN280">280</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="281"><td class="num" id="LN281">281</td><td class="line">	<span class='comment'>// Check for a matching word in keep-case words.</span></td></tr>
<tr class="codeline" data-linenumber="282"><td class="num" id="LN282">282</td><td class="line">	find_word(&amp;mi, <span class='macro'>FIND_KEEPWORD<span class='macro_popup'>1</span></span>);</td></tr>
<tr class="codeline" data-linenumber="283"><td class="num" id="LN283">283</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="284"><td class="num" id="LN284">284</td><td class="line">	<span class='comment'>// Check for matching prefixes.</span></td></tr>
<tr class="codeline" data-linenumber="285"><td class="num" id="LN285">285</td><td class="line">	find_prefix(&amp;mi, <span class='macro'>FIND_FOLDWORD<span class='macro_popup'>0</span></span>);</td></tr>
<tr class="codeline" data-linenumber="286"><td class="num" id="LN286">286</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="287"><td class="num" id="LN287">287</td><td class="line">	<span class='comment'>// For a NOBREAK language, may want to use a word without a following</span></td></tr>
<tr class="codeline" data-linenumber="288"><td class="num" id="LN288">288</td><td class="line">	<span class='comment'>// word as a backup.</span></td></tr>
<tr class="codeline" data-linenumber="289"><td class="num" id="LN289">289</td><td class="line">	<span class='keyword'>if</span> (mi.mi_lp-&gt;lp_slang-&gt;sl_nobreak &amp;&amp; mi.mi_result == <span class='macro'>SP_BAD<span class='macro_popup'>3</span></span></td></tr>
<tr class="codeline" data-linenumber="290"><td class="num" id="LN290">290</td><td class="line">						   &amp;&amp; mi.mi_result2 != <span class='macro'>SP_BAD<span class='macro_popup'>3</span></span>)</td></tr>
<tr class="codeline" data-linenumber="291"><td class="num" id="LN291">291</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="292"><td class="num" id="LN292">292</td><td class="line">	    mi.mi_result = mi.mi_result2;</td></tr>
<tr class="codeline" data-linenumber="293"><td class="num" id="LN293">293</td><td class="line">	    mi.mi_end = mi.mi_end2;</td></tr>
<tr class="codeline" data-linenumber="294"><td class="num" id="LN294">294</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="295"><td class="num" id="LN295">295</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="296"><td class="num" id="LN296">296</td><td class="line">	<span class='comment'>// Count the word in the first language where it's found to be OK.</span></td></tr>
<tr class="codeline" data-linenumber="297"><td class="num" id="LN297">297</td><td class="line">	<span class='keyword'>if</span> (count_word &amp;&amp; mi.mi_result == <span class='macro'>SP_OK<span class='macro_popup'>0</span></span>)</td></tr>
<tr class="codeline" data-linenumber="298"><td class="num" id="LN298">298</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="299"><td class="num" id="LN299">299</td><td class="line">	    count_common_word(mi.mi_lp-&gt;lp_slang, ptr,</td></tr>
<tr class="codeline" data-linenumber="300"><td class="num" id="LN300">300</td><td class="line">						   (<span class='keyword'>int</span>)(mi.mi_end - ptr), 1);</td></tr>
<tr class="codeline" data-linenumber="301"><td class="num" id="LN301">301</td><td class="line">	    count_word = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="302"><td class="num" id="LN302">302</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="303"><td class="num" id="LN303">303</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="304"><td class="num" id="LN304">304</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="305"><td class="num" id="LN305">305</td><td class="line">    <span class='keyword'>if</span> (mi.mi_result != <span class='macro'>SP_OK<span class='macro_popup'>0</span></span>)</td></tr>
<tr class="codeline" data-linenumber="306"><td class="num" id="LN306">306</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="307"><td class="num" id="LN307">307</td><td class="line">	<span class='comment'>// If we found a number skip over it.  Allows for "42nd".  Do flag</span></td></tr>
<tr class="codeline" data-linenumber="308"><td class="num" id="LN308">308</td><td class="line">	<span class='comment'>// rare and local words, e.g., "3GPP".</span></td></tr>
<tr class="codeline" data-linenumber="309"><td class="num" id="LN309">309</td><td class="line">	<span class='keyword'>if</span> (nrlen &gt; 0)</td></tr>
<tr class="codeline" data-linenumber="310"><td class="num" id="LN310">310</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="311"><td class="num" id="LN311">311</td><td class="line">	    <span class='keyword'>if</span> (mi.mi_result == <span class='macro'>SP_BAD<span class='macro_popup'>3</span></span> || mi.mi_result == <span class='macro'>SP_BANNED<span class='macro_popup'>-1</span></span>)</td></tr>
<tr class="codeline" data-linenumber="312"><td class="num" id="LN312">312</td><td class="line">		<span class='keyword'>return</span> nrlen;</td></tr>
<tr class="codeline" data-linenumber="313"><td class="num" id="LN313">313</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="314"><td class="num" id="LN314">314</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="315"><td class="num" id="LN315">315</td><td class="line">	<span class='comment'>// When we are at a non-word character there is no error, just</span></td></tr>
<tr class="codeline" data-linenumber="316"><td class="num" id="LN316">316</td><td class="line">	<span class='comment'>// skip over the character (try looking for a word after it).</span></td></tr>
<tr class="codeline" data-linenumber="317"><td class="num" id="LN317">317</td><td class="line">	<span class='keyword'>else</span> <span class='keyword'>if</span> (!spell_iswordp_nmw(ptr, wp))</td></tr>
<tr class="codeline" data-linenumber="318"><td class="num" id="LN318">318</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="319"><td class="num" id="LN319">319</td><td class="line">	    <span class='keyword'>if</span> (capcol != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span> &amp;&amp; wp-&gt;w_s-&gt;b_cap_prog != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="320"><td class="num" id="LN320">320</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="321"><td class="num" id="LN321">321</td><td class="line">		regmatch_T	regmatch;</td></tr>
<tr class="codeline" data-linenumber="322"><td class="num" id="LN322">322</td><td class="line">		<span class='keyword'>int</span>		r;</td></tr>
<tr class="codeline" data-linenumber="323"><td class="num" id="LN323">323</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="324"><td class="num" id="LN324">324</td><td class="line">		<span class='comment'>// Check for end of sentence.</span></td></tr>
<tr class="codeline" data-linenumber="325"><td class="num" id="LN325">325</td><td class="line">		regmatch.regprog = wp-&gt;w_s-&gt;b_cap_prog;</td></tr>
<tr class="codeline" data-linenumber="326"><td class="num" id="LN326">326</td><td class="line">		regmatch.rm_ic = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="327"><td class="num" id="LN327">327</td><td class="line">		r = vim_regexec(&amp;regmatch, ptr, 0);</td></tr>
<tr class="codeline" data-linenumber="328"><td class="num" id="LN328">328</td><td class="line">		wp-&gt;w_s-&gt;b_cap_prog = regmatch.regprog;</td></tr>
<tr class="codeline" data-linenumber="329"><td class="num" id="LN329">329</td><td class="line">		<span class='keyword'>if</span> (r)</td></tr>
<tr class="codeline" data-linenumber="330"><td class="num" id="LN330">330</td><td class="line">		    *capcol = (<span class='keyword'>int</span>)(regmatch.endp[0] - ptr);</td></tr>
<tr class="codeline" data-linenumber="331"><td class="num" id="LN331">331</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="332"><td class="num" id="LN332">332</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="333"><td class="num" id="LN333">333</td><td class="line">	    <span class='keyword'>if</span> (has_mbyte)</td></tr>
<tr class="codeline" data-linenumber="334"><td class="num" id="LN334">334</td><td class="line">		<span class='keyword'>return</span> (*mb_ptr2len)(ptr);</td></tr>
<tr class="codeline" data-linenumber="335"><td class="num" id="LN335">335</td><td class="line">	    <span class='keyword'>return</span> 1;</td></tr>
<tr class="codeline" data-linenumber="336"><td class="num" id="LN336">336</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="337"><td class="num" id="LN337">337</td><td class="line">	<span class='keyword'>else</span> <span class='keyword'>if</span> (mi.mi_end == ptr)</td></tr>
<tr class="codeline" data-linenumber="338"><td class="num" id="LN338">338</td><td class="line">	    <span class='comment'>// Always include at least one character.  Required for when there</span></td></tr>
<tr class="codeline" data-linenumber="339"><td class="num" id="LN339">339</td><td class="line">	    <span class='comment'>// is a mixup in "midword".</span></td></tr>
<tr class="codeline" data-linenumber="340"><td class="num" id="LN340">340</td><td class="line">	    <span class='macro'>MB_PTR_ADV(mi.mi_end)<span class='macro_popup'>mi.mi_end += (*mb_ptr2len)(mi.mi_end)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="341"><td class="num" id="LN341">341</td><td class="line">	<span class='keyword'>else</span> <span class='keyword'>if</span> (mi.mi_result == <span class='macro'>SP_BAD<span class='macro_popup'>3</span></span></td></tr>
<tr class="codeline" data-linenumber="342"><td class="num" id="LN342">342</td><td class="line">		&amp;&amp; <span class='macro'>LANGP_ENTRY(wp-&gt;w_s-&gt;b_langp, 0)<span class='macro_popup'>(((langp_T *)(wp-&gt;w_s-&gt;b_langp).ga_data) + (0))</span></span>-&gt;lp_slang-&gt;sl_nobreak)</td></tr>
<tr class="codeline" data-linenumber="343"><td class="num" id="LN343">343</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="344"><td class="num" id="LN344">344</td><td class="line">	    char_u	*p, *fp;</td></tr>
<tr class="codeline" data-linenumber="345"><td class="num" id="LN345">345</td><td class="line">	    <span class='keyword'>int</span>		save_result = mi.mi_result;</td></tr>
<tr class="codeline" data-linenumber="346"><td class="num" id="LN346">346</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="347"><td class="num" id="LN347">347</td><td class="line">	    <span class='comment'>// First language in 'spelllang' is NOBREAK.  Find first position</span></td></tr>
<tr class="codeline" data-linenumber="348"><td class="num" id="LN348">348</td><td class="line">	    <span class='comment'>// at which any word would be valid.</span></td></tr>
<tr class="codeline" data-linenumber="349"><td class="num" id="LN349">349</td><td class="line">	    mi.mi_lp = <span class='macro'>LANGP_ENTRY(wp-&gt;w_s-&gt;b_langp, 0)<span class='macro_popup'>(((langp_T *)(wp-&gt;w_s-&gt;b_langp).ga_data) + (0))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="350"><td class="num" id="LN350">350</td><td class="line">	    <span class='keyword'>if</span> (mi.mi_lp-&gt;lp_slang-&gt;sl_fidxs != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="351"><td class="num" id="LN351">351</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="352"><td class="num" id="LN352">352</td><td class="line">		p = mi.mi_word;</td></tr>
<tr class="codeline" data-linenumber="353"><td class="num" id="LN353">353</td><td class="line">		fp = mi.mi_fword;</td></tr>
<tr class="codeline" data-linenumber="354"><td class="num" id="LN354">354</td><td class="line">		<span class='keyword'>for</span> (;;)</td></tr>
<tr class="codeline" data-linenumber="355"><td class="num" id="LN355">355</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="356"><td class="num" id="LN356">356</td><td class="line">		    <span class='macro'>MB_PTR_ADV(p)<span class='macro_popup'>p += (*mb_ptr2len)(p)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="357"><td class="num" id="LN357">357</td><td class="line">		    <span class='macro'>MB_PTR_ADV(fp)<span class='macro_popup'>fp += (*mb_ptr2len)(fp)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="358"><td class="num" id="LN358">358</td><td class="line">		    <span class='keyword'>if</span> (p &gt;= mi.mi_end)</td></tr>
<tr class="codeline" data-linenumber="359"><td class="num" id="LN359">359</td><td class="line">			<span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="360"><td class="num" id="LN360">360</td><td class="line">		    mi.mi_compoff = (<span class='keyword'>int</span>)(fp - mi.mi_fword);</td></tr>
<tr class="codeline" data-linenumber="361"><td class="num" id="LN361">361</td><td class="line">		    find_word(&amp;mi, <span class='macro'>FIND_COMPOUND<span class='macro_popup'>3</span></span>);</td></tr>
<tr class="codeline" data-linenumber="362"><td class="num" id="LN362">362</td><td class="line">		    <span class='keyword'>if</span> (mi.mi_result != <span class='macro'>SP_BAD<span class='macro_popup'>3</span></span>)</td></tr>
<tr class="codeline" data-linenumber="363"><td class="num" id="LN363">363</td><td class="line">		    {</td></tr>
<tr class="codeline" data-linenumber="364"><td class="num" id="LN364">364</td><td class="line">			mi.mi_end = p;</td></tr>
<tr class="codeline" data-linenumber="365"><td class="num" id="LN365">365</td><td class="line">			<span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="366"><td class="num" id="LN366">366</td><td class="line">		    }</td></tr>
<tr class="codeline" data-linenumber="367"><td class="num" id="LN367">367</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="368"><td class="num" id="LN368">368</td><td class="line">		mi.mi_result = save_result;</td></tr>
<tr class="codeline" data-linenumber="369"><td class="num" id="LN369">369</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="370"><td class="num" id="LN370">370</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="371"><td class="num" id="LN371">371</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="372"><td class="num" id="LN372">372</td><td class="line">	<span class='keyword'>if</span> (mi.mi_result == <span class='macro'>SP_BAD<span class='macro_popup'>3</span></span> || mi.mi_result == <span class='macro'>SP_BANNED<span class='macro_popup'>-1</span></span>)</td></tr>
<tr class="codeline" data-linenumber="373"><td class="num" id="LN373">373</td><td class="line">	    *attrp = HLF_SPB;</td></tr>
<tr class="codeline" data-linenumber="374"><td class="num" id="LN374">374</td><td class="line">	<span class='keyword'>else</span> <span class='keyword'>if</span> (mi.mi_result == <span class='macro'>SP_RARE<span class='macro_popup'>1</span></span>)</td></tr>
<tr class="codeline" data-linenumber="375"><td class="num" id="LN375">375</td><td class="line">	    *attrp = HLF_SPR;</td></tr>
<tr class="codeline" data-linenumber="376"><td class="num" id="LN376">376</td><td class="line">	<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="377"><td class="num" id="LN377">377</td><td class="line">	    *attrp = HLF_SPL;</td></tr>
<tr class="codeline" data-linenumber="378"><td class="num" id="LN378">378</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="379"><td class="num" id="LN379">379</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="380"><td class="num" id="LN380">380</td><td class="line">    <span class='keyword'>if</span> (wrongcaplen &gt; 0 &amp;&amp; (mi.mi_result == <span class='macro'>SP_OK<span class='macro_popup'>0</span></span> || mi.mi_result == <span class='macro'>SP_RARE<span class='macro_popup'>1</span></span>))</td></tr>
<tr class="codeline" data-linenumber="381"><td class="num" id="LN381">381</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="382"><td class="num" id="LN382">382</td><td class="line">	<span class='comment'>// Report SpellCap only when the word isn't badly spelled.</span></td></tr>
<tr class="codeline" data-linenumber="383"><td class="num" id="LN383">383</td><td class="line">	*attrp = HLF_SPC;</td></tr>
<tr class="codeline" data-linenumber="384"><td class="num" id="LN384">384</td><td class="line">	<span class='keyword'>return</span> wrongcaplen;</td></tr>
<tr class="codeline" data-linenumber="385"><td class="num" id="LN385">385</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="386"><td class="num" id="LN386">386</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="387"><td class="num" id="LN387">387</td><td class="line">    <span class='keyword'>return</span> (<span class='keyword'>int</span>)(mi.mi_end - ptr);</td></tr>
<tr class="codeline" data-linenumber="388"><td class="num" id="LN388">388</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="389"><td class="num" id="LN389">389</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="390"><td class="num" id="LN390">390</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="391"><td class="num" id="LN391">391</td><td class="line"> <span class='comment'>* Check if the word at "mip-&gt;mi_word" is in the tree.</span></td></tr>
<tr class="codeline" data-linenumber="392"><td class="num" id="LN392">392</td><td class="line"> <span class='comment'>* When "mode" is FIND_FOLDWORD check in fold-case word tree.</span></td></tr>
<tr class="codeline" data-linenumber="393"><td class="num" id="LN393">393</td><td class="line"> <span class='comment'>* When "mode" is FIND_KEEPWORD check in keep-case word tree.</span></td></tr>
<tr class="codeline" data-linenumber="394"><td class="num" id="LN394">394</td><td class="line"> <span class='comment'>* When "mode" is FIND_PREFIX check for word after prefix in fold-case word</span></td></tr>
<tr class="codeline" data-linenumber="395"><td class="num" id="LN395">395</td><td class="line"> <span class='comment'>* tree.</span></td></tr>
<tr class="codeline" data-linenumber="396"><td class="num" id="LN396">396</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="397"><td class="num" id="LN397">397</td><td class="line"> <span class='comment'>* For a match mip-&gt;mi_result is updated.</span></td></tr>
<tr class="codeline" data-linenumber="398"><td class="num" id="LN398">398</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="399"><td class="num" id="LN399">399</td><td class="line">    <span class='keyword'>static</span> <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="400"><td class="num" id="LN400">400</td><td class="line">find_word(matchinf_T *mip, <span class='keyword'>int</span> mode)</td></tr>
<tr class="codeline" data-linenumber="401"><td class="num" id="LN401">401</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="402"><td class="num" id="LN402">402</td><td class="line">    idx_T	arridx = 0;</td></tr>
<tr class="codeline" data-linenumber="403"><td class="num" id="LN403">403</td><td class="line">    <span class='keyword'>int</span>		endlen[<span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>];    <span class='comment'>// length at possible word endings</span></td></tr>
<tr class="codeline" data-linenumber="404"><td class="num" id="LN404">404</td><td class="line">    idx_T	endidx[<span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>];    <span class='comment'>// possible word endings</span></td></tr>
<tr class="codeline" data-linenumber="405"><td class="num" id="LN405">405</td><td class="line">    <span class='keyword'>int</span>		endidxcnt = 0;</td></tr>
<tr class="codeline" data-linenumber="406"><td class="num" id="LN406">406</td><td class="line">    <span class='keyword'>int</span>		len;</td></tr>
<tr class="codeline" data-linenumber="407"><td class="num" id="LN407">407</td><td class="line">    <span class='keyword'>int</span>		wlen = 0;</td></tr>
<tr class="codeline" data-linenumber="408"><td class="num" id="LN408">408</td><td class="line">    <span class='keyword'>int</span>		flen;</td></tr>
<tr class="codeline" data-linenumber="409"><td class="num" id="LN409">409</td><td class="line">    <span class='keyword'>int</span>		c;</td></tr>
<tr class="codeline" data-linenumber="410"><td class="num" id="LN410">410</td><td class="line">    char_u	*ptr;</td></tr>
<tr class="codeline" data-linenumber="411"><td class="num" id="LN411">411</td><td class="line">    idx_T	lo, hi, m;</td></tr>
<tr class="codeline" data-linenumber="412"><td class="num" id="LN412">412</td><td class="line">    char_u	*s;</td></tr>
<tr class="codeline" data-linenumber="413"><td class="num" id="LN413">413</td><td class="line">    char_u	*p;</td></tr>
<tr class="codeline" data-linenumber="414"><td class="num" id="LN414">414</td><td class="line">    <span class='keyword'>int</span>		res = <span class='macro'>SP_BAD<span class='macro_popup'>3</span></span>;</td></tr>
<tr class="codeline" data-linenumber="415"><td class="num" id="LN415">415</td><td class="line">    slang_T	*slang = mip-&gt;mi_lp-&gt;lp_slang;</td></tr>
<tr class="codeline" data-linenumber="416"><td class="num" id="LN416">416</td><td class="line">    <span class='keyword'>unsigned</span>	flags;</td></tr>
<tr class="codeline" data-linenumber="417"><td class="num" id="LN417">417</td><td class="line">    char_u	*byts;</td></tr>
<tr class="codeline" data-linenumber="418"><td class="num" id="LN418">418</td><td class="line">    idx_T	*idxs;</td></tr>
<tr class="codeline" data-linenumber="419"><td class="num" id="LN419">419</td><td class="line">    <span class='keyword'>int</span>		word_ends;</td></tr>
<tr class="codeline" data-linenumber="420"><td class="num" id="LN420">420</td><td class="line">    <span class='keyword'>int</span>		prefix_found;</td></tr>
<tr class="codeline" data-linenumber="421"><td class="num" id="LN421">421</td><td class="line">    <span class='keyword'>int</span>		nobreak_result;</td></tr>
<tr class="codeline" data-linenumber="422"><td class="num" id="LN422">422</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="423"><td class="num" id="LN423">423</td><td class="line">    <span class='keyword'>if</span> (mode == <span class='macro'>FIND_KEEPWORD<span class='macro_popup'>1</span></span> || mode == <span class='macro'>FIND_KEEPCOMPOUND<span class='macro_popup'>4</span></span>)</td></tr>
<tr class="codeline" data-linenumber="424"><td class="num" id="LN424">424</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="425"><td class="num" id="LN425">425</td><td class="line">	<span class='comment'>// Check for word with matching case in keep-case tree.</span></td></tr>
<tr class="codeline" data-linenumber="426"><td class="num" id="LN426">426</td><td class="line">	ptr = mip-&gt;mi_word;</td></tr>
<tr class="codeline" data-linenumber="427"><td class="num" id="LN427">427</td><td class="line">	flen = 9999;		    <span class='comment'>// no case folding, always enough bytes</span></td></tr>
<tr class="codeline" data-linenumber="428"><td class="num" id="LN428">428</td><td class="line">	byts = slang-&gt;sl_kbyts;</td></tr>
<tr class="codeline" data-linenumber="429"><td class="num" id="LN429">429</td><td class="line">	idxs = slang-&gt;sl_kidxs;</td></tr>
<tr class="codeline" data-linenumber="430"><td class="num" id="LN430">430</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="431"><td class="num" id="LN431">431</td><td class="line">	<span class='keyword'>if</span> (mode == <span class='macro'>FIND_KEEPCOMPOUND<span class='macro_popup'>4</span></span>)</td></tr>
<tr class="codeline" data-linenumber="432"><td class="num" id="LN432">432</td><td class="line">	    <span class='comment'>// Skip over the previously found word(s).</span></td></tr>
<tr class="codeline" data-linenumber="433"><td class="num" id="LN433">433</td><td class="line">	    wlen += mip-&gt;mi_compoff;</td></tr>
<tr class="codeline" data-linenumber="434"><td class="num" id="LN434">434</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="435"><td class="num" id="LN435">435</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="436"><td class="num" id="LN436">436</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="437"><td class="num" id="LN437">437</td><td class="line">	<span class='comment'>// Check for case-folded in case-folded tree.</span></td></tr>
<tr class="codeline" data-linenumber="438"><td class="num" id="LN438">438</td><td class="line">	ptr = mip-&gt;mi_fword;</td></tr>
<tr class="codeline" data-linenumber="439"><td class="num" id="LN439">439</td><td class="line">	flen = mip-&gt;mi_fwordlen;    <span class='comment'>// available case-folded bytes</span></td></tr>
<tr class="codeline" data-linenumber="440"><td class="num" id="LN440">440</td><td class="line">	byts = slang-&gt;sl_fbyts;</td></tr>
<tr class="codeline" data-linenumber="441"><td class="num" id="LN441">441</td><td class="line">	idxs = slang-&gt;sl_fidxs;</td></tr>
<tr class="codeline" data-linenumber="442"><td class="num" id="LN442">442</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="443"><td class="num" id="LN443">443</td><td class="line">	<span class='keyword'>if</span> (mode == <span class='macro'>FIND_PREFIX<span class='macro_popup'>2</span></span>)</td></tr>
<tr class="codeline" data-linenumber="444"><td class="num" id="LN444">444</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="445"><td class="num" id="LN445">445</td><td class="line">	    <span class='comment'>// Skip over the prefix.</span></td></tr>
<tr class="codeline" data-linenumber="446"><td class="num" id="LN446">446</td><td class="line">	    wlen = mip-&gt;mi_prefixlen;</td></tr>
<tr class="codeline" data-linenumber="447"><td class="num" id="LN447">447</td><td class="line">	    flen -= mip-&gt;mi_prefixlen;</td></tr>
<tr class="codeline" data-linenumber="448"><td class="num" id="LN448">448</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="449"><td class="num" id="LN449">449</td><td class="line">	<span class='keyword'>else</span> <span class='keyword'>if</span> (mode == <span class='macro'>FIND_COMPOUND<span class='macro_popup'>3</span></span>)</td></tr>
<tr class="codeline" data-linenumber="450"><td class="num" id="LN450">450</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="451"><td class="num" id="LN451">451</td><td class="line">	    <span class='comment'>// Skip over the previously found word(s).</span></td></tr>
<tr class="codeline" data-linenumber="452"><td class="num" id="LN452">452</td><td class="line">	    wlen = mip-&gt;mi_compoff;</td></tr>
<tr class="codeline" data-linenumber="453"><td class="num" id="LN453">453</td><td class="line">	    flen -= mip-&gt;mi_compoff;</td></tr>
<tr class="codeline" data-linenumber="454"><td class="num" id="LN454">454</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="455"><td class="num" id="LN455">455</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="456"><td class="num" id="LN456">456</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="457"><td class="num" id="LN457">457</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="458"><td class="num" id="LN458">458</td><td class="line">    <span class='keyword'>if</span> (byts == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="459"><td class="num" id="LN459">459</td><td class="line">	<span class='keyword'>return</span>;			<span class='comment'>// array is empty</span></td></tr>
<tr class="codeline" data-linenumber="460"><td class="num" id="LN460">460</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="461"><td class="num" id="LN461">461</td><td class="line">    <span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="462"><td class="num" id="LN462">462</td><td class="line">     <span class='comment'>* Repeat advancing in the tree until:</span></td></tr>
<tr class="codeline" data-linenumber="463"><td class="num" id="LN463">463</td><td class="line">     <span class='comment'>* - there is a byte that doesn't match,</span></td></tr>
<tr class="codeline" data-linenumber="464"><td class="num" id="LN464">464</td><td class="line">     <span class='comment'>* - we reach the end of the tree,</span></td></tr>
<tr class="codeline" data-linenumber="465"><td class="num" id="LN465">465</td><td class="line">     <span class='comment'>* - or we reach the end of the line.</span></td></tr>
<tr class="codeline" data-linenumber="466"><td class="num" id="LN466">466</td><td class="line">     <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="467"><td class="num" id="LN467">467</td><td class="line">    <span class='keyword'>for</span> (;;)</td></tr>
<tr class="codeline" data-linenumber="468"><td class="num" id="LN468">468</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="469"><td class="num" id="LN469">469</td><td class="line">	<span class='keyword'>if</span> (flen &lt;= 0 &amp;&amp; *mip-&gt;mi_fend != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="470"><td class="num" id="LN470">470</td><td class="line">	    flen = fold_more(mip);</td></tr>
<tr class="codeline" data-linenumber="471"><td class="num" id="LN471">471</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="472"><td class="num" id="LN472">472</td><td class="line">	len = byts[arridx++];</td></tr>
<tr class="codeline" data-linenumber="473"><td class="num" id="LN473">473</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="474"><td class="num" id="LN474">474</td><td class="line">	<span class='comment'>// If the first possible byte is a zero the word could end here.</span></td></tr>
<tr class="codeline" data-linenumber="475"><td class="num" id="LN475">475</td><td class="line">	<span class='comment'>// Remember this index, we first check for the longest word.</span></td></tr>
<tr class="codeline" data-linenumber="476"><td class="num" id="LN476">476</td><td class="line">	<span class='keyword'>if</span> (byts[arridx] == 0)</td></tr>
<tr class="codeline" data-linenumber="477"><td class="num" id="LN477">477</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="478"><td class="num" id="LN478">478</td><td class="line">	    <span class='keyword'>if</span> (endidxcnt == <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>)</td></tr>
<tr class="codeline" data-linenumber="479"><td class="num" id="LN479">479</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="480"><td class="num" id="LN480">480</td><td class="line">		<span class='comment'>// Must be a corrupted spell file.</span></td></tr>
<tr class="codeline" data-linenumber="481"><td class="num" id="LN481">481</td><td class="line">		emsg(<span class='macro'>_(e_format)<span class='macro_popup'>dcgettext (((void*)0), (char *)(e_format), 5)</span></span>);</td></tr>
<tr class="codeline" data-linenumber="482"><td class="num" id="LN482">482</td><td class="line">		<span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="483"><td class="num" id="LN483">483</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="484"><td class="num" id="LN484">484</td><td class="line">	    endlen[endidxcnt] = wlen;</td></tr>
<tr class="codeline" data-linenumber="485"><td class="num" id="LN485">485</td><td class="line">	    endidx[endidxcnt++] = arridx++;</td></tr>
<tr class="codeline" data-linenumber="486"><td class="num" id="LN486">486</td><td class="line">	    --len;</td></tr>
<tr class="codeline" data-linenumber="487"><td class="num" id="LN487">487</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="488"><td class="num" id="LN488">488</td><td class="line">	    <span class='comment'>// Skip over the zeros, there can be several flag/region</span></td></tr>
<tr class="codeline" data-linenumber="489"><td class="num" id="LN489">489</td><td class="line">	    <span class='comment'>// combinations.</span></td></tr>
<tr class="codeline" data-linenumber="490"><td class="num" id="LN490">490</td><td class="line">	    <span class='keyword'>while</span> (len &gt; 0 &amp;&amp; byts[arridx] == 0)</td></tr>
<tr class="codeline" data-linenumber="491"><td class="num" id="LN491">491</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="492"><td class="num" id="LN492">492</td><td class="line">		++arridx;</td></tr>
<tr class="codeline" data-linenumber="493"><td class="num" id="LN493">493</td><td class="line">		--len;</td></tr>
<tr class="codeline" data-linenumber="494"><td class="num" id="LN494">494</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="495"><td class="num" id="LN495">495</td><td class="line">	    <span class='keyword'>if</span> (len == 0)</td></tr>
<tr class="codeline" data-linenumber="496"><td class="num" id="LN496">496</td><td class="line">		<span class='keyword'>break</span>;	    <span class='comment'>// no children, word must end here</span></td></tr>
<tr class="codeline" data-linenumber="497"><td class="num" id="LN497">497</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="498"><td class="num" id="LN498">498</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="499"><td class="num" id="LN499">499</td><td class="line">	<span class='comment'>// Stop looking at end of the line.</span></td></tr>
<tr class="codeline" data-linenumber="500"><td class="num" id="LN500">500</td><td class="line">	<span class='keyword'>if</span> (ptr[wlen] == <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="501"><td class="num" id="LN501">501</td><td class="line">	    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="502"><td class="num" id="LN502">502</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="503"><td class="num" id="LN503">503</td><td class="line">	<span class='comment'>// Perform a binary search in the list of accepted bytes.</span></td></tr>
<tr class="codeline" data-linenumber="504"><td class="num" id="LN504">504</td><td class="line">	c = ptr[wlen];</td></tr>
<tr class="codeline" data-linenumber="505"><td class="num" id="LN505">505</td><td class="line">	<span class='keyword'>if</span> (c == <span class='macro'>TAB<span class='macro_popup'>'\011'</span></span>)	    <span class='comment'>// &lt;Tab&gt; is handled like &lt;Space&gt;</span></td></tr>
<tr class="codeline" data-linenumber="506"><td class="num" id="LN506">506</td><td class="line">	    c = ' ';</td></tr>
<tr class="codeline" data-linenumber="507"><td class="num" id="LN507">507</td><td class="line">	lo = arridx;</td></tr>
<tr class="codeline" data-linenumber="508"><td class="num" id="LN508">508</td><td class="line">	hi = arridx + len - 1;</td></tr>
<tr class="codeline" data-linenumber="509"><td class="num" id="LN509">509</td><td class="line">	<span class='keyword'>while</span> (lo &lt; hi)</td></tr>
<tr class="codeline" data-linenumber="510"><td class="num" id="LN510">510</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="511"><td class="num" id="LN511">511</td><td class="line">	    m = (lo + hi) / 2;</td></tr>
<tr class="codeline" data-linenumber="512"><td class="num" id="LN512">512</td><td class="line">	    <span class='keyword'>if</span> (byts[m] &gt; c)</td></tr>
<tr class="codeline" data-linenumber="513"><td class="num" id="LN513">513</td><td class="line">		hi = m - 1;</td></tr>
<tr class="codeline" data-linenumber="514"><td class="num" id="LN514">514</td><td class="line">	    <span class='keyword'>else</span> <span class='keyword'>if</span> (byts[m] &lt; c)</td></tr>
<tr class="codeline" data-linenumber="515"><td class="num" id="LN515">515</td><td class="line">		lo = m + 1;</td></tr>
<tr class="codeline" data-linenumber="516"><td class="num" id="LN516">516</td><td class="line">	    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="517"><td class="num" id="LN517">517</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="518"><td class="num" id="LN518">518</td><td class="line">		lo = hi = m;</td></tr>
<tr class="codeline" data-linenumber="519"><td class="num" id="LN519">519</td><td class="line">		<span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="520"><td class="num" id="LN520">520</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="521"><td class="num" id="LN521">521</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="522"><td class="num" id="LN522">522</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="523"><td class="num" id="LN523">523</td><td class="line">	<span class='comment'>// Stop if there is no matching byte.</span></td></tr>
<tr class="codeline" data-linenumber="524"><td class="num" id="LN524">524</td><td class="line">	<span class='keyword'>if</span> (hi &lt; lo || byts[lo] != c)</td></tr>
<tr class="codeline" data-linenumber="525"><td class="num" id="LN525">525</td><td class="line">	    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="526"><td class="num" id="LN526">526</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="527"><td class="num" id="LN527">527</td><td class="line">	<span class='comment'>// Continue at the child (if there is one).</span></td></tr>
<tr class="codeline" data-linenumber="528"><td class="num" id="LN528">528</td><td class="line">	arridx = idxs[lo];</td></tr>
<tr class="codeline" data-linenumber="529"><td class="num" id="LN529">529</td><td class="line">	++wlen;</td></tr>
<tr class="codeline" data-linenumber="530"><td class="num" id="LN530">530</td><td class="line">	--flen;</td></tr>
<tr class="codeline" data-linenumber="531"><td class="num" id="LN531">531</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="532"><td class="num" id="LN532">532</td><td class="line">	<span class='comment'>// One space in the good word may stand for several spaces in the</span></td></tr>
<tr class="codeline" data-linenumber="533"><td class="num" id="LN533">533</td><td class="line">	<span class='comment'>// checked word.</span></td></tr>
<tr class="codeline" data-linenumber="534"><td class="num" id="LN534">534</td><td class="line">	<span class='keyword'>if</span> (c == ' ')</td></tr>
<tr class="codeline" data-linenumber="535"><td class="num" id="LN535">535</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="536"><td class="num" id="LN536">536</td><td class="line">	    <span class='keyword'>for</span> (;;)</td></tr>
<tr class="codeline" data-linenumber="537"><td class="num" id="LN537">537</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="538"><td class="num" id="LN538">538</td><td class="line">		<span class='keyword'>if</span> (flen &lt;= 0 &amp;&amp; *mip-&gt;mi_fend != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="539"><td class="num" id="LN539">539</td><td class="line">		    flen = fold_more(mip);</td></tr>
<tr class="codeline" data-linenumber="540"><td class="num" id="LN540">540</td><td class="line">		<span class='keyword'>if</span> (ptr[wlen] != ' ' &amp;&amp; ptr[wlen] != <span class='macro'>TAB<span class='macro_popup'>'\011'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="541"><td class="num" id="LN541">541</td><td class="line">		    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="542"><td class="num" id="LN542">542</td><td class="line">		++wlen;</td></tr>
<tr class="codeline" data-linenumber="543"><td class="num" id="LN543">543</td><td class="line">		--flen;</td></tr>
<tr class="codeline" data-linenumber="544"><td class="num" id="LN544">544</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="545"><td class="num" id="LN545">545</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="546"><td class="num" id="LN546">546</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="547"><td class="num" id="LN547">547</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="548"><td class="num" id="LN548">548</td><td class="line">    <span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="549"><td class="num" id="LN549">549</td><td class="line">     <span class='comment'>* Verify that one of the possible endings is valid.  Try the longest</span></td></tr>
<tr class="codeline" data-linenumber="550"><td class="num" id="LN550">550</td><td class="line">     <span class='comment'>* first.</span></td></tr>
<tr class="codeline" data-linenumber="551"><td class="num" id="LN551">551</td><td class="line">     <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="552"><td class="num" id="LN552">552</td><td class="line">    <span class='keyword'>while</span> (endidxcnt &gt; 0)</td></tr>
<tr class="codeline" data-linenumber="553"><td class="num" id="LN553">553</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="554"><td class="num" id="LN554">554</td><td class="line">	--endidxcnt;</td></tr>
<tr class="codeline" data-linenumber="555"><td class="num" id="LN555">555</td><td class="line">	arridx = endidx[endidxcnt];</td></tr>
<tr class="codeline" data-linenumber="556"><td class="num" id="LN556">556</td><td class="line">	wlen = endlen[endidxcnt];</td></tr>
<tr class="codeline" data-linenumber="557"><td class="num" id="LN557">557</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="558"><td class="num" id="LN558">558</td><td class="line">	<span class='keyword'>if</span> ((*mb_head_off)(ptr, ptr + wlen) &gt; 0)</td></tr>
<tr class="codeline" data-linenumber="559"><td class="num" id="LN559">559</td><td class="line">	    <span class='keyword'>continue</span>;	    <span class='comment'>// not at first byte of character</span></td></tr>
<tr class="codeline" data-linenumber="560"><td class="num" id="LN560">560</td><td class="line">	<span class='keyword'>if</span> (spell_iswordp(ptr + wlen, mip-&gt;mi_win))</td></tr>
<tr class="codeline" data-linenumber="561"><td class="num" id="LN561">561</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="562"><td class="num" id="LN562">562</td><td class="line">	    <span class='keyword'>if</span> (slang-&gt;sl_compprog == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span> &amp;&amp; !slang-&gt;sl_nobreak)</td></tr>
<tr class="codeline" data-linenumber="563"><td class="num" id="LN563">563</td><td class="line">		<span class='keyword'>continue</span>;	    <span class='comment'>// next char is a word character</span></td></tr>
<tr class="codeline" data-linenumber="564"><td class="num" id="LN564">564</td><td class="line">	    word_ends = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="565"><td class="num" id="LN565">565</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="566"><td class="num" id="LN566">566</td><td class="line">	<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="567"><td class="num" id="LN567">567</td><td class="line">	    word_ends = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="568"><td class="num" id="LN568">568</td><td class="line">	<span class='comment'>// The prefix flag is before compound flags.  Once a valid prefix flag</span></td></tr>
<tr class="codeline" data-linenumber="569"><td class="num" id="LN569">569</td><td class="line">	<span class='comment'>// has been found we try compound flags.</span></td></tr>
<tr class="codeline" data-linenumber="570"><td class="num" id="LN570">570</td><td class="line">	prefix_found = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="571"><td class="num" id="LN571">571</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="572"><td class="num" id="LN572">572</td><td class="line">	<span class='keyword'>if</span> (mode != <span class='macro'>FIND_KEEPWORD<span class='macro_popup'>1</span></span> &amp;&amp; has_mbyte)</td></tr>
<tr class="codeline" data-linenumber="573"><td class="num" id="LN573">573</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="574"><td class="num" id="LN574">574</td><td class="line">	    <span class='comment'>// Compute byte length in original word, length may change</span></td></tr>
<tr class="codeline" data-linenumber="575"><td class="num" id="LN575">575</td><td class="line">	    <span class='comment'>// when folding case.  This can be slow, take a shortcut when the</span></td></tr>
<tr class="codeline" data-linenumber="576"><td class="num" id="LN576">576</td><td class="line">	    <span class='comment'>// case-folded word is equal to the keep-case word.</span></td></tr>
<tr class="codeline" data-linenumber="577"><td class="num" id="LN577">577</td><td class="line">	    p = mip-&gt;mi_word;</td></tr>
<tr class="codeline" data-linenumber="578"><td class="num" id="LN578">578</td><td class="line">	    <span class='keyword'>if</span> (<span class='macro'>STRNCMP(ptr, p, wlen)<span class='macro_popup'>strncmp((char *)(ptr), (char *)(p), (size_t)(wlen))</span></span> != 0)</td></tr>
<tr class="codeline" data-linenumber="579"><td class="num" id="LN579">579</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="580"><td class="num" id="LN580">580</td><td class="line">		<span class='keyword'>for</span> (s = ptr; s &lt; ptr + wlen; <span class='macro'>MB_PTR_ADV(s)<span class='macro_popup'>s += (*mb_ptr2len)(s)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="581"><td class="num" id="LN581">581</td><td class="line">		    <span class='macro'>MB_PTR_ADV(p)<span class='macro_popup'>p += (*mb_ptr2len)(p)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="582"><td class="num" id="LN582">582</td><td class="line">		wlen = (<span class='keyword'>int</span>)(p - mip-&gt;mi_word);</td></tr>
<tr class="codeline" data-linenumber="583"><td class="num" id="LN583">583</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="584"><td class="num" id="LN584">584</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="585"><td class="num" id="LN585">585</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="586"><td class="num" id="LN586">586</td><td class="line">	<span class='comment'>// Check flags and region.  For FIND_PREFIX check the condition and</span></td></tr>
<tr class="codeline" data-linenumber="587"><td class="num" id="LN587">587</td><td class="line">	<span class='comment'>// prefix ID.</span></td></tr>
<tr class="codeline" data-linenumber="588"><td class="num" id="LN588">588</td><td class="line">	<span class='comment'>// Repeat this if there are more flags/region alternatives until there</span></td></tr>
<tr class="codeline" data-linenumber="589"><td class="num" id="LN589">589</td><td class="line">	<span class='comment'>// is a match.</span></td></tr>
<tr class="codeline" data-linenumber="590"><td class="num" id="LN590">590</td><td class="line">	res = <span class='macro'>SP_BAD<span class='macro_popup'>3</span></span>;</td></tr>
<tr class="codeline" data-linenumber="591"><td class="num" id="LN591">591</td><td class="line">	<span class='keyword'>for</span> (len = byts[arridx - 1]; len &gt; 0 &amp;&amp; byts[arridx] == 0;</td></tr>
<tr class="codeline" data-linenumber="592"><td class="num" id="LN592">592</td><td class="line">							      --len, ++arridx)</td></tr>
<tr class="codeline" data-linenumber="593"><td class="num" id="LN593">593</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="594"><td class="num" id="LN594">594</td><td class="line">	    flags = idxs[arridx];</td></tr>
<tr class="codeline" data-linenumber="595"><td class="num" id="LN595">595</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="596"><td class="num" id="LN596">596</td><td class="line">	    <span class='comment'>// For the fold-case tree check that the case of the checked word</span></td></tr>
<tr class="codeline" data-linenumber="597"><td class="num" id="LN597">597</td><td class="line">	    <span class='comment'>// matches with what the word in the tree requires.</span></td></tr>
<tr class="codeline" data-linenumber="598"><td class="num" id="LN598">598</td><td class="line">	    <span class='comment'>// For keep-case tree the case is always right.  For prefixes we</span></td></tr>
<tr class="codeline" data-linenumber="599"><td class="num" id="LN599">599</td><td class="line">	    <span class='comment'>// don't bother to check.</span></td></tr>
<tr class="codeline" data-linenumber="600"><td class="num" id="LN600">600</td><td class="line">	    <span class='keyword'>if</span> (mode == <span class='macro'>FIND_FOLDWORD<span class='macro_popup'>0</span></span>)</td></tr>
<tr class="codeline" data-linenumber="601"><td class="num" id="LN601">601</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="602"><td class="num" id="LN602">602</td><td class="line">		<span class='keyword'>if</span> (mip-&gt;mi_cend != mip-&gt;mi_word + wlen)</td></tr>
<tr class="codeline" data-linenumber="603"><td class="num" id="LN603">603</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="604"><td class="num" id="LN604">604</td><td class="line">		    <span class='comment'>// mi_capflags was set for a different word length, need</span></td></tr>
<tr class="codeline" data-linenumber="605"><td class="num" id="LN605">605</td><td class="line">		    <span class='comment'>// to do it again.</span></td></tr>
<tr class="codeline" data-linenumber="606"><td class="num" id="LN606">606</td><td class="line">		    mip-&gt;mi_cend = mip-&gt;mi_word + wlen;</td></tr>
<tr class="codeline" data-linenumber="607"><td class="num" id="LN607">607</td><td class="line">		    mip-&gt;mi_capflags = captype(mip-&gt;mi_word, mip-&gt;mi_cend);</td></tr>
<tr class="codeline" data-linenumber="608"><td class="num" id="LN608">608</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="609"><td class="num" id="LN609">609</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="610"><td class="num" id="LN610">610</td><td class="line">		<span class='keyword'>if</span> (mip-&gt;mi_capflags == <span class='macro'>WF_KEEPCAP<span class='macro_popup'>0x80</span></span></td></tr>
<tr class="codeline" data-linenumber="611"><td class="num" id="LN611">611</td><td class="line">				|| !spell_valid_case(mip-&gt;mi_capflags, flags))</td></tr>
<tr class="codeline" data-linenumber="612"><td class="num" id="LN612">612</td><td class="line">		    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="613"><td class="num" id="LN613">613</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="614"><td class="num" id="LN614">614</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="615"><td class="num" id="LN615">615</td><td class="line">	    <span class='comment'>// When mode is FIND_PREFIX the word must support the prefix:</span></td></tr>
<tr class="codeline" data-linenumber="616"><td class="num" id="LN616">616</td><td class="line">	    <span class='comment'>// check the prefix ID and the condition.  Do that for the list at</span></td></tr>
<tr class="codeline" data-linenumber="617"><td class="num" id="LN617">617</td><td class="line">	    <span class='comment'>// mip-&gt;mi_prefarridx that find_prefix() filled.</span></td></tr>
<tr class="codeline" data-linenumber="618"><td class="num" id="LN618">618</td><td class="line">	    <span class='keyword'>else</span> <span class='keyword'>if</span> (mode == <span class='macro'>FIND_PREFIX<span class='macro_popup'>2</span></span> &amp;&amp; !prefix_found)</td></tr>
<tr class="codeline" data-linenumber="619"><td class="num" id="LN619">619</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="620"><td class="num" id="LN620">620</td><td class="line">		c = valid_word_prefix(mip-&gt;mi_prefcnt, mip-&gt;mi_prefarridx,</td></tr>
<tr class="codeline" data-linenumber="621"><td class="num" id="LN621">621</td><td class="line">				    flags,</td></tr>
<tr class="codeline" data-linenumber="622"><td class="num" id="LN622">622</td><td class="line">				    mip-&gt;mi_word + mip-&gt;mi_cprefixlen, slang,</td></tr>
<tr class="codeline" data-linenumber="623"><td class="num" id="LN623">623</td><td class="line">				    <span class='macro'>FALSE<span class='macro_popup'>0</span></span>);</td></tr>
<tr class="codeline" data-linenumber="624"><td class="num" id="LN624">624</td><td class="line">		<span class='keyword'>if</span> (c == 0)</td></tr>
<tr class="codeline" data-linenumber="625"><td class="num" id="LN625">625</td><td class="line">		    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="626"><td class="num" id="LN626">626</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="627"><td class="num" id="LN627">627</td><td class="line">		<span class='comment'>// Use the WF_RARE flag for a rare prefix.</span></td></tr>
<tr class="codeline" data-linenumber="628"><td class="num" id="LN628">628</td><td class="line">		<span class='keyword'>if</span> (c &amp; <span class='macro'>WF_RAREPFX<span class='macro_popup'>(0x01 &lt;&lt; 24)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="629"><td class="num" id="LN629">629</td><td class="line">		    flags |= <span class='macro'>WF_RARE<span class='macro_popup'>0x08</span></span>;</td></tr>
<tr class="codeline" data-linenumber="630"><td class="num" id="LN630">630</td><td class="line">		prefix_found = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="631"><td class="num" id="LN631">631</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="632"><td class="num" id="LN632">632</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="633"><td class="num" id="LN633">633</td><td class="line">	    <span class='keyword'>if</span> (slang-&gt;sl_nobreak)</td></tr>
<tr class="codeline" data-linenumber="634"><td class="num" id="LN634">634</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="635"><td class="num" id="LN635">635</td><td class="line">		<span class='keyword'>if</span> ((mode == <span class='macro'>FIND_COMPOUND<span class='macro_popup'>3</span></span> || mode == <span class='macro'>FIND_KEEPCOMPOUND<span class='macro_popup'>4</span></span>)</td></tr>
<tr class="codeline" data-linenumber="636"><td class="num" id="LN636">636</td><td class="line">			&amp;&amp; (flags &amp; <span class='macro'>WF_BANNED<span class='macro_popup'>0x10</span></span>) == 0)</td></tr>
<tr class="codeline" data-linenumber="637"><td class="num" id="LN637">637</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="638"><td class="num" id="LN638">638</td><td class="line">		    <span class='comment'>// NOBREAK: found a valid following word.  That's all we</span></td></tr>
<tr class="codeline" data-linenumber="639"><td class="num" id="LN639">639</td><td class="line">		    <span class='comment'>// need to know, so return.</span></td></tr>
<tr class="codeline" data-linenumber="640"><td class="num" id="LN640">640</td><td class="line">		    mip-&gt;mi_result = <span class='macro'>SP_OK<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="641"><td class="num" id="LN641">641</td><td class="line">		    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="642"><td class="num" id="LN642">642</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="643"><td class="num" id="LN643">643</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="644"><td class="num" id="LN644">644</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="645"><td class="num" id="LN645">645</td><td class="line">	    <span class='keyword'>else</span> <span class='keyword'>if</span> ((mode == <span class='macro'>FIND_COMPOUND<span class='macro_popup'>3</span></span> || mode == <span class='macro'>FIND_KEEPCOMPOUND<span class='macro_popup'>4</span></span></td></tr>
<tr class="codeline" data-linenumber="646"><td class="num" id="LN646">646</td><td class="line">								|| !word_ends))</td></tr>
<tr class="codeline" data-linenumber="647"><td class="num" id="LN647">647</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="648"><td class="num" id="LN648">648</td><td class="line">		<span class='comment'>// If there is no compound flag or the word is shorter than</span></td></tr>
<tr class="codeline" data-linenumber="649"><td class="num" id="LN649">649</td><td class="line">		<span class='comment'>// COMPOUNDMIN reject it quickly.</span></td></tr>
<tr class="codeline" data-linenumber="650"><td class="num" id="LN650">650</td><td class="line">		<span class='comment'>// Makes you wonder why someone puts a compound flag on a word</span></td></tr>
<tr class="codeline" data-linenumber="651"><td class="num" id="LN651">651</td><td class="line">		<span class='comment'>// that's too short...  Myspell compatibility requires this</span></td></tr>
<tr class="codeline" data-linenumber="652"><td class="num" id="LN652">652</td><td class="line">		<span class='comment'>// anyway.</span></td></tr>
<tr class="codeline" data-linenumber="653"><td class="num" id="LN653">653</td><td class="line">		<span class='keyword'>if</span> (((<span class='keyword'>unsigned</span>)flags &gt;&gt; 24) == 0</td></tr>
<tr class="codeline" data-linenumber="654"><td class="num" id="LN654">654</td><td class="line">			     || wlen - mip-&gt;mi_compoff &lt; slang-&gt;sl_compminlen)</td></tr>
<tr class="codeline" data-linenumber="655"><td class="num" id="LN655">655</td><td class="line">		    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="656"><td class="num" id="LN656">656</td><td class="line">		<span class='comment'>// For multi-byte chars check character length against</span></td></tr>
<tr class="codeline" data-linenumber="657"><td class="num" id="LN657">657</td><td class="line">		<span class='comment'>// COMPOUNDMIN.</span></td></tr>
<tr class="codeline" data-linenumber="658"><td class="num" id="LN658">658</td><td class="line">		<span class='keyword'>if</span> (has_mbyte</td></tr>
<tr class="codeline" data-linenumber="659"><td class="num" id="LN659">659</td><td class="line">			&amp;&amp; slang-&gt;sl_compminlen &gt; 0</td></tr>
<tr class="codeline" data-linenumber="660"><td class="num" id="LN660">660</td><td class="line">			&amp;&amp; mb_charlen_len(mip-&gt;mi_word + mip-&gt;mi_compoff,</td></tr>
<tr class="codeline" data-linenumber="661"><td class="num" id="LN661">661</td><td class="line">				wlen - mip-&gt;mi_compoff) &lt; slang-&gt;sl_compminlen)</td></tr>
<tr class="codeline" data-linenumber="662"><td class="num" id="LN662">662</td><td class="line">			<span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="663"><td class="num" id="LN663">663</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="664"><td class="num" id="LN664">664</td><td class="line">		<span class='comment'>// Limit the number of compound words to COMPOUNDWORDMAX if no</span></td></tr>
<tr class="codeline" data-linenumber="665"><td class="num" id="LN665">665</td><td class="line">		<span class='comment'>// maximum for syllables is specified.</span></td></tr>
<tr class="codeline" data-linenumber="666"><td class="num" id="LN666">666</td><td class="line">		<span class='keyword'>if</span> (!word_ends &amp;&amp; mip-&gt;mi_complen + mip-&gt;mi_compextra + 2</td></tr>
<tr class="codeline" data-linenumber="667"><td class="num" id="LN667">667</td><td class="line">							   &gt; slang-&gt;sl_compmax</td></tr>
<tr class="codeline" data-linenumber="668"><td class="num" id="LN668">668</td><td class="line">					   &amp;&amp; slang-&gt;sl_compsylmax == <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>)</td></tr>
<tr class="codeline" data-linenumber="669"><td class="num" id="LN669">669</td><td class="line">		    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="670"><td class="num" id="LN670">670</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="671"><td class="num" id="LN671">671</td><td class="line">		<span class='comment'>// Don't allow compounding on a side where an affix was added,</span></td></tr>
<tr class="codeline" data-linenumber="672"><td class="num" id="LN672">672</td><td class="line">		<span class='comment'>// unless COMPOUNDPERMITFLAG was used.</span></td></tr>
<tr class="codeline" data-linenumber="673"><td class="num" id="LN673">673</td><td class="line">		<span class='keyword'>if</span> (mip-&gt;mi_complen &gt; 0 &amp;&amp; (flags &amp; <span class='macro'>WF_NOCOMPBEF<span class='macro_popup'>0x1000</span></span>))</td></tr>
<tr class="codeline" data-linenumber="674"><td class="num" id="LN674">674</td><td class="line">		    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="675"><td class="num" id="LN675">675</td><td class="line">		<span class='keyword'>if</span> (!word_ends &amp;&amp; (flags &amp; <span class='macro'>WF_NOCOMPAFT<span class='macro_popup'>0x2000</span></span>))</td></tr>
<tr class="codeline" data-linenumber="676"><td class="num" id="LN676">676</td><td class="line">		    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="677"><td class="num" id="LN677">677</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="678"><td class="num" id="LN678">678</td><td class="line">		<span class='comment'>// Quickly check if compounding is possible with this flag.</span></td></tr>
<tr class="codeline" data-linenumber="679"><td class="num" id="LN679">679</td><td class="line">		<span class='keyword'>if</span> (!byte_in_str(mip-&gt;mi_complen == 0</td></tr>
<tr class="codeline" data-linenumber="680"><td class="num" id="LN680">680</td><td class="line">					? slang-&gt;sl_compstartflags</td></tr>
<tr class="codeline" data-linenumber="681"><td class="num" id="LN681">681</td><td class="line">					: slang-&gt;sl_compallflags,</td></tr>
<tr class="codeline" data-linenumber="682"><td class="num" id="LN682">682</td><td class="line">					    ((<span class='keyword'>unsigned</span>)flags &gt;&gt; 24)))</td></tr>
<tr class="codeline" data-linenumber="683"><td class="num" id="LN683">683</td><td class="line">		    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="684"><td class="num" id="LN684">684</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="685"><td class="num" id="LN685">685</td><td class="line">		<span class='comment'>// If there is a match with a CHECKCOMPOUNDPATTERN rule</span></td></tr>
<tr class="codeline" data-linenumber="686"><td class="num" id="LN686">686</td><td class="line">		<span class='comment'>// discard the compound word.</span></td></tr>
<tr class="codeline" data-linenumber="687"><td class="num" id="LN687">687</td><td class="line">		<span class='keyword'>if</span> (match_checkcompoundpattern(ptr, wlen, &amp;slang-&gt;sl_comppat))</td></tr>
<tr class="codeline" data-linenumber="688"><td class="num" id="LN688">688</td><td class="line">		    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="689"><td class="num" id="LN689">689</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="690"><td class="num" id="LN690">690</td><td class="line">		<span class='keyword'>if</span> (mode == <span class='macro'>FIND_COMPOUND<span class='macro_popup'>3</span></span>)</td></tr>
<tr class="codeline" data-linenumber="691"><td class="num" id="LN691">691</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="692"><td class="num" id="LN692">692</td><td class="line">		    <span class='keyword'>int</span>	    capflags;</td></tr>
<tr class="codeline" data-linenumber="693"><td class="num" id="LN693">693</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="694"><td class="num" id="LN694">694</td><td class="line">		    <span class='comment'>// Need to check the caps type of the appended compound</span></td></tr>
<tr class="codeline" data-linenumber="695"><td class="num" id="LN695">695</td><td class="line">		    <span class='comment'>// word.</span></td></tr>
<tr class="codeline" data-linenumber="696"><td class="num" id="LN696">696</td><td class="line">		    <span class='keyword'>if</span> (has_mbyte &amp;&amp; <span class='macro'>STRNCMP(ptr, mip-&gt;mi_word,<span class='macro_popup'>strncmp((char *)(ptr), (char *)(mip-&gt;mi_word), (size_t)(mip<br>-&gt;mi_compoff))</span></span></td></tr>
<tr class="codeline" data-linenumber="697"><td class="num" id="LN697">697</td><td class="line">							<span class='macro'>mip-&gt;mi_compoff)<span class='macro_popup'>strncmp((char *)(ptr), (char *)(mip-&gt;mi_word), (size_t)(mip<br>-&gt;mi_compoff))</span></span> != 0)</td></tr>
<tr class="codeline" data-linenumber="698"><td class="num" id="LN698">698</td><td class="line">		    {</td></tr>
<tr class="codeline" data-linenumber="699"><td class="num" id="LN699">699</td><td class="line">			<span class='comment'>// case folding may have changed the length</span></td></tr>
<tr class="codeline" data-linenumber="700"><td class="num" id="LN700">700</td><td class="line">			p = mip-&gt;mi_word;</td></tr>
<tr class="codeline" data-linenumber="701"><td class="num" id="LN701">701</td><td class="line">			<span class='keyword'>for</span> (s = ptr; s &lt; ptr + mip-&gt;mi_compoff; <span class='macro'>MB_PTR_ADV(s)<span class='macro_popup'>s += (*mb_ptr2len)(s)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="702"><td class="num" id="LN702">702</td><td class="line">			    <span class='macro'>MB_PTR_ADV(p)<span class='macro_popup'>p += (*mb_ptr2len)(p)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="703"><td class="num" id="LN703">703</td><td class="line">		    }</td></tr>
<tr class="codeline" data-linenumber="704"><td class="num" id="LN704">704</td><td class="line">		    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="705"><td class="num" id="LN705">705</td><td class="line">			p = mip-&gt;mi_word + mip-&gt;mi_compoff;</td></tr>
<tr class="codeline" data-linenumber="706"><td class="num" id="LN706">706</td><td class="line">		    capflags = captype(p, mip-&gt;mi_word + wlen);</td></tr>
<tr class="codeline" data-linenumber="707"><td class="num" id="LN707">707</td><td class="line">		    <span class='keyword'>if</span> (capflags == <span class='macro'>WF_KEEPCAP<span class='macro_popup'>0x80</span></span> || (capflags == <span class='macro'>WF_ALLCAP<span class='macro_popup'>0x04</span></span></td></tr>
<tr class="codeline" data-linenumber="708"><td class="num" id="LN708">708</td><td class="line">						 &amp;&amp; (flags &amp; <span class='macro'>WF_FIXCAP<span class='macro_popup'>0x40</span></span>) != 0))</td></tr>
<tr class="codeline" data-linenumber="709"><td class="num" id="LN709">709</td><td class="line">			<span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="710"><td class="num" id="LN710">710</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="711"><td class="num" id="LN711">711</td><td class="line">		    <span class='keyword'>if</span> (capflags != <span class='macro'>WF_ALLCAP<span class='macro_popup'>0x04</span></span>)</td></tr>
<tr class="codeline" data-linenumber="712"><td class="num" id="LN712">712</td><td class="line">		    {</td></tr>
<tr class="codeline" data-linenumber="713"><td class="num" id="LN713">713</td><td class="line">			<span class='comment'>// When the character before the word is a word</span></td></tr>
<tr class="codeline" data-linenumber="714"><td class="num" id="LN714">714</td><td class="line">			<span class='comment'>// character we do not accept a Onecap word.  We do</span></td></tr>
<tr class="codeline" data-linenumber="715"><td class="num" id="LN715">715</td><td class="line">			<span class='comment'>// accept a no-caps word, even when the dictionary</span></td></tr>
<tr class="codeline" data-linenumber="716"><td class="num" id="LN716">716</td><td class="line">			<span class='comment'>// word specifies ONECAP.</span></td></tr>
<tr class="codeline" data-linenumber="717"><td class="num" id="LN717">717</td><td class="line">			<span class='macro'>MB_PTR_BACK(mip-&gt;mi_word, p)<span class='macro_popup'>p -= has_mbyte ? ((*mb_head_off)(mip-&gt;mi_word, p - 1) + 1)<br> : 1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="718"><td class="num" id="LN718">718</td><td class="line">			<span class='keyword'>if</span> (spell_iswordp_nmw(p, mip-&gt;mi_win)</td></tr>
<tr class="codeline" data-linenumber="719"><td class="num" id="LN719">719</td><td class="line">				? capflags == <span class='macro'>WF_ONECAP<span class='macro_popup'>0x02</span></span></td></tr>
<tr class="codeline" data-linenumber="720"><td class="num" id="LN720">720</td><td class="line">				: (flags &amp; <span class='macro'>WF_ONECAP<span class='macro_popup'>0x02</span></span>) != 0</td></tr>
<tr class="codeline" data-linenumber="721"><td class="num" id="LN721">721</td><td class="line">						     &amp;&amp; capflags != <span class='macro'>WF_ONECAP<span class='macro_popup'>0x02</span></span>)</td></tr>
<tr class="codeline" data-linenumber="722"><td class="num" id="LN722">722</td><td class="line">			    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="723"><td class="num" id="LN723">723</td><td class="line">		    }</td></tr>
<tr class="codeline" data-linenumber="724"><td class="num" id="LN724">724</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="725"><td class="num" id="LN725">725</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="726"><td class="num" id="LN726">726</td><td class="line">		<span class='comment'>// If the word ends the sequence of compound flags of the</span></td></tr>
<tr class="codeline" data-linenumber="727"><td class="num" id="LN727">727</td><td class="line">		<span class='comment'>// words must match with one of the COMPOUNDRULE items and</span></td></tr>
<tr class="codeline" data-linenumber="728"><td class="num" id="LN728">728</td><td class="line">		<span class='comment'>// the number of syllables must not be too large.</span></td></tr>
<tr class="codeline" data-linenumber="729"><td class="num" id="LN729">729</td><td class="line">		mip-&gt;mi_compflags[mip-&gt;mi_complen] = ((<span class='keyword'>unsigned</span>)flags &gt;&gt; 24);</td></tr>
<tr class="codeline" data-linenumber="730"><td class="num" id="LN730">730</td><td class="line">		mip-&gt;mi_compflags[mip-&gt;mi_complen + 1] = <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>;</td></tr>
<tr class="codeline" data-linenumber="731"><td class="num" id="LN731">731</td><td class="line">		<span class='keyword'>if</span> (word_ends)</td></tr>
<tr class="codeline" data-linenumber="732"><td class="num" id="LN732">732</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="733"><td class="num" id="LN733">733</td><td class="line">		    char_u	fword[<span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>];</td></tr>
<tr class="codeline" data-linenumber="734"><td class="num" id="LN734">734</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="735"><td class="num" id="LN735">735</td><td class="line">		    <span class='keyword'>if</span> (slang-&gt;sl_compsylmax &lt; <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>)</td></tr>
<tr class="codeline" data-linenumber="736"><td class="num" id="LN736">736</td><td class="line">		    {</td></tr>
<tr class="codeline" data-linenumber="737"><td class="num" id="LN737">737</td><td class="line">			<span class='comment'>// "fword" is only needed for checking syllables.</span></td></tr>
<tr class="codeline" data-linenumber="738"><td class="num" id="LN738">738</td><td class="line">			<span class='keyword'>if</span> (ptr == mip-&gt;mi_word)</td></tr>
<tr class="codeline" data-linenumber="739"><td class="num" id="LN739">739</td><td class="line">			    (<span class='keyword'>void</span>)spell_casefold(ptr, wlen, fword, <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>);</td></tr>
<tr class="codeline" data-linenumber="740"><td class="num" id="LN740">740</td><td class="line">			<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="741"><td class="num" id="LN741">741</td><td class="line">			    vim_strncpy(fword, ptr, endlen[endidxcnt]);</td></tr>
<tr class="codeline" data-linenumber="742"><td class="num" id="LN742">742</td><td class="line">		    }</td></tr>
<tr class="codeline" data-linenumber="743"><td class="num" id="LN743">743</td><td class="line">		    <span class='keyword'>if</span> (!can_compound(slang, fword, mip-&gt;mi_compflags))</td></tr>
<tr class="codeline" data-linenumber="744"><td class="num" id="LN744">744</td><td class="line">			<span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="745"><td class="num" id="LN745">745</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="746"><td class="num" id="LN746">746</td><td class="line">		<span class='keyword'>else</span> <span class='keyword'>if</span> (slang-&gt;sl_comprules != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span></td></tr>
<tr class="codeline" data-linenumber="747"><td class="num" id="LN747">747</td><td class="line">			     &amp;&amp; !match_compoundrule(slang, mip-&gt;mi_compflags))</td></tr>
<tr class="codeline" data-linenumber="748"><td class="num" id="LN748">748</td><td class="line">		    <span class='comment'>// The compound flags collected so far do not match any</span></td></tr>
<tr class="codeline" data-linenumber="749"><td class="num" id="LN749">749</td><td class="line">		    <span class='comment'>// COMPOUNDRULE, discard the compounded word.</span></td></tr>
<tr class="codeline" data-linenumber="750"><td class="num" id="LN750">750</td><td class="line">		    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="751"><td class="num" id="LN751">751</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="752"><td class="num" id="LN752">752</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="753"><td class="num" id="LN753">753</td><td class="line">	    <span class='comment'>// Check NEEDCOMPOUND: can't use word without compounding.</span></td></tr>
<tr class="codeline" data-linenumber="754"><td class="num" id="LN754">754</td><td class="line">	    <span class='keyword'>else</span> <span class='keyword'>if</span> (flags &amp; <span class='macro'>WF_NEEDCOMP<span class='macro_popup'>0x0200</span></span>)</td></tr>
<tr class="codeline" data-linenumber="755"><td class="num" id="LN755">755</td><td class="line">		<span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="756"><td class="num" id="LN756">756</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="757"><td class="num" id="LN757">757</td><td class="line">	    nobreak_result = <span class='macro'>SP_OK<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="758"><td class="num" id="LN758">758</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="759"><td class="num" id="LN759">759</td><td class="line">	    <span class='keyword'>if</span> (!word_ends)</td></tr>
<tr class="codeline" data-linenumber="760"><td class="num" id="LN760">760</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="761"><td class="num" id="LN761">761</td><td class="line">		<span class='keyword'>int</span>	save_result = mip-&gt;mi_result;</td></tr>
<tr class="codeline" data-linenumber="762"><td class="num" id="LN762">762</td><td class="line">		char_u	*save_end = mip-&gt;mi_end;</td></tr>
<tr class="codeline" data-linenumber="763"><td class="num" id="LN763">763</td><td class="line">		langp_T	*save_lp = mip-&gt;mi_lp;</td></tr>
<tr class="codeline" data-linenumber="764"><td class="num" id="LN764">764</td><td class="line">		<span class='keyword'>int</span>	lpi;</td></tr>
<tr class="codeline" data-linenumber="765"><td class="num" id="LN765">765</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="766"><td class="num" id="LN766">766</td><td class="line">		<span class='comment'>// Check that a valid word follows.  If there is one and we</span></td></tr>
<tr class="codeline" data-linenumber="767"><td class="num" id="LN767">767</td><td class="line">		<span class='comment'>// are compounding, it will set "mi_result", thus we are</span></td></tr>
<tr class="codeline" data-linenumber="768"><td class="num" id="LN768">768</td><td class="line">		<span class='comment'>// always finished here.  For NOBREAK we only check that a</span></td></tr>
<tr class="codeline" data-linenumber="769"><td class="num" id="LN769">769</td><td class="line">		<span class='comment'>// valid word follows.</span></td></tr>
<tr class="codeline" data-linenumber="770"><td class="num" id="LN770">770</td><td class="line">		<span class='comment'>// Recursive!</span></td></tr>
<tr class="codeline" data-linenumber="771"><td class="num" id="LN771">771</td><td class="line">		<span class='keyword'>if</span> (slang-&gt;sl_nobreak)</td></tr>
<tr class="codeline" data-linenumber="772"><td class="num" id="LN772">772</td><td class="line">		    mip-&gt;mi_result = <span class='macro'>SP_BAD<span class='macro_popup'>3</span></span>;</td></tr>
<tr class="codeline" data-linenumber="773"><td class="num" id="LN773">773</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="774"><td class="num" id="LN774">774</td><td class="line">		<span class='comment'>// Find following word in case-folded tree.</span></td></tr>
<tr class="codeline" data-linenumber="775"><td class="num" id="LN775">775</td><td class="line">		mip-&gt;mi_compoff = endlen[endidxcnt];</td></tr>
<tr class="codeline" data-linenumber="776"><td class="num" id="LN776">776</td><td class="line">		<span class='keyword'>if</span> (has_mbyte &amp;&amp; mode == <span class='macro'>FIND_KEEPWORD<span class='macro_popup'>1</span></span>)</td></tr>
<tr class="codeline" data-linenumber="777"><td class="num" id="LN777">777</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="778"><td class="num" id="LN778">778</td><td class="line">		    <span class='comment'>// Compute byte length in case-folded word from "wlen":</span></td></tr>
<tr class="codeline" data-linenumber="779"><td class="num" id="LN779">779</td><td class="line">		    <span class='comment'>// byte length in keep-case word.  Length may change when</span></td></tr>
<tr class="codeline" data-linenumber="780"><td class="num" id="LN780">780</td><td class="line">		    <span class='comment'>// folding case.  This can be slow, take a shortcut when</span></td></tr>
<tr class="codeline" data-linenumber="781"><td class="num" id="LN781">781</td><td class="line">		    <span class='comment'>// the case-folded word is equal to the keep-case word.</span></td></tr>
<tr class="codeline" data-linenumber="782"><td class="num" id="LN782">782</td><td class="line">		    p = mip-&gt;mi_fword;</td></tr>
<tr class="codeline" data-linenumber="783"><td class="num" id="LN783">783</td><td class="line">		    <span class='keyword'>if</span> (<span class='macro'>STRNCMP(ptr, p, wlen)<span class='macro_popup'>strncmp((char *)(ptr), (char *)(p), (size_t)(wlen))</span></span> != 0)</td></tr>
<tr class="codeline" data-linenumber="784"><td class="num" id="LN784">784</td><td class="line">		    {</td></tr>
<tr class="codeline" data-linenumber="785"><td class="num" id="LN785">785</td><td class="line">			<span class='keyword'>for</span> (s = ptr; s &lt; ptr + wlen; <span class='macro'>MB_PTR_ADV(s)<span class='macro_popup'>s += (*mb_ptr2len)(s)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="786"><td class="num" id="LN786">786</td><td class="line">			    <span class='macro'>MB_PTR_ADV(p)<span class='macro_popup'>p += (*mb_ptr2len)(p)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="787"><td class="num" id="LN787">787</td><td class="line">			mip-&gt;mi_compoff = (<span class='keyword'>int</span>)(p - mip-&gt;mi_fword);</td></tr>
<tr class="codeline" data-linenumber="788"><td class="num" id="LN788">788</td><td class="line">		    }</td></tr>
<tr class="codeline" data-linenumber="789"><td class="num" id="LN789">789</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="790"><td class="num" id="LN790">790</td><td class="line"><span class='directive'>#if 0 // Disabled, see below</span></td></tr>
<tr class="codeline" data-linenumber="791"><td class="num" id="LN791">791</td><td class="line">		c = mip-&gt;mi_compoff;</td></tr>
<tr class="codeline" data-linenumber="792"><td class="num" id="LN792">792</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="793"><td class="num" id="LN793">793</td><td class="line">		++mip-&gt;mi_complen;</td></tr>
<tr class="codeline" data-linenumber="794"><td class="num" id="LN794">794</td><td class="line">		<span class='keyword'>if</span> (flags &amp; <span class='macro'>WF_COMPROOT<span class='macro_popup'>0x0800</span></span>)</td></tr>
<tr class="codeline" data-linenumber="795"><td class="num" id="LN795">795</td><td class="line">		    ++mip-&gt;mi_compextra;</td></tr>
<tr class="codeline" data-linenumber="796"><td class="num" id="LN796">796</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="797"><td class="num" id="LN797">797</td><td class="line">		<span class='comment'>// For NOBREAK we need to try all NOBREAK languages, at least</span></td></tr>
<tr class="codeline" data-linenumber="798"><td class="num" id="LN798">798</td><td class="line">		<span class='comment'>// to find the ".add" file(s).</span></td></tr>
<tr class="codeline" data-linenumber="799"><td class="num" id="LN799">799</td><td class="line">		<span class='keyword'>for</span> (lpi = 0; lpi &lt; mip-&gt;mi_win-&gt;w_s-&gt;b_langp.ga_len; ++lpi)</td></tr>
<tr class="codeline" data-linenumber="800"><td class="num" id="LN800">800</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="801"><td class="num" id="LN801">801</td><td class="line">		    <span class='keyword'>if</span> (slang-&gt;sl_nobreak)</td></tr>
<tr class="codeline" data-linenumber="802"><td class="num" id="LN802">802</td><td class="line">		    {</td></tr>
<tr class="codeline" data-linenumber="803"><td class="num" id="LN803">803</td><td class="line">			mip-&gt;mi_lp = <span class='macro'>LANGP_ENTRY(mip-&gt;mi_win-&gt;w_s-&gt;b_langp, lpi)<span class='macro_popup'>(((langp_T *)(mip-&gt;mi_win-&gt;w_s-&gt;b_langp).ga_data) + (<br>lpi))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="804"><td class="num" id="LN804">804</td><td class="line">			<span class='keyword'>if</span> (mip-&gt;mi_lp-&gt;lp_slang-&gt;sl_fidxs == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span></td></tr>
<tr class="codeline" data-linenumber="805"><td class="num" id="LN805">805</td><td class="line">					 || !mip-&gt;mi_lp-&gt;lp_slang-&gt;sl_nobreak)</td></tr>
<tr class="codeline" data-linenumber="806"><td class="num" id="LN806">806</td><td class="line">			    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="807"><td class="num" id="LN807">807</td><td class="line">		    }</td></tr>
<tr class="codeline" data-linenumber="808"><td class="num" id="LN808">808</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="809"><td class="num" id="LN809">809</td><td class="line">		    find_word(mip, <span class='macro'>FIND_COMPOUND<span class='macro_popup'>3</span></span>);</td></tr>
<tr class="codeline" data-linenumber="810"><td class="num" id="LN810">810</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="811"><td class="num" id="LN811">811</td><td class="line">		    <span class='comment'>// When NOBREAK any word that matches is OK.  Otherwise we</span></td></tr>
<tr class="codeline" data-linenumber="812"><td class="num" id="LN812">812</td><td class="line">		    <span class='comment'>// need to find the longest match, thus try with keep-case</span></td></tr>
<tr class="codeline" data-linenumber="813"><td class="num" id="LN813">813</td><td class="line">		    <span class='comment'>// and prefix too.</span></td></tr>
<tr class="codeline" data-linenumber="814"><td class="num" id="LN814">814</td><td class="line">		    <span class='keyword'>if</span> (!slang-&gt;sl_nobreak || mip-&gt;mi_result == <span class='macro'>SP_BAD<span class='macro_popup'>3</span></span>)</td></tr>
<tr class="codeline" data-linenumber="815"><td class="num" id="LN815">815</td><td class="line">		    {</td></tr>
<tr class="codeline" data-linenumber="816"><td class="num" id="LN816">816</td><td class="line">			<span class='comment'>// Find following word in keep-case tree.</span></td></tr>
<tr class="codeline" data-linenumber="817"><td class="num" id="LN817">817</td><td class="line">			mip-&gt;mi_compoff = wlen;</td></tr>
<tr class="codeline" data-linenumber="818"><td class="num" id="LN818">818</td><td class="line">			find_word(mip, <span class='macro'>FIND_KEEPCOMPOUND<span class='macro_popup'>4</span></span>);</td></tr>
<tr class="codeline" data-linenumber="819"><td class="num" id="LN819">819</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="820"><td class="num" id="LN820">820</td><td class="line"><span class='directive'>#if 0	    // Disabled, a prefix must not appear halfway a compound word,</span></td></tr>
<tr class="codeline" data-linenumber="821"><td class="num" id="LN821">821</td><td class="line">	    <span class='comment'>// unless the COMPOUNDPERMITFLAG is used and then it can't be a</span></td></tr>
<tr class="codeline" data-linenumber="822"><td class="num" id="LN822">822</td><td class="line">	    <span class='comment'>// postponed prefix.</span></td></tr>
<tr class="codeline" data-linenumber="823"><td class="num" id="LN823">823</td><td class="line">			<span class='keyword'>if</span> (!slang-&gt;sl_nobreak || mip-&gt;mi_result == <span class='macro'>SP_BAD<span class='macro_popup'>3</span></span>)</td></tr>
<tr class="codeline" data-linenumber="824"><td class="num" id="LN824">824</td><td class="line">			{</td></tr>
<tr class="codeline" data-linenumber="825"><td class="num" id="LN825">825</td><td class="line">			    <span class='comment'>// Check for following word with prefix.</span></td></tr>
<tr class="codeline" data-linenumber="826"><td class="num" id="LN826">826</td><td class="line">			    mip-&gt;mi_compoff = c;</td></tr>
<tr class="codeline" data-linenumber="827"><td class="num" id="LN827">827</td><td class="line">			    find_prefix(mip, <span class='macro'>FIND_COMPOUND<span class='macro_popup'>3</span></span>);</td></tr>
<tr class="codeline" data-linenumber="828"><td class="num" id="LN828">828</td><td class="line">			}</td></tr>
<tr class="codeline" data-linenumber="829"><td class="num" id="LN829">829</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="830"><td class="num" id="LN830">830</td><td class="line">		    }</td></tr>
<tr class="codeline" data-linenumber="831"><td class="num" id="LN831">831</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="832"><td class="num" id="LN832">832</td><td class="line">		    <span class='keyword'>if</span> (!slang-&gt;sl_nobreak)</td></tr>
<tr class="codeline" data-linenumber="833"><td class="num" id="LN833">833</td><td class="line">			<span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="834"><td class="num" id="LN834">834</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="835"><td class="num" id="LN835">835</td><td class="line">		--mip-&gt;mi_complen;</td></tr>
<tr class="codeline" data-linenumber="836"><td class="num" id="LN836">836</td><td class="line">		<span class='keyword'>if</span> (flags &amp; <span class='macro'>WF_COMPROOT<span class='macro_popup'>0x0800</span></span>)</td></tr>
<tr class="codeline" data-linenumber="837"><td class="num" id="LN837">837</td><td class="line">		    --mip-&gt;mi_compextra;</td></tr>
<tr class="codeline" data-linenumber="838"><td class="num" id="LN838">838</td><td class="line">		mip-&gt;mi_lp = save_lp;</td></tr>
<tr class="codeline" data-linenumber="839"><td class="num" id="LN839">839</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="840"><td class="num" id="LN840">840</td><td class="line">		<span class='keyword'>if</span> (slang-&gt;sl_nobreak)</td></tr>
<tr class="codeline" data-linenumber="841"><td class="num" id="LN841">841</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="842"><td class="num" id="LN842">842</td><td class="line">		    nobreak_result = mip-&gt;mi_result;</td></tr>
<tr class="codeline" data-linenumber="843"><td class="num" id="LN843">843</td><td class="line">		    mip-&gt;mi_result = save_result;</td></tr>
<tr class="codeline" data-linenumber="844"><td class="num" id="LN844">844</td><td class="line">		    mip-&gt;mi_end = save_end;</td></tr>
<tr class="codeline" data-linenumber="845"><td class="num" id="LN845">845</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="846"><td class="num" id="LN846">846</td><td class="line">		<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="847"><td class="num" id="LN847">847</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="848"><td class="num" id="LN848">848</td><td class="line">		    <span class='keyword'>if</span> (mip-&gt;mi_result == <span class='macro'>SP_OK<span class='macro_popup'>0</span></span>)</td></tr>
<tr class="codeline" data-linenumber="849"><td class="num" id="LN849">849</td><td class="line">			<span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="850"><td class="num" id="LN850">850</td><td class="line">		    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="851"><td class="num" id="LN851">851</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="852"><td class="num" id="LN852">852</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="853"><td class="num" id="LN853">853</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="854"><td class="num" id="LN854">854</td><td class="line">	    <span class='keyword'>if</span> (flags &amp; <span class='macro'>WF_BANNED<span class='macro_popup'>0x10</span></span>)</td></tr>
<tr class="codeline" data-linenumber="855"><td class="num" id="LN855">855</td><td class="line">		res = <span class='macro'>SP_BANNED<span class='macro_popup'>-1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="856"><td class="num" id="LN856">856</td><td class="line">	    <span class='keyword'>else</span> <span class='keyword'>if</span> (flags &amp; <span class='macro'>WF_REGION<span class='macro_popup'>0x01</span></span>)</td></tr>
<tr class="codeline" data-linenumber="857"><td class="num" id="LN857">857</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="858"><td class="num" id="LN858">858</td><td class="line">		<span class='comment'>// Check region.</span></td></tr>
<tr class="codeline" data-linenumber="859"><td class="num" id="LN859">859</td><td class="line">		<span class='keyword'>if</span> ((mip-&gt;mi_lp-&gt;lp_region &amp; (flags &gt;&gt; 16)) != 0)</td></tr>
<tr class="codeline" data-linenumber="860"><td class="num" id="LN860">860</td><td class="line">		    res = <span class='macro'>SP_OK<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="861"><td class="num" id="LN861">861</td><td class="line">		<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="862"><td class="num" id="LN862">862</td><td class="line">		    res = <span class='macro'>SP_LOCAL<span class='macro_popup'>2</span></span>;</td></tr>
<tr class="codeline" data-linenumber="863"><td class="num" id="LN863">863</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="864"><td class="num" id="LN864">864</td><td class="line">	    <span class='keyword'>else</span> <span class='keyword'>if</span> (flags &amp; <span class='macro'>WF_RARE<span class='macro_popup'>0x08</span></span>)</td></tr>
<tr class="codeline" data-linenumber="865"><td class="num" id="LN865">865</td><td class="line">		res = <span class='macro'>SP_RARE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="866"><td class="num" id="LN866">866</td><td class="line">	    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="867"><td class="num" id="LN867">867</td><td class="line">		res = <span class='macro'>SP_OK<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="868"><td class="num" id="LN868">868</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="869"><td class="num" id="LN869">869</td><td class="line">	    <span class='comment'>// Always use the longest match and the best result.  For NOBREAK</span></td></tr>
<tr class="codeline" data-linenumber="870"><td class="num" id="LN870">870</td><td class="line">	    <span class='comment'>// we separately keep the longest match without a following good</span></td></tr>
<tr class="codeline" data-linenumber="871"><td class="num" id="LN871">871</td><td class="line">	    <span class='comment'>// word as a fall-back.</span></td></tr>
<tr class="codeline" data-linenumber="872"><td class="num" id="LN872">872</td><td class="line">	    <span class='keyword'>if</span> (nobreak_result == <span class='macro'>SP_BAD<span class='macro_popup'>3</span></span>)</td></tr>
<tr class="codeline" data-linenumber="873"><td class="num" id="LN873">873</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="874"><td class="num" id="LN874">874</td><td class="line">		<span class='keyword'>if</span> (mip-&gt;mi_result2 &gt; res)</td></tr>
<tr class="codeline" data-linenumber="875"><td class="num" id="LN875">875</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="876"><td class="num" id="LN876">876</td><td class="line">		    mip-&gt;mi_result2 = res;</td></tr>
<tr class="codeline" data-linenumber="877"><td class="num" id="LN877">877</td><td class="line">		    mip-&gt;mi_end2 = mip-&gt;mi_word + wlen;</td></tr>
<tr class="codeline" data-linenumber="878"><td class="num" id="LN878">878</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="879"><td class="num" id="LN879">879</td><td class="line">		<span class='keyword'>else</span> <span class='keyword'>if</span> (mip-&gt;mi_result2 == res</td></tr>
<tr class="codeline" data-linenumber="880"><td class="num" id="LN880">880</td><td class="line">					&amp;&amp; mip-&gt;mi_end2 &lt; mip-&gt;mi_word + wlen)</td></tr>
<tr class="codeline" data-linenumber="881"><td class="num" id="LN881">881</td><td class="line">		    mip-&gt;mi_end2 = mip-&gt;mi_word + wlen;</td></tr>
<tr class="codeline" data-linenumber="882"><td class="num" id="LN882">882</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="883"><td class="num" id="LN883">883</td><td class="line">	    <span class='keyword'>else</span> <span class='keyword'>if</span> (mip-&gt;mi_result &gt; res)</td></tr>
<tr class="codeline" data-linenumber="884"><td class="num" id="LN884">884</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="885"><td class="num" id="LN885">885</td><td class="line">		mip-&gt;mi_result = res;</td></tr>
<tr class="codeline" data-linenumber="886"><td class="num" id="LN886">886</td><td class="line">		mip-&gt;mi_end = mip-&gt;mi_word + wlen;</td></tr>
<tr class="codeline" data-linenumber="887"><td class="num" id="LN887">887</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="888"><td class="num" id="LN888">888</td><td class="line">	    <span class='keyword'>else</span> <span class='keyword'>if</span> (mip-&gt;mi_result == res &amp;&amp; mip-&gt;mi_end &lt; mip-&gt;mi_word + wlen)</td></tr>
<tr class="codeline" data-linenumber="889"><td class="num" id="LN889">889</td><td class="line">		mip-&gt;mi_end = mip-&gt;mi_word + wlen;</td></tr>
<tr class="codeline" data-linenumber="890"><td class="num" id="LN890">890</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="891"><td class="num" id="LN891">891</td><td class="line">	    <span class='keyword'>if</span> (mip-&gt;mi_result == <span class='macro'>SP_OK<span class='macro_popup'>0</span></span>)</td></tr>
<tr class="codeline" data-linenumber="892"><td class="num" id="LN892">892</td><td class="line">		<span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="893"><td class="num" id="LN893">893</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="894"><td class="num" id="LN894">894</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="895"><td class="num" id="LN895">895</td><td class="line">	<span class='keyword'>if</span> (mip-&gt;mi_result == <span class='macro'>SP_OK<span class='macro_popup'>0</span></span>)</td></tr>
<tr class="codeline" data-linenumber="896"><td class="num" id="LN896">896</td><td class="line">	    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="897"><td class="num" id="LN897">897</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="898"><td class="num" id="LN898">898</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="899"><td class="num" id="LN899">899</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="900"><td class="num" id="LN900">900</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="901"><td class="num" id="LN901">901</td><td class="line"> <span class='comment'>* Return TRUE if there is a match between the word ptr[wlen] and</span></td></tr>
<tr class="codeline" data-linenumber="902"><td class="num" id="LN902">902</td><td class="line"> <span class='comment'>* CHECKCOMPOUNDPATTERN rules, assuming that we will concatenate with another</span></td></tr>
<tr class="codeline" data-linenumber="903"><td class="num" id="LN903">903</td><td class="line"> <span class='comment'>* word.</span></td></tr>
<tr class="codeline" data-linenumber="904"><td class="num" id="LN904">904</td><td class="line"> <span class='comment'>* A match means that the first part of CHECKCOMPOUNDPATTERN matches at the</span></td></tr>
<tr class="codeline" data-linenumber="905"><td class="num" id="LN905">905</td><td class="line"> <span class='comment'>* end of ptr[wlen] and the second part matches after it.</span></td></tr>
<tr class="codeline" data-linenumber="906"><td class="num" id="LN906">906</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="907"><td class="num" id="LN907">907</td><td class="line">    <span class='keyword'>int</span></td></tr>
<tr class="codeline" data-linenumber="908"><td class="num" id="LN908">908</td><td class="line">match_checkcompoundpattern(</td></tr>
<tr class="codeline" data-linenumber="909"><td class="num" id="LN909">909</td><td class="line">    char_u	*ptr,</td></tr>
<tr class="codeline" data-linenumber="910"><td class="num" id="LN910">910</td><td class="line">    <span class='keyword'>int</span>		wlen,</td></tr>
<tr class="codeline" data-linenumber="911"><td class="num" id="LN911">911</td><td class="line">    garray_T	*gap)  <span class='comment'>// &amp;sl_comppat</span></td></tr>
<tr class="codeline" data-linenumber="912"><td class="num" id="LN912">912</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="913"><td class="num" id="LN913">913</td><td class="line">    <span class='keyword'>int</span>		i;</td></tr>
<tr class="codeline" data-linenumber="914"><td class="num" id="LN914">914</td><td class="line">    char_u	*p;</td></tr>
<tr class="codeline" data-linenumber="915"><td class="num" id="LN915">915</td><td class="line">    <span class='keyword'>int</span>		len;</td></tr>
<tr class="codeline" data-linenumber="916"><td class="num" id="LN916">916</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="917"><td class="num" id="LN917">917</td><td class="line">    <span class='keyword'>for</span> (i = 0; i + 1 &lt; gap-&gt;ga_len; i += 2)</td></tr>
<tr class="codeline" data-linenumber="918"><td class="num" id="LN918">918</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="919"><td class="num" id="LN919">919</td><td class="line">	p = ((char_u **)gap-&gt;ga_data)[i + 1];</td></tr>
<tr class="codeline" data-linenumber="920"><td class="num" id="LN920">920</td><td class="line">	<span class='keyword'>if</span> (<span class='macro'>STRNCMP(ptr + wlen, p, STRLEN(p))<span class='macro_popup'>strncmp((char *)(ptr + wlen), (char *)(p), (size_t)(strlen((char<br> *)(p))))</span></span> == 0)</td></tr>
<tr class="codeline" data-linenumber="921"><td class="num" id="LN921">921</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="922"><td class="num" id="LN922">922</td><td class="line">	    <span class='comment'>// Second part matches at start of following compound word, now</span></td></tr>
<tr class="codeline" data-linenumber="923"><td class="num" id="LN923">923</td><td class="line">	    <span class='comment'>// check if first part matches at end of previous word.</span></td></tr>
<tr class="codeline" data-linenumber="924"><td class="num" id="LN924">924</td><td class="line">	    p = ((char_u **)gap-&gt;ga_data)[i];</td></tr>
<tr class="codeline" data-linenumber="925"><td class="num" id="LN925">925</td><td class="line">	    len = (<span class='keyword'>int</span>)<span class='macro'>STRLEN(p)<span class='macro_popup'>strlen((char *)(p))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="926"><td class="num" id="LN926">926</td><td class="line">	    <span class='keyword'>if</span> (len &lt;= wlen &amp;&amp; <span class='macro'>STRNCMP(ptr + wlen - len, p, len)<span class='macro_popup'>strncmp((char *)(ptr + wlen - len), (char *)(p), (size_t)(len<br>))</span></span> == 0)</td></tr>
<tr class="codeline" data-linenumber="927"><td class="num" id="LN927">927</td><td class="line">		<span class='keyword'>return</span> <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="928"><td class="num" id="LN928">928</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="929"><td class="num" id="LN929">929</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="930"><td class="num" id="LN930">930</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="931"><td class="num" id="LN931">931</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="932"><td class="num" id="LN932">932</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="933"><td class="num" id="LN933">933</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="934"><td class="num" id="LN934">934</td><td class="line"> <span class='comment'>* Return TRUE if "flags" is a valid sequence of compound flags and "word"</span></td></tr>
<tr class="codeline" data-linenumber="935"><td class="num" id="LN935">935</td><td class="line"> <span class='comment'>* does not have too many syllables.</span></td></tr>
<tr class="codeline" data-linenumber="936"><td class="num" id="LN936">936</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="937"><td class="num" id="LN937">937</td><td class="line">    <span class='keyword'>int</span></td></tr>
<tr class="codeline" data-linenumber="938"><td class="num" id="LN938">938</td><td class="line">can_compound(slang_T *slang, char_u *word, char_u *flags)</td></tr>
<tr class="codeline" data-linenumber="939"><td class="num" id="LN939">939</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="940"><td class="num" id="LN940">940</td><td class="line">    char_u	uflags[<span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span> * 2];</td></tr>
<tr class="codeline" data-linenumber="941"><td class="num" id="LN941">941</td><td class="line">    <span class='keyword'>int</span>		i;</td></tr>
<tr class="codeline" data-linenumber="942"><td class="num" id="LN942">942</td><td class="line">    char_u	*p;</td></tr>
<tr class="codeline" data-linenumber="943"><td class="num" id="LN943">943</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="944"><td class="num" id="LN944">944</td><td class="line">    <span class='keyword'>if</span> (slang-&gt;sl_compprog == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="945"><td class="num" id="LN945">945</td><td class="line">	<span class='keyword'>return</span> <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="946"><td class="num" id="LN946">946</td><td class="line">    <span class='keyword'>if</span> (enc_utf8)</td></tr>
<tr class="codeline" data-linenumber="947"><td class="num" id="LN947">947</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="948"><td class="num" id="LN948">948</td><td class="line">	<span class='comment'>// Need to convert the single byte flags to utf8 characters.</span></td></tr>
<tr class="codeline" data-linenumber="949"><td class="num" id="LN949">949</td><td class="line">	p = uflags;</td></tr>
<tr class="codeline" data-linenumber="950"><td class="num" id="LN950">950</td><td class="line">	<span class='keyword'>for</span> (i = 0; flags[i] != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>; ++i)</td></tr>
<tr class="codeline" data-linenumber="951"><td class="num" id="LN951">951</td><td class="line">	    p += utf_char2bytes(flags[i], p);</td></tr>
<tr class="codeline" data-linenumber="952"><td class="num" id="LN952">952</td><td class="line">	*p = <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>;</td></tr>
<tr class="codeline" data-linenumber="953"><td class="num" id="LN953">953</td><td class="line">	p = uflags;</td></tr>
<tr class="codeline" data-linenumber="954"><td class="num" id="LN954">954</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="955"><td class="num" id="LN955">955</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="956"><td class="num" id="LN956">956</td><td class="line">	p = flags;</td></tr>
<tr class="codeline" data-linenumber="957"><td class="num" id="LN957">957</td><td class="line">    <span class='keyword'>if</span> (!vim_regexec_prog(&amp;slang-&gt;sl_compprog, <span class='macro'>FALSE<span class='macro_popup'>0</span></span>, p, 0))</td></tr>
<tr class="codeline" data-linenumber="958"><td class="num" id="LN958">958</td><td class="line">	<span class='keyword'>return</span> <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="959"><td class="num" id="LN959">959</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="960"><td class="num" id="LN960">960</td><td class="line">    <span class='comment'>// Count the number of syllables.  This may be slow, do it last.  If there</span></td></tr>
<tr class="codeline" data-linenumber="961"><td class="num" id="LN961">961</td><td class="line">    <span class='comment'>// are too many syllables AND the number of compound words is above</span></td></tr>
<tr class="codeline" data-linenumber="962"><td class="num" id="LN962">962</td><td class="line">    <span class='comment'>// COMPOUNDWORDMAX then compounding is not allowed.</span></td></tr>
<tr class="codeline" data-linenumber="963"><td class="num" id="LN963">963</td><td class="line">    <span class='keyword'>if</span> (slang-&gt;sl_compsylmax &lt; <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span></td></tr>
<tr class="codeline" data-linenumber="964"><td class="num" id="LN964">964</td><td class="line">		       &amp;&amp; count_syllables(slang, word) &gt; slang-&gt;sl_compsylmax)</td></tr>
<tr class="codeline" data-linenumber="965"><td class="num" id="LN965">965</td><td class="line">	<span class='keyword'>return</span> (<span class='keyword'>int</span>)<span class='macro'>STRLEN(flags)<span class='macro_popup'>strlen((char *)(flags))</span></span> &lt; slang-&gt;sl_compmax;</td></tr>
<tr class="codeline" data-linenumber="966"><td class="num" id="LN966">966</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="967"><td class="num" id="LN967">967</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="968"><td class="num" id="LN968">968</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="969"><td class="num" id="LN969">969</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="970"><td class="num" id="LN970">970</td><td class="line"> <span class='comment'>* Return TRUE if the compound flags in compflags[] match the start of any</span></td></tr>
<tr class="codeline" data-linenumber="971"><td class="num" id="LN971">971</td><td class="line"> <span class='comment'>* compound rule.  This is used to stop trying a compound if the flags</span></td></tr>
<tr class="codeline" data-linenumber="972"><td class="num" id="LN972">972</td><td class="line"> <span class='comment'>* collected so far can't possibly match any compound rule.</span></td></tr>
<tr class="codeline" data-linenumber="973"><td class="num" id="LN973">973</td><td class="line"> <span class='comment'>* Caller must check that slang-&gt;sl_comprules is not NULL.</span></td></tr>
<tr class="codeline" data-linenumber="974"><td class="num" id="LN974">974</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="975"><td class="num" id="LN975">975</td><td class="line">    <span class='keyword'>int</span></td></tr>
<tr class="codeline" data-linenumber="976"><td class="num" id="LN976">976</td><td class="line">match_compoundrule(slang_T *slang, char_u *compflags)</td></tr>
<tr class="codeline" data-linenumber="977"><td class="num" id="LN977">977</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="978"><td class="num" id="LN978">978</td><td class="line">    char_u	*p;</td></tr>
<tr class="codeline" data-linenumber="979"><td class="num" id="LN979">979</td><td class="line">    <span class='keyword'>int</span>		i;</td></tr>
<tr class="codeline" data-linenumber="980"><td class="num" id="LN980">980</td><td class="line">    <span class='keyword'>int</span>		c;</td></tr>
<tr class="codeline" data-linenumber="981"><td class="num" id="LN981">981</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="982"><td class="num" id="LN982">982</td><td class="line">    <span class='comment'>// loop over all the COMPOUNDRULE entries</span></td></tr>
<tr class="codeline" data-linenumber="983"><td class="num" id="LN983">983</td><td class="line">    <span class='keyword'>for</span> (p = slang-&gt;sl_comprules; *p != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>; ++p)</td></tr>
<tr class="codeline" data-linenumber="984"><td class="num" id="LN984">984</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="985"><td class="num" id="LN985">985</td><td class="line">	<span class='comment'>// loop over the flags in the compound word we have made, match</span></td></tr>
<tr class="codeline" data-linenumber="986"><td class="num" id="LN986">986</td><td class="line">	<span class='comment'>// them against the current rule entry</span></td></tr>
<tr class="codeline" data-linenumber="987"><td class="num" id="LN987">987</td><td class="line">	<span class='keyword'>for</span> (i = 0; ; ++i)</td></tr>
<tr class="codeline" data-linenumber="988"><td class="num" id="LN988">988</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="989"><td class="num" id="LN989">989</td><td class="line">	    c = compflags[i];</td></tr>
<tr class="codeline" data-linenumber="990"><td class="num" id="LN990">990</td><td class="line">	    <span class='keyword'>if</span> (c == <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="991"><td class="num" id="LN991">991</td><td class="line">		<span class='comment'>// found a rule that matches for the flags we have so far</span></td></tr>
<tr class="codeline" data-linenumber="992"><td class="num" id="LN992">992</td><td class="line">		<span class='keyword'>return</span> <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="993"><td class="num" id="LN993">993</td><td class="line">	    <span class='keyword'>if</span> (*p == '/' || *p == <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="994"><td class="num" id="LN994">994</td><td class="line">		<span class='keyword'>break</span>;  <span class='comment'>// end of rule, it's too short</span></td></tr>
<tr class="codeline" data-linenumber="995"><td class="num" id="LN995">995</td><td class="line">	    <span class='keyword'>if</span> (*p == '[')</td></tr>
<tr class="codeline" data-linenumber="996"><td class="num" id="LN996">996</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="997"><td class="num" id="LN997">997</td><td class="line">		<span class='keyword'>int</span> match = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="998"><td class="num" id="LN998">998</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="999"><td class="num" id="LN999">999</td><td class="line">		<span class='comment'>// compare against all the flags in []</span></td></tr>
<tr class="codeline" data-linenumber="1000"><td class="num" id="LN1000">1000</td><td class="line">		++p;</td></tr>
<tr class="codeline" data-linenumber="1001"><td class="num" id="LN1001">1001</td><td class="line">		<span class='keyword'>while</span> (*p != ']' &amp;&amp; *p != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1002"><td class="num" id="LN1002">1002</td><td class="line">		    <span class='keyword'>if</span> (*p++ == c)</td></tr>
<tr class="codeline" data-linenumber="1003"><td class="num" id="LN1003">1003</td><td class="line">			match = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1004"><td class="num" id="LN1004">1004</td><td class="line">		<span class='keyword'>if</span> (!match)</td></tr>
<tr class="codeline" data-linenumber="1005"><td class="num" id="LN1005">1005</td><td class="line">		    <span class='keyword'>break</span>;  <span class='comment'>// none matches</span></td></tr>
<tr class="codeline" data-linenumber="1006"><td class="num" id="LN1006">1006</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="1007"><td class="num" id="LN1007">1007</td><td class="line">	    <span class='keyword'>else</span> <span class='keyword'>if</span> (*p != c)</td></tr>
<tr class="codeline" data-linenumber="1008"><td class="num" id="LN1008">1008</td><td class="line">		<span class='keyword'>break</span>;  <span class='comment'>// flag of word doesn't match flag in pattern</span></td></tr>
<tr class="codeline" data-linenumber="1009"><td class="num" id="LN1009">1009</td><td class="line">	    ++p;</td></tr>
<tr class="codeline" data-linenumber="1010"><td class="num" id="LN1010">1010</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="1011"><td class="num" id="LN1011">1011</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1012"><td class="num" id="LN1012">1012</td><td class="line">	<span class='comment'>// Skip to the next "/", where the next pattern starts.</span></td></tr>
<tr class="codeline" data-linenumber="1013"><td class="num" id="LN1013">1013</td><td class="line">	p = vim_strchr(p, '/');</td></tr>
<tr class="codeline" data-linenumber="1014"><td class="num" id="LN1014">1014</td><td class="line">	<span class='keyword'>if</span> (p == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1015"><td class="num" id="LN1015">1015</td><td class="line">	    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="1016"><td class="num" id="LN1016">1016</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1017"><td class="num" id="LN1017">1017</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1018"><td class="num" id="LN1018">1018</td><td class="line">    <span class='comment'>// Checked all the rules and none of them match the flags, so there</span></td></tr>
<tr class="codeline" data-linenumber="1019"><td class="num" id="LN1019">1019</td><td class="line">    <span class='comment'>// can't possibly be a compound starting with these flags.</span></td></tr>
<tr class="codeline" data-linenumber="1020"><td class="num" id="LN1020">1020</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1021"><td class="num" id="LN1021">1021</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1022"><td class="num" id="LN1022">1022</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1023"><td class="num" id="LN1023">1023</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="1024"><td class="num" id="LN1024">1024</td><td class="line"> <span class='comment'>* Return non-zero if the prefix indicated by "arridx" matches with the prefix</span></td></tr>
<tr class="codeline" data-linenumber="1025"><td class="num" id="LN1025">1025</td><td class="line"> <span class='comment'>* ID in "flags" for the word "word".</span></td></tr>
<tr class="codeline" data-linenumber="1026"><td class="num" id="LN1026">1026</td><td class="line"> <span class='comment'>* The WF_RAREPFX flag is included in the return value for a rare prefix.</span></td></tr>
<tr class="codeline" data-linenumber="1027"><td class="num" id="LN1027">1027</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1028"><td class="num" id="LN1028">1028</td><td class="line">    <span class='keyword'>int</span></td></tr>
<tr class="codeline" data-linenumber="1029"><td class="num" id="LN1029">1029</td><td class="line">valid_word_prefix(</td></tr>
<tr class="codeline" data-linenumber="1030"><td class="num" id="LN1030">1030</td><td class="line">    <span class='keyword'>int</span>		totprefcnt,	<span class='comment'>// nr of prefix IDs</span></td></tr>
<tr class="codeline" data-linenumber="1031"><td class="num" id="LN1031">1031</td><td class="line">    <span class='keyword'>int</span>		arridx,		<span class='comment'>// idx in sl_pidxs[]</span></td></tr>
<tr class="codeline" data-linenumber="1032"><td class="num" id="LN1032">1032</td><td class="line">    <span class='keyword'>int</span>		flags,</td></tr>
<tr class="codeline" data-linenumber="1033"><td class="num" id="LN1033">1033</td><td class="line">    char_u	*word,</td></tr>
<tr class="codeline" data-linenumber="1034"><td class="num" id="LN1034">1034</td><td class="line">    slang_T	*slang,</td></tr>
<tr class="codeline" data-linenumber="1035"><td class="num" id="LN1035">1035</td><td class="line">    <span class='keyword'>int</span>		cond_req)	<span class='comment'>// only use prefixes with a condition</span></td></tr>
<tr class="codeline" data-linenumber="1036"><td class="num" id="LN1036">1036</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="1037"><td class="num" id="LN1037">1037</td><td class="line">    <span class='keyword'>int</span>		prefcnt;</td></tr>
<tr class="codeline" data-linenumber="1038"><td class="num" id="LN1038">1038</td><td class="line">    <span class='keyword'>int</span>		pidx;</td></tr>
<tr class="codeline" data-linenumber="1039"><td class="num" id="LN1039">1039</td><td class="line">    regprog_T	**rp;</td></tr>
<tr class="codeline" data-linenumber="1040"><td class="num" id="LN1040">1040</td><td class="line">    <span class='keyword'>int</span>		prefid;</td></tr>
<tr class="codeline" data-linenumber="1041"><td class="num" id="LN1041">1041</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1042"><td class="num" id="LN1042">1042</td><td class="line">    prefid = (<span class='keyword'>unsigned</span>)flags &gt;&gt; 24;</td></tr>
<tr class="codeline" data-linenumber="1043"><td class="num" id="LN1043">1043</td><td class="line">    <span class='keyword'>for</span> (prefcnt = totprefcnt - 1; prefcnt &gt;= 0; --prefcnt)</td></tr>
<tr class="codeline" data-linenumber="1044"><td class="num" id="LN1044">1044</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="1045"><td class="num" id="LN1045">1045</td><td class="line">	pidx = slang-&gt;sl_pidxs[arridx + prefcnt];</td></tr>
<tr class="codeline" data-linenumber="1046"><td class="num" id="LN1046">1046</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1047"><td class="num" id="LN1047">1047</td><td class="line">	<span class='comment'>// Check the prefix ID.</span></td></tr>
<tr class="codeline" data-linenumber="1048"><td class="num" id="LN1048">1048</td><td class="line">	<span class='keyword'>if</span> (prefid != (pidx &amp; 0xff))</td></tr>
<tr class="codeline" data-linenumber="1049"><td class="num" id="LN1049">1049</td><td class="line">	    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="1050"><td class="num" id="LN1050">1050</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1051"><td class="num" id="LN1051">1051</td><td class="line">	<span class='comment'>// Check if the prefix doesn't combine and the word already has a</span></td></tr>
<tr class="codeline" data-linenumber="1052"><td class="num" id="LN1052">1052</td><td class="line">	<span class='comment'>// suffix.</span></td></tr>
<tr class="codeline" data-linenumber="1053"><td class="num" id="LN1053">1053</td><td class="line">	<span class='keyword'>if</span> ((flags &amp; <span class='macro'>WF_HAS_AFF<span class='macro_popup'>0x0100</span></span>) &amp;&amp; (pidx &amp; <span class='macro'>WF_PFX_NC<span class='macro_popup'>(0x02 &lt;&lt; 24)</span></span>))</td></tr>
<tr class="codeline" data-linenumber="1054"><td class="num" id="LN1054">1054</td><td class="line">	    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="1055"><td class="num" id="LN1055">1055</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1056"><td class="num" id="LN1056">1056</td><td class="line">	<span class='comment'>// Check the condition, if there is one.  The condition index is</span></td></tr>
<tr class="codeline" data-linenumber="1057"><td class="num" id="LN1057">1057</td><td class="line">	<span class='comment'>// stored in the two bytes above the prefix ID byte.</span></td></tr>
<tr class="codeline" data-linenumber="1058"><td class="num" id="LN1058">1058</td><td class="line">	rp = &amp;slang-&gt;sl_prefprog[((<span class='keyword'>unsigned</span>)pidx &gt;&gt; 8) &amp; 0xffff];</td></tr>
<tr class="codeline" data-linenumber="1059"><td class="num" id="LN1059">1059</td><td class="line">	<span class='keyword'>if</span> (*rp != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1060"><td class="num" id="LN1060">1060</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="1061"><td class="num" id="LN1061">1061</td><td class="line">	    <span class='keyword'>if</span> (!vim_regexec_prog(rp, <span class='macro'>FALSE<span class='macro_popup'>0</span></span>, word, 0))</td></tr>
<tr class="codeline" data-linenumber="1062"><td class="num" id="LN1062">1062</td><td class="line">		<span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="1063"><td class="num" id="LN1063">1063</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="1064"><td class="num" id="LN1064">1064</td><td class="line">	<span class='keyword'>else</span> <span class='keyword'>if</span> (cond_req)</td></tr>
<tr class="codeline" data-linenumber="1065"><td class="num" id="LN1065">1065</td><td class="line">	    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="1066"><td class="num" id="LN1066">1066</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1067"><td class="num" id="LN1067">1067</td><td class="line">	<span class='comment'>// It's a match!  Return the WF_ flags.</span></td></tr>
<tr class="codeline" data-linenumber="1068"><td class="num" id="LN1068">1068</td><td class="line">	<span class='keyword'>return</span> pidx;</td></tr>
<tr class="codeline" data-linenumber="1069"><td class="num" id="LN1069">1069</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1070"><td class="num" id="LN1070">1070</td><td class="line">    <span class='keyword'>return</span> 0;</td></tr>
<tr class="codeline" data-linenumber="1071"><td class="num" id="LN1071">1071</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1072"><td class="num" id="LN1072">1072</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1073"><td class="num" id="LN1073">1073</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="1074"><td class="num" id="LN1074">1074</td><td class="line"> <span class='comment'>* Check if the word at "mip-&gt;mi_word" has a matching prefix.</span></td></tr>
<tr class="codeline" data-linenumber="1075"><td class="num" id="LN1075">1075</td><td class="line"> <span class='comment'>* If it does, then check the following word.</span></td></tr>
<tr class="codeline" data-linenumber="1076"><td class="num" id="LN1076">1076</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="1077"><td class="num" id="LN1077">1077</td><td class="line"> <span class='comment'>* If "mode" is "FIND_COMPOUND" then do the same after another word, find a</span></td></tr>
<tr class="codeline" data-linenumber="1078"><td class="num" id="LN1078">1078</td><td class="line"> <span class='comment'>* prefix in a compound word.</span></td></tr>
<tr class="codeline" data-linenumber="1079"><td class="num" id="LN1079">1079</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="1080"><td class="num" id="LN1080">1080</td><td class="line"> <span class='comment'>* For a match mip-&gt;mi_result is updated.</span></td></tr>
<tr class="codeline" data-linenumber="1081"><td class="num" id="LN1081">1081</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1082"><td class="num" id="LN1082">1082</td><td class="line">    <span class='keyword'>static</span> <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="1083"><td class="num" id="LN1083">1083</td><td class="line">find_prefix(matchinf_T *mip, <span class='keyword'>int</span> mode)</td></tr>
<tr class="codeline" data-linenumber="1084"><td class="num" id="LN1084">1084</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="1085"><td class="num" id="LN1085">1085</td><td class="line">    idx_T	arridx = 0;</td></tr>
<tr class="codeline" data-linenumber="1086"><td class="num" id="LN1086">1086</td><td class="line">    <span class='keyword'>int</span>		len;</td></tr>
<tr class="codeline" data-linenumber="1087"><td class="num" id="LN1087">1087</td><td class="line">    <span class='keyword'>int</span>		wlen = 0;</td></tr>
<tr class="codeline" data-linenumber="1088"><td class="num" id="LN1088">1088</td><td class="line">    <span class='keyword'>int</span>		flen;</td></tr>
<tr class="codeline" data-linenumber="1089"><td class="num" id="LN1089">1089</td><td class="line">    <span class='keyword'>int</span>		c;</td></tr>
<tr class="codeline" data-linenumber="1090"><td class="num" id="LN1090">1090</td><td class="line">    char_u	*ptr;</td></tr>
<tr class="codeline" data-linenumber="1091"><td class="num" id="LN1091">1091</td><td class="line">    idx_T	lo, hi, m;</td></tr>
<tr class="codeline" data-linenumber="1092"><td class="num" id="LN1092">1092</td><td class="line">    slang_T	*slang = mip-&gt;mi_lp-&gt;lp_slang;</td></tr>
<tr class="codeline" data-linenumber="1093"><td class="num" id="LN1093">1093</td><td class="line">    char_u	*byts;</td></tr>
<tr class="codeline" data-linenumber="1094"><td class="num" id="LN1094">1094</td><td class="line">    idx_T	*idxs;</td></tr>
<tr class="codeline" data-linenumber="1095"><td class="num" id="LN1095">1095</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1096"><td class="num" id="LN1096">1096</td><td class="line">    byts = slang-&gt;sl_pbyts;</td></tr>
<tr class="codeline" data-linenumber="1097"><td class="num" id="LN1097">1097</td><td class="line">    <span class='keyword'>if</span> (byts == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1098"><td class="num" id="LN1098">1098</td><td class="line">	<span class='keyword'>return</span>;			<span class='comment'>// array is empty</span></td></tr>
<tr class="codeline" data-linenumber="1099"><td class="num" id="LN1099">1099</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1100"><td class="num" id="LN1100">1100</td><td class="line">    <span class='comment'>// We use the case-folded word here, since prefixes are always</span></td></tr>
<tr class="codeline" data-linenumber="1101"><td class="num" id="LN1101">1101</td><td class="line">    <span class='comment'>// case-folded.</span></td></tr>
<tr class="codeline" data-linenumber="1102"><td class="num" id="LN1102">1102</td><td class="line">    ptr = mip-&gt;mi_fword;</td></tr>
<tr class="codeline" data-linenumber="1103"><td class="num" id="LN1103">1103</td><td class="line">    flen = mip-&gt;mi_fwordlen;    <span class='comment'>// available case-folded bytes</span></td></tr>
<tr class="codeline" data-linenumber="1104"><td class="num" id="LN1104">1104</td><td class="line">    <span class='keyword'>if</span> (mode == <span class='macro'>FIND_COMPOUND<span class='macro_popup'>3</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1105"><td class="num" id="LN1105">1105</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="1106"><td class="num" id="LN1106">1106</td><td class="line">	<span class='comment'>// Skip over the previously found word(s).</span></td></tr>
<tr class="codeline" data-linenumber="1107"><td class="num" id="LN1107">1107</td><td class="line">	ptr += mip-&gt;mi_compoff;</td></tr>
<tr class="codeline" data-linenumber="1108"><td class="num" id="LN1108">1108</td><td class="line">	flen -= mip-&gt;mi_compoff;</td></tr>
<tr class="codeline" data-linenumber="1109"><td class="num" id="LN1109">1109</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1110"><td class="num" id="LN1110">1110</td><td class="line">    idxs = slang-&gt;sl_pidxs;</td></tr>
<tr class="codeline" data-linenumber="1111"><td class="num" id="LN1111">1111</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1112"><td class="num" id="LN1112">1112</td><td class="line">    <span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="1113"><td class="num" id="LN1113">1113</td><td class="line">     <span class='comment'>* Repeat advancing in the tree until:</span></td></tr>
<tr class="codeline" data-linenumber="1114"><td class="num" id="LN1114">1114</td><td class="line">     <span class='comment'>* - there is a byte that doesn't match,</span></td></tr>
<tr class="codeline" data-linenumber="1115"><td class="num" id="LN1115">1115</td><td class="line">     <span class='comment'>* - we reach the end of the tree,</span></td></tr>
<tr class="codeline" data-linenumber="1116"><td class="num" id="LN1116">1116</td><td class="line">     <span class='comment'>* - or we reach the end of the line.</span></td></tr>
<tr class="codeline" data-linenumber="1117"><td class="num" id="LN1117">1117</td><td class="line">     <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1118"><td class="num" id="LN1118">1118</td><td class="line">    <span class='keyword'>for</span> (;;)</td></tr>
<tr class="codeline" data-linenumber="1119"><td class="num" id="LN1119">1119</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="1120"><td class="num" id="LN1120">1120</td><td class="line">	<span class='keyword'>if</span> (flen == 0 &amp;&amp; *mip-&gt;mi_fend != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1121"><td class="num" id="LN1121">1121</td><td class="line">	    flen = fold_more(mip);</td></tr>
<tr class="codeline" data-linenumber="1122"><td class="num" id="LN1122">1122</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1123"><td class="num" id="LN1123">1123</td><td class="line">	len = byts[arridx++];</td></tr>
<tr class="codeline" data-linenumber="1124"><td class="num" id="LN1124">1124</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1125"><td class="num" id="LN1125">1125</td><td class="line">	<span class='comment'>// If the first possible byte is a zero the prefix could end here.</span></td></tr>
<tr class="codeline" data-linenumber="1126"><td class="num" id="LN1126">1126</td><td class="line">	<span class='comment'>// Check if the following word matches and supports the prefix.</span></td></tr>
<tr class="codeline" data-linenumber="1127"><td class="num" id="LN1127">1127</td><td class="line">	<span class='keyword'>if</span> (byts[arridx] == 0)</td></tr>
<tr class="codeline" data-linenumber="1128"><td class="num" id="LN1128">1128</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="1129"><td class="num" id="LN1129">1129</td><td class="line">	    <span class='comment'>// There can be several prefixes with different conditions.  We</span></td></tr>
<tr class="codeline" data-linenumber="1130"><td class="num" id="LN1130">1130</td><td class="line">	    <span class='comment'>// try them all, since we don't know which one will give the</span></td></tr>
<tr class="codeline" data-linenumber="1131"><td class="num" id="LN1131">1131</td><td class="line">	    <span class='comment'>// longest match.  The word is the same each time, pass the list</span></td></tr>
<tr class="codeline" data-linenumber="1132"><td class="num" id="LN1132">1132</td><td class="line">	    <span class='comment'>// of possible prefixes to find_word().</span></td></tr>
<tr class="codeline" data-linenumber="1133"><td class="num" id="LN1133">1133</td><td class="line">	    mip-&gt;mi_prefarridx = arridx;</td></tr>
<tr class="codeline" data-linenumber="1134"><td class="num" id="LN1134">1134</td><td class="line">	    mip-&gt;mi_prefcnt = len;</td></tr>
<tr class="codeline" data-linenumber="1135"><td class="num" id="LN1135">1135</td><td class="line">	    <span class='keyword'>while</span> (len &gt; 0 &amp;&amp; byts[arridx] == 0)</td></tr>
<tr class="codeline" data-linenumber="1136"><td class="num" id="LN1136">1136</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="1137"><td class="num" id="LN1137">1137</td><td class="line">		++arridx;</td></tr>
<tr class="codeline" data-linenumber="1138"><td class="num" id="LN1138">1138</td><td class="line">		--len;</td></tr>
<tr class="codeline" data-linenumber="1139"><td class="num" id="LN1139">1139</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="1140"><td class="num" id="LN1140">1140</td><td class="line">	    mip-&gt;mi_prefcnt -= len;</td></tr>
<tr class="codeline" data-linenumber="1141"><td class="num" id="LN1141">1141</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1142"><td class="num" id="LN1142">1142</td><td class="line">	    <span class='comment'>// Find the word that comes after the prefix.</span></td></tr>
<tr class="codeline" data-linenumber="1143"><td class="num" id="LN1143">1143</td><td class="line">	    mip-&gt;mi_prefixlen = wlen;</td></tr>
<tr class="codeline" data-linenumber="1144"><td class="num" id="LN1144">1144</td><td class="line">	    <span class='keyword'>if</span> (mode == <span class='macro'>FIND_COMPOUND<span class='macro_popup'>3</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1145"><td class="num" id="LN1145">1145</td><td class="line">		<span class='comment'>// Skip over the previously found word(s).</span></td></tr>
<tr class="codeline" data-linenumber="1146"><td class="num" id="LN1146">1146</td><td class="line">		mip-&gt;mi_prefixlen += mip-&gt;mi_compoff;</td></tr>
<tr class="codeline" data-linenumber="1147"><td class="num" id="LN1147">1147</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1148"><td class="num" id="LN1148">1148</td><td class="line">	    <span class='keyword'>if</span> (has_mbyte)</td></tr>
<tr class="codeline" data-linenumber="1149"><td class="num" id="LN1149">1149</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="1150"><td class="num" id="LN1150">1150</td><td class="line">		<span class='comment'>// Case-folded length may differ from original length.</span></td></tr>
<tr class="codeline" data-linenumber="1151"><td class="num" id="LN1151">1151</td><td class="line">		mip-&gt;mi_cprefixlen = nofold_len(mip-&gt;mi_fword,</td></tr>
<tr class="codeline" data-linenumber="1152"><td class="num" id="LN1152">1152</td><td class="line">					     mip-&gt;mi_prefixlen, mip-&gt;mi_word);</td></tr>
<tr class="codeline" data-linenumber="1153"><td class="num" id="LN1153">1153</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="1154"><td class="num" id="LN1154">1154</td><td class="line">	    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="1155"><td class="num" id="LN1155">1155</td><td class="line">		mip-&gt;mi_cprefixlen = mip-&gt;mi_prefixlen;</td></tr>
<tr class="codeline" data-linenumber="1156"><td class="num" id="LN1156">1156</td><td class="line">	    find_word(mip, <span class='macro'>FIND_PREFIX<span class='macro_popup'>2</span></span>);</td></tr>
<tr class="codeline" data-linenumber="1157"><td class="num" id="LN1157">1157</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1158"><td class="num" id="LN1158">1158</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1159"><td class="num" id="LN1159">1159</td><td class="line">	    <span class='keyword'>if</span> (len == 0)</td></tr>
<tr class="codeline" data-linenumber="1160"><td class="num" id="LN1160">1160</td><td class="line">		<span class='keyword'>break</span>;	    <span class='comment'>// no children, word must end here</span></td></tr>
<tr class="codeline" data-linenumber="1161"><td class="num" id="LN1161">1161</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="1162"><td class="num" id="LN1162">1162</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1163"><td class="num" id="LN1163">1163</td><td class="line">	<span class='comment'>// Stop looking at end of the line.</span></td></tr>
<tr class="codeline" data-linenumber="1164"><td class="num" id="LN1164">1164</td><td class="line">	<span class='keyword'>if</span> (ptr[wlen] == <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1165"><td class="num" id="LN1165">1165</td><td class="line">	    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="1166"><td class="num" id="LN1166">1166</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1167"><td class="num" id="LN1167">1167</td><td class="line">	<span class='comment'>// Perform a binary search in the list of accepted bytes.</span></td></tr>
<tr class="codeline" data-linenumber="1168"><td class="num" id="LN1168">1168</td><td class="line">	c = ptr[wlen];</td></tr>
<tr class="codeline" data-linenumber="1169"><td class="num" id="LN1169">1169</td><td class="line">	lo = arridx;</td></tr>
<tr class="codeline" data-linenumber="1170"><td class="num" id="LN1170">1170</td><td class="line">	hi = arridx + len - 1;</td></tr>
<tr class="codeline" data-linenumber="1171"><td class="num" id="LN1171">1171</td><td class="line">	<span class='keyword'>while</span> (lo &lt; hi)</td></tr>
<tr class="codeline" data-linenumber="1172"><td class="num" id="LN1172">1172</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="1173"><td class="num" id="LN1173">1173</td><td class="line">	    m = (lo + hi) / 2;</td></tr>
<tr class="codeline" data-linenumber="1174"><td class="num" id="LN1174">1174</td><td class="line">	    <span class='keyword'>if</span> (byts[m] &gt; c)</td></tr>
<tr class="codeline" data-linenumber="1175"><td class="num" id="LN1175">1175</td><td class="line">		hi = m - 1;</td></tr>
<tr class="codeline" data-linenumber="1176"><td class="num" id="LN1176">1176</td><td class="line">	    <span class='keyword'>else</span> <span class='keyword'>if</span> (byts[m] &lt; c)</td></tr>
<tr class="codeline" data-linenumber="1177"><td class="num" id="LN1177">1177</td><td class="line">		lo = m + 1;</td></tr>
<tr class="codeline" data-linenumber="1178"><td class="num" id="LN1178">1178</td><td class="line">	    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="1179"><td class="num" id="LN1179">1179</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="1180"><td class="num" id="LN1180">1180</td><td class="line">		lo = hi = m;</td></tr>
<tr class="codeline" data-linenumber="1181"><td class="num" id="LN1181">1181</td><td class="line">		<span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="1182"><td class="num" id="LN1182">1182</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="1183"><td class="num" id="LN1183">1183</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="1184"><td class="num" id="LN1184">1184</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1185"><td class="num" id="LN1185">1185</td><td class="line">	<span class='comment'>// Stop if there is no matching byte.</span></td></tr>
<tr class="codeline" data-linenumber="1186"><td class="num" id="LN1186">1186</td><td class="line">	<span class='keyword'>if</span> (hi &lt; lo || byts[lo] != c)</td></tr>
<tr class="codeline" data-linenumber="1187"><td class="num" id="LN1187">1187</td><td class="line">	    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="1188"><td class="num" id="LN1188">1188</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1189"><td class="num" id="LN1189">1189</td><td class="line">	<span class='comment'>// Continue at the child (if there is one).</span></td></tr>
<tr class="codeline" data-linenumber="1190"><td class="num" id="LN1190">1190</td><td class="line">	arridx = idxs[lo];</td></tr>
<tr class="codeline" data-linenumber="1191"><td class="num" id="LN1191">1191</td><td class="line">	++wlen;</td></tr>
<tr class="codeline" data-linenumber="1192"><td class="num" id="LN1192">1192</td><td class="line">	--flen;</td></tr>
<tr class="codeline" data-linenumber="1193"><td class="num" id="LN1193">1193</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1194"><td class="num" id="LN1194">1194</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1195"><td class="num" id="LN1195">1195</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1196"><td class="num" id="LN1196">1196</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="1197"><td class="num" id="LN1197">1197</td><td class="line"> <span class='comment'>* Need to fold at least one more character.  Do until next non-word character</span></td></tr>
<tr class="codeline" data-linenumber="1198"><td class="num" id="LN1198">1198</td><td class="line"> <span class='comment'>* for efficiency.  Include the non-word character too.</span></td></tr>
<tr class="codeline" data-linenumber="1199"><td class="num" id="LN1199">1199</td><td class="line"> <span class='comment'>* Return the length of the folded chars in bytes.</span></td></tr>
<tr class="codeline" data-linenumber="1200"><td class="num" id="LN1200">1200</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1201"><td class="num" id="LN1201">1201</td><td class="line">    <span class='keyword'>static</span> <span class='keyword'>int</span></td></tr>
<tr class="codeline" data-linenumber="1202"><td class="num" id="LN1202">1202</td><td class="line">fold_more(matchinf_T *mip)</td></tr>
<tr class="codeline" data-linenumber="1203"><td class="num" id="LN1203">1203</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="1204"><td class="num" id="LN1204">1204</td><td class="line">    <span class='keyword'>int</span>		flen;</td></tr>
<tr class="codeline" data-linenumber="1205"><td class="num" id="LN1205">1205</td><td class="line">    char_u	*p;</td></tr>
<tr class="codeline" data-linenumber="1206"><td class="num" id="LN1206">1206</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1207"><td class="num" id="LN1207">1207</td><td class="line">    p = mip-&gt;mi_fend;</td></tr>
<tr class="codeline" data-linenumber="1208"><td class="num" id="LN1208">1208</td><td class="line">    <span class='keyword'>do</span></td></tr>
<tr class="codeline" data-linenumber="1209"><td class="num" id="LN1209">1209</td><td class="line">	<span class='macro'>MB_PTR_ADV(mip-&gt;mi_fend)<span class='macro_popup'>mip-&gt;mi_fend += (*mb_ptr2len)(mip-&gt;mi_fend)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1210"><td class="num" id="LN1210">1210</td><td class="line">    <span class='keyword'>while</span> (*mip-&gt;mi_fend != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span> &amp;&amp; spell_iswordp(mip-&gt;mi_fend, mip-&gt;mi_win));</td></tr>
<tr class="codeline" data-linenumber="1211"><td class="num" id="LN1211">1211</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1212"><td class="num" id="LN1212">1212</td><td class="line">    <span class='comment'>// Include the non-word character so that we can check for the word end.</span></td></tr>
<tr class="codeline" data-linenumber="1213"><td class="num" id="LN1213">1213</td><td class="line">    <span class='keyword'>if</span> (*mip-&gt;mi_fend != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1214"><td class="num" id="LN1214">1214</td><td class="line">	<span class='macro'>MB_PTR_ADV(mip-&gt;mi_fend)<span class='macro_popup'>mip-&gt;mi_fend += (*mb_ptr2len)(mip-&gt;mi_fend)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1215"><td class="num" id="LN1215">1215</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1216"><td class="num" id="LN1216">1216</td><td class="line">    (<span class='keyword'>void</span>)spell_casefold(p, (<span class='keyword'>int</span>)(mip-&gt;mi_fend - p),</td></tr>
<tr class="codeline" data-linenumber="1217"><td class="num" id="LN1217">1217</td><td class="line">			     mip-&gt;mi_fword + mip-&gt;mi_fwordlen,</td></tr>
<tr class="codeline" data-linenumber="1218"><td class="num" id="LN1218">1218</td><td class="line">			     <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span> - mip-&gt;mi_fwordlen);</td></tr>
<tr class="codeline" data-linenumber="1219"><td class="num" id="LN1219">1219</td><td class="line">    flen = (<span class='keyword'>int</span>)<span class='macro'>STRLEN(mip-&gt;mi_fword + mip-&gt;mi_fwordlen)<span class='macro_popup'>strlen((char *)(mip-&gt;mi_fword + mip-&gt;mi_fwordlen))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1220"><td class="num" id="LN1220">1220</td><td class="line">    mip-&gt;mi_fwordlen += flen;</td></tr>
<tr class="codeline" data-linenumber="1221"><td class="num" id="LN1221">1221</td><td class="line">    <span class='keyword'>return</span> flen;</td></tr>
<tr class="codeline" data-linenumber="1222"><td class="num" id="LN1222">1222</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1223"><td class="num" id="LN1223">1223</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1224"><td class="num" id="LN1224">1224</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="1225"><td class="num" id="LN1225">1225</td><td class="line"> <span class='comment'>* Check case flags for a word.  Return TRUE if the word has the requested</span></td></tr>
<tr class="codeline" data-linenumber="1226"><td class="num" id="LN1226">1226</td><td class="line"> <span class='comment'>* case.</span></td></tr>
<tr class="codeline" data-linenumber="1227"><td class="num" id="LN1227">1227</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1228"><td class="num" id="LN1228">1228</td><td class="line">    <span class='keyword'>int</span></td></tr>
<tr class="codeline" data-linenumber="1229"><td class="num" id="LN1229">1229</td><td class="line">spell_valid_case(</td></tr>
<tr class="codeline" data-linenumber="1230"><td class="num" id="LN1230">1230</td><td class="line">    <span class='keyword'>int</span>	    wordflags,	    <span class='comment'>// flags for the checked word.</span></td></tr>
<tr class="codeline" data-linenumber="1231"><td class="num" id="LN1231">1231</td><td class="line">    <span class='keyword'>int</span>	    treeflags)	    <span class='comment'>// flags for the word in the spell tree</span></td></tr>
<tr class="codeline" data-linenumber="1232"><td class="num" id="LN1232">1232</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="1233"><td class="num" id="LN1233">1233</td><td class="line">    <span class='keyword'>return</span> ((wordflags == <span class='macro'>WF_ALLCAP<span class='macro_popup'>0x04</span></span> &amp;&amp; (treeflags &amp; <span class='macro'>WF_FIXCAP<span class='macro_popup'>0x40</span></span>) == 0)</td></tr>
<tr class="codeline" data-linenumber="1234"><td class="num" id="LN1234">1234</td><td class="line">	    || ((treeflags &amp; (<span class='macro'>WF_ALLCAP<span class='macro_popup'>0x04</span></span> | <span class='macro'>WF_KEEPCAP<span class='macro_popup'>0x80</span></span>)) == 0</td></tr>
<tr class="codeline" data-linenumber="1235"><td class="num" id="LN1235">1235</td><td class="line">		&amp;&amp; ((treeflags &amp; <span class='macro'>WF_ONECAP<span class='macro_popup'>0x02</span></span>) == 0</td></tr>
<tr class="codeline" data-linenumber="1236"><td class="num" id="LN1236">1236</td><td class="line">					   || (wordflags &amp; <span class='macro'>WF_ONECAP<span class='macro_popup'>0x02</span></span>) != 0)));</td></tr>
<tr class="codeline" data-linenumber="1237"><td class="num" id="LN1237">1237</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1238"><td class="num" id="LN1238">1238</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1239"><td class="num" id="LN1239">1239</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="1240"><td class="num" id="LN1240">1240</td><td class="line"> <span class='comment'>* Return TRUE if spell checking is not enabled.</span></td></tr>
<tr class="codeline" data-linenumber="1241"><td class="num" id="LN1241">1241</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1242"><td class="num" id="LN1242">1242</td><td class="line">    <span class='keyword'>int</span></td></tr>
<tr class="codeline" data-linenumber="1243"><td class="num" id="LN1243">1243</td><td class="line">no_spell_checking(win_T *wp)</td></tr>
<tr class="codeline" data-linenumber="1244"><td class="num" id="LN1244">1244</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="1245"><td class="num" id="LN1245">1245</td><td class="line">    <span class='keyword'>if</span> (!wp-&gt;<span class='macro'>w_p_spell<span class='macro_popup'>w_onebuf_opt.wo_spell</span></span> || *wp-&gt;w_s-&gt;b_p_spl == <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span></td></tr>
<tr class="codeline" data-linenumber="1246"><td class="num" id="LN1246">1246</td><td class="line">					 || wp-&gt;w_s-&gt;b_langp.ga_len == 0)</td></tr>
<tr class="codeline" data-linenumber="1247"><td class="num" id="LN1247">1247</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="1248"><td class="num" id="LN1248">1248</td><td class="line">	emsg(<span class='macro'>_(e_no_spell)<span class='macro_popup'>dcgettext (((void*)0), (char *)(e_no_spell), 5)</span></span>);</td></tr>
<tr class="codeline" data-linenumber="1249"><td class="num" id="LN1249">1249</td><td class="line">	<span class='keyword'>return</span> <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1250"><td class="num" id="LN1250">1250</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1251"><td class="num" id="LN1251">1251</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1252"><td class="num" id="LN1252">1252</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1253"><td class="num" id="LN1253">1253</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1254"><td class="num" id="LN1254">1254</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="1255"><td class="num" id="LN1255">1255</td><td class="line"> <span class='comment'>* Move to next spell error.</span></td></tr>
<tr class="codeline" data-linenumber="1256"><td class="num" id="LN1256">1256</td><td class="line"> <span class='comment'>* "curline" is FALSE for "[s", "]s", "[S" and "]S".</span></td></tr>
<tr class="codeline" data-linenumber="1257"><td class="num" id="LN1257">1257</td><td class="line"> <span class='comment'>* "curline" is TRUE to find word under/after cursor in the same line.</span></td></tr>
<tr class="codeline" data-linenumber="1258"><td class="num" id="LN1258">1258</td><td class="line"> <span class='comment'>* For Insert mode completion "dir" is BACKWARD and "curline" is TRUE: move</span></td></tr>
<tr class="codeline" data-linenumber="1259"><td class="num" id="LN1259">1259</td><td class="line"> <span class='comment'>* to after badly spelled word before the cursor.</span></td></tr>
<tr class="codeline" data-linenumber="1260"><td class="num" id="LN1260">1260</td><td class="line"> <span class='comment'>* Return 0 if not found, length of the badly spelled word otherwise.</span></td></tr>
<tr class="codeline" data-linenumber="1261"><td class="num" id="LN1261">1261</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1262"><td class="num" id="LN1262">1262</td><td class="line">    <span class='keyword'>int</span></td></tr>
<tr class="codeline" data-linenumber="1263"><td class="num" id="LN1263">1263</td><td class="line">spell_move_to(</td></tr>
<tr class="codeline" data-linenumber="1264"><td class="num" id="LN1264">1264</td><td class="line">    win_T	*wp,</td></tr>
<tr class="codeline" data-linenumber="1265"><td class="num" id="LN1265">1265</td><td class="line">    <span class='keyword'>int</span>		dir,		<span class='comment'>// FORWARD or BACKWARD</span></td></tr>
<tr class="codeline" data-linenumber="1266"><td class="num" id="LN1266">1266</td><td class="line">    <span class='keyword'>int</span>		allwords,	<span class='comment'>// TRUE for "[s"/"]s", FALSE for "[S"/"]S"</span></td></tr>
<tr class="codeline" data-linenumber="1267"><td class="num" id="LN1267">1267</td><td class="line">    <span class='keyword'>int</span>		curline,</td></tr>
<tr class="codeline" data-linenumber="1268"><td class="num" id="LN1268">1268</td><td class="line">    hlf_T	*attrp)		<span class='comment'>// return: attributes of bad word or NULL</span></td></tr>
<tr class="codeline" data-linenumber="1269"><td class="num" id="LN1269">1269</td><td class="line">				<span class='comment'>// (only when "dir" is FORWARD)</span></td></tr>
<tr class="codeline" data-linenumber="1270"><td class="num" id="LN1270">1270</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="1271"><td class="num" id="LN1271">1271</td><td class="line">    linenr_T	lnum;</td></tr>
<tr class="codeline" data-linenumber="1272"><td class="num" id="LN1272">1272</td><td class="line">    pos_T	found_pos;</td></tr>
<tr class="codeline" data-linenumber="1273"><td class="num" id="LN1273">1273</td><td class="line">    <span class='keyword'>int</span>		found_len = 0;</td></tr>
<tr class="codeline" data-linenumber="1274"><td class="num" id="LN1274">1274</td><td class="line">    char_u	*line;</td></tr>
<tr class="codeline" data-linenumber="1275"><td class="num" id="LN1275">1275</td><td class="line">    char_u	*p;</td></tr>
<tr class="codeline" data-linenumber="1276"><td class="num" id="LN1276">1276</td><td class="line">    char_u	*endp;</td></tr>
<tr class="codeline" data-linenumber="1277"><td class="num" id="LN1277">1277</td><td class="line">    hlf_T	attr;</td></tr>
<tr class="codeline" data-linenumber="1278"><td class="num" id="LN1278">1278</td><td class="line">    <span class='keyword'>int</span>		len;</td></tr>
<tr class="codeline" data-linenumber="1279"><td class="num" id="LN1279">1279</td><td class="line"><span class='directive'>#ifdef FEAT_SYN_HL</span></td></tr>
<tr class="codeline" data-linenumber="1280"><td class="num" id="LN1280">1280</td><td class="line">    <span class='keyword'>int</span>		has_syntax = syntax_present(wp);</td></tr>
<tr class="codeline" data-linenumber="1281"><td class="num" id="LN1281">1281</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="1282"><td class="num" id="LN1282">1282</td><td class="line">    <span class='keyword'>int</span>		col;</td></tr>
<tr class="codeline" data-linenumber="1283"><td class="num" id="LN1283">1283</td><td class="line">    <span class='keyword'>int</span>		can_spell;</td></tr>
<tr class="codeline" data-linenumber="1284"><td class="num" id="LN1284">1284</td><td class="line">    char_u	*buf = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1285"><td class="num" id="LN1285">1285</td><td class="line">    <span class='keyword'>int</span>		buflen = 0;</td></tr>
<tr class="codeline" data-linenumber="1286"><td class="num" id="LN1286">1286</td><td class="line">    <span class='keyword'>int</span>		skip = 0;</td></tr>
<tr class="codeline" data-linenumber="1287"><td class="num" id="LN1287">1287</td><td class="line">    <span class='keyword'>int</span>		capcol = -1;</td></tr>
<tr class="codeline" data-linenumber="1288"><td class="num" id="LN1288">1288</td><td class="line">    <span class='keyword'>int</span>		found_one = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1289"><td class="num" id="LN1289">1289</td><td class="line">    <span class='keyword'>int</span>		wrapped = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1290"><td class="num" id="LN1290">1290</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1291"><td class="num" id="LN1291">1291</td><td class="line">    <span class='keyword'>if</span> (no_spell_checking(wp))</td></tr>
<tr class="codeline" data-linenumber="1292"><td class="num" id="LN1292">1292</td><td class="line">	<span class='keyword'>return</span> 0;</td></tr>
<tr class="codeline" data-linenumber="1293"><td class="num" id="LN1293">1293</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1294"><td class="num" id="LN1294">1294</td><td class="line">    <span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="1295"><td class="num" id="LN1295">1295</td><td class="line">     <span class='comment'>* Start looking for bad word at the start of the line, because we can't</span></td></tr>
<tr class="codeline" data-linenumber="1296"><td class="num" id="LN1296">1296</td><td class="line">     <span class='comment'>* start halfway a word, we don't know where it starts or ends.</span></td></tr>
<tr class="codeline" data-linenumber="1297"><td class="num" id="LN1297">1297</td><td class="line">     <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="1298"><td class="num" id="LN1298">1298</td><td class="line">     <span class='comment'>* When searching backwards, we continue in the line to find the last</span></td></tr>
<tr class="codeline" data-linenumber="1299"><td class="num" id="LN1299">1299</td><td class="line">     <span class='comment'>* bad word (in the cursor line: before the cursor).</span></td></tr>
<tr class="codeline" data-linenumber="1300"><td class="num" id="LN1300">1300</td><td class="line">     <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="1301"><td class="num" id="LN1301">1301</td><td class="line">     <span class='comment'>* We concatenate the start of the next line, so that wrapped words work</span></td></tr>
<tr class="codeline" data-linenumber="1302"><td class="num" id="LN1302">1302</td><td class="line">     <span class='comment'>* (e.g. "et&lt;line-break&gt;cetera").  Doesn't work when searching backwards</span></td></tr>
<tr class="codeline" data-linenumber="1303"><td class="num" id="LN1303">1303</td><td class="line">     <span class='comment'>* though...</span></td></tr>
<tr class="codeline" data-linenumber="1304"><td class="num" id="LN1304">1304</td><td class="line">     <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1305"><td class="num" id="LN1305">1305</td><td class="line">    lnum = wp-&gt;w_cursor.lnum;</td></tr>
<tr class="codeline" data-linenumber="1306"><td class="num" id="LN1306">1306</td><td class="line">    <span class='macro'>CLEAR_POS(&amp;found_pos)<span class='macro_popup'>do {(&amp;found_pos)-&gt;lnum = 0; (&amp;found_pos)-&gt;col =<br> 0; (&amp;found_pos)-&gt;coladd = 0;} while (0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1307"><td class="num" id="LN1307">1307</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1308"><td class="num" id="LN1308">1308</td><td class="line">    <span class='keyword'>while</span> (!got_int)</td></tr>
<tr class="codeline" data-linenumber="1309"><td class="num" id="LN1309">1309</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="1310"><td class="num" id="LN1310">1310</td><td class="line">	line = ml_get_buf(wp-&gt;w_buffer, lnum, <span class='macro'>FALSE<span class='macro_popup'>0</span></span>);</td></tr>
<tr class="codeline" data-linenumber="1311"><td class="num" id="LN1311">1311</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1312"><td class="num" id="LN1312">1312</td><td class="line">	len = (<span class='keyword'>int</span>)<span class='macro'>STRLEN(line)<span class='macro_popup'>strlen((char *)(line))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1313"><td class="num" id="LN1313">1313</td><td class="line">	<span class='keyword'>if</span> (buflen &lt; len + <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span> + 2)</td></tr>
<tr class="codeline" data-linenumber="1314"><td class="num" id="LN1314">1314</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="1315"><td class="num" id="LN1315">1315</td><td class="line">	    vim_free(buf);</td></tr>
<tr class="codeline" data-linenumber="1316"><td class="num" id="LN1316">1316</td><td class="line">	    buflen = len + <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span> + 2;</td></tr>
<tr class="codeline" data-linenumber="1317"><td class="num" id="LN1317">1317</td><td class="line">	    buf = alloc(buflen);</td></tr>
<tr class="codeline" data-linenumber="1318"><td class="num" id="LN1318">1318</td><td class="line">	    <span class='keyword'>if</span> (buf == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1319"><td class="num" id="LN1319">1319</td><td class="line">		<span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="1320"><td class="num" id="LN1320">1320</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="1321"><td class="num" id="LN1321">1321</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1322"><td class="num" id="LN1322">1322</td><td class="line">	<span class='comment'>// In first line check first word for Capital.</span></td></tr>
<tr class="codeline" data-linenumber="1323"><td class="num" id="LN1323">1323</td><td class="line">	<span class='keyword'>if</span> (lnum == 1)</td></tr>
<tr class="codeline" data-linenumber="1324"><td class="num" id="LN1324">1324</td><td class="line">	    capcol = 0;</td></tr>
<tr class="codeline" data-linenumber="1325"><td class="num" id="LN1325">1325</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1326"><td class="num" id="LN1326">1326</td><td class="line">	<span class='comment'>// For checking first word with a capital skip white space.</span></td></tr>
<tr class="codeline" data-linenumber="1327"><td class="num" id="LN1327">1327</td><td class="line">	<span class='keyword'>if</span> (capcol == 0)</td></tr>
<tr class="codeline" data-linenumber="1328"><td class="num" id="LN1328">1328</td><td class="line">	    capcol = getwhitecols(line);</td></tr>
<tr class="codeline" data-linenumber="1329"><td class="num" id="LN1329">1329</td><td class="line">	<span class='keyword'>else</span> <span class='keyword'>if</span> (curline &amp;&amp; wp == curwin)</td></tr>
<tr class="codeline" data-linenumber="1330"><td class="num" id="LN1330">1330</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="1331"><td class="num" id="LN1331">1331</td><td class="line">	    <span class='comment'>// For spellbadword(): check if first word needs a capital.</span></td></tr>
<tr class="codeline" data-linenumber="1332"><td class="num" id="LN1332">1332</td><td class="line">	    col = getwhitecols(line);</td></tr>
<tr class="codeline" data-linenumber="1333"><td class="num" id="LN1333">1333</td><td class="line">	    <span class='keyword'>if</span> (check_need_cap(lnum, col))</td></tr>
<tr class="codeline" data-linenumber="1334"><td class="num" id="LN1334">1334</td><td class="line">		capcol = col;</td></tr>
<tr class="codeline" data-linenumber="1335"><td class="num" id="LN1335">1335</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1336"><td class="num" id="LN1336">1336</td><td class="line">	    <span class='comment'>// Need to get the line again, may have looked at the previous</span></td></tr>
<tr class="codeline" data-linenumber="1337"><td class="num" id="LN1337">1337</td><td class="line">	    <span class='comment'>// one.</span></td></tr>
<tr class="codeline" data-linenumber="1338"><td class="num" id="LN1338">1338</td><td class="line">	    line = ml_get_buf(wp-&gt;w_buffer, lnum, <span class='macro'>FALSE<span class='macro_popup'>0</span></span>);</td></tr>
<tr class="codeline" data-linenumber="1339"><td class="num" id="LN1339">1339</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="1340"><td class="num" id="LN1340">1340</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1341"><td class="num" id="LN1341">1341</td><td class="line">	<span class='comment'>// Copy the line into "buf" and append the start of the next line if</span></td></tr>
<tr class="codeline" data-linenumber="1342"><td class="num" id="LN1342">1342</td><td class="line">	<span class='comment'>// possible.</span></td></tr>
<tr class="codeline" data-linenumber="1343"><td class="num" id="LN1343">1343</td><td class="line">	<span class='macro'>STRCPY(buf, line)<span class='macro_popup'>strcpy((char *)(buf), (char *)(line))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1344"><td class="num" id="LN1344">1344</td><td class="line">	<span class='keyword'>if</span> (lnum &lt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count)</td></tr>
<tr class="codeline" data-linenumber="1345"><td class="num" id="LN1345">1345</td><td class="line">	    spell_cat_line(buf + <span class='macro'>STRLEN(buf)<span class='macro_popup'>strlen((char *)(buf))</span></span>,</td></tr>
<tr class="codeline" data-linenumber="1346"><td class="num" id="LN1346">1346</td><td class="line">			  ml_get_buf(wp-&gt;w_buffer, lnum + 1, <span class='macro'>FALSE<span class='macro_popup'>0</span></span>), <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>);</td></tr>
<tr class="codeline" data-linenumber="1347"><td class="num" id="LN1347">1347</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1348"><td class="num" id="LN1348">1348</td><td class="line">	p = buf + skip;</td></tr>
<tr class="codeline" data-linenumber="1349"><td class="num" id="LN1349">1349</td><td class="line">	endp = buf + len;</td></tr>
<tr class="codeline" data-linenumber="1350"><td class="num" id="LN1350">1350</td><td class="line">	<span class='keyword'>while</span> (p &lt; endp)</td></tr>
<tr class="codeline" data-linenumber="1351"><td class="num" id="LN1351">1351</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="1352"><td class="num" id="LN1352">1352</td><td class="line">	    <span class='comment'>// When searching backward don't search after the cursor.  Unless</span></td></tr>
<tr class="codeline" data-linenumber="1353"><td class="num" id="LN1353">1353</td><td class="line">	    <span class='comment'>// we wrapped around the end of the buffer.</span></td></tr>
<tr class="codeline" data-linenumber="1354"><td class="num" id="LN1354">1354</td><td class="line">	    <span class='keyword'>if</span> (dir == <span class='macro'>BACKWARD<span class='macro_popup'>(-1)</span></span></td></tr>
<tr class="codeline" data-linenumber="1355"><td class="num" id="LN1355">1355</td><td class="line">		    &amp;&amp; lnum == wp-&gt;w_cursor.lnum</td></tr>
<tr class="codeline" data-linenumber="1356"><td class="num" id="LN1356">1356</td><td class="line">		    &amp;&amp; !wrapped</td></tr>
<tr class="codeline" data-linenumber="1357"><td class="num" id="LN1357">1357</td><td class="line">		    &amp;&amp; (colnr_T)(p - buf) &gt;= wp-&gt;w_cursor.col)</td></tr>
<tr class="codeline" data-linenumber="1358"><td class="num" id="LN1358">1358</td><td class="line">		<span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="1359"><td class="num" id="LN1359">1359</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1360"><td class="num" id="LN1360">1360</td><td class="line">	    <span class='comment'>// start of word</span></td></tr>
<tr class="codeline" data-linenumber="1361"><td class="num" id="LN1361">1361</td><td class="line">	    attr = HLF_COUNT;</td></tr>
<tr class="codeline" data-linenumber="1362"><td class="num" id="LN1362">1362</td><td class="line">	    len = spell_check(wp, p, &amp;attr, &amp;capcol, <span class='macro'>FALSE<span class='macro_popup'>0</span></span>);</td></tr>
<tr class="codeline" data-linenumber="1363"><td class="num" id="LN1363">1363</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1364"><td class="num" id="LN1364">1364</td><td class="line">	    <span class='keyword'>if</span> (attr != HLF_COUNT)</td></tr>
<tr class="codeline" data-linenumber="1365"><td class="num" id="LN1365">1365</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="1366"><td class="num" id="LN1366">1366</td><td class="line">		<span class='comment'>// We found a bad word.  Check the attribute.</span></td></tr>
<tr class="codeline" data-linenumber="1367"><td class="num" id="LN1367">1367</td><td class="line">		<span class='keyword'>if</span> (allwords || attr == HLF_SPB)</td></tr>
<tr class="codeline" data-linenumber="1368"><td class="num" id="LN1368">1368</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="1369"><td class="num" id="LN1369">1369</td><td class="line">		    <span class='comment'>// When searching forward only accept a bad word after</span></td></tr>
<tr class="codeline" data-linenumber="1370"><td class="num" id="LN1370">1370</td><td class="line">		    <span class='comment'>// the cursor.</span></td></tr>
<tr class="codeline" data-linenumber="1371"><td class="num" id="LN1371">1371</td><td class="line">		    <span class='keyword'>if</span> (dir == <span class='macro'>BACKWARD<span class='macro_popup'>(-1)</span></span></td></tr>
<tr class="codeline" data-linenumber="1372"><td class="num" id="LN1372">1372</td><td class="line">			    || lnum != wp-&gt;w_cursor.lnum</td></tr>
<tr class="codeline" data-linenumber="1373"><td class="num" id="LN1373">1373</td><td class="line">			    || (lnum == wp-&gt;w_cursor.lnum</td></tr>
<tr class="codeline" data-linenumber="1374"><td class="num" id="LN1374">1374</td><td class="line">				&amp;&amp; (wrapped</td></tr>
<tr class="codeline" data-linenumber="1375"><td class="num" id="LN1375">1375</td><td class="line">				    || (colnr_T)(curline ? p - buf + len</td></tr>
<tr class="codeline" data-linenumber="1376"><td class="num" id="LN1376">1376</td><td class="line">						     : p - buf)</td></tr>
<tr class="codeline" data-linenumber="1377"><td class="num" id="LN1377">1377</td><td class="line">						  &gt; wp-&gt;w_cursor.col)))</td></tr>
<tr class="codeline" data-linenumber="1378"><td class="num" id="LN1378">1378</td><td class="line">		    {</td></tr>
<tr class="codeline" data-linenumber="1379"><td class="num" id="LN1379">1379</td><td class="line"><span class='directive'>#ifdef FEAT_SYN_HL</span></td></tr>
<tr class="codeline" data-linenumber="1380"><td class="num" id="LN1380">1380</td><td class="line">			<span class='keyword'>if</span> (has_syntax)</td></tr>
<tr class="codeline" data-linenumber="1381"><td class="num" id="LN1381">1381</td><td class="line">			{</td></tr>
<tr class="codeline" data-linenumber="1382"><td class="num" id="LN1382">1382</td><td class="line">			    col = (<span class='keyword'>int</span>)(p - buf);</td></tr>
<tr class="codeline" data-linenumber="1383"><td class="num" id="LN1383">1383</td><td class="line">			    (<span class='keyword'>void</span>)syn_get_id(wp, lnum, (colnr_T)col,</td></tr>
<tr class="codeline" data-linenumber="1384"><td class="num" id="LN1384">1384</td><td class="line">						    <span class='macro'>FALSE<span class='macro_popup'>0</span></span>, &amp;can_spell, <span class='macro'>FALSE<span class='macro_popup'>0</span></span>);</td></tr>
<tr class="codeline" data-linenumber="1385"><td class="num" id="LN1385">1385</td><td class="line">			    <span class='keyword'>if</span> (!can_spell)</td></tr>
<tr class="codeline" data-linenumber="1386"><td class="num" id="LN1386">1386</td><td class="line">				attr = HLF_COUNT;</td></tr>
<tr class="codeline" data-linenumber="1387"><td class="num" id="LN1387">1387</td><td class="line">			}</td></tr>
<tr class="codeline" data-linenumber="1388"><td class="num" id="LN1388">1388</td><td class="line">			<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="1389"><td class="num" id="LN1389">1389</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="1390"><td class="num" id="LN1390">1390</td><td class="line">			    can_spell = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1391"><td class="num" id="LN1391">1391</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1392"><td class="num" id="LN1392">1392</td><td class="line">			<span class='keyword'>if</span> (can_spell)</td></tr>
<tr class="codeline" data-linenumber="1393"><td class="num" id="LN1393">1393</td><td class="line">			{</td></tr>
<tr class="codeline" data-linenumber="1394"><td class="num" id="LN1394">1394</td><td class="line">			    found_one = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1395"><td class="num" id="LN1395">1395</td><td class="line">			    found_pos.lnum = lnum;</td></tr>
<tr class="codeline" data-linenumber="1396"><td class="num" id="LN1396">1396</td><td class="line">			    found_pos.col = (<span class='keyword'>int</span>)(p - buf);</td></tr>
<tr class="codeline" data-linenumber="1397"><td class="num" id="LN1397">1397</td><td class="line">			    found_pos.coladd = 0;</td></tr>
<tr class="codeline" data-linenumber="1398"><td class="num" id="LN1398">1398</td><td class="line">			    <span class='keyword'>if</span> (dir == <span class='macro'>FORWARD<span class='macro_popup'>1</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1399"><td class="num" id="LN1399">1399</td><td class="line">			    {</td></tr>
<tr class="codeline" data-linenumber="1400"><td class="num" id="LN1400">1400</td><td class="line">				<span class='comment'>// No need to search further.</span></td></tr>
<tr class="codeline" data-linenumber="1401"><td class="num" id="LN1401">1401</td><td class="line">				wp-&gt;w_cursor = found_pos;</td></tr>
<tr class="codeline" data-linenumber="1402"><td class="num" id="LN1402">1402</td><td class="line">				vim_free(buf);</td></tr>
<tr class="codeline" data-linenumber="1403"><td class="num" id="LN1403">1403</td><td class="line">				<span class='keyword'>if</span> (attrp != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1404"><td class="num" id="LN1404">1404</td><td class="line">				    *attrp = attr;</td></tr>
<tr class="codeline" data-linenumber="1405"><td class="num" id="LN1405">1405</td><td class="line">				<span class='keyword'>return</span> len;</td></tr>
<tr class="codeline" data-linenumber="1406"><td class="num" id="LN1406">1406</td><td class="line">			    }</td></tr>
<tr class="codeline" data-linenumber="1407"><td class="num" id="LN1407">1407</td><td class="line">			    <span class='keyword'>else</span> <span class='keyword'>if</span> (curline)</td></tr>
<tr class="codeline" data-linenumber="1408"><td class="num" id="LN1408">1408</td><td class="line">				<span class='comment'>// Insert mode completion: put cursor after</span></td></tr>
<tr class="codeline" data-linenumber="1409"><td class="num" id="LN1409">1409</td><td class="line">				<span class='comment'>// the bad word.</span></td></tr>
<tr class="codeline" data-linenumber="1410"><td class="num" id="LN1410">1410</td><td class="line">				found_pos.col += len;</td></tr>
<tr class="codeline" data-linenumber="1411"><td class="num" id="LN1411">1411</td><td class="line">			    found_len = len;</td></tr>
<tr class="codeline" data-linenumber="1412"><td class="num" id="LN1412">1412</td><td class="line">			}</td></tr>
<tr class="codeline" data-linenumber="1413"><td class="num" id="LN1413">1413</td><td class="line">		    }</td></tr>
<tr class="codeline" data-linenumber="1414"><td class="num" id="LN1414">1414</td><td class="line">		    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="1415"><td class="num" id="LN1415">1415</td><td class="line">			found_one = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1416"><td class="num" id="LN1416">1416</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="1417"><td class="num" id="LN1417">1417</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="1418"><td class="num" id="LN1418">1418</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1419"><td class="num" id="LN1419">1419</td><td class="line">	    <span class='comment'>// advance to character after the word</span></td></tr>
<tr class="codeline" data-linenumber="1420"><td class="num" id="LN1420">1420</td><td class="line">	    p += len;</td></tr>
<tr class="codeline" data-linenumber="1421"><td class="num" id="LN1421">1421</td><td class="line">	    capcol -= len;</td></tr>
<tr class="codeline" data-linenumber="1422"><td class="num" id="LN1422">1422</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="1423"><td class="num" id="LN1423">1423</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1424"><td class="num" id="LN1424">1424</td><td class="line">	<span class='keyword'>if</span> (dir == <span class='macro'>BACKWARD<span class='macro_popup'>(-1)</span></span> &amp;&amp; found_pos.lnum != 0)</td></tr>
<tr class="codeline" data-linenumber="1425"><td class="num" id="LN1425">1425</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="1426"><td class="num" id="LN1426">1426</td><td class="line">	    <span class='comment'>// Use the last match in the line (before the cursor).</span></td></tr>
<tr class="codeline" data-linenumber="1427"><td class="num" id="LN1427">1427</td><td class="line">	    wp-&gt;w_cursor = found_pos;</td></tr>
<tr class="codeline" data-linenumber="1428"><td class="num" id="LN1428">1428</td><td class="line">	    vim_free(buf);</td></tr>
<tr class="codeline" data-linenumber="1429"><td class="num" id="LN1429">1429</td><td class="line">	    <span class='keyword'>return</span> found_len;</td></tr>
<tr class="codeline" data-linenumber="1430"><td class="num" id="LN1430">1430</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="1431"><td class="num" id="LN1431">1431</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1432"><td class="num" id="LN1432">1432</td><td class="line">	<span class='keyword'>if</span> (curline)</td></tr>
<tr class="codeline" data-linenumber="1433"><td class="num" id="LN1433">1433</td><td class="line">	    <span class='keyword'>break</span>;	<span class='comment'>// only check cursor line</span></td></tr>
<tr class="codeline" data-linenumber="1434"><td class="num" id="LN1434">1434</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1435"><td class="num" id="LN1435">1435</td><td class="line">	<span class='comment'>// If we are back at the starting line and searched it again there</span></td></tr>
<tr class="codeline" data-linenumber="1436"><td class="num" id="LN1436">1436</td><td class="line">	<span class='comment'>// is no match, give up.</span></td></tr>
<tr class="codeline" data-linenumber="1437"><td class="num" id="LN1437">1437</td><td class="line">	<span class='keyword'>if</span> (lnum == wp-&gt;w_cursor.lnum &amp;&amp; wrapped)</td></tr>
<tr class="codeline" data-linenumber="1438"><td class="num" id="LN1438">1438</td><td class="line">	    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="1439"><td class="num" id="LN1439">1439</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1440"><td class="num" id="LN1440">1440</td><td class="line">	<span class='comment'>// Advance to next line.</span></td></tr>
<tr class="codeline" data-linenumber="1441"><td class="num" id="LN1441">1441</td><td class="line">	<span class='keyword'>if</span> (dir == <span class='macro'>BACKWARD<span class='macro_popup'>(-1)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1442"><td class="num" id="LN1442">1442</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="1443"><td class="num" id="LN1443">1443</td><td class="line">	    <span class='keyword'>if</span> (lnum &gt; 1)</td></tr>
<tr class="codeline" data-linenumber="1444"><td class="num" id="LN1444">1444</td><td class="line">		--lnum;</td></tr>
<tr class="codeline" data-linenumber="1445"><td class="num" id="LN1445">1445</td><td class="line">	    <span class='keyword'>else</span> <span class='keyword'>if</span> (!p_ws)</td></tr>
<tr class="codeline" data-linenumber="1446"><td class="num" id="LN1446">1446</td><td class="line">		<span class='keyword'>break</span>;	    <span class='comment'>// at first line and 'nowrapscan'</span></td></tr>
<tr class="codeline" data-linenumber="1447"><td class="num" id="LN1447">1447</td><td class="line">	    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="1448"><td class="num" id="LN1448">1448</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="1449"><td class="num" id="LN1449">1449</td><td class="line">		<span class='comment'>// Wrap around to the end of the buffer.  May search the</span></td></tr>
<tr class="codeline" data-linenumber="1450"><td class="num" id="LN1450">1450</td><td class="line">		<span class='comment'>// starting line again and accept the last match.</span></td></tr>
<tr class="codeline" data-linenumber="1451"><td class="num" id="LN1451">1451</td><td class="line">		lnum = wp-&gt;w_buffer-&gt;b_ml.ml_line_count;</td></tr>
<tr class="codeline" data-linenumber="1452"><td class="num" id="LN1452">1452</td><td class="line">		wrapped = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1453"><td class="num" id="LN1453">1453</td><td class="line">		<span class='keyword'>if</span> (!shortmess(<span class='macro'>SHM_SEARCH<span class='macro_popup'>'s'</span></span>))</td></tr>
<tr class="codeline" data-linenumber="1454"><td class="num" id="LN1454">1454</td><td class="line">		    give_warning((char_u *)<span class='macro'>_(top_bot_msg)<span class='macro_popup'>dcgettext (((void*)0), (char *)(top_bot_msg), 5)</span></span>, <span class='macro'>TRUE<span class='macro_popup'>1</span></span>);</td></tr>
<tr class="codeline" data-linenumber="1455"><td class="num" id="LN1455">1455</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="1456"><td class="num" id="LN1456">1456</td><td class="line">	    capcol = -1;</td></tr>
<tr class="codeline" data-linenumber="1457"><td class="num" id="LN1457">1457</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="1458"><td class="num" id="LN1458">1458</td><td class="line">	<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="1459"><td class="num" id="LN1459">1459</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="1460"><td class="num" id="LN1460">1460</td><td class="line">	    <span class='keyword'>if</span> (lnum &lt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count)</td></tr>
<tr class="codeline" data-linenumber="1461"><td class="num" id="LN1461">1461</td><td class="line">		++lnum;</td></tr>
<tr class="codeline" data-linenumber="1462"><td class="num" id="LN1462">1462</td><td class="line">	    <span class='keyword'>else</span> <span class='keyword'>if</span> (!p_ws)</td></tr>
<tr class="codeline" data-linenumber="1463"><td class="num" id="LN1463">1463</td><td class="line">		<span class='keyword'>break</span>;	    <span class='comment'>// at first line and 'nowrapscan'</span></td></tr>
<tr class="codeline" data-linenumber="1464"><td class="num" id="LN1464">1464</td><td class="line">	    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="1465"><td class="num" id="LN1465">1465</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="1466"><td class="num" id="LN1466">1466</td><td class="line">		<span class='comment'>// Wrap around to the start of the buffer.  May search the</span></td></tr>
<tr class="codeline" data-linenumber="1467"><td class="num" id="LN1467">1467</td><td class="line">		<span class='comment'>// starting line again and accept the first match.</span></td></tr>
<tr class="codeline" data-linenumber="1468"><td class="num" id="LN1468">1468</td><td class="line">		lnum = 1;</td></tr>
<tr class="codeline" data-linenumber="1469"><td class="num" id="LN1469">1469</td><td class="line">		wrapped = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1470"><td class="num" id="LN1470">1470</td><td class="line">		<span class='keyword'>if</span> (!shortmess(<span class='macro'>SHM_SEARCH<span class='macro_popup'>'s'</span></span>))</td></tr>
<tr class="codeline" data-linenumber="1471"><td class="num" id="LN1471">1471</td><td class="line">		    give_warning((char_u *)<span class='macro'>_(bot_top_msg)<span class='macro_popup'>dcgettext (((void*)0), (char *)(bot_top_msg), 5)</span></span>, <span class='macro'>TRUE<span class='macro_popup'>1</span></span>);</td></tr>
<tr class="codeline" data-linenumber="1472"><td class="num" id="LN1472">1472</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="1473"><td class="num" id="LN1473">1473</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1474"><td class="num" id="LN1474">1474</td><td class="line">	    <span class='comment'>// If we are back at the starting line and there is no match then</span></td></tr>
<tr class="codeline" data-linenumber="1475"><td class="num" id="LN1475">1475</td><td class="line">	    <span class='comment'>// give up.</span></td></tr>
<tr class="codeline" data-linenumber="1476"><td class="num" id="LN1476">1476</td><td class="line">	    <span class='keyword'>if</span> (lnum == wp-&gt;w_cursor.lnum &amp;&amp; !found_one)</td></tr>
<tr class="codeline" data-linenumber="1477"><td class="num" id="LN1477">1477</td><td class="line">		<span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="1478"><td class="num" id="LN1478">1478</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1479"><td class="num" id="LN1479">1479</td><td class="line">	    <span class='comment'>// Skip the characters at the start of the next line that were</span></td></tr>
<tr class="codeline" data-linenumber="1480"><td class="num" id="LN1480">1480</td><td class="line">	    <span class='comment'>// included in a match crossing line boundaries.</span></td></tr>
<tr class="codeline" data-linenumber="1481"><td class="num" id="LN1481">1481</td><td class="line">	    <span class='keyword'>if</span> (attr == HLF_COUNT)</td></tr>
<tr class="codeline" data-linenumber="1482"><td class="num" id="LN1482">1482</td><td class="line">		skip = (<span class='keyword'>int</span>)(p - endp);</td></tr>
<tr class="codeline" data-linenumber="1483"><td class="num" id="LN1483">1483</td><td class="line">	    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="1484"><td class="num" id="LN1484">1484</td><td class="line">		skip = 0;</td></tr>
<tr class="codeline" data-linenumber="1485"><td class="num" id="LN1485">1485</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1486"><td class="num" id="LN1486">1486</td><td class="line">	    <span class='comment'>// Capcol skips over the inserted space.</span></td></tr>
<tr class="codeline" data-linenumber="1487"><td class="num" id="LN1487">1487</td><td class="line">	    --capcol;</td></tr>
<tr class="codeline" data-linenumber="1488"><td class="num" id="LN1488">1488</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1489"><td class="num" id="LN1489">1489</td><td class="line">	    <span class='comment'>// But after empty line check first word in next line</span></td></tr>
<tr class="codeline" data-linenumber="1490"><td class="num" id="LN1490">1490</td><td class="line">	    <span class='keyword'>if</span> (*skipwhite(line) == <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1491"><td class="num" id="LN1491">1491</td><td class="line">		capcol = 0;</td></tr>
<tr class="codeline" data-linenumber="1492"><td class="num" id="LN1492">1492</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="1493"><td class="num" id="LN1493">1493</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1494"><td class="num" id="LN1494">1494</td><td class="line">	line_breakcheck();</td></tr>
<tr class="codeline" data-linenumber="1495"><td class="num" id="LN1495">1495</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1496"><td class="num" id="LN1496">1496</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1497"><td class="num" id="LN1497">1497</td><td class="line">    vim_free(buf);</td></tr>
<tr class="codeline" data-linenumber="1498"><td class="num" id="LN1498">1498</td><td class="line">    <span class='keyword'>return</span> 0;</td></tr>
<tr class="codeline" data-linenumber="1499"><td class="num" id="LN1499">1499</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1500"><td class="num" id="LN1500">1500</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1501"><td class="num" id="LN1501">1501</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="1502"><td class="num" id="LN1502">1502</td><td class="line"> <span class='comment'>* For spell checking: concatenate the start of the following line "line" into</span></td></tr>
<tr class="codeline" data-linenumber="1503"><td class="num" id="LN1503">1503</td><td class="line"> <span class='comment'>* "buf", blanking-out special characters.  Copy less then "maxlen" bytes.</span></td></tr>
<tr class="codeline" data-linenumber="1504"><td class="num" id="LN1504">1504</td><td class="line"> <span class='comment'>* Keep the blanks at the start of the next line, this is used in win_line()</span></td></tr>
<tr class="codeline" data-linenumber="1505"><td class="num" id="LN1505">1505</td><td class="line"> <span class='comment'>* to skip those bytes if the word was OK.</span></td></tr>
<tr class="codeline" data-linenumber="1506"><td class="num" id="LN1506">1506</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1507"><td class="num" id="LN1507">1507</td><td class="line">    <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="1508"><td class="num" id="LN1508">1508</td><td class="line">spell_cat_line(char_u *buf, char_u *line, <span class='keyword'>int</span> maxlen)</td></tr>
<tr class="codeline" data-linenumber="1509"><td class="num" id="LN1509">1509</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="1510"><td class="num" id="LN1510">1510</td><td class="line">    char_u	*p;</td></tr>
<tr class="codeline" data-linenumber="1511"><td class="num" id="LN1511">1511</td><td class="line">    <span class='keyword'>int</span>		n;</td></tr>
<tr class="codeline" data-linenumber="1512"><td class="num" id="LN1512">1512</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1513"><td class="num" id="LN1513">1513</td><td class="line">    p = skipwhite(line);</td></tr>
<tr class="codeline" data-linenumber="1514"><td class="num" id="LN1514">1514</td><td class="line">    <span class='keyword'>while</span> (vim_strchr((char_u *)<span class='string_literal'>"*#/\"\t"</span>, *p) != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1515"><td class="num" id="LN1515">1515</td><td class="line">	p = skipwhite(p + 1);</td></tr>
<tr class="codeline" data-linenumber="1516"><td class="num" id="LN1516">1516</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1517"><td class="num" id="LN1517">1517</td><td class="line">    <span class='keyword'>if</span> (*p != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1518"><td class="num" id="LN1518">1518</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="1519"><td class="num" id="LN1519">1519</td><td class="line">	<span class='comment'>// Only worth concatenating if there is something else than spaces to</span></td></tr>
<tr class="codeline" data-linenumber="1520"><td class="num" id="LN1520">1520</td><td class="line">	<span class='comment'>// concatenate.</span></td></tr>
<tr class="codeline" data-linenumber="1521"><td class="num" id="LN1521">1521</td><td class="line">	n = (<span class='keyword'>int</span>)(p - line) + 1;</td></tr>
<tr class="codeline" data-linenumber="1522"><td class="num" id="LN1522">1522</td><td class="line">	<span class='keyword'>if</span> (n &lt; maxlen - 1)</td></tr>
<tr class="codeline" data-linenumber="1523"><td class="num" id="LN1523">1523</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="1524"><td class="num" id="LN1524">1524</td><td class="line">	    <span class='macro'>vim_memset(buf, ' ', n)<span class='macro_popup'>memset((buf), (' '), (n))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1525"><td class="num" id="LN1525">1525</td><td class="line">	    vim_strncpy(buf +  n, p, maxlen - 1 - n);</td></tr>
<tr class="codeline" data-linenumber="1526"><td class="num" id="LN1526">1526</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="1527"><td class="num" id="LN1527">1527</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1528"><td class="num" id="LN1528">1528</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1529"><td class="num" id="LN1529">1529</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1530"><td class="num" id="LN1530">1530</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="1531"><td class="num" id="LN1531">1531</td><td class="line"> <span class='comment'>* Structure used for the cookie argument of do_in_runtimepath().</span></td></tr>
<tr class="codeline" data-linenumber="1532"><td class="num" id="LN1532">1532</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1533"><td class="num" id="LN1533">1533</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> spelload_S</td></tr>
<tr class="codeline" data-linenumber="1534"><td class="num" id="LN1534">1534</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="1535"><td class="num" id="LN1535">1535</td><td class="line">    char_u  sl_lang[<span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span> + 1];	<span class='comment'>// language name</span></td></tr>
<tr class="codeline" data-linenumber="1536"><td class="num" id="LN1536">1536</td><td class="line">    slang_T *sl_slang;			<span class='comment'>// resulting slang_T struct</span></td></tr>
<tr class="codeline" data-linenumber="1537"><td class="num" id="LN1537">1537</td><td class="line">    <span class='keyword'>int</span>	    sl_nobreak;			<span class='comment'>// NOBREAK language found</span></td></tr>
<tr class="codeline" data-linenumber="1538"><td class="num" id="LN1538">1538</td><td class="line">} spelload_T;</td></tr>
<tr class="codeline" data-linenumber="1539"><td class="num" id="LN1539">1539</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1540"><td class="num" id="LN1540">1540</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="1541"><td class="num" id="LN1541">1541</td><td class="line"> <span class='comment'>* Load word list(s) for "lang" from Vim spell file(s).</span></td></tr>
<tr class="codeline" data-linenumber="1542"><td class="num" id="LN1542">1542</td><td class="line"> <span class='comment'>* "lang" must be the language without the region: e.g., "en".</span></td></tr>
<tr class="codeline" data-linenumber="1543"><td class="num" id="LN1543">1543</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1544"><td class="num" id="LN1544">1544</td><td class="line">    <span class='keyword'>static</span> <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="1545"><td class="num" id="LN1545">1545</td><td class="line">spell_load_lang(char_u *lang)</td></tr>
<tr class="codeline" data-linenumber="1546"><td class="num" id="LN1546">1546</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="1547"><td class="num" id="LN1547">1547</td><td class="line">    char_u	fname_enc[85];</td></tr>
<tr class="codeline" data-linenumber="1548"><td class="num" id="LN1548">1548</td><td class="line">    <span class='keyword'>int</span>		r;</td></tr>
<tr class="codeline" data-linenumber="1549"><td class="num" id="LN1549">1549</td><td class="line">    spelload_T	sl;</td></tr>
<tr class="codeline" data-linenumber="1550"><td class="num" id="LN1550">1550</td><td class="line">    <span class='keyword'>int</span>		round;</td></tr>
<tr class="codeline" data-linenumber="1551"><td class="num" id="LN1551">1551</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1552"><td class="num" id="LN1552">1552</td><td class="line">    <span class='comment'>// Copy the language name to pass it to spell_load_cb() as a cookie.</span></td></tr>
<tr class="codeline" data-linenumber="1553"><td class="num" id="LN1553">1553</td><td class="line">    <span class='comment'>// It's truncated when an error is detected.</span></td></tr>
<tr class="codeline" data-linenumber="1554"><td class="num" id="LN1554">1554</td><td class="line">    <span class='macro'>STRCPY(sl.sl_lang, lang)<span class='macro_popup'>strcpy((char *)(sl.sl_lang), (char *)(lang))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1555"><td class="num" id="LN1555">1555</td><td class="line">    sl.sl_slang = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1556"><td class="num" id="LN1556">1556</td><td class="line">    sl.sl_nobreak = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1557"><td class="num" id="LN1557">1557</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1558"><td class="num" id="LN1558">1558</td><td class="line">    <span class='comment'>// We may retry when no spell file is found for the language, an</span></td></tr>
<tr class="codeline" data-linenumber="1559"><td class="num" id="LN1559">1559</td><td class="line">    <span class='comment'>// autocommand may load it then.</span></td></tr>
<tr class="codeline" data-linenumber="1560"><td class="num" id="LN1560">1560</td><td class="line">    <span class='keyword'>for</span> (round = 1; round &lt;= 2; ++round)</td></tr>
<tr class="codeline" data-linenumber="1561"><td class="num" id="LN1561">1561</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="1562"><td class="num" id="LN1562">1562</td><td class="line">	<span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="1563"><td class="num" id="LN1563">1563</td><td class="line">	 <span class='comment'>* Find the first spell file for "lang" in 'runtimepath' and load it.</span></td></tr>
<tr class="codeline" data-linenumber="1564"><td class="num" id="LN1564">1564</td><td class="line">	 <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1565"><td class="num" id="LN1565">1565</td><td class="line">	vim_snprintf((<span class='keyword'>char</span> *)fname_enc, <span class='keyword'>sizeof</span>(fname_enc) - 5,</td></tr>
<tr class="codeline" data-linenumber="1566"><td class="num" id="LN1566">1566</td><td class="line"><span class='directive'>#ifdef VMS</span></td></tr>
<tr class="codeline" data-linenumber="1567"><td class="num" id="LN1567">1567</td><td class="line">					<span class='string_literal'>"spell/%s_%s.spl"</span>,</td></tr>
<tr class="codeline" data-linenumber="1568"><td class="num" id="LN1568">1568</td><td class="line"><span class='directive'>#else</span></td></tr>
<tr class="codeline" data-linenumber="1569"><td class="num" id="LN1569">1569</td><td class="line">					<span class='string_literal'>"spell/%s.%s.spl"</span>,</td></tr>
<tr class="codeline" data-linenumber="1570"><td class="num" id="LN1570">1570</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="1571"><td class="num" id="LN1571">1571</td><td class="line">							   lang, spell_enc());</td></tr>
<tr class="codeline" data-linenumber="1572"><td class="num" id="LN1572">1572</td><td class="line">	r = do_in_runtimepath(fname_enc, 0, spell_load_cb, &amp;sl);</td></tr>
<tr class="codeline" data-linenumber="1573"><td class="num" id="LN1573">1573</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1574"><td class="num" id="LN1574">1574</td><td class="line">	<span class='keyword'>if</span> (r == <span class='macro'>FAIL<span class='macro_popup'>0</span></span> &amp;&amp; *sl.sl_lang != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1575"><td class="num" id="LN1575">1575</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="1576"><td class="num" id="LN1576">1576</td><td class="line">	    <span class='comment'>// Try loading the ASCII version.</span></td></tr>
<tr class="codeline" data-linenumber="1577"><td class="num" id="LN1577">1577</td><td class="line">	    vim_snprintf((<span class='keyword'>char</span> *)fname_enc, <span class='keyword'>sizeof</span>(fname_enc) - 5,</td></tr>
<tr class="codeline" data-linenumber="1578"><td class="num" id="LN1578">1578</td><td class="line"><span class='directive'>#ifdef VMS</span></td></tr>
<tr class="codeline" data-linenumber="1579"><td class="num" id="LN1579">1579</td><td class="line">						  <span class='string_literal'>"spell/%s_ascii.spl"</span>,</td></tr>
<tr class="codeline" data-linenumber="1580"><td class="num" id="LN1580">1580</td><td class="line"><span class='directive'>#else</span></td></tr>
<tr class="codeline" data-linenumber="1581"><td class="num" id="LN1581">1581</td><td class="line">						  <span class='string_literal'>"spell/%s.ascii.spl"</span>,</td></tr>
<tr class="codeline" data-linenumber="1582"><td class="num" id="LN1582">1582</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="1583"><td class="num" id="LN1583">1583</td><td class="line">									lang);</td></tr>
<tr class="codeline" data-linenumber="1584"><td class="num" id="LN1584">1584</td><td class="line">	    r = do_in_runtimepath(fname_enc, 0, spell_load_cb, &amp;sl);</td></tr>
<tr class="codeline" data-linenumber="1585"><td class="num" id="LN1585">1585</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1586"><td class="num" id="LN1586">1586</td><td class="line">	    <span class='keyword'>if</span> (r == <span class='macro'>FAIL<span class='macro_popup'>0</span></span> &amp;&amp; *sl.sl_lang != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span> &amp;&amp; round == 1</td></tr>
<tr class="codeline" data-linenumber="1587"><td class="num" id="LN1587">1587</td><td class="line">		    &amp;&amp; apply_autocmds(EVENT_SPELLFILEMISSING, lang,</td></tr>
<tr class="codeline" data-linenumber="1588"><td class="num" id="LN1588">1588</td><td class="line">					      curbuf-&gt;b_fname, <span class='macro'>FALSE<span class='macro_popup'>0</span></span>, curbuf))</td></tr>
<tr class="codeline" data-linenumber="1589"><td class="num" id="LN1589">1589</td><td class="line">		<span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="1590"><td class="num" id="LN1590">1590</td><td class="line">	    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="1591"><td class="num" id="LN1591">1591</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="1592"><td class="num" id="LN1592">1592</td><td class="line">	<span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="1593"><td class="num" id="LN1593">1593</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1594"><td class="num" id="LN1594">1594</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1595"><td class="num" id="LN1595">1595</td><td class="line">    <span class='keyword'>if</span> (r == <span class='macro'>FAIL<span class='macro_popup'>0</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1596"><td class="num" id="LN1596">1596</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="1597"><td class="num" id="LN1597">1597</td><td class="line">	smsg(</td></tr>
<tr class="codeline" data-linenumber="1598"><td class="num" id="LN1598">1598</td><td class="line"><span class='directive'>#ifdef VMS</span></td></tr>
<tr class="codeline" data-linenumber="1599"><td class="num" id="LN1599">1599</td><td class="line">	<span class='macro'>_(<span class='string_literal'>"Warning: Cannot find word list \"%s_%s.spl\" or \"%s_ascii.spl\""</span>)<span class='macro_popup'>dcgettext (((void*)0), (char *)("Warning: Cannot find word list \"%s_%s.spl\" or \"%s_ascii.spl\""<br>), 5)</span></span>,</td></tr>
<tr class="codeline" data-linenumber="1600"><td class="num" id="LN1600">1600</td><td class="line"><span class='directive'>#else</span></td></tr>
<tr class="codeline" data-linenumber="1601"><td class="num" id="LN1601">1601</td><td class="line">	<span class='macro'>_(<span class='string_literal'>"Warning: Cannot find word list \"%s.%s.spl\" or \"%s.ascii.spl\""</span>)<span class='macro_popup'>dcgettext (((void*)0), (char *)("Warning: Cannot find word list \"%s.%s.spl\" or \"%s.ascii.spl\""<br>), 5)</span></span>,</td></tr>
<tr class="codeline" data-linenumber="1602"><td class="num" id="LN1602">1602</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="1603"><td class="num" id="LN1603">1603</td><td class="line">						     lang, spell_enc(), lang);</td></tr>
<tr class="codeline" data-linenumber="1604"><td class="num" id="LN1604">1604</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1605"><td class="num" id="LN1605">1605</td><td class="line">    <span class='keyword'>else</span> <span class='keyword'>if</span> (sl.sl_slang != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1606"><td class="num" id="LN1606">1606</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="1607"><td class="num" id="LN1607">1607</td><td class="line">	<span class='comment'>// At least one file was loaded, now load ALL the additions.</span></td></tr>
<tr class="codeline" data-linenumber="1608"><td class="num" id="LN1608">1608</td><td class="line">	<span class='macro'>STRCPY(fname_enc + STRLEN(fname_enc) - 3, <span class='string_literal'>"add.spl"</span>)<span class='macro_popup'>strcpy((char *)(fname_enc + strlen((char *)(fname_enc)) - 3),<br> (char *)("add.spl"))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1609"><td class="num" id="LN1609">1609</td><td class="line">	do_in_runtimepath(fname_enc, <span class='macro'>DIP_ALL<span class='macro_popup'>0x01</span></span>, spell_load_cb, &amp;sl);</td></tr>
<tr class="codeline" data-linenumber="1610"><td class="num" id="LN1610">1610</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1611"><td class="num" id="LN1611">1611</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1612"><td class="num" id="LN1612">1612</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1613"><td class="num" id="LN1613">1613</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="1614"><td class="num" id="LN1614">1614</td><td class="line"> <span class='comment'>* Return the encoding used for spell checking: Use 'encoding', except that we</span></td></tr>
<tr class="codeline" data-linenumber="1615"><td class="num" id="LN1615">1615</td><td class="line"> <span class='comment'>* use "latin1" for "latin9".  And limit to 60 characters (just in case).</span></td></tr>
<tr class="codeline" data-linenumber="1616"><td class="num" id="LN1616">1616</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1617"><td class="num" id="LN1617">1617</td><td class="line">    char_u *</td></tr>
<tr class="codeline" data-linenumber="1618"><td class="num" id="LN1618">1618</td><td class="line">spell_enc(<span class='keyword'>void</span>)</td></tr>
<tr class="codeline" data-linenumber="1619"><td class="num" id="LN1619">1619</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="1620"><td class="num" id="LN1620">1620</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1621"><td class="num" id="LN1621">1621</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>STRLEN(p_enc)<span class='macro_popup'>strlen((char *)(p_enc))</span></span> &lt; 60 &amp;&amp; <span class='macro'>STRCMP(p_enc, <span class='string_literal'>"iso-8859-15"</span>)<span class='macro_popup'>strcmp((char *)(p_enc), (char *)("iso-8859-15"))</span></span> != 0)</td></tr>
<tr class="codeline" data-linenumber="1622"><td class="num" id="LN1622">1622</td><td class="line">	<span class='keyword'>return</span> p_enc;</td></tr>
<tr class="codeline" data-linenumber="1623"><td class="num" id="LN1623">1623</td><td class="line">    <span class='keyword'>return</span> (char_u *)<span class='string_literal'>"latin1"</span>;</td></tr>
<tr class="codeline" data-linenumber="1624"><td class="num" id="LN1624">1624</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1625"><td class="num" id="LN1625">1625</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1626"><td class="num" id="LN1626">1626</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="1627"><td class="num" id="LN1627">1627</td><td class="line"> <span class='comment'>* Get the name of the .spl file for the internal wordlist into</span></td></tr>
<tr class="codeline" data-linenumber="1628"><td class="num" id="LN1628">1628</td><td class="line"> <span class='comment'>* "fname[MAXPATHL]".</span></td></tr>
<tr class="codeline" data-linenumber="1629"><td class="num" id="LN1629">1629</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1630"><td class="num" id="LN1630">1630</td><td class="line">    <span class='keyword'>static</span> <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="1631"><td class="num" id="LN1631">1631</td><td class="line">int_wordlist_spl(char_u *fname)</td></tr>
<tr class="codeline" data-linenumber="1632"><td class="num" id="LN1632">1632</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="1633"><td class="num" id="LN1633">1633</td><td class="line">    vim_snprintf((<span class='keyword'>char</span> *)fname, <span class='macro'>MAXPATHL<span class='macro_popup'>4096</span></span>, <span class='macro'>SPL_FNAME_TMPL<span class='macro_popup'>"%s.%s.spl"</span></span>,</td></tr>
<tr class="codeline" data-linenumber="1634"><td class="num" id="LN1634">1634</td><td class="line">						  int_wordlist, spell_enc());</td></tr>
<tr class="codeline" data-linenumber="1635"><td class="num" id="LN1635">1635</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1636"><td class="num" id="LN1636">1636</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1637"><td class="num" id="LN1637">1637</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="1638"><td class="num" id="LN1638">1638</td><td class="line"> <span class='comment'>* Allocate a new slang_T for language "lang".  "lang" can be NULL.</span></td></tr>
<tr class="codeline" data-linenumber="1639"><td class="num" id="LN1639">1639</td><td class="line"> <span class='comment'>* Caller must fill "sl_next".</span></td></tr>
<tr class="codeline" data-linenumber="1640"><td class="num" id="LN1640">1640</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1641"><td class="num" id="LN1641">1641</td><td class="line">    slang_T *</td></tr>
<tr class="codeline" data-linenumber="1642"><td class="num" id="LN1642">1642</td><td class="line">slang_alloc(char_u *lang)</td></tr>
<tr class="codeline" data-linenumber="1643"><td class="num" id="LN1643">1643</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="1644"><td class="num" id="LN1644">1644</td><td class="line">    slang_T *lp;</td></tr>
<tr class="codeline" data-linenumber="1645"><td class="num" id="LN1645">1645</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1646"><td class="num" id="LN1646">1646</td><td class="line">    lp = <span class='macro'>ALLOC_CLEAR_ONE(slang_T)<span class='macro_popup'>(slang_T *)alloc_clear(sizeof(slang_T))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1647"><td class="num" id="LN1647">1647</td><td class="line">    <span class='keyword'>if</span> (lp != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1648"><td class="num" id="LN1648">1648</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="1649"><td class="num" id="LN1649">1649</td><td class="line">	<span class='keyword'>if</span> (lang != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1650"><td class="num" id="LN1650">1650</td><td class="line">	    lp-&gt;sl_name = vim_strsave(lang);</td></tr>
<tr class="codeline" data-linenumber="1651"><td class="num" id="LN1651">1651</td><td class="line">	ga_init2(&amp;lp-&gt;sl_rep, <span class='keyword'>sizeof</span>(fromto_T), 10);</td></tr>
<tr class="codeline" data-linenumber="1652"><td class="num" id="LN1652">1652</td><td class="line">	ga_init2(&amp;lp-&gt;sl_repsal, <span class='keyword'>sizeof</span>(fromto_T), 10);</td></tr>
<tr class="codeline" data-linenumber="1653"><td class="num" id="LN1653">1653</td><td class="line">	lp-&gt;sl_compmax = <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1654"><td class="num" id="LN1654">1654</td><td class="line">	lp-&gt;sl_compsylmax = <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1655"><td class="num" id="LN1655">1655</td><td class="line">	hash_init(&amp;lp-&gt;sl_wordcount);</td></tr>
<tr class="codeline" data-linenumber="1656"><td class="num" id="LN1656">1656</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1657"><td class="num" id="LN1657">1657</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1658"><td class="num" id="LN1658">1658</td><td class="line">    <span class='keyword'>return</span> lp;</td></tr>
<tr class="codeline" data-linenumber="1659"><td class="num" id="LN1659">1659</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1660"><td class="num" id="LN1660">1660</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1661"><td class="num" id="LN1661">1661</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="1662"><td class="num" id="LN1662">1662</td><td class="line"> <span class='comment'>* Free the contents of an slang_T and the structure itself.</span></td></tr>
<tr class="codeline" data-linenumber="1663"><td class="num" id="LN1663">1663</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1664"><td class="num" id="LN1664">1664</td><td class="line">    <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="1665"><td class="num" id="LN1665">1665</td><td class="line">slang_free(slang_T *lp)</td></tr>
<tr class="codeline" data-linenumber="1666"><td class="num" id="LN1666">1666</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="1667"><td class="num" id="LN1667">1667</td><td class="line">    vim_free(lp-&gt;sl_name);</td></tr>
<tr class="codeline" data-linenumber="1668"><td class="num" id="LN1668">1668</td><td class="line">    vim_free(lp-&gt;sl_fname);</td></tr>
<tr class="codeline" data-linenumber="1669"><td class="num" id="LN1669">1669</td><td class="line">    slang_clear(lp);</td></tr>
<tr class="codeline" data-linenumber="1670"><td class="num" id="LN1670">1670</td><td class="line">    vim_free(lp);</td></tr>
<tr class="codeline" data-linenumber="1671"><td class="num" id="LN1671">1671</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1672"><td class="num" id="LN1672">1672</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1673"><td class="num" id="LN1673">1673</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="1674"><td class="num" id="LN1674">1674</td><td class="line"> <span class='comment'>* Clear an slang_T so that the file can be reloaded.</span></td></tr>
<tr class="codeline" data-linenumber="1675"><td class="num" id="LN1675">1675</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1676"><td class="num" id="LN1676">1676</td><td class="line">    <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="1677"><td class="num" id="LN1677">1677</td><td class="line">slang_clear(slang_T *lp)</td></tr>
<tr class="codeline" data-linenumber="1678"><td class="num" id="LN1678">1678</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="1679"><td class="num" id="LN1679">1679</td><td class="line">    garray_T	*gap;</td></tr>
<tr class="codeline" data-linenumber="1680"><td class="num" id="LN1680">1680</td><td class="line">    fromto_T	*ftp;</td></tr>
<tr class="codeline" data-linenumber="1681"><td class="num" id="LN1681">1681</td><td class="line">    salitem_T	*smp;</td></tr>
<tr class="codeline" data-linenumber="1682"><td class="num" id="LN1682">1682</td><td class="line">    <span class='keyword'>int</span>		i;</td></tr>
<tr class="codeline" data-linenumber="1683"><td class="num" id="LN1683">1683</td><td class="line">    <span class='keyword'>int</span>		round;</td></tr>
<tr class="codeline" data-linenumber="1684"><td class="num" id="LN1684">1684</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1685"><td class="num" id="LN1685">1685</td><td class="line">    <span class='macro'>VIM_CLEAR(lp-&gt;sl_fbyts)<span class='macro_popup'>do { if ((lp-&gt;sl_fbyts) != ((void*)0)) { vim_free(lp-&gt;sl_fbyts<br>); (lp-&gt;sl_fbyts) = ((void*)0); } } while (0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1686"><td class="num" id="LN1686">1686</td><td class="line">    <span class='macro'>VIM_CLEAR(lp-&gt;sl_kbyts)<span class='macro_popup'>do { if ((lp-&gt;sl_kbyts) != ((void*)0)) { vim_free(lp-&gt;sl_kbyts<br>); (lp-&gt;sl_kbyts) = ((void*)0); } } while (0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1687"><td class="num" id="LN1687">1687</td><td class="line">    <span class='macro'>VIM_CLEAR(lp-&gt;sl_pbyts)<span class='macro_popup'>do { if ((lp-&gt;sl_pbyts) != ((void*)0)) { vim_free(lp-&gt;sl_pbyts<br>); (lp-&gt;sl_pbyts) = ((void*)0); } } while (0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1688"><td class="num" id="LN1688">1688</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1689"><td class="num" id="LN1689">1689</td><td class="line">    <span class='macro'>VIM_CLEAR(lp-&gt;sl_fidxs)<span class='macro_popup'>do { if ((lp-&gt;sl_fidxs) != ((void*)0)) { vim_free(lp-&gt;sl_fidxs<br>); (lp-&gt;sl_fidxs) = ((void*)0); } } while (0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1690"><td class="num" id="LN1690">1690</td><td class="line">    <span class='macro'>VIM_CLEAR(lp-&gt;sl_kidxs)<span class='macro_popup'>do { if ((lp-&gt;sl_kidxs) != ((void*)0)) { vim_free(lp-&gt;sl_kidxs<br>); (lp-&gt;sl_kidxs) = ((void*)0); } } while (0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1691"><td class="num" id="LN1691">1691</td><td class="line">    <span class='macro'>VIM_CLEAR(lp-&gt;sl_pidxs)<span class='macro_popup'>do { if ((lp-&gt;sl_pidxs) != ((void*)0)) { vim_free(lp-&gt;sl_pidxs<br>); (lp-&gt;sl_pidxs) = ((void*)0); } } while (0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1692"><td class="num" id="LN1692">1692</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1693"><td class="num" id="LN1693">1693</td><td class="line">    <span class='keyword'>for</span> (round = 1; round &lt;= 2; ++round)</td></tr>
<tr class="codeline" data-linenumber="1694"><td class="num" id="LN1694">1694</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="1695"><td class="num" id="LN1695">1695</td><td class="line">	gap = round == 1 ? &amp;lp-&gt;sl_rep : &amp;lp-&gt;sl_repsal;</td></tr>
<tr class="codeline" data-linenumber="1696"><td class="num" id="LN1696">1696</td><td class="line">	<span class='keyword'>while</span> (gap-&gt;ga_len &gt; 0)</td></tr>
<tr class="codeline" data-linenumber="1697"><td class="num" id="LN1697">1697</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="1698"><td class="num" id="LN1698">1698</td><td class="line">	    ftp = &amp;((fromto_T *)gap-&gt;ga_data)[--gap-&gt;ga_len];</td></tr>
<tr class="codeline" data-linenumber="1699"><td class="num" id="LN1699">1699</td><td class="line">	    vim_free(ftp-&gt;ft_from);</td></tr>
<tr class="codeline" data-linenumber="1700"><td class="num" id="LN1700">1700</td><td class="line">	    vim_free(ftp-&gt;ft_to);</td></tr>
<tr class="codeline" data-linenumber="1701"><td class="num" id="LN1701">1701</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="1702"><td class="num" id="LN1702">1702</td><td class="line">	ga_clear(gap);</td></tr>
<tr class="codeline" data-linenumber="1703"><td class="num" id="LN1703">1703</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1704"><td class="num" id="LN1704">1704</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1705"><td class="num" id="LN1705">1705</td><td class="line">    gap = &amp;lp-&gt;sl_sal;</td></tr>
<tr class="codeline" data-linenumber="1706"><td class="num" id="LN1706">1706</td><td class="line">    <span class='keyword'>if</span> (lp-&gt;sl_sofo)</td></tr>
<tr class="codeline" data-linenumber="1707"><td class="num" id="LN1707">1707</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="1708"><td class="num" id="LN1708">1708</td><td class="line">	<span class='comment'>// "ga_len" is set to 1 without adding an item for latin1</span></td></tr>
<tr class="codeline" data-linenumber="1709"><td class="num" id="LN1709">1709</td><td class="line">	<span class='keyword'>if</span> (gap-&gt;ga_data != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1710"><td class="num" id="LN1710">1710</td><td class="line">	    <span class='comment'>// SOFOFROM and SOFOTO items: free lists of wide characters.</span></td></tr>
<tr class="codeline" data-linenumber="1711"><td class="num" id="LN1711">1711</td><td class="line">	    <span class='keyword'>for</span> (i = 0; i &lt; gap-&gt;ga_len; ++i)</td></tr>
<tr class="codeline" data-linenumber="1712"><td class="num" id="LN1712">1712</td><td class="line">		vim_free(((<span class='keyword'>int</span> **)gap-&gt;ga_data)[i]);</td></tr>
<tr class="codeline" data-linenumber="1713"><td class="num" id="LN1713">1713</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1714"><td class="num" id="LN1714">1714</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="1715"><td class="num" id="LN1715">1715</td><td class="line">	<span class='comment'>// SAL items: free salitem_T items</span></td></tr>
<tr class="codeline" data-linenumber="1716"><td class="num" id="LN1716">1716</td><td class="line">	<span class='keyword'>while</span> (gap-&gt;ga_len &gt; 0)</td></tr>
<tr class="codeline" data-linenumber="1717"><td class="num" id="LN1717">1717</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="1718"><td class="num" id="LN1718">1718</td><td class="line">	    smp = &amp;((salitem_T *)gap-&gt;ga_data)[--gap-&gt;ga_len];</td></tr>
<tr class="codeline" data-linenumber="1719"><td class="num" id="LN1719">1719</td><td class="line">	    vim_free(smp-&gt;sm_lead);</td></tr>
<tr class="codeline" data-linenumber="1720"><td class="num" id="LN1720">1720</td><td class="line">	    <span class='comment'>// Don't free sm_oneof and sm_rules, they point into sm_lead.</span></td></tr>
<tr class="codeline" data-linenumber="1721"><td class="num" id="LN1721">1721</td><td class="line">	    vim_free(smp-&gt;sm_to);</td></tr>
<tr class="codeline" data-linenumber="1722"><td class="num" id="LN1722">1722</td><td class="line">	    vim_free(smp-&gt;sm_lead_w);</td></tr>
<tr class="codeline" data-linenumber="1723"><td class="num" id="LN1723">1723</td><td class="line">	    vim_free(smp-&gt;sm_oneof_w);</td></tr>
<tr class="codeline" data-linenumber="1724"><td class="num" id="LN1724">1724</td><td class="line">	    vim_free(smp-&gt;sm_to_w);</td></tr>
<tr class="codeline" data-linenumber="1725"><td class="num" id="LN1725">1725</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="1726"><td class="num" id="LN1726">1726</td><td class="line">    ga_clear(gap);</td></tr>
<tr class="codeline" data-linenumber="1727"><td class="num" id="LN1727">1727</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1728"><td class="num" id="LN1728">1728</td><td class="line">    <span class='keyword'>for</span> (i = 0; i &lt; lp-&gt;sl_prefixcnt; ++i)</td></tr>
<tr class="codeline" data-linenumber="1729"><td class="num" id="LN1729">1729</td><td class="line">	vim_regfree(lp-&gt;sl_prefprog[i]);</td></tr>
<tr class="codeline" data-linenumber="1730"><td class="num" id="LN1730">1730</td><td class="line">    lp-&gt;sl_prefixcnt = 0;</td></tr>
<tr class="codeline" data-linenumber="1731"><td class="num" id="LN1731">1731</td><td class="line">    <span class='macro'>VIM_CLEAR(lp-&gt;sl_prefprog)<span class='macro_popup'>do { if ((lp-&gt;sl_prefprog) != ((void*)0)) { vim_free(lp-&gt;<br>sl_prefprog); (lp-&gt;sl_prefprog) = ((void*)0); } } while (0<br>)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1732"><td class="num" id="LN1732">1732</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1733"><td class="num" id="LN1733">1733</td><td class="line">    <span class='macro'>VIM_CLEAR(lp-&gt;sl_info)<span class='macro_popup'>do { if ((lp-&gt;sl_info) != ((void*)0)) { vim_free(lp-&gt;sl_info<br>); (lp-&gt;sl_info) = ((void*)0); } } while (0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1734"><td class="num" id="LN1734">1734</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1735"><td class="num" id="LN1735">1735</td><td class="line">    <span class='macro'>VIM_CLEAR(lp-&gt;sl_midword)<span class='macro_popup'>do { if ((lp-&gt;sl_midword) != ((void*)0)) { vim_free(lp-&gt;<br>sl_midword); (lp-&gt;sl_midword) = ((void*)0); } } while (0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1736"><td class="num" id="LN1736">1736</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1737"><td class="num" id="LN1737">1737</td><td class="line">    vim_regfree(lp-&gt;sl_compprog);</td></tr>
<tr class="codeline" data-linenumber="1738"><td class="num" id="LN1738">1738</td><td class="line">    lp-&gt;sl_compprog = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1739"><td class="num" id="LN1739">1739</td><td class="line">    <span class='macro'>VIM_CLEAR(lp-&gt;sl_comprules)<span class='macro_popup'>do { if ((lp-&gt;sl_comprules) != ((void*)0)) { vim_free(lp-&gt;<br>sl_comprules); (lp-&gt;sl_comprules) = ((void*)0); } } while (<br>0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1740"><td class="num" id="LN1740">1740</td><td class="line">    <span class='macro'>VIM_CLEAR(lp-&gt;sl_compstartflags)<span class='macro_popup'>do { if ((lp-&gt;sl_compstartflags) != ((void*)0)) { vim_free<br>(lp-&gt;sl_compstartflags); (lp-&gt;sl_compstartflags) = ((void<br>*)0); } } while (0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1741"><td class="num" id="LN1741">1741</td><td class="line">    <span class='macro'>VIM_CLEAR(lp-&gt;sl_compallflags)<span class='macro_popup'>do { if ((lp-&gt;sl_compallflags) != ((void*)0)) { vim_free(lp<br>-&gt;sl_compallflags); (lp-&gt;sl_compallflags) = ((void*)0);<br> } } while (0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1742"><td class="num" id="LN1742">1742</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1743"><td class="num" id="LN1743">1743</td><td class="line">    <span class='macro'>VIM_CLEAR(lp-&gt;sl_syllable)<span class='macro_popup'>do { if ((lp-&gt;sl_syllable) != ((void*)0)) { vim_free(lp-&gt;<br>sl_syllable); (lp-&gt;sl_syllable) = ((void*)0); } } while (0<br>)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1744"><td class="num" id="LN1744">1744</td><td class="line">    ga_clear(&amp;lp-&gt;sl_syl_items);</td></tr>
<tr class="codeline" data-linenumber="1745"><td class="num" id="LN1745">1745</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1746"><td class="num" id="LN1746">1746</td><td class="line">    ga_clear_strings(&amp;lp-&gt;sl_comppat);</td></tr>
<tr class="codeline" data-linenumber="1747"><td class="num" id="LN1747">1747</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1748"><td class="num" id="LN1748">1748</td><td class="line">    hash_clear_all(&amp;lp-&gt;sl_wordcount, <span class='macro'>WC_KEY_OFF<span class='macro_popup'>__builtin_offsetof(wordcount_T, wc_word)</span></span>);</td></tr>
<tr class="codeline" data-linenumber="1749"><td class="num" id="LN1749">1749</td><td class="line">    hash_init(&amp;lp-&gt;sl_wordcount);</td></tr>
<tr class="codeline" data-linenumber="1750"><td class="num" id="LN1750">1750</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1751"><td class="num" id="LN1751">1751</td><td class="line">    hash_clear_all(&amp;lp-&gt;sl_map_hash, 0);</td></tr>
<tr class="codeline" data-linenumber="1752"><td class="num" id="LN1752">1752</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1753"><td class="num" id="LN1753">1753</td><td class="line">    <span class='comment'>// Clear info from .sug file.</span></td></tr>
<tr class="codeline" data-linenumber="1754"><td class="num" id="LN1754">1754</td><td class="line">    slang_clear_sug(lp);</td></tr>
<tr class="codeline" data-linenumber="1755"><td class="num" id="LN1755">1755</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1756"><td class="num" id="LN1756">1756</td><td class="line">    lp-&gt;sl_compmax = <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1757"><td class="num" id="LN1757">1757</td><td class="line">    lp-&gt;sl_compminlen = 0;</td></tr>
<tr class="codeline" data-linenumber="1758"><td class="num" id="LN1758">1758</td><td class="line">    lp-&gt;sl_compsylmax = <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1759"><td class="num" id="LN1759">1759</td><td class="line">    lp-&gt;sl_regions[0] = <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1760"><td class="num" id="LN1760">1760</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1761"><td class="num" id="LN1761">1761</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1762"><td class="num" id="LN1762">1762</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="1763"><td class="num" id="LN1763">1763</td><td class="line"> <span class='comment'>* Clear the info from the .sug file in "lp".</span></td></tr>
<tr class="codeline" data-linenumber="1764"><td class="num" id="LN1764">1764</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1765"><td class="num" id="LN1765">1765</td><td class="line">    <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="1766"><td class="num" id="LN1766">1766</td><td class="line">slang_clear_sug(slang_T *lp)</td></tr>
<tr class="codeline" data-linenumber="1767"><td class="num" id="LN1767">1767</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="1768"><td class="num" id="LN1768">1768</td><td class="line">    <span class='macro'>VIM_CLEAR(lp-&gt;sl_sbyts)<span class='macro_popup'>do { if ((lp-&gt;sl_sbyts) != ((void*)0)) { vim_free(lp-&gt;sl_sbyts<br>); (lp-&gt;sl_sbyts) = ((void*)0); } } while (0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1769"><td class="num" id="LN1769">1769</td><td class="line">    <span class='macro'>VIM_CLEAR(lp-&gt;sl_sidxs)<span class='macro_popup'>do { if ((lp-&gt;sl_sidxs) != ((void*)0)) { vim_free(lp-&gt;sl_sidxs<br>); (lp-&gt;sl_sidxs) = ((void*)0); } } while (0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1770"><td class="num" id="LN1770">1770</td><td class="line">    close_spellbuf(lp-&gt;sl_sugbuf);</td></tr>
<tr class="codeline" data-linenumber="1771"><td class="num" id="LN1771">1771</td><td class="line">    lp-&gt;sl_sugbuf = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1772"><td class="num" id="LN1772">1772</td><td class="line">    lp-&gt;sl_sugloaded = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1773"><td class="num" id="LN1773">1773</td><td class="line">    lp-&gt;sl_sugtime = 0;</td></tr>
<tr class="codeline" data-linenumber="1774"><td class="num" id="LN1774">1774</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1775"><td class="num" id="LN1775">1775</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1776"><td class="num" id="LN1776">1776</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="1777"><td class="num" id="LN1777">1777</td><td class="line"> <span class='comment'>* Load one spell file and store the info into a slang_T.</span></td></tr>
<tr class="codeline" data-linenumber="1778"><td class="num" id="LN1778">1778</td><td class="line"> <span class='comment'>* Invoked through do_in_runtimepath().</span></td></tr>
<tr class="codeline" data-linenumber="1779"><td class="num" id="LN1779">1779</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1780"><td class="num" id="LN1780">1780</td><td class="line">    <span class='keyword'>static</span> <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="1781"><td class="num" id="LN1781">1781</td><td class="line">spell_load_cb(char_u *fname, <span class='keyword'>void</span> *cookie)</td></tr>
<tr class="codeline" data-linenumber="1782"><td class="num" id="LN1782">1782</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="1783"><td class="num" id="LN1783">1783</td><td class="line">    spelload_T	*slp = (spelload_T *)cookie;</td></tr>
<tr class="codeline" data-linenumber="1784"><td class="num" id="LN1784">1784</td><td class="line">    slang_T	*slang;</td></tr>
<tr class="codeline" data-linenumber="1785"><td class="num" id="LN1785">1785</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1786"><td class="num" id="LN1786">1786</td><td class="line">    slang = spell_load_file(fname, slp-&gt;sl_lang, <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>, <span class='macro'>FALSE<span class='macro_popup'>0</span></span>);</td></tr>
<tr class="codeline" data-linenumber="1787"><td class="num" id="LN1787">1787</td><td class="line">    <span class='keyword'>if</span> (slang != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1788"><td class="num" id="LN1788">1788</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="1789"><td class="num" id="LN1789">1789</td><td class="line">	<span class='comment'>// When a previously loaded file has NOBREAK also use it for the</span></td></tr>
<tr class="codeline" data-linenumber="1790"><td class="num" id="LN1790">1790</td><td class="line">	<span class='comment'>// ".add" files.</span></td></tr>
<tr class="codeline" data-linenumber="1791"><td class="num" id="LN1791">1791</td><td class="line">	<span class='keyword'>if</span> (slp-&gt;sl_nobreak &amp;&amp; slang-&gt;sl_add)</td></tr>
<tr class="codeline" data-linenumber="1792"><td class="num" id="LN1792">1792</td><td class="line">	    slang-&gt;sl_nobreak = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1793"><td class="num" id="LN1793">1793</td><td class="line">	<span class='keyword'>else</span> <span class='keyword'>if</span> (slang-&gt;sl_nobreak)</td></tr>
<tr class="codeline" data-linenumber="1794"><td class="num" id="LN1794">1794</td><td class="line">	    slp-&gt;sl_nobreak = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1795"><td class="num" id="LN1795">1795</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1796"><td class="num" id="LN1796">1796</td><td class="line">	slp-&gt;sl_slang = slang;</td></tr>
<tr class="codeline" data-linenumber="1797"><td class="num" id="LN1797">1797</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1798"><td class="num" id="LN1798">1798</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1799"><td class="num" id="LN1799">1799</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1800"><td class="num" id="LN1800">1800</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1801"><td class="num" id="LN1801">1801</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="1802"><td class="num" id="LN1802">1802</td><td class="line"> <span class='comment'>* Add a word to the hashtable of common words.</span></td></tr>
<tr class="codeline" data-linenumber="1803"><td class="num" id="LN1803">1803</td><td class="line"> <span class='comment'>* If it's already there then the counter is increased.</span></td></tr>
<tr class="codeline" data-linenumber="1804"><td class="num" id="LN1804">1804</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1805"><td class="num" id="LN1805">1805</td><td class="line">    <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="1806"><td class="num" id="LN1806">1806</td><td class="line">count_common_word(</td></tr>
<tr class="codeline" data-linenumber="1807"><td class="num" id="LN1807">1807</td><td class="line">    slang_T	*lp,</td></tr>
<tr class="codeline" data-linenumber="1808"><td class="num" id="LN1808">1808</td><td class="line">    char_u	*word,</td></tr>
<tr class="codeline" data-linenumber="1809"><td class="num" id="LN1809">1809</td><td class="line">    <span class='keyword'>int</span>		len,	    <span class='comment'>// word length, -1 for up to NUL</span></td></tr>
<tr class="codeline" data-linenumber="1810"><td class="num" id="LN1810">1810</td><td class="line">    <span class='keyword'>int</span>		count)	    <span class='comment'>// 1 to count once, 10 to init</span></td></tr>
<tr class="codeline" data-linenumber="1811"><td class="num" id="LN1811">1811</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="1812"><td class="num" id="LN1812">1812</td><td class="line">    hash_T	hash;</td></tr>
<tr class="codeline" data-linenumber="1813"><td class="num" id="LN1813">1813</td><td class="line">    hashitem_T	*hi;</td></tr>
<tr class="codeline" data-linenumber="1814"><td class="num" id="LN1814">1814</td><td class="line">    wordcount_T	*wc;</td></tr>
<tr class="codeline" data-linenumber="1815"><td class="num" id="LN1815">1815</td><td class="line">    char_u	buf[<span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>];</td></tr>
<tr class="codeline" data-linenumber="1816"><td class="num" id="LN1816">1816</td><td class="line">    char_u	*p;</td></tr>
<tr class="codeline" data-linenumber="1817"><td class="num" id="LN1817">1817</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1818"><td class="num" id="LN1818">1818</td><td class="line">    <span class='keyword'>if</span> (len == -1)</td></tr>
<tr class="codeline" data-linenumber="1819"><td class="num" id="LN1819">1819</td><td class="line">	p = word;</td></tr>
<tr class="codeline" data-linenumber="1820"><td class="num" id="LN1820">1820</td><td class="line">    <span class='keyword'>else</span> <span class='keyword'>if</span> (len &gt;= <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1821"><td class="num" id="LN1821">1821</td><td class="line">	<span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="1822"><td class="num" id="LN1822">1822</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="1823"><td class="num" id="LN1823">1823</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="1824"><td class="num" id="LN1824">1824</td><td class="line">	vim_strncpy(buf, word, len);</td></tr>
<tr class="codeline" data-linenumber="1825"><td class="num" id="LN1825">1825</td><td class="line">	p = buf;</td></tr>
<tr class="codeline" data-linenumber="1826"><td class="num" id="LN1826">1826</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1827"><td class="num" id="LN1827">1827</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1828"><td class="num" id="LN1828">1828</td><td class="line">    hash = hash_hash(p);</td></tr>
<tr class="codeline" data-linenumber="1829"><td class="num" id="LN1829">1829</td><td class="line">    hi = hash_lookup(&amp;lp-&gt;sl_wordcount, p, hash);</td></tr>
<tr class="codeline" data-linenumber="1830"><td class="num" id="LN1830">1830</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>HASHITEM_EMPTY(hi)<span class='macro_popup'>((hi)-&gt;hi_key == ((void*)0) || (hi)-&gt;hi_key == &amp;hash_removed<br>)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1831"><td class="num" id="LN1831">1831</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="1832"><td class="num" id="LN1832">1832</td><td class="line">	wc = alloc(<span class='keyword'>sizeof</span>(wordcount_T) + <span class='macro'>STRLEN(p)<span class='macro_popup'>strlen((char *)(p))</span></span>);</td></tr>
<tr class="codeline" data-linenumber="1833"><td class="num" id="LN1833">1833</td><td class="line">	<span class='keyword'>if</span> (wc == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1834"><td class="num" id="LN1834">1834</td><td class="line">	    <span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="1835"><td class="num" id="LN1835">1835</td><td class="line">	<span class='macro'>STRCPY(wc-&gt;wc_word, p)<span class='macro_popup'>strcpy((char *)(wc-&gt;wc_word), (char *)(p))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1836"><td class="num" id="LN1836">1836</td><td class="line">	wc-&gt;wc_count = count;</td></tr>
<tr class="codeline" data-linenumber="1837"><td class="num" id="LN1837">1837</td><td class="line">	hash_add_item(&amp;lp-&gt;sl_wordcount, hi, wc-&gt;wc_word, hash);</td></tr>
<tr class="codeline" data-linenumber="1838"><td class="num" id="LN1838">1838</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1839"><td class="num" id="LN1839">1839</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="1840"><td class="num" id="LN1840">1840</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="1841"><td class="num" id="LN1841">1841</td><td class="line">	wc = <span class='macro'>HI2WC(hi)<span class='macro_popup'>((wordcount_T *)((hi)-&gt;hi_key - __builtin_offsetof(wordcount_T<br>, wc_word)))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1842"><td class="num" id="LN1842">1842</td><td class="line">	<span class='keyword'>if</span> ((wc-&gt;wc_count += count) &lt; (<span class='keyword'>unsigned</span>)count)	<span class='comment'>// check for overflow</span></td></tr>
<tr class="codeline" data-linenumber="1843"><td class="num" id="LN1843">1843</td><td class="line">	    wc-&gt;wc_count = <span class='macro'>MAXWORDCOUNT<span class='macro_popup'>0xffff</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1844"><td class="num" id="LN1844">1844</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1845"><td class="num" id="LN1845">1845</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1846"><td class="num" id="LN1846">1846</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1847"><td class="num" id="LN1847">1847</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="1848"><td class="num" id="LN1848">1848</td><td class="line"> <span class='comment'>* Return TRUE if byte "n" appears in "str".</span></td></tr>
<tr class="codeline" data-linenumber="1849"><td class="num" id="LN1849">1849</td><td class="line"> <span class='comment'>* Like strchr() but independent of locale.</span></td></tr>
<tr class="codeline" data-linenumber="1850"><td class="num" id="LN1850">1850</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1851"><td class="num" id="LN1851">1851</td><td class="line">    <span class='keyword'>int</span></td></tr>
<tr class="codeline" data-linenumber="1852"><td class="num" id="LN1852">1852</td><td class="line">byte_in_str(char_u *str, <span class='keyword'>int</span> n)</td></tr>
<tr class="codeline" data-linenumber="1853"><td class="num" id="LN1853">1853</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="1854"><td class="num" id="LN1854">1854</td><td class="line">    char_u	*p;</td></tr>
<tr class="codeline" data-linenumber="1855"><td class="num" id="LN1855">1855</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1856"><td class="num" id="LN1856">1856</td><td class="line">    <span class='keyword'>for</span> (p = str; *p != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>; ++p)</td></tr>
<tr class="codeline" data-linenumber="1857"><td class="num" id="LN1857">1857</td><td class="line">	<span class='keyword'>if</span> (*p == n)</td></tr>
<tr class="codeline" data-linenumber="1858"><td class="num" id="LN1858">1858</td><td class="line">	    <span class='keyword'>return</span> <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1859"><td class="num" id="LN1859">1859</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1860"><td class="num" id="LN1860">1860</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1861"><td class="num" id="LN1861">1861</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1862"><td class="num" id="LN1862">1862</td><td class="line"><span class='directive'>#define <span class='macro'>SY_MAXLEN<span class='macro_popup'>30</span></span>   30</span></td></tr>
<tr class="codeline" data-linenumber="1863"><td class="num" id="LN1863">1863</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> syl_item_S</td></tr>
<tr class="codeline" data-linenumber="1864"><td class="num" id="LN1864">1864</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="1865"><td class="num" id="LN1865">1865</td><td class="line">    char_u	sy_chars[<span class='macro'>SY_MAXLEN<span class='macro_popup'>30</span></span>];	    <span class='comment'>// the sequence of chars</span></td></tr>
<tr class="codeline" data-linenumber="1866"><td class="num" id="LN1866">1866</td><td class="line">    <span class='keyword'>int</span>		sy_len;</td></tr>
<tr class="codeline" data-linenumber="1867"><td class="num" id="LN1867">1867</td><td class="line">} syl_item_T;</td></tr>
<tr class="codeline" data-linenumber="1868"><td class="num" id="LN1868">1868</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1869"><td class="num" id="LN1869">1869</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="1870"><td class="num" id="LN1870">1870</td><td class="line"> <span class='comment'>* Truncate "slang-&gt;sl_syllable" at the first slash and put the following items</span></td></tr>
<tr class="codeline" data-linenumber="1871"><td class="num" id="LN1871">1871</td><td class="line"> <span class='comment'>* in "slang-&gt;sl_syl_items".</span></td></tr>
<tr class="codeline" data-linenumber="1872"><td class="num" id="LN1872">1872</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1873"><td class="num" id="LN1873">1873</td><td class="line">    <span class='keyword'>int</span></td></tr>
<tr class="codeline" data-linenumber="1874"><td class="num" id="LN1874">1874</td><td class="line">init_syl_tab(slang_T *slang)</td></tr>
<tr class="codeline" data-linenumber="1875"><td class="num" id="LN1875">1875</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="1876"><td class="num" id="LN1876">1876</td><td class="line">    char_u	*p;</td></tr>
<tr class="codeline" data-linenumber="1877"><td class="num" id="LN1877">1877</td><td class="line">    char_u	*s;</td></tr>
<tr class="codeline" data-linenumber="1878"><td class="num" id="LN1878">1878</td><td class="line">    <span class='keyword'>int</span>		l;</td></tr>
<tr class="codeline" data-linenumber="1879"><td class="num" id="LN1879">1879</td><td class="line">    syl_item_T	*syl;</td></tr>
<tr class="codeline" data-linenumber="1880"><td class="num" id="LN1880">1880</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1881"><td class="num" id="LN1881">1881</td><td class="line">    ga_init2(&amp;slang-&gt;sl_syl_items, <span class='keyword'>sizeof</span>(syl_item_T), 4);</td></tr>
<tr class="codeline" data-linenumber="1882"><td class="num" id="LN1882">1882</td><td class="line">    p = vim_strchr(slang-&gt;sl_syllable, '/');</td></tr>
<tr class="codeline" data-linenumber="1883"><td class="num" id="LN1883">1883</td><td class="line">    <span class='keyword'>while</span> (p != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1884"><td class="num" id="LN1884">1884</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="1885"><td class="num" id="LN1885">1885</td><td class="line">	*p++ = <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1886"><td class="num" id="LN1886">1886</td><td class="line">	<span class='keyword'>if</span> (*p == <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)	    <span class='comment'>// trailing slash</span></td></tr>
<tr class="codeline" data-linenumber="1887"><td class="num" id="LN1887">1887</td><td class="line">	    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="1888"><td class="num" id="LN1888">1888</td><td class="line">	s = p;</td></tr>
<tr class="codeline" data-linenumber="1889"><td class="num" id="LN1889">1889</td><td class="line">	p = vim_strchr(p, '/');</td></tr>
<tr class="codeline" data-linenumber="1890"><td class="num" id="LN1890">1890</td><td class="line">	<span class='keyword'>if</span> (p == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1891"><td class="num" id="LN1891">1891</td><td class="line">	    l = (<span class='keyword'>int</span>)<span class='macro'>STRLEN(s)<span class='macro_popup'>strlen((char *)(s))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1892"><td class="num" id="LN1892">1892</td><td class="line">	<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="1893"><td class="num" id="LN1893">1893</td><td class="line">	    l = (<span class='keyword'>int</span>)(p - s);</td></tr>
<tr class="codeline" data-linenumber="1894"><td class="num" id="LN1894">1894</td><td class="line">	<span class='keyword'>if</span> (l &gt;= <span class='macro'>SY_MAXLEN<span class='macro_popup'>30</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1895"><td class="num" id="LN1895">1895</td><td class="line">	    <span class='keyword'>return</span> <span class='macro'>SP_FORMERROR<span class='macro_popup'>-2</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1896"><td class="num" id="LN1896">1896</td><td class="line">	<span class='keyword'>if</span> (ga_grow(&amp;slang-&gt;sl_syl_items, 1) == <span class='macro'>FAIL<span class='macro_popup'>0</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1897"><td class="num" id="LN1897">1897</td><td class="line">	    <span class='keyword'>return</span> <span class='macro'>SP_OTHERERROR<span class='macro_popup'>-3</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1898"><td class="num" id="LN1898">1898</td><td class="line">	syl = ((syl_item_T *)slang-&gt;sl_syl_items.ga_data)</td></tr>
<tr class="codeline" data-linenumber="1899"><td class="num" id="LN1899">1899</td><td class="line">					       + slang-&gt;sl_syl_items.ga_len++;</td></tr>
<tr class="codeline" data-linenumber="1900"><td class="num" id="LN1900">1900</td><td class="line">	vim_strncpy(syl-&gt;sy_chars, s, l);</td></tr>
<tr class="codeline" data-linenumber="1901"><td class="num" id="LN1901">1901</td><td class="line">	syl-&gt;sy_len = l;</td></tr>
<tr class="codeline" data-linenumber="1902"><td class="num" id="LN1902">1902</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1903"><td class="num" id="LN1903">1903</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>OK<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1904"><td class="num" id="LN1904">1904</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1905"><td class="num" id="LN1905">1905</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1906"><td class="num" id="LN1906">1906</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="1907"><td class="num" id="LN1907">1907</td><td class="line"> <span class='comment'>* Count the number of syllables in "word".</span></td></tr>
<tr class="codeline" data-linenumber="1908"><td class="num" id="LN1908">1908</td><td class="line"> <span class='comment'>* When "word" contains spaces the syllables after the last space are counted.</span></td></tr>
<tr class="codeline" data-linenumber="1909"><td class="num" id="LN1909">1909</td><td class="line"> <span class='comment'>* Returns zero if syllables are not defines.</span></td></tr>
<tr class="codeline" data-linenumber="1910"><td class="num" id="LN1910">1910</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1911"><td class="num" id="LN1911">1911</td><td class="line">    <span class='keyword'>static</span> <span class='keyword'>int</span></td></tr>
<tr class="codeline" data-linenumber="1912"><td class="num" id="LN1912">1912</td><td class="line">count_syllables(slang_T *slang, char_u *word)</td></tr>
<tr class="codeline" data-linenumber="1913"><td class="num" id="LN1913">1913</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="1914"><td class="num" id="LN1914">1914</td><td class="line">    <span class='keyword'>int</span>		cnt = 0;</td></tr>
<tr class="codeline" data-linenumber="1915"><td class="num" id="LN1915">1915</td><td class="line">    <span class='keyword'>int</span>		skip = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1916"><td class="num" id="LN1916">1916</td><td class="line">    char_u	*p;</td></tr>
<tr class="codeline" data-linenumber="1917"><td class="num" id="LN1917">1917</td><td class="line">    <span class='keyword'>int</span>		len;</td></tr>
<tr class="codeline" data-linenumber="1918"><td class="num" id="LN1918">1918</td><td class="line">    <span class='keyword'>int</span>		i;</td></tr>
<tr class="codeline" data-linenumber="1919"><td class="num" id="LN1919">1919</td><td class="line">    syl_item_T	*syl;</td></tr>
<tr class="codeline" data-linenumber="1920"><td class="num" id="LN1920">1920</td><td class="line">    <span class='keyword'>int</span>		c;</td></tr>
<tr class="codeline" data-linenumber="1921"><td class="num" id="LN1921">1921</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1922"><td class="num" id="LN1922">1922</td><td class="line">    <span class='keyword'>if</span> (slang-&gt;sl_syllable == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1923"><td class="num" id="LN1923">1923</td><td class="line">	<span class='keyword'>return</span> 0;</td></tr>
<tr class="codeline" data-linenumber="1924"><td class="num" id="LN1924">1924</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1925"><td class="num" id="LN1925">1925</td><td class="line">    <span class='keyword'>for</span> (p = word; *p != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>; p += len)</td></tr>
<tr class="codeline" data-linenumber="1926"><td class="num" id="LN1926">1926</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="1927"><td class="num" id="LN1927">1927</td><td class="line">	<span class='comment'>// When running into a space reset counter.</span></td></tr>
<tr class="codeline" data-linenumber="1928"><td class="num" id="LN1928">1928</td><td class="line">	<span class='keyword'>if</span> (*p == ' ')</td></tr>
<tr class="codeline" data-linenumber="1929"><td class="num" id="LN1929">1929</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="1930"><td class="num" id="LN1930">1930</td><td class="line">	    len = 1;</td></tr>
<tr class="codeline" data-linenumber="1931"><td class="num" id="LN1931">1931</td><td class="line">	    cnt = 0;</td></tr>
<tr class="codeline" data-linenumber="1932"><td class="num" id="LN1932">1932</td><td class="line">	    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="1933"><td class="num" id="LN1933">1933</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="1934"><td class="num" id="LN1934">1934</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1935"><td class="num" id="LN1935">1935</td><td class="line">	<span class='comment'>// Find longest match of syllable items.</span></td></tr>
<tr class="codeline" data-linenumber="1936"><td class="num" id="LN1936">1936</td><td class="line">	len = 0;</td></tr>
<tr class="codeline" data-linenumber="1937"><td class="num" id="LN1937">1937</td><td class="line">	<span class='keyword'>for</span> (i = 0; i &lt; slang-&gt;sl_syl_items.ga_len; ++i)</td></tr>
<tr class="codeline" data-linenumber="1938"><td class="num" id="LN1938">1938</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="1939"><td class="num" id="LN1939">1939</td><td class="line">	    syl = ((syl_item_T *)slang-&gt;sl_syl_items.ga_data) + i;</td></tr>
<tr class="codeline" data-linenumber="1940"><td class="num" id="LN1940">1940</td><td class="line">	    <span class='keyword'>if</span> (syl-&gt;sy_len &gt; len</td></tr>
<tr class="codeline" data-linenumber="1941"><td class="num" id="LN1941">1941</td><td class="line">			       &amp;&amp; <span class='macro'>STRNCMP(p, syl-&gt;sy_chars, syl-&gt;sy_len)<span class='macro_popup'>strncmp((char *)(p), (char *)(syl-&gt;sy_chars), (size_t)(syl<br>-&gt;sy_len))</span></span> == 0)</td></tr>
<tr class="codeline" data-linenumber="1942"><td class="num" id="LN1942">1942</td><td class="line">		len = syl-&gt;sy_len;</td></tr>
<tr class="codeline" data-linenumber="1943"><td class="num" id="LN1943">1943</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="1944"><td class="num" id="LN1944">1944</td><td class="line">	<span class='keyword'>if</span> (len != 0)	<span class='comment'>// found a match, count syllable</span></td></tr>
<tr class="codeline" data-linenumber="1945"><td class="num" id="LN1945">1945</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="1946"><td class="num" id="LN1946">1946</td><td class="line">	    ++cnt;</td></tr>
<tr class="codeline" data-linenumber="1947"><td class="num" id="LN1947">1947</td><td class="line">	    skip = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1948"><td class="num" id="LN1948">1948</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="1949"><td class="num" id="LN1949">1949</td><td class="line">	<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="1950"><td class="num" id="LN1950">1950</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="1951"><td class="num" id="LN1951">1951</td><td class="line">	    <span class='comment'>// No recognized syllable item, at least a syllable char then?</span></td></tr>
<tr class="codeline" data-linenumber="1952"><td class="num" id="LN1952">1952</td><td class="line">	    c = mb_ptr2char(p);</td></tr>
<tr class="codeline" data-linenumber="1953"><td class="num" id="LN1953">1953</td><td class="line">	    len = (*mb_ptr2len)(p);</td></tr>
<tr class="codeline" data-linenumber="1954"><td class="num" id="LN1954">1954</td><td class="line">	    <span class='keyword'>if</span> (vim_strchr(slang-&gt;sl_syllable, c) == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="1955"><td class="num" id="LN1955">1955</td><td class="line">		skip = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;	    <span class='comment'>// No, search for next syllable</span></td></tr>
<tr class="codeline" data-linenumber="1956"><td class="num" id="LN1956">1956</td><td class="line">	    <span class='keyword'>else</span> <span class='keyword'>if</span> (!skip)</td></tr>
<tr class="codeline" data-linenumber="1957"><td class="num" id="LN1957">1957</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="1958"><td class="num" id="LN1958">1958</td><td class="line">		++cnt;		    <span class='comment'>// Yes, count it</span></td></tr>
<tr class="codeline" data-linenumber="1959"><td class="num" id="LN1959">1959</td><td class="line">		skip = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;	    <span class='comment'>// don't count following syllable chars</span></td></tr>
<tr class="codeline" data-linenumber="1960"><td class="num" id="LN1960">1960</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="1961"><td class="num" id="LN1961">1961</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="1962"><td class="num" id="LN1962">1962</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1963"><td class="num" id="LN1963">1963</td><td class="line">    <span class='keyword'>return</span> cnt;</td></tr>
<tr class="codeline" data-linenumber="1964"><td class="num" id="LN1964">1964</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1965"><td class="num" id="LN1965">1965</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1966"><td class="num" id="LN1966">1966</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="1967"><td class="num" id="LN1967">1967</td><td class="line"> <span class='comment'>* Parse 'spelllang' and set w_s-&gt;b_langp accordingly.</span></td></tr>
<tr class="codeline" data-linenumber="1968"><td class="num" id="LN1968">1968</td><td class="line"> <span class='comment'>* Returns NULL if it's OK, an error message otherwise.</span></td></tr>
<tr class="codeline" data-linenumber="1969"><td class="num" id="LN1969">1969</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1970"><td class="num" id="LN1970">1970</td><td class="line">    <span class='keyword'>char</span> *</td></tr>
<tr class="codeline" data-linenumber="1971"><td class="num" id="LN1971">1971</td><td class="line">did_set_spelllang(win_T *wp)</td></tr>
<tr class="codeline" data-linenumber="1972"><td class="num" id="LN1972">1972</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="1973"><td class="num" id="LN1973">1973</td><td class="line">    garray_T	ga;</td></tr>
<tr class="codeline" data-linenumber="1974"><td class="num" id="LN1974">1974</td><td class="line">    char_u	*splp;</td></tr>
<tr class="codeline" data-linenumber="1975"><td class="num" id="LN1975">1975</td><td class="line">    char_u	*region;</td></tr>
<tr class="codeline" data-linenumber="1976"><td class="num" id="LN1976">1976</td><td class="line">    char_u	region_cp[3];</td></tr>
<tr class="codeline" data-linenumber="1977"><td class="num" id="LN1977">1977</td><td class="line">    <span class='keyword'>int</span>		filename;</td></tr>
<tr class="codeline" data-linenumber="1978"><td class="num" id="LN1978">1978</td><td class="line">    <span class='keyword'>int</span>		region_mask;</td></tr>
<tr class="codeline" data-linenumber="1979"><td class="num" id="LN1979">1979</td><td class="line">    slang_T	*slang;</td></tr>
<tr class="codeline" data-linenumber="1980"><td class="num" id="LN1980">1980</td><td class="line">    <span class='keyword'>int</span>		c;</td></tr>
<tr class="codeline" data-linenumber="1981"><td class="num" id="LN1981">1981</td><td class="line">    char_u	lang[<span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span> + 1];</td></tr>
<tr class="codeline" data-linenumber="1982"><td class="num" id="LN1982">1982</td><td class="line">    char_u	spf_name[<span class='macro'>MAXPATHL<span class='macro_popup'>4096</span></span>];</td></tr>
<tr class="codeline" data-linenumber="1983"><td class="num" id="LN1983">1983</td><td class="line">    <span class='keyword'>int</span>		len;</td></tr>
<tr class="codeline" data-linenumber="1984"><td class="num" id="LN1984">1984</td><td class="line">    char_u	*p;</td></tr>
<tr class="codeline" data-linenumber="1985"><td class="num" id="LN1985">1985</td><td class="line">    <span class='keyword'>int</span>		round;</td></tr>
<tr class="codeline" data-linenumber="1986"><td class="num" id="LN1986">1986</td><td class="line">    char_u	*spf;</td></tr>
<tr class="codeline" data-linenumber="1987"><td class="num" id="LN1987">1987</td><td class="line">    char_u	*use_region = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1988"><td class="num" id="LN1988">1988</td><td class="line">    <span class='keyword'>int</span>		dont_use_region = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1989"><td class="num" id="LN1989">1989</td><td class="line">    <span class='keyword'>int</span>		nobreak = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1990"><td class="num" id="LN1990">1990</td><td class="line">    <span class='keyword'>int</span>		i, j;</td></tr>
<tr class="codeline" data-linenumber="1991"><td class="num" id="LN1991">1991</td><td class="line">    langp_T	*lp, *lp2;</td></tr>
<tr class="codeline" data-linenumber="1992"><td class="num" id="LN1992">1992</td><td class="line">    <span class='keyword'>static</span> <span class='keyword'>int</span>	recursive = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1993"><td class="num" id="LN1993">1993</td><td class="line">    <span class='keyword'>char</span>	*ret_msg = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1994"><td class="num" id="LN1994">1994</td><td class="line">    char_u	*spl_copy;</td></tr>
<tr class="codeline" data-linenumber="1995"><td class="num" id="LN1995">1995</td><td class="line">    bufref_T	bufref;</td></tr>
<tr class="codeline" data-linenumber="1996"><td class="num" id="LN1996">1996</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1997"><td class="num" id="LN1997">1997</td><td class="line">    set_bufref(&amp;bufref, wp-&gt;w_buffer);</td></tr>
<tr class="codeline" data-linenumber="1998"><td class="num" id="LN1998">1998</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1999"><td class="num" id="LN1999">1999</td><td class="line">    <span class='comment'>// We don't want to do this recursively.  May happen when a language is</span></td></tr>
<tr class="codeline" data-linenumber="2000"><td class="num" id="LN2000">2000</td><td class="line">    <span class='comment'>// not available and the SpellFileMissing autocommand opens a new buffer</span></td></tr>
<tr class="codeline" data-linenumber="2001"><td class="num" id="LN2001">2001</td><td class="line">    <span class='comment'>// in which 'spell' is set.</span></td></tr>
<tr class="codeline" data-linenumber="2002"><td class="num" id="LN2002">2002</td><td class="line">    <span class='keyword'>if</span> (recursive)</td></tr>
<tr class="codeline" data-linenumber="2003"><td class="num" id="LN2003">2003</td><td class="line">	<span class='keyword'>return</span> <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2004"><td class="num" id="LN2004">2004</td><td class="line">    recursive = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2005"><td class="num" id="LN2005">2005</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2006"><td class="num" id="LN2006">2006</td><td class="line">    ga_init2(&amp;ga, <span class='keyword'>sizeof</span>(langp_T), 2);</td></tr>
<tr class="codeline" data-linenumber="2007"><td class="num" id="LN2007">2007</td><td class="line">    clear_midword(wp);</td></tr>
<tr class="codeline" data-linenumber="2008"><td class="num" id="LN2008">2008</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2009"><td class="num" id="LN2009">2009</td><td class="line">    <span class='comment'>// Make a copy of 'spelllang', the SpellFileMissing autocommands may change</span></td></tr>
<tr class="codeline" data-linenumber="2010"><td class="num" id="LN2010">2010</td><td class="line">    <span class='comment'>// it under our fingers.</span></td></tr>
<tr class="codeline" data-linenumber="2011"><td class="num" id="LN2011">2011</td><td class="line">    spl_copy = vim_strsave(wp-&gt;w_s-&gt;b_p_spl);</td></tr>
<tr class="codeline" data-linenumber="2012"><td class="num" id="LN2012">2012</td><td class="line">    <span class='keyword'>if</span> (spl_copy == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2013"><td class="num" id="LN2013">2013</td><td class="line">	<span class='keyword'>goto</span> theend;</td></tr>
<tr class="codeline" data-linenumber="2014"><td class="num" id="LN2014">2014</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2015"><td class="num" id="LN2015">2015</td><td class="line">    wp-&gt;w_s-&gt;b_cjk = 0;</td></tr>
<tr class="codeline" data-linenumber="2016"><td class="num" id="LN2016">2016</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2017"><td class="num" id="LN2017">2017</td><td class="line">    <span class='comment'>// Loop over comma separated language names.</span></td></tr>
<tr class="codeline" data-linenumber="2018"><td class="num" id="LN2018">2018</td><td class="line">    <span class='keyword'>for</span> (splp = spl_copy; *splp != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>; )</td></tr>
<tr class="codeline" data-linenumber="2019"><td class="num" id="LN2019">2019</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2020"><td class="num" id="LN2020">2020</td><td class="line">	<span class='comment'>// Get one language name.</span></td></tr>
<tr class="codeline" data-linenumber="2021"><td class="num" id="LN2021">2021</td><td class="line">	copy_option_part(&amp;splp, lang, <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>, <span class='string_literal'>","</span>);</td></tr>
<tr class="codeline" data-linenumber="2022"><td class="num" id="LN2022">2022</td><td class="line">	region = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2023"><td class="num" id="LN2023">2023</td><td class="line">	len = (<span class='keyword'>int</span>)<span class='macro'>STRLEN(lang)<span class='macro_popup'>strlen((char *)(lang))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2024"><td class="num" id="LN2024">2024</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2025"><td class="num" id="LN2025">2025</td><td class="line">	<span class='keyword'>if</span> (!valid_spelllang(lang))</td></tr>
<tr class="codeline" data-linenumber="2026"><td class="num" id="LN2026">2026</td><td class="line">	    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="2027"><td class="num" id="LN2027">2027</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2028"><td class="num" id="LN2028">2028</td><td class="line">	<span class='keyword'>if</span> (<span class='macro'>STRCMP(lang, <span class='string_literal'>"cjk"</span>)<span class='macro_popup'>strcmp((char *)(lang), (char *)("cjk"))</span></span> == 0)</td></tr>
<tr class="codeline" data-linenumber="2029"><td class="num" id="LN2029">2029</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="2030"><td class="num" id="LN2030">2030</td><td class="line">	    wp-&gt;w_s-&gt;b_cjk = 1;</td></tr>
<tr class="codeline" data-linenumber="2031"><td class="num" id="LN2031">2031</td><td class="line">	    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="2032"><td class="num" id="LN2032">2032</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="2033"><td class="num" id="LN2033">2033</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2034"><td class="num" id="LN2034">2034</td><td class="line">	<span class='comment'>// If the name ends in ".spl" use it as the name of the spell file.</span></td></tr>
<tr class="codeline" data-linenumber="2035"><td class="num" id="LN2035">2035</td><td class="line">	<span class='comment'>// If there is a region name let "region" point to it and remove it</span></td></tr>
<tr class="codeline" data-linenumber="2036"><td class="num" id="LN2036">2036</td><td class="line">	<span class='comment'>// from the name.</span></td></tr>
<tr class="codeline" data-linenumber="2037"><td class="num" id="LN2037">2037</td><td class="line">	<span class='keyword'>if</span> (len &gt; 4 &amp;&amp; <span class='macro'>fnamecmp(lang + len - 4, <span class='string_literal'>".spl"</span>)<span class='macro_popup'>vim_fnamecmp((char_u *)(lang + len - 4), (char_u *)(".spl"))</span></span> == 0)</td></tr>
<tr class="codeline" data-linenumber="2038"><td class="num" id="LN2038">2038</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="2039"><td class="num" id="LN2039">2039</td><td class="line">	    filename = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2040"><td class="num" id="LN2040">2040</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2041"><td class="num" id="LN2041">2041</td><td class="line">	    <span class='comment'>// Locate a region and remove it from the file name.</span></td></tr>
<tr class="codeline" data-linenumber="2042"><td class="num" id="LN2042">2042</td><td class="line">	    p = vim_strchr(gettail(lang), '_');</td></tr>
<tr class="codeline" data-linenumber="2043"><td class="num" id="LN2043">2043</td><td class="line">	    <span class='keyword'>if</span> (p != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span> &amp;&amp; <span class='macro'>ASCII_ISALPHA(p[1])<span class='macro_popup'>(((unsigned)(p[1]) - 'A' &lt; 26) || ((unsigned)(p[1]) - 'a' &lt;<br> 26))</span></span> &amp;&amp; <span class='macro'>ASCII_ISALPHA(p[2])<span class='macro_popup'>(((unsigned)(p[2]) - 'A' &lt; 26) || ((unsigned)(p[2]) - 'a' &lt;<br> 26))</span></span></td></tr>
<tr class="codeline" data-linenumber="2044"><td class="num" id="LN2044">2044</td><td class="line">						      &amp;&amp; !<span class='macro'>ASCII_ISALPHA(p[3])<span class='macro_popup'>(((unsigned)(p[3]) - 'A' &lt; 26) || ((unsigned)(p[3]) - 'a' &lt;<br> 26))</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2045"><td class="num" id="LN2045">2045</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="2046"><td class="num" id="LN2046">2046</td><td class="line">		vim_strncpy(region_cp, p + 1, 2);</td></tr>
<tr class="codeline" data-linenumber="2047"><td class="num" id="LN2047">2047</td><td class="line">		<span class='macro'>mch_memmove(p, p + 3, len - (p - lang) - 2)<span class='macro_popup'>memmove((char *)(p), (char *)(p + 3), len - (p - lang) - 2)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2048"><td class="num" id="LN2048">2048</td><td class="line">		region = region_cp;</td></tr>
<tr class="codeline" data-linenumber="2049"><td class="num" id="LN2049">2049</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="2050"><td class="num" id="LN2050">2050</td><td class="line">	    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2051"><td class="num" id="LN2051">2051</td><td class="line">		dont_use_region = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2052"><td class="num" id="LN2052">2052</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2053"><td class="num" id="LN2053">2053</td><td class="line">	    <span class='comment'>// Check if we loaded this language before.</span></td></tr>
<tr class="codeline" data-linenumber="2054"><td class="num" id="LN2054">2054</td><td class="line">	    <span class='macro'>FOR_ALL_SPELL_LANGS(slang)<span class='macro_popup'>for ((slang) = first_lang; (slang) != ((void*)0); (slang) = (<br>slang)-&gt;sl_next)</span></span></td></tr>
<tr class="codeline" data-linenumber="2055"><td class="num" id="LN2055">2055</td><td class="line">		<span class='keyword'>if</span> (fullpathcmp(lang, slang-&gt;sl_fname, <span class='macro'>FALSE<span class='macro_popup'>0</span></span>, <span class='macro'>TRUE<span class='macro_popup'>1</span></span>) == <span class='macro'>FPC_SAME<span class='macro_popup'>1</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2056"><td class="num" id="LN2056">2056</td><td class="line">		    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="2057"><td class="num" id="LN2057">2057</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="2058"><td class="num" id="LN2058">2058</td><td class="line">	<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2059"><td class="num" id="LN2059">2059</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="2060"><td class="num" id="LN2060">2060</td><td class="line">	    filename = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2061"><td class="num" id="LN2061">2061</td><td class="line">	    <span class='keyword'>if</span> (len &gt; 3 &amp;&amp; lang[len - 3] == '_')</td></tr>
<tr class="codeline" data-linenumber="2062"><td class="num" id="LN2062">2062</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="2063"><td class="num" id="LN2063">2063</td><td class="line">		region = lang + len - 2;</td></tr>
<tr class="codeline" data-linenumber="2064"><td class="num" id="LN2064">2064</td><td class="line">		len -= 3;</td></tr>
<tr class="codeline" data-linenumber="2065"><td class="num" id="LN2065">2065</td><td class="line">		lang[len] = <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2066"><td class="num" id="LN2066">2066</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="2067"><td class="num" id="LN2067">2067</td><td class="line">	    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2068"><td class="num" id="LN2068">2068</td><td class="line">		dont_use_region = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2069"><td class="num" id="LN2069">2069</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2070"><td class="num" id="LN2070">2070</td><td class="line">	    <span class='comment'>// Check if we loaded this language before.</span></td></tr>
<tr class="codeline" data-linenumber="2071"><td class="num" id="LN2071">2071</td><td class="line">	    <span class='macro'>FOR_ALL_SPELL_LANGS(slang)<span class='macro_popup'>for ((slang) = first_lang; (slang) != ((void*)0); (slang) = (<br>slang)-&gt;sl_next)</span></span></td></tr>
<tr class="codeline" data-linenumber="2072"><td class="num" id="LN2072">2072</td><td class="line">		<span class='keyword'>if</span> (<span class='macro'>STRICMP(lang, slang-&gt;sl_name)<span class='macro_popup'>strcasecmp((char *)(lang), (char *)(slang-&gt;sl_name))</span></span> == 0)</td></tr>
<tr class="codeline" data-linenumber="2073"><td class="num" id="LN2073">2073</td><td class="line">		    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="2074"><td class="num" id="LN2074">2074</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="2075"><td class="num" id="LN2075">2075</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2076"><td class="num" id="LN2076">2076</td><td class="line">	<span class='keyword'>if</span> (region != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2077"><td class="num" id="LN2077">2077</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="2078"><td class="num" id="LN2078">2078</td><td class="line">	    <span class='comment'>// If the region differs from what was used before then don't</span></td></tr>
<tr class="codeline" data-linenumber="2079"><td class="num" id="LN2079">2079</td><td class="line">	    <span class='comment'>// use it for 'spellfile'.</span></td></tr>
<tr class="codeline" data-linenumber="2080"><td class="num" id="LN2080">2080</td><td class="line">	    <span class='keyword'>if</span> (use_region != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span> &amp;&amp; <span class='macro'>STRCMP(region, use_region)<span class='macro_popup'>strcmp((char *)(region), (char *)(use_region))</span></span> != 0)</td></tr>
<tr class="codeline" data-linenumber="2081"><td class="num" id="LN2081">2081</td><td class="line">		dont_use_region = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2082"><td class="num" id="LN2082">2082</td><td class="line">	    use_region = region;</td></tr>
<tr class="codeline" data-linenumber="2083"><td class="num" id="LN2083">2083</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="2084"><td class="num" id="LN2084">2084</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2085"><td class="num" id="LN2085">2085</td><td class="line">	<span class='comment'>// If not found try loading the language now.</span></td></tr>
<tr class="codeline" data-linenumber="2086"><td class="num" id="LN2086">2086</td><td class="line">	<span class='keyword'>if</span> (slang == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2087"><td class="num" id="LN2087">2087</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="2088"><td class="num" id="LN2088">2088</td><td class="line">	    <span class='keyword'>if</span> (filename)</td></tr>
<tr class="codeline" data-linenumber="2089"><td class="num" id="LN2089">2089</td><td class="line">		(<span class='keyword'>void</span>)spell_load_file(lang, lang, <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>, <span class='macro'>FALSE<span class='macro_popup'>0</span></span>);</td></tr>
<tr class="codeline" data-linenumber="2090"><td class="num" id="LN2090">2090</td><td class="line">	    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2091"><td class="num" id="LN2091">2091</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="2092"><td class="num" id="LN2092">2092</td><td class="line">		spell_load_lang(lang);</td></tr>
<tr class="codeline" data-linenumber="2093"><td class="num" id="LN2093">2093</td><td class="line">		<span class='comment'>// SpellFileMissing autocommands may do anything, including</span></td></tr>
<tr class="codeline" data-linenumber="2094"><td class="num" id="LN2094">2094</td><td class="line">		<span class='comment'>// destroying the buffer we are using...</span></td></tr>
<tr class="codeline" data-linenumber="2095"><td class="num" id="LN2095">2095</td><td class="line">		<span class='keyword'>if</span> (!bufref_valid(&amp;bufref))</td></tr>
<tr class="codeline" data-linenumber="2096"><td class="num" id="LN2096">2096</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="2097"><td class="num" id="LN2097">2097</td><td class="line">		    ret_msg = <span class='macro'>N_(<span class='string_literal'>"E797: SpellFileMissing autocommand deleted buffer"</span>)<span class='macro_popup'>"E797: SpellFileMissing autocommand deleted buffer"</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2098"><td class="num" id="LN2098">2098</td><td class="line">		    <span class='keyword'>goto</span> theend;</td></tr>
<tr class="codeline" data-linenumber="2099"><td class="num" id="LN2099">2099</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="2100"><td class="num" id="LN2100">2100</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="2101"><td class="num" id="LN2101">2101</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="2102"><td class="num" id="LN2102">2102</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2103"><td class="num" id="LN2103">2103</td><td class="line">	<span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="2104"><td class="num" id="LN2104">2104</td><td class="line">	 <span class='comment'>* Loop over the languages, there can be several files for "lang".</span></td></tr>
<tr class="codeline" data-linenumber="2105"><td class="num" id="LN2105">2105</td><td class="line">	 <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="2106"><td class="num" id="LN2106">2106</td><td class="line">	<span class='macro'>FOR_ALL_SPELL_LANGS(slang)<span class='macro_popup'>for ((slang) = first_lang; (slang) != ((void*)0); (slang) = (<br>slang)-&gt;sl_next)</span></span></td></tr>
<tr class="codeline" data-linenumber="2107"><td class="num" id="LN2107">2107</td><td class="line">	    <span class='keyword'>if</span> (filename ? fullpathcmp(lang, slang-&gt;sl_fname, <span class='macro'>FALSE<span class='macro_popup'>0</span></span>, <span class='macro'>TRUE<span class='macro_popup'>1</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2108"><td class="num" id="LN2108">2108</td><td class="line">								    == <span class='macro'>FPC_SAME<span class='macro_popup'>1</span></span></td></tr>
<tr class="codeline" data-linenumber="2109"><td class="num" id="LN2109">2109</td><td class="line">			 : <span class='macro'>STRICMP(lang, slang-&gt;sl_name)<span class='macro_popup'>strcasecmp((char *)(lang), (char *)(slang-&gt;sl_name))</span></span> == 0)</td></tr>
<tr class="codeline" data-linenumber="2110"><td class="num" id="LN2110">2110</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="2111"><td class="num" id="LN2111">2111</td><td class="line">		region_mask = <span class='macro'>REGION_ALL<span class='macro_popup'>0xff</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2112"><td class="num" id="LN2112">2112</td><td class="line">		<span class='keyword'>if</span> (!filename &amp;&amp; region != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2113"><td class="num" id="LN2113">2113</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="2114"><td class="num" id="LN2114">2114</td><td class="line">		    <span class='comment'>// find region in sl_regions</span></td></tr>
<tr class="codeline" data-linenumber="2115"><td class="num" id="LN2115">2115</td><td class="line">		    c = find_region(slang-&gt;sl_regions, region);</td></tr>
<tr class="codeline" data-linenumber="2116"><td class="num" id="LN2116">2116</td><td class="line">		    <span class='keyword'>if</span> (c == <span class='macro'>REGION_ALL<span class='macro_popup'>0xff</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2117"><td class="num" id="LN2117">2117</td><td class="line">		    {</td></tr>
<tr class="codeline" data-linenumber="2118"><td class="num" id="LN2118">2118</td><td class="line">			<span class='keyword'>if</span> (slang-&gt;sl_add)</td></tr>
<tr class="codeline" data-linenumber="2119"><td class="num" id="LN2119">2119</td><td class="line">			{</td></tr>
<tr class="codeline" data-linenumber="2120"><td class="num" id="LN2120">2120</td><td class="line">			    <span class='keyword'>if</span> (*slang-&gt;sl_regions != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2121"><td class="num" id="LN2121">2121</td><td class="line">				<span class='comment'>// This addition file is for other regions.</span></td></tr>
<tr class="codeline" data-linenumber="2122"><td class="num" id="LN2122">2122</td><td class="line">				region_mask = 0;</td></tr>
<tr class="codeline" data-linenumber="2123"><td class="num" id="LN2123">2123</td><td class="line">			}</td></tr>
<tr class="codeline" data-linenumber="2124"><td class="num" id="LN2124">2124</td><td class="line">			<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2125"><td class="num" id="LN2125">2125</td><td class="line">			    <span class='comment'>// This is probably an error.  Give a warning and</span></td></tr>
<tr class="codeline" data-linenumber="2126"><td class="num" id="LN2126">2126</td><td class="line">			    <span class='comment'>// accept the words anyway.</span></td></tr>
<tr class="codeline" data-linenumber="2127"><td class="num" id="LN2127">2127</td><td class="line">			    smsg(<span class='macro'>_(<span class='string_literal'>"Warning: region %s not supported"</span>)<span class='macro_popup'>dcgettext (((void*)0), (char *)("Warning: region %s not supported"<br>), 5)</span></span>,</td></tr>
<tr class="codeline" data-linenumber="2128"><td class="num" id="LN2128">2128</td><td class="line">								      region);</td></tr>
<tr class="codeline" data-linenumber="2129"><td class="num" id="LN2129">2129</td><td class="line">		    }</td></tr>
<tr class="codeline" data-linenumber="2130"><td class="num" id="LN2130">2130</td><td class="line">		    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2131"><td class="num" id="LN2131">2131</td><td class="line">			region_mask = 1 &lt;&lt; c;</td></tr>
<tr class="codeline" data-linenumber="2132"><td class="num" id="LN2132">2132</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="2133"><td class="num" id="LN2133">2133</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2134"><td class="num" id="LN2134">2134</td><td class="line">		<span class='keyword'>if</span> (region_mask != 0)</td></tr>
<tr class="codeline" data-linenumber="2135"><td class="num" id="LN2135">2135</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="2136"><td class="num" id="LN2136">2136</td><td class="line">		    <span class='keyword'>if</span> (ga_grow(&amp;ga, 1) == <span class='macro'>FAIL<span class='macro_popup'>0</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2137"><td class="num" id="LN2137">2137</td><td class="line">		    {</td></tr>
<tr class="codeline" data-linenumber="2138"><td class="num" id="LN2138">2138</td><td class="line">			ga_clear(&amp;ga);</td></tr>
<tr class="codeline" data-linenumber="2139"><td class="num" id="LN2139">2139</td><td class="line">			ret_msg = e_outofmem;</td></tr>
<tr class="codeline" data-linenumber="2140"><td class="num" id="LN2140">2140</td><td class="line">			<span class='keyword'>goto</span> theend;</td></tr>
<tr class="codeline" data-linenumber="2141"><td class="num" id="LN2141">2141</td><td class="line">		    }</td></tr>
<tr class="codeline" data-linenumber="2142"><td class="num" id="LN2142">2142</td><td class="line">		    <span class='macro'>LANGP_ENTRY(ga, ga.ga_len)<span class='macro_popup'>(((langp_T *)(ga).ga_data) + (ga.ga_len))</span></span>-&gt;lp_slang = slang;</td></tr>
<tr class="codeline" data-linenumber="2143"><td class="num" id="LN2143">2143</td><td class="line">		    <span class='macro'>LANGP_ENTRY(ga, ga.ga_len)<span class='macro_popup'>(((langp_T *)(ga).ga_data) + (ga.ga_len))</span></span>-&gt;lp_region = region_mask;</td></tr>
<tr class="codeline" data-linenumber="2144"><td class="num" id="LN2144">2144</td><td class="line">		    ++ga.ga_len;</td></tr>
<tr class="codeline" data-linenumber="2145"><td class="num" id="LN2145">2145</td><td class="line">		    use_midword(slang, wp);</td></tr>
<tr class="codeline" data-linenumber="2146"><td class="num" id="LN2146">2146</td><td class="line">		    <span class='keyword'>if</span> (slang-&gt;sl_nobreak)</td></tr>
<tr class="codeline" data-linenumber="2147"><td class="num" id="LN2147">2147</td><td class="line">			nobreak = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2148"><td class="num" id="LN2148">2148</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="2149"><td class="num" id="LN2149">2149</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="2150"><td class="num" id="LN2150">2150</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="2151"><td class="num" id="LN2151">2151</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2152"><td class="num" id="LN2152">2152</td><td class="line">    <span class='comment'>// round 0: load int_wordlist, if possible.</span></td></tr>
<tr class="codeline" data-linenumber="2153"><td class="num" id="LN2153">2153</td><td class="line">    <span class='comment'>// round 1: load first name in 'spellfile'.</span></td></tr>
<tr class="codeline" data-linenumber="2154"><td class="num" id="LN2154">2154</td><td class="line">    <span class='comment'>// round 2: load second name in 'spellfile.</span></td></tr>
<tr class="codeline" data-linenumber="2155"><td class="num" id="LN2155">2155</td><td class="line">    <span class='comment'>// etc.</span></td></tr>
<tr class="codeline" data-linenumber="2156"><td class="num" id="LN2156">2156</td><td class="line">    spf = curwin-&gt;w_s-&gt;b_p_spf;</td></tr>
<tr class="codeline" data-linenumber="2157"><td class="num" id="LN2157">2157</td><td class="line">    <span class='keyword'>for</span> (round = 0; round == 0 || *spf != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>; ++round)</td></tr>
<tr class="codeline" data-linenumber="2158"><td class="num" id="LN2158">2158</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2159"><td class="num" id="LN2159">2159</td><td class="line">	<span class='keyword'>if</span> (round == 0)</td></tr>
<tr class="codeline" data-linenumber="2160"><td class="num" id="LN2160">2160</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="2161"><td class="num" id="LN2161">2161</td><td class="line">	    <span class='comment'>// Internal wordlist, if there is one.</span></td></tr>
<tr class="codeline" data-linenumber="2162"><td class="num" id="LN2162">2162</td><td class="line">	    <span class='keyword'>if</span> (int_wordlist == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2163"><td class="num" id="LN2163">2163</td><td class="line">		<span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="2164"><td class="num" id="LN2164">2164</td><td class="line">	    int_wordlist_spl(spf_name);</td></tr>
<tr class="codeline" data-linenumber="2165"><td class="num" id="LN2165">2165</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="2166"><td class="num" id="LN2166">2166</td><td class="line">	<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2167"><td class="num" id="LN2167">2167</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="2168"><td class="num" id="LN2168">2168</td><td class="line">	    <span class='comment'>// One entry in 'spellfile'.</span></td></tr>
<tr class="codeline" data-linenumber="2169"><td class="num" id="LN2169">2169</td><td class="line">	    copy_option_part(&amp;spf, spf_name, <span class='macro'>MAXPATHL<span class='macro_popup'>4096</span></span> - 5, <span class='string_literal'>","</span>);</td></tr>
<tr class="codeline" data-linenumber="2170"><td class="num" id="LN2170">2170</td><td class="line">	    <span class='macro'>STRCAT(spf_name, <span class='string_literal'>".spl"</span>)<span class='macro_popup'>strcat((char *)(spf_name), (char *)(".spl"))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2171"><td class="num" id="LN2171">2171</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2172"><td class="num" id="LN2172">2172</td><td class="line">	    <span class='comment'>// If it was already found above then skip it.</span></td></tr>
<tr class="codeline" data-linenumber="2173"><td class="num" id="LN2173">2173</td><td class="line">	    <span class='keyword'>for</span> (c = 0; c &lt; ga.ga_len; ++c)</td></tr>
<tr class="codeline" data-linenumber="2174"><td class="num" id="LN2174">2174</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="2175"><td class="num" id="LN2175">2175</td><td class="line">		p = <span class='macro'>LANGP_ENTRY(ga, c)<span class='macro_popup'>(((langp_T *)(ga).ga_data) + (c))</span></span>-&gt;lp_slang-&gt;sl_fname;</td></tr>
<tr class="codeline" data-linenumber="2176"><td class="num" id="LN2176">2176</td><td class="line">		<span class='keyword'>if</span> (p != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span> &amp;&amp; fullpathcmp(spf_name, p, <span class='macro'>FALSE<span class='macro_popup'>0</span></span>, <span class='macro'>TRUE<span class='macro_popup'>1</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2177"><td class="num" id="LN2177">2177</td><td class="line">								== <span class='macro'>FPC_SAME<span class='macro_popup'>1</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2178"><td class="num" id="LN2178">2178</td><td class="line">		    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="2179"><td class="num" id="LN2179">2179</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="2180"><td class="num" id="LN2180">2180</td><td class="line">	    <span class='keyword'>if</span> (c &lt; ga.ga_len)</td></tr>
<tr class="codeline" data-linenumber="2181"><td class="num" id="LN2181">2181</td><td class="line">		<span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="2182"><td class="num" id="LN2182">2182</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="2183"><td class="num" id="LN2183">2183</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2184"><td class="num" id="LN2184">2184</td><td class="line">	<span class='comment'>// Check if it was loaded already.</span></td></tr>
<tr class="codeline" data-linenumber="2185"><td class="num" id="LN2185">2185</td><td class="line">	<span class='macro'>FOR_ALL_SPELL_LANGS(slang)<span class='macro_popup'>for ((slang) = first_lang; (slang) != ((void*)0); (slang) = (<br>slang)-&gt;sl_next)</span></span></td></tr>
<tr class="codeline" data-linenumber="2186"><td class="num" id="LN2186">2186</td><td class="line">	    <span class='keyword'>if</span> (fullpathcmp(spf_name, slang-&gt;sl_fname, <span class='macro'>FALSE<span class='macro_popup'>0</span></span>, <span class='macro'>TRUE<span class='macro_popup'>1</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2187"><td class="num" id="LN2187">2187</td><td class="line">								== <span class='macro'>FPC_SAME<span class='macro_popup'>1</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2188"><td class="num" id="LN2188">2188</td><td class="line">		<span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="2189"><td class="num" id="LN2189">2189</td><td class="line">	<span class='keyword'>if</span> (slang == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2190"><td class="num" id="LN2190">2190</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="2191"><td class="num" id="LN2191">2191</td><td class="line">	    <span class='comment'>// Not loaded, try loading it now.  The language name includes the</span></td></tr>
<tr class="codeline" data-linenumber="2192"><td class="num" id="LN2192">2192</td><td class="line">	    <span class='comment'>// region name, the region is ignored otherwise.  for int_wordlist</span></td></tr>
<tr class="codeline" data-linenumber="2193"><td class="num" id="LN2193">2193</td><td class="line">	    <span class='comment'>// use an arbitrary name.</span></td></tr>
<tr class="codeline" data-linenumber="2194"><td class="num" id="LN2194">2194</td><td class="line">	    <span class='keyword'>if</span> (round == 0)</td></tr>
<tr class="codeline" data-linenumber="2195"><td class="num" id="LN2195">2195</td><td class="line">		<span class='macro'>STRCPY(lang, <span class='string_literal'>"internal wordlist"</span>)<span class='macro_popup'>strcpy((char *)(lang), (char *)("internal wordlist"))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2196"><td class="num" id="LN2196">2196</td><td class="line">	    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2197"><td class="num" id="LN2197">2197</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="2198"><td class="num" id="LN2198">2198</td><td class="line">		vim_strncpy(lang, gettail(spf_name), <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>);</td></tr>
<tr class="codeline" data-linenumber="2199"><td class="num" id="LN2199">2199</td><td class="line">		p = vim_strchr(lang, '.');</td></tr>
<tr class="codeline" data-linenumber="2200"><td class="num" id="LN2200">2200</td><td class="line">		<span class='keyword'>if</span> (p != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2201"><td class="num" id="LN2201">2201</td><td class="line">		    *p = <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>;	<span class='comment'>// truncate at ".encoding.add"</span></td></tr>
<tr class="codeline" data-linenumber="2202"><td class="num" id="LN2202">2202</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="2203"><td class="num" id="LN2203">2203</td><td class="line">	    slang = spell_load_file(spf_name, lang, <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>, <span class='macro'>TRUE<span class='macro_popup'>1</span></span>);</td></tr>
<tr class="codeline" data-linenumber="2204"><td class="num" id="LN2204">2204</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2205"><td class="num" id="LN2205">2205</td><td class="line">	    <span class='comment'>// If one of the languages has NOBREAK we assume the addition</span></td></tr>
<tr class="codeline" data-linenumber="2206"><td class="num" id="LN2206">2206</td><td class="line">	    <span class='comment'>// files also have this.</span></td></tr>
<tr class="codeline" data-linenumber="2207"><td class="num" id="LN2207">2207</td><td class="line">	    <span class='keyword'>if</span> (slang != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span> &amp;&amp; nobreak)</td></tr>
<tr class="codeline" data-linenumber="2208"><td class="num" id="LN2208">2208</td><td class="line">		slang-&gt;sl_nobreak = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2209"><td class="num" id="LN2209">2209</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="2210"><td class="num" id="LN2210">2210</td><td class="line">	<span class='keyword'>if</span> (slang != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span> &amp;&amp; ga_grow(&amp;ga, 1) == <span class='macro'>OK<span class='macro_popup'>1</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2211"><td class="num" id="LN2211">2211</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="2212"><td class="num" id="LN2212">2212</td><td class="line">	    region_mask = <span class='macro'>REGION_ALL<span class='macro_popup'>0xff</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2213"><td class="num" id="LN2213">2213</td><td class="line">	    <span class='keyword'>if</span> (use_region != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span> &amp;&amp; !dont_use_region)</td></tr>
<tr class="codeline" data-linenumber="2214"><td class="num" id="LN2214">2214</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="2215"><td class="num" id="LN2215">2215</td><td class="line">		<span class='comment'>// find region in sl_regions</span></td></tr>
<tr class="codeline" data-linenumber="2216"><td class="num" id="LN2216">2216</td><td class="line">		c = find_region(slang-&gt;sl_regions, use_region);</td></tr>
<tr class="codeline" data-linenumber="2217"><td class="num" id="LN2217">2217</td><td class="line">		<span class='keyword'>if</span> (c != <span class='macro'>REGION_ALL<span class='macro_popup'>0xff</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2218"><td class="num" id="LN2218">2218</td><td class="line">		    region_mask = 1 &lt;&lt; c;</td></tr>
<tr class="codeline" data-linenumber="2219"><td class="num" id="LN2219">2219</td><td class="line">		<span class='keyword'>else</span> <span class='keyword'>if</span> (*slang-&gt;sl_regions != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2220"><td class="num" id="LN2220">2220</td><td class="line">		    <span class='comment'>// This spell file is for other regions.</span></td></tr>
<tr class="codeline" data-linenumber="2221"><td class="num" id="LN2221">2221</td><td class="line">		    region_mask = 0;</td></tr>
<tr class="codeline" data-linenumber="2222"><td class="num" id="LN2222">2222</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="2223"><td class="num" id="LN2223">2223</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2224"><td class="num" id="LN2224">2224</td><td class="line">	    <span class='keyword'>if</span> (region_mask != 0)</td></tr>
<tr class="codeline" data-linenumber="2225"><td class="num" id="LN2225">2225</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="2226"><td class="num" id="LN2226">2226</td><td class="line">		<span class='macro'>LANGP_ENTRY(ga, ga.ga_len)<span class='macro_popup'>(((langp_T *)(ga).ga_data) + (ga.ga_len))</span></span>-&gt;lp_slang = slang;</td></tr>
<tr class="codeline" data-linenumber="2227"><td class="num" id="LN2227">2227</td><td class="line">		<span class='macro'>LANGP_ENTRY(ga, ga.ga_len)<span class='macro_popup'>(((langp_T *)(ga).ga_data) + (ga.ga_len))</span></span>-&gt;lp_sallang = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2228"><td class="num" id="LN2228">2228</td><td class="line">		<span class='macro'>LANGP_ENTRY(ga, ga.ga_len)<span class='macro_popup'>(((langp_T *)(ga).ga_data) + (ga.ga_len))</span></span>-&gt;lp_replang = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2229"><td class="num" id="LN2229">2229</td><td class="line">		<span class='macro'>LANGP_ENTRY(ga, ga.ga_len)<span class='macro_popup'>(((langp_T *)(ga).ga_data) + (ga.ga_len))</span></span>-&gt;lp_region = region_mask;</td></tr>
<tr class="codeline" data-linenumber="2230"><td class="num" id="LN2230">2230</td><td class="line">		++ga.ga_len;</td></tr>
<tr class="codeline" data-linenumber="2231"><td class="num" id="LN2231">2231</td><td class="line">		use_midword(slang, wp);</td></tr>
<tr class="codeline" data-linenumber="2232"><td class="num" id="LN2232">2232</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="2233"><td class="num" id="LN2233">2233</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="2234"><td class="num" id="LN2234">2234</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="2235"><td class="num" id="LN2235">2235</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2236"><td class="num" id="LN2236">2236</td><td class="line">    <span class='comment'>// Everything is fine, store the new b_langp value.</span></td></tr>
<tr class="codeline" data-linenumber="2237"><td class="num" id="LN2237">2237</td><td class="line">    ga_clear(&amp;wp-&gt;w_s-&gt;b_langp);</td></tr>
<tr class="codeline" data-linenumber="2238"><td class="num" id="LN2238">2238</td><td class="line">    wp-&gt;w_s-&gt;b_langp = ga;</td></tr>
<tr class="codeline" data-linenumber="2239"><td class="num" id="LN2239">2239</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2240"><td class="num" id="LN2240">2240</td><td class="line">    <span class='comment'>// For each language figure out what language to use for sound folding and</span></td></tr>
<tr class="codeline" data-linenumber="2241"><td class="num" id="LN2241">2241</td><td class="line">    <span class='comment'>// REP items.  If the language doesn't support it itself use another one</span></td></tr>
<tr class="codeline" data-linenumber="2242"><td class="num" id="LN2242">2242</td><td class="line">    <span class='comment'>// with the same name.  E.g. for "en-math" use "en".</span></td></tr>
<tr class="codeline" data-linenumber="2243"><td class="num" id="LN2243">2243</td><td class="line">    <span class='keyword'>for</span> (i = 0; i &lt; ga.ga_len; ++i)</td></tr>
<tr class="codeline" data-linenumber="2244"><td class="num" id="LN2244">2244</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2245"><td class="num" id="LN2245">2245</td><td class="line">	lp = <span class='macro'>LANGP_ENTRY(ga, i)<span class='macro_popup'>(((langp_T *)(ga).ga_data) + (i))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2246"><td class="num" id="LN2246">2246</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2247"><td class="num" id="LN2247">2247</td><td class="line">	<span class='comment'>// sound folding</span></td></tr>
<tr class="codeline" data-linenumber="2248"><td class="num" id="LN2248">2248</td><td class="line">	<span class='keyword'>if</span> (lp-&gt;lp_slang-&gt;sl_sal.ga_len &gt; 0)</td></tr>
<tr class="codeline" data-linenumber="2249"><td class="num" id="LN2249">2249</td><td class="line">	    <span class='comment'>// language does sound folding itself</span></td></tr>
<tr class="codeline" data-linenumber="2250"><td class="num" id="LN2250">2250</td><td class="line">	    lp-&gt;lp_sallang = lp-&gt;lp_slang;</td></tr>
<tr class="codeline" data-linenumber="2251"><td class="num" id="LN2251">2251</td><td class="line">	<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2252"><td class="num" id="LN2252">2252</td><td class="line">	    <span class='comment'>// find first similar language that does sound folding</span></td></tr>
<tr class="codeline" data-linenumber="2253"><td class="num" id="LN2253">2253</td><td class="line">	    <span class='keyword'>for</span> (j = 0; j &lt; ga.ga_len; ++j)</td></tr>
<tr class="codeline" data-linenumber="2254"><td class="num" id="LN2254">2254</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="2255"><td class="num" id="LN2255">2255</td><td class="line">		lp2 = <span class='macro'>LANGP_ENTRY(ga, j)<span class='macro_popup'>(((langp_T *)(ga).ga_data) + (j))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2256"><td class="num" id="LN2256">2256</td><td class="line">		<span class='keyword'>if</span> (lp2-&gt;lp_slang-&gt;sl_sal.ga_len &gt; 0</td></tr>
<tr class="codeline" data-linenumber="2257"><td class="num" id="LN2257">2257</td><td class="line">			&amp;&amp; <span class='macro'>STRNCMP(lp-&gt;lp_slang-&gt;sl_name,<span class='macro_popup'>strncmp((char *)(lp-&gt;lp_slang-&gt;sl_name), (char *)(lp2-&gt;<br>lp_slang-&gt;sl_name), (size_t)(2))</span></span></td></tr>
<tr class="codeline" data-linenumber="2258"><td class="num" id="LN2258">2258</td><td class="line">					      <span class='macro'>lp2-&gt;lp_slang-&gt;sl_name, 2)<span class='macro_popup'>strncmp((char *)(lp-&gt;lp_slang-&gt;sl_name), (char *)(lp2-&gt;<br>lp_slang-&gt;sl_name), (size_t)(2))</span></span> == 0)</td></tr>
<tr class="codeline" data-linenumber="2259"><td class="num" id="LN2259">2259</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="2260"><td class="num" id="LN2260">2260</td><td class="line">		    lp-&gt;lp_sallang = lp2-&gt;lp_slang;</td></tr>
<tr class="codeline" data-linenumber="2261"><td class="num" id="LN2261">2261</td><td class="line">		    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="2262"><td class="num" id="LN2262">2262</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="2263"><td class="num" id="LN2263">2263</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="2264"><td class="num" id="LN2264">2264</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2265"><td class="num" id="LN2265">2265</td><td class="line">	<span class='comment'>// REP items</span></td></tr>
<tr class="codeline" data-linenumber="2266"><td class="num" id="LN2266">2266</td><td class="line">	<span class='keyword'>if</span> (lp-&gt;lp_slang-&gt;sl_rep.ga_len &gt; 0)</td></tr>
<tr class="codeline" data-linenumber="2267"><td class="num" id="LN2267">2267</td><td class="line">	    <span class='comment'>// language has REP items itself</span></td></tr>
<tr class="codeline" data-linenumber="2268"><td class="num" id="LN2268">2268</td><td class="line">	    lp-&gt;lp_replang = lp-&gt;lp_slang;</td></tr>
<tr class="codeline" data-linenumber="2269"><td class="num" id="LN2269">2269</td><td class="line">	<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2270"><td class="num" id="LN2270">2270</td><td class="line">	    <span class='comment'>// find first similar language that has REP items</span></td></tr>
<tr class="codeline" data-linenumber="2271"><td class="num" id="LN2271">2271</td><td class="line">	    <span class='keyword'>for</span> (j = 0; j &lt; ga.ga_len; ++j)</td></tr>
<tr class="codeline" data-linenumber="2272"><td class="num" id="LN2272">2272</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="2273"><td class="num" id="LN2273">2273</td><td class="line">		lp2 = <span class='macro'>LANGP_ENTRY(ga, j)<span class='macro_popup'>(((langp_T *)(ga).ga_data) + (j))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2274"><td class="num" id="LN2274">2274</td><td class="line">		<span class='keyword'>if</span> (lp2-&gt;lp_slang-&gt;sl_rep.ga_len &gt; 0</td></tr>
<tr class="codeline" data-linenumber="2275"><td class="num" id="LN2275">2275</td><td class="line">			&amp;&amp; <span class='macro'>STRNCMP(lp-&gt;lp_slang-&gt;sl_name,<span class='macro_popup'>strncmp((char *)(lp-&gt;lp_slang-&gt;sl_name), (char *)(lp2-&gt;<br>lp_slang-&gt;sl_name), (size_t)(2))</span></span></td></tr>
<tr class="codeline" data-linenumber="2276"><td class="num" id="LN2276">2276</td><td class="line">					      <span class='macro'>lp2-&gt;lp_slang-&gt;sl_name, 2)<span class='macro_popup'>strncmp((char *)(lp-&gt;lp_slang-&gt;sl_name), (char *)(lp2-&gt;<br>lp_slang-&gt;sl_name), (size_t)(2))</span></span> == 0)</td></tr>
<tr class="codeline" data-linenumber="2277"><td class="num" id="LN2277">2277</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="2278"><td class="num" id="LN2278">2278</td><td class="line">		    lp-&gt;lp_replang = lp2-&gt;lp_slang;</td></tr>
<tr class="codeline" data-linenumber="2279"><td class="num" id="LN2279">2279</td><td class="line">		    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="2280"><td class="num" id="LN2280">2280</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="2281"><td class="num" id="LN2281">2281</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="2282"><td class="num" id="LN2282">2282</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="2283"><td class="num" id="LN2283">2283</td><td class="line">    redraw_win_later(wp, <span class='macro'>NOT_VALID<span class='macro_popup'>40</span></span>);</td></tr>
<tr class="codeline" data-linenumber="2284"><td class="num" id="LN2284">2284</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2285"><td class="num" id="LN2285">2285</td><td class="line">theend:</td></tr>
<tr class="codeline" data-linenumber="2286"><td class="num" id="LN2286">2286</td><td class="line">    vim_free(spl_copy);</td></tr>
<tr class="codeline" data-linenumber="2287"><td class="num" id="LN2287">2287</td><td class="line">    recursive = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2288"><td class="num" id="LN2288">2288</td><td class="line">    <span class='keyword'>return</span> ret_msg;</td></tr>
<tr class="codeline" data-linenumber="2289"><td class="num" id="LN2289">2289</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="2290"><td class="num" id="LN2290">2290</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2291"><td class="num" id="LN2291">2291</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="2292"><td class="num" id="LN2292">2292</td><td class="line"> <span class='comment'>* Clear the midword characters for buffer "buf".</span></td></tr>
<tr class="codeline" data-linenumber="2293"><td class="num" id="LN2293">2293</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="2294"><td class="num" id="LN2294">2294</td><td class="line">    <span class='keyword'>static</span> <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="2295"><td class="num" id="LN2295">2295</td><td class="line">clear_midword(win_T *wp)</td></tr>
<tr class="codeline" data-linenumber="2296"><td class="num" id="LN2296">2296</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="2297"><td class="num" id="LN2297">2297</td><td class="line">    <span class="mrange"><span class='macro'>CLEAR_FIELD</span>(wp-&gt;w_s-&gt;b_spell_ismw)<span class='macro_popup'>memset((&amp;(wp-&gt;w_s-&gt;b_spell_ismw)), (0), (sizeof(wp-&gt;<br>w_s-&gt;b_spell_ismw)))</span></span>;</td></tr>
<tr><td class="num"></td><td class="line"><div id="EndPath" class="msg msgEvent" style="margin-left:5ex; max-width:58em">Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11</div></td></tr>
<tr class="codeline" data-linenumber="2298"><td class="num" id="LN2298">2298</td><td class="line">    <span class='macro'>VIM_CLEAR(wp-&gt;w_s-&gt;b_spell_ismw_mb)<span class='macro_popup'>do { if ((wp-&gt;w_s-&gt;b_spell_ismw_mb) != ((void*)0)) { vim_free<br>(wp-&gt;w_s-&gt;b_spell_ismw_mb); (wp-&gt;w_s-&gt;b_spell_ismw_mb<br>) = ((void*)0); } } while (0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2299"><td class="num" id="LN2299">2299</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="2300"><td class="num" id="LN2300">2300</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2301"><td class="num" id="LN2301">2301</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="2302"><td class="num" id="LN2302">2302</td><td class="line"> <span class='comment'>* Use the "sl_midword" field of language "lp" for buffer "buf".</span></td></tr>
<tr class="codeline" data-linenumber="2303"><td class="num" id="LN2303">2303</td><td class="line"> <span class='comment'>* They add up to any currently used midword characters.</span></td></tr>
<tr class="codeline" data-linenumber="2304"><td class="num" id="LN2304">2304</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="2305"><td class="num" id="LN2305">2305</td><td class="line">    <span class='keyword'>static</span> <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="2306"><td class="num" id="LN2306">2306</td><td class="line">use_midword(slang_T *lp, win_T *wp)</td></tr>
<tr class="codeline" data-linenumber="2307"><td class="num" id="LN2307">2307</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="2308"><td class="num" id="LN2308">2308</td><td class="line">    char_u	*p;</td></tr>
<tr class="codeline" data-linenumber="2309"><td class="num" id="LN2309">2309</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2310"><td class="num" id="LN2310">2310</td><td class="line">    <span class='keyword'>if</span> (lp-&gt;sl_midword == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)	    <span class='comment'>// there aren't any</span></td></tr>
<tr class="codeline" data-linenumber="2311"><td class="num" id="LN2311">2311</td><td class="line">	<span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="2312"><td class="num" id="LN2312">2312</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2313"><td class="num" id="LN2313">2313</td><td class="line">    <span class='keyword'>for</span> (p = lp-&gt;sl_midword; *p != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>; )</td></tr>
<tr class="codeline" data-linenumber="2314"><td class="num" id="LN2314">2314</td><td class="line">	<span class='keyword'>if</span> (has_mbyte)</td></tr>
<tr class="codeline" data-linenumber="2315"><td class="num" id="LN2315">2315</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="2316"><td class="num" id="LN2316">2316</td><td class="line">	    <span class='keyword'>int</span>	    c, l, n;</td></tr>
<tr class="codeline" data-linenumber="2317"><td class="num" id="LN2317">2317</td><td class="line">	    char_u  *bp;</td></tr>
<tr class="codeline" data-linenumber="2318"><td class="num" id="LN2318">2318</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2319"><td class="num" id="LN2319">2319</td><td class="line">	    c = mb_ptr2char(p);</td></tr>
<tr class="codeline" data-linenumber="2320"><td class="num" id="LN2320">2320</td><td class="line">	    l = (*mb_ptr2len)(p);</td></tr>
<tr class="codeline" data-linenumber="2321"><td class="num" id="LN2321">2321</td><td class="line">	    <span class='keyword'>if</span> (c &lt; 256 &amp;&amp; l &lt;= 2)</td></tr>
<tr class="codeline" data-linenumber="2322"><td class="num" id="LN2322">2322</td><td class="line">		wp-&gt;w_s-&gt;b_spell_ismw[c] = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2323"><td class="num" id="LN2323">2323</td><td class="line">	    <span class='keyword'>else</span> <span class='keyword'>if</span> (wp-&gt;w_s-&gt;b_spell_ismw_mb == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2324"><td class="num" id="LN2324">2324</td><td class="line">		<span class='comment'>// First multi-byte char in "b_spell_ismw_mb".</span></td></tr>
<tr class="codeline" data-linenumber="2325"><td class="num" id="LN2325">2325</td><td class="line">		wp-&gt;w_s-&gt;b_spell_ismw_mb = vim_strnsave(p, l);</td></tr>
<tr class="codeline" data-linenumber="2326"><td class="num" id="LN2326">2326</td><td class="line">	    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2327"><td class="num" id="LN2327">2327</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="2328"><td class="num" id="LN2328">2328</td><td class="line">		<span class='comment'>// Append multi-byte chars to "b_spell_ismw_mb".</span></td></tr>
<tr class="codeline" data-linenumber="2329"><td class="num" id="LN2329">2329</td><td class="line">		n = (<span class='keyword'>int</span>)<span class='macro'>STRLEN(wp-&gt;w_s-&gt;b_spell_ismw_mb)<span class='macro_popup'>strlen((char *)(wp-&gt;w_s-&gt;b_spell_ismw_mb))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2330"><td class="num" id="LN2330">2330</td><td class="line">		bp = vim_strnsave(wp-&gt;w_s-&gt;b_spell_ismw_mb, n + l);</td></tr>
<tr class="codeline" data-linenumber="2331"><td class="num" id="LN2331">2331</td><td class="line">		<span class='keyword'>if</span> (bp != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2332"><td class="num" id="LN2332">2332</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="2333"><td class="num" id="LN2333">2333</td><td class="line">		    vim_free(wp-&gt;w_s-&gt;b_spell_ismw_mb);</td></tr>
<tr class="codeline" data-linenumber="2334"><td class="num" id="LN2334">2334</td><td class="line">		    wp-&gt;w_s-&gt;b_spell_ismw_mb = bp;</td></tr>
<tr class="codeline" data-linenumber="2335"><td class="num" id="LN2335">2335</td><td class="line">		    vim_strncpy(bp + n, p, l);</td></tr>
<tr class="codeline" data-linenumber="2336"><td class="num" id="LN2336">2336</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="2337"><td class="num" id="LN2337">2337</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="2338"><td class="num" id="LN2338">2338</td><td class="line">	    p += l;</td></tr>
<tr class="codeline" data-linenumber="2339"><td class="num" id="LN2339">2339</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="2340"><td class="num" id="LN2340">2340</td><td class="line">	<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2341"><td class="num" id="LN2341">2341</td><td class="line">	    wp-&gt;w_s-&gt;b_spell_ismw[*p++] = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2342"><td class="num" id="LN2342">2342</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="2343"><td class="num" id="LN2343">2343</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2344"><td class="num" id="LN2344">2344</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="2345"><td class="num" id="LN2345">2345</td><td class="line"> <span class='comment'>* Find the region "region[2]" in "rp" (points to "sl_regions").</span></td></tr>
<tr class="codeline" data-linenumber="2346"><td class="num" id="LN2346">2346</td><td class="line"> <span class='comment'>* Each region is simply stored as the two characters of its name.</span></td></tr>
<tr class="codeline" data-linenumber="2347"><td class="num" id="LN2347">2347</td><td class="line"> <span class='comment'>* Returns the index if found (first is 0), REGION_ALL if not found.</span></td></tr>
<tr class="codeline" data-linenumber="2348"><td class="num" id="LN2348">2348</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="2349"><td class="num" id="LN2349">2349</td><td class="line">    <span class='keyword'>static</span> <span class='keyword'>int</span></td></tr>
<tr class="codeline" data-linenumber="2350"><td class="num" id="LN2350">2350</td><td class="line">find_region(char_u *rp, char_u *region)</td></tr>
<tr class="codeline" data-linenumber="2351"><td class="num" id="LN2351">2351</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="2352"><td class="num" id="LN2352">2352</td><td class="line">    <span class='keyword'>int</span>		i;</td></tr>
<tr class="codeline" data-linenumber="2353"><td class="num" id="LN2353">2353</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2354"><td class="num" id="LN2354">2354</td><td class="line">    <span class='keyword'>for</span> (i = 0; ; i += 2)</td></tr>
<tr class="codeline" data-linenumber="2355"><td class="num" id="LN2355">2355</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2356"><td class="num" id="LN2356">2356</td><td class="line">	<span class='keyword'>if</span> (rp[i] == <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2357"><td class="num" id="LN2357">2357</td><td class="line">	    <span class='keyword'>return</span> <span class='macro'>REGION_ALL<span class='macro_popup'>0xff</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2358"><td class="num" id="LN2358">2358</td><td class="line">	<span class='keyword'>if</span> (rp[i] == region[0] &amp;&amp; rp[i + 1] == region[1])</td></tr>
<tr class="codeline" data-linenumber="2359"><td class="num" id="LN2359">2359</td><td class="line">	    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="2360"><td class="num" id="LN2360">2360</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="2361"><td class="num" id="LN2361">2361</td><td class="line">    <span class='keyword'>return</span> i / 2;</td></tr>
<tr class="codeline" data-linenumber="2362"><td class="num" id="LN2362">2362</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="2363"><td class="num" id="LN2363">2363</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2364"><td class="num" id="LN2364">2364</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="2365"><td class="num" id="LN2365">2365</td><td class="line"> <span class='comment'>* Return case type of word:</span></td></tr>
<tr class="codeline" data-linenumber="2366"><td class="num" id="LN2366">2366</td><td class="line"> <span class='comment'>* w word	0</span></td></tr>
<tr class="codeline" data-linenumber="2367"><td class="num" id="LN2367">2367</td><td class="line"> <span class='comment'>* Word		WF_ONECAP</span></td></tr>
<tr class="codeline" data-linenumber="2368"><td class="num" id="LN2368">2368</td><td class="line"> <span class='comment'>* W WORD	WF_ALLCAP</span></td></tr>
<tr class="codeline" data-linenumber="2369"><td class="num" id="LN2369">2369</td><td class="line"> <span class='comment'>* WoRd	wOrd	WF_KEEPCAP</span></td></tr>
<tr class="codeline" data-linenumber="2370"><td class="num" id="LN2370">2370</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="2371"><td class="num" id="LN2371">2371</td><td class="line">    <span class='keyword'>int</span></td></tr>
<tr class="codeline" data-linenumber="2372"><td class="num" id="LN2372">2372</td><td class="line">captype(</td></tr>
<tr class="codeline" data-linenumber="2373"><td class="num" id="LN2373">2373</td><td class="line">    char_u	*word,</td></tr>
<tr class="codeline" data-linenumber="2374"><td class="num" id="LN2374">2374</td><td class="line">    char_u	*end)	    <span class='comment'>// When NULL use up to NUL byte.</span></td></tr>
<tr class="codeline" data-linenumber="2375"><td class="num" id="LN2375">2375</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="2376"><td class="num" id="LN2376">2376</td><td class="line">    char_u	*p;</td></tr>
<tr class="codeline" data-linenumber="2377"><td class="num" id="LN2377">2377</td><td class="line">    <span class='keyword'>int</span>		c;</td></tr>
<tr class="codeline" data-linenumber="2378"><td class="num" id="LN2378">2378</td><td class="line">    <span class='keyword'>int</span>		firstcap;</td></tr>
<tr class="codeline" data-linenumber="2379"><td class="num" id="LN2379">2379</td><td class="line">    <span class='keyword'>int</span>		allcap;</td></tr>
<tr class="codeline" data-linenumber="2380"><td class="num" id="LN2380">2380</td><td class="line">    <span class='keyword'>int</span>		past_second = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;	<span class='comment'>// past second word char</span></td></tr>
<tr class="codeline" data-linenumber="2381"><td class="num" id="LN2381">2381</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2382"><td class="num" id="LN2382">2382</td><td class="line">    <span class='comment'>// find first letter</span></td></tr>
<tr class="codeline" data-linenumber="2383"><td class="num" id="LN2383">2383</td><td class="line">    <span class='keyword'>for</span> (p = word; !spell_iswordp_nmw(p, curwin); <span class='macro'>MB_PTR_ADV(p)<span class='macro_popup'>p += (*mb_ptr2len)(p)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2384"><td class="num" id="LN2384">2384</td><td class="line">	<span class='keyword'>if</span> (end == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span> ? *p == <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span> : p &gt;= end)</td></tr>
<tr class="codeline" data-linenumber="2385"><td class="num" id="LN2385">2385</td><td class="line">	    <span class='keyword'>return</span> 0;	    <span class='comment'>// only non-word characters, illegal word</span></td></tr>
<tr class="codeline" data-linenumber="2386"><td class="num" id="LN2386">2386</td><td class="line">    <span class='keyword'>if</span> (has_mbyte)</td></tr>
<tr class="codeline" data-linenumber="2387"><td class="num" id="LN2387">2387</td><td class="line">	c = mb_ptr2char_adv(&amp;p);</td></tr>
<tr class="codeline" data-linenumber="2388"><td class="num" id="LN2388">2388</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2389"><td class="num" id="LN2389">2389</td><td class="line">	c = *p++;</td></tr>
<tr class="codeline" data-linenumber="2390"><td class="num" id="LN2390">2390</td><td class="line">    firstcap = allcap = <span class='macro'>SPELL_ISUPPER(c)<span class='macro_popup'>(enc_utf8 &amp;&amp; (c) &gt;= 128 ? utf_isupper(c) : (c) &lt;<br> 256 ? spelltab.st_isu[c] : iswupper(c))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2391"><td class="num" id="LN2391">2391</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2392"><td class="num" id="LN2392">2392</td><td class="line">    <span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="2393"><td class="num" id="LN2393">2393</td><td class="line">     <span class='comment'>* Need to check all letters to find a word with mixed upper/lower.</span></td></tr>
<tr class="codeline" data-linenumber="2394"><td class="num" id="LN2394">2394</td><td class="line">     <span class='comment'>* But a word with an upper char only at start is a ONECAP.</span></td></tr>
<tr class="codeline" data-linenumber="2395"><td class="num" id="LN2395">2395</td><td class="line">     <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="2396"><td class="num" id="LN2396">2396</td><td class="line">    <span class='keyword'>for</span> ( ; end == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span> ? *p != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span> : p &lt; end; <span class='macro'>MB_PTR_ADV(p)<span class='macro_popup'>p += (*mb_ptr2len)(p)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2397"><td class="num" id="LN2397">2397</td><td class="line">	<span class='keyword'>if</span> (spell_iswordp_nmw(p, curwin))</td></tr>
<tr class="codeline" data-linenumber="2398"><td class="num" id="LN2398">2398</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="2399"><td class="num" id="LN2399">2399</td><td class="line">	    c = <span class='macro'>PTR2CHAR(p)<span class='macro_popup'>(has_mbyte ? mb_ptr2char(p) : (int)*(p))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2400"><td class="num" id="LN2400">2400</td><td class="line">	    <span class='keyword'>if</span> (!<span class='macro'>SPELL_ISUPPER(c)<span class='macro_popup'>(enc_utf8 &amp;&amp; (c) &gt;= 128 ? utf_isupper(c) : (c) &lt;<br> 256 ? spelltab.st_isu[c] : iswupper(c))</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2401"><td class="num" id="LN2401">2401</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="2402"><td class="num" id="LN2402">2402</td><td class="line">		<span class='comment'>// UUl -&gt; KEEPCAP</span></td></tr>
<tr class="codeline" data-linenumber="2403"><td class="num" id="LN2403">2403</td><td class="line">		<span class='keyword'>if</span> (past_second &amp;&amp; allcap)</td></tr>
<tr class="codeline" data-linenumber="2404"><td class="num" id="LN2404">2404</td><td class="line">		    <span class='keyword'>return</span> <span class='macro'>WF_KEEPCAP<span class='macro_popup'>0x80</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2405"><td class="num" id="LN2405">2405</td><td class="line">		allcap = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2406"><td class="num" id="LN2406">2406</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="2407"><td class="num" id="LN2407">2407</td><td class="line">	    <span class='keyword'>else</span> <span class='keyword'>if</span> (!allcap)</td></tr>
<tr class="codeline" data-linenumber="2408"><td class="num" id="LN2408">2408</td><td class="line">		<span class='comment'>// UlU -&gt; KEEPCAP</span></td></tr>
<tr class="codeline" data-linenumber="2409"><td class="num" id="LN2409">2409</td><td class="line">		<span class='keyword'>return</span> <span class='macro'>WF_KEEPCAP<span class='macro_popup'>0x80</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2410"><td class="num" id="LN2410">2410</td><td class="line">	    past_second = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2411"><td class="num" id="LN2411">2411</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="2412"><td class="num" id="LN2412">2412</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2413"><td class="num" id="LN2413">2413</td><td class="line">    <span class='keyword'>if</span> (allcap)</td></tr>
<tr class="codeline" data-linenumber="2414"><td class="num" id="LN2414">2414</td><td class="line">	<span class='keyword'>return</span> <span class='macro'>WF_ALLCAP<span class='macro_popup'>0x04</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2415"><td class="num" id="LN2415">2415</td><td class="line">    <span class='keyword'>if</span> (firstcap)</td></tr>
<tr class="codeline" data-linenumber="2416"><td class="num" id="LN2416">2416</td><td class="line">	<span class='keyword'>return</span> <span class='macro'>WF_ONECAP<span class='macro_popup'>0x02</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2417"><td class="num" id="LN2417">2417</td><td class="line">    <span class='keyword'>return</span> 0;</td></tr>
<tr class="codeline" data-linenumber="2418"><td class="num" id="LN2418">2418</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="2419"><td class="num" id="LN2419">2419</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2420"><td class="num" id="LN2420">2420</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="2421"><td class="num" id="LN2421">2421</td><td class="line"> <span class='comment'>* Delete the internal wordlist and its .spl file.</span></td></tr>
<tr class="codeline" data-linenumber="2422"><td class="num" id="LN2422">2422</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="2423"><td class="num" id="LN2423">2423</td><td class="line">    <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="2424"><td class="num" id="LN2424">2424</td><td class="line">spell_delete_wordlist(<span class='keyword'>void</span>)</td></tr>
<tr class="codeline" data-linenumber="2425"><td class="num" id="LN2425">2425</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="2426"><td class="num" id="LN2426">2426</td><td class="line">    char_u	fname[<span class='macro'>MAXPATHL<span class='macro_popup'>4096</span></span>];</td></tr>
<tr class="codeline" data-linenumber="2427"><td class="num" id="LN2427">2427</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2428"><td class="num" id="LN2428">2428</td><td class="line">    <span class='keyword'>if</span> (int_wordlist != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2429"><td class="num" id="LN2429">2429</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2430"><td class="num" id="LN2430">2430</td><td class="line">	<span class='macro'>mch_remove(int_wordlist)<span class='macro_popup'>unlink((char *)(int_wordlist))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2431"><td class="num" id="LN2431">2431</td><td class="line">	int_wordlist_spl(fname);</td></tr>
<tr class="codeline" data-linenumber="2432"><td class="num" id="LN2432">2432</td><td class="line">	<span class='macro'>mch_remove(fname)<span class='macro_popup'>unlink((char *)(fname))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2433"><td class="num" id="LN2433">2433</td><td class="line">	<span class='macro'>VIM_CLEAR(int_wordlist)<span class='macro_popup'>do { if ((int_wordlist) != ((void*)0)) { vim_free(int_wordlist<br>); (int_wordlist) = ((void*)0); } } while (0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2434"><td class="num" id="LN2434">2434</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="2435"><td class="num" id="LN2435">2435</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="2436"><td class="num" id="LN2436">2436</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2437"><td class="num" id="LN2437">2437</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="2438"><td class="num" id="LN2438">2438</td><td class="line"> <span class='comment'>* Free all languages.</span></td></tr>
<tr class="codeline" data-linenumber="2439"><td class="num" id="LN2439">2439</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="2440"><td class="num" id="LN2440">2440</td><td class="line">    <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="2441"><td class="num" id="LN2441">2441</td><td class="line">spell_free_all(<span class='keyword'>void</span>)</td></tr>
<tr class="codeline" data-linenumber="2442"><td class="num" id="LN2442">2442</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="2443"><td class="num" id="LN2443">2443</td><td class="line">    slang_T	*slang;</td></tr>
<tr class="codeline" data-linenumber="2444"><td class="num" id="LN2444">2444</td><td class="line">    buf_T	*buf;</td></tr>
<tr class="codeline" data-linenumber="2445"><td class="num" id="LN2445">2445</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2446"><td class="num" id="LN2446">2446</td><td class="line">    <span class='comment'>// Go through all buffers and handle 'spelllang'. &lt;VN&gt;</span></td></tr>
<tr class="codeline" data-linenumber="2447"><td class="num" id="LN2447">2447</td><td class="line">    <span class='macro'>FOR_ALL_BUFFERS(buf)<span class='macro_popup'>for ((buf) = firstbuf; (buf) != ((void*)0); (buf) = (buf)-&gt;<br>b_next)</span></span></td></tr>
<tr class="codeline" data-linenumber="2448"><td class="num" id="LN2448">2448</td><td class="line">	ga_clear(&amp;buf-&gt;b_s.b_langp);</td></tr>
<tr class="codeline" data-linenumber="2449"><td class="num" id="LN2449">2449</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2450"><td class="num" id="LN2450">2450</td><td class="line">    <span class='keyword'>while</span> (first_lang != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2451"><td class="num" id="LN2451">2451</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2452"><td class="num" id="LN2452">2452</td><td class="line">	slang = first_lang;</td></tr>
<tr class="codeline" data-linenumber="2453"><td class="num" id="LN2453">2453</td><td class="line">	first_lang = slang-&gt;sl_next;</td></tr>
<tr class="codeline" data-linenumber="2454"><td class="num" id="LN2454">2454</td><td class="line">	slang_free(slang);</td></tr>
<tr class="codeline" data-linenumber="2455"><td class="num" id="LN2455">2455</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="2456"><td class="num" id="LN2456">2456</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2457"><td class="num" id="LN2457">2457</td><td class="line">    spell_delete_wordlist();</td></tr>
<tr class="codeline" data-linenumber="2458"><td class="num" id="LN2458">2458</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2459"><td class="num" id="LN2459">2459</td><td class="line">    <span class='macro'>VIM_CLEAR(repl_to)<span class='macro_popup'>do { if ((repl_to) != ((void*)0)) { vim_free(repl_to); (repl_to<br>) = ((void*)0); } } while (0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2460"><td class="num" id="LN2460">2460</td><td class="line">    <span class='macro'>VIM_CLEAR(repl_from)<span class='macro_popup'>do { if ((repl_from) != ((void*)0)) { vim_free(repl_from); (repl_from<br>) = ((void*)0); } } while (0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2461"><td class="num" id="LN2461">2461</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="2462"><td class="num" id="LN2462">2462</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2463"><td class="num" id="LN2463">2463</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="2464"><td class="num" id="LN2464">2464</td><td class="line"> <span class='comment'>* Clear all spelling tables and reload them.</span></td></tr>
<tr class="codeline" data-linenumber="2465"><td class="num" id="LN2465">2465</td><td class="line"> <span class='comment'>* Used after 'encoding' is set and when ":mkspell" was used.</span></td></tr>
<tr class="codeline" data-linenumber="2466"><td class="num" id="LN2466">2466</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="2467"><td class="num" id="LN2467">2467</td><td class="line">    <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="2468"><td class="num" id="LN2468">2468</td><td class="line">spell_reload(<span class='keyword'>void</span>)</td></tr>
<tr class="codeline" data-linenumber="2469"><td class="num" id="LN2469">2469</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="2470"><td class="num" id="LN2470">2470</td><td class="line">    win_T	*wp;</td></tr>
<tr class="codeline" data-linenumber="2471"><td class="num" id="LN2471">2471</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2472"><td class="num" id="LN2472">2472</td><td class="line">    <span class='comment'>// Initialize the table for spell_iswordp().</span></td></tr>
<tr class="codeline" data-linenumber="2473"><td class="num" id="LN2473">2473</td><td class="line">    init_spell_chartab();</td></tr>
<tr class="codeline" data-linenumber="2474"><td class="num" id="LN2474">2474</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2475"><td class="num" id="LN2475">2475</td><td class="line">    <span class='comment'>// Unload all allocated memory.</span></td></tr>
<tr class="codeline" data-linenumber="2476"><td class="num" id="LN2476">2476</td><td class="line">    spell_free_all();</td></tr>
<tr class="codeline" data-linenumber="2477"><td class="num" id="LN2477">2477</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2478"><td class="num" id="LN2478">2478</td><td class="line">    <span class='comment'>// Go through all buffers and handle 'spelllang'.</span></td></tr>
<tr class="codeline" data-linenumber="2479"><td class="num" id="LN2479">2479</td><td class="line">    <span class='macro'>FOR_ALL_WINDOWS(wp)<span class='macro_popup'>for (wp = firstwin; wp != ((void*)0); wp = wp-&gt;w_next)</span></span></td></tr>
<tr class="codeline" data-linenumber="2480"><td class="num" id="LN2480">2480</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2481"><td class="num" id="LN2481">2481</td><td class="line">	<span class='comment'>// Only load the wordlists when 'spelllang' is set and there is a</span></td></tr>
<tr class="codeline" data-linenumber="2482"><td class="num" id="LN2482">2482</td><td class="line">	<span class='comment'>// window for this buffer in which 'spell' is set.</span></td></tr>
<tr class="codeline" data-linenumber="2483"><td class="num" id="LN2483">2483</td><td class="line">	<span class='keyword'>if</span> (*wp-&gt;w_s-&gt;b_p_spl != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2484"><td class="num" id="LN2484">2484</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="2485"><td class="num" id="LN2485">2485</td><td class="line">		<span class='keyword'>if</span> (wp-&gt;<span class='macro'>w_p_spell<span class='macro_popup'>w_onebuf_opt.wo_spell</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2486"><td class="num" id="LN2486">2486</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="2487"><td class="num" id="LN2487">2487</td><td class="line">		    (<span class='keyword'>void</span>)did_set_spelllang(wp);</td></tr>
<tr class="codeline" data-linenumber="2488"><td class="num" id="LN2488">2488</td><td class="line">		    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="2489"><td class="num" id="LN2489">2489</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="2490"><td class="num" id="LN2490">2490</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="2491"><td class="num" id="LN2491">2491</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="2492"><td class="num" id="LN2492">2492</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="2493"><td class="num" id="LN2493">2493</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2494"><td class="num" id="LN2494">2494</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="2495"><td class="num" id="LN2495">2495</td><td class="line"> <span class='comment'>* Open a spell buffer.  This is a nameless buffer that is not in the buffer</span></td></tr>
<tr class="codeline" data-linenumber="2496"><td class="num" id="LN2496">2496</td><td class="line"> <span class='comment'>* list and only contains text lines.  Can use a swapfile to reduce memory</span></td></tr>
<tr class="codeline" data-linenumber="2497"><td class="num" id="LN2497">2497</td><td class="line"> <span class='comment'>* use.</span></td></tr>
<tr class="codeline" data-linenumber="2498"><td class="num" id="LN2498">2498</td><td class="line"> <span class='comment'>* Most other fields are invalid!  Esp. watch out for string options being</span></td></tr>
<tr class="codeline" data-linenumber="2499"><td class="num" id="LN2499">2499</td><td class="line"> <span class='comment'>* NULL and there is no undo info.</span></td></tr>
<tr class="codeline" data-linenumber="2500"><td class="num" id="LN2500">2500</td><td class="line"> <span class='comment'>* Returns NULL when out of memory.</span></td></tr>
<tr class="codeline" data-linenumber="2501"><td class="num" id="LN2501">2501</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="2502"><td class="num" id="LN2502">2502</td><td class="line">    buf_T *</td></tr>
<tr class="codeline" data-linenumber="2503"><td class="num" id="LN2503">2503</td><td class="line">open_spellbuf(<span class='keyword'>void</span>)</td></tr>
<tr class="codeline" data-linenumber="2504"><td class="num" id="LN2504">2504</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="2505"><td class="num" id="LN2505">2505</td><td class="line">    buf_T	*buf;</td></tr>
<tr class="codeline" data-linenumber="2506"><td class="num" id="LN2506">2506</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2507"><td class="num" id="LN2507">2507</td><td class="line">    buf = <span class='macro'>ALLOC_CLEAR_ONE(buf_T)<span class='macro_popup'>(buf_T *)alloc_clear(sizeof(buf_T))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2508"><td class="num" id="LN2508">2508</td><td class="line">    <span class='keyword'>if</span> (buf != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2509"><td class="num" id="LN2509">2509</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2510"><td class="num" id="LN2510">2510</td><td class="line">	buf-&gt;b_spell = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2511"><td class="num" id="LN2511">2511</td><td class="line">	buf-&gt;b_p_swf = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;	<span class='comment'>// may create a swap file</span></td></tr>
<tr class="codeline" data-linenumber="2512"><td class="num" id="LN2512">2512</td><td class="line"><span class='directive'>#ifdef FEAT_CRYPT</span></td></tr>
<tr class="codeline" data-linenumber="2513"><td class="num" id="LN2513">2513</td><td class="line">	buf-&gt;b_p_key = empty_option;</td></tr>
<tr class="codeline" data-linenumber="2514"><td class="num" id="LN2514">2514</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="2515"><td class="num" id="LN2515">2515</td><td class="line">	ml_open(buf);</td></tr>
<tr class="codeline" data-linenumber="2516"><td class="num" id="LN2516">2516</td><td class="line">	ml_open_file(buf);	<span class='comment'>// create swap file now</span></td></tr>
<tr class="codeline" data-linenumber="2517"><td class="num" id="LN2517">2517</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="2518"><td class="num" id="LN2518">2518</td><td class="line">    <span class='keyword'>return</span> buf;</td></tr>
<tr class="codeline" data-linenumber="2519"><td class="num" id="LN2519">2519</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="2520"><td class="num" id="LN2520">2520</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2521"><td class="num" id="LN2521">2521</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="2522"><td class="num" id="LN2522">2522</td><td class="line"> <span class='comment'>* Close the buffer used for spell info.</span></td></tr>
<tr class="codeline" data-linenumber="2523"><td class="num" id="LN2523">2523</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="2524"><td class="num" id="LN2524">2524</td><td class="line">    <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="2525"><td class="num" id="LN2525">2525</td><td class="line">close_spellbuf(buf_T *buf)</td></tr>
<tr class="codeline" data-linenumber="2526"><td class="num" id="LN2526">2526</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="2527"><td class="num" id="LN2527">2527</td><td class="line">    <span class='keyword'>if</span> (buf != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2528"><td class="num" id="LN2528">2528</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2529"><td class="num" id="LN2529">2529</td><td class="line">	ml_close(buf, <span class='macro'>TRUE<span class='macro_popup'>1</span></span>);</td></tr>
<tr class="codeline" data-linenumber="2530"><td class="num" id="LN2530">2530</td><td class="line">	vim_free(buf);</td></tr>
<tr class="codeline" data-linenumber="2531"><td class="num" id="LN2531">2531</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="2532"><td class="num" id="LN2532">2532</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="2533"><td class="num" id="LN2533">2533</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2534"><td class="num" id="LN2534">2534</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="2535"><td class="num" id="LN2535">2535</td><td class="line"> <span class='comment'>* Init the chartab used for spelling for ASCII.</span></td></tr>
<tr class="codeline" data-linenumber="2536"><td class="num" id="LN2536">2536</td><td class="line"> <span class='comment'>* EBCDIC is not supported!</span></td></tr>
<tr class="codeline" data-linenumber="2537"><td class="num" id="LN2537">2537</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="2538"><td class="num" id="LN2538">2538</td><td class="line">    <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="2539"><td class="num" id="LN2539">2539</td><td class="line">clear_spell_chartab(spelltab_T *sp)</td></tr>
<tr class="codeline" data-linenumber="2540"><td class="num" id="LN2540">2540</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="2541"><td class="num" id="LN2541">2541</td><td class="line">    <span class='keyword'>int</span>		i;</td></tr>
<tr class="codeline" data-linenumber="2542"><td class="num" id="LN2542">2542</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2543"><td class="num" id="LN2543">2543</td><td class="line">    <span class='comment'>// Init everything to FALSE (zero).</span></td></tr>
<tr class="codeline" data-linenumber="2544"><td class="num" id="LN2544">2544</td><td class="line">    <span class='macro'>CLEAR_FIELD(sp-&gt;st_isw)<span class='macro_popup'>memset((&amp;(sp-&gt;st_isw)), (0), (sizeof(sp-&gt;st_isw)))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2545"><td class="num" id="LN2545">2545</td><td class="line">    <span class='macro'>CLEAR_FIELD(sp-&gt;st_isu)<span class='macro_popup'>memset((&amp;(sp-&gt;st_isu)), (0), (sizeof(sp-&gt;st_isu)))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2546"><td class="num" id="LN2546">2546</td><td class="line">    <span class='keyword'>for</span> (i = 0; i &lt; 256; ++i)</td></tr>
<tr class="codeline" data-linenumber="2547"><td class="num" id="LN2547">2547</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2548"><td class="num" id="LN2548">2548</td><td class="line">	sp-&gt;st_fold[i] = i;</td></tr>
<tr class="codeline" data-linenumber="2549"><td class="num" id="LN2549">2549</td><td class="line">	sp-&gt;st_upper[i] = i;</td></tr>
<tr class="codeline" data-linenumber="2550"><td class="num" id="LN2550">2550</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="2551"><td class="num" id="LN2551">2551</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2552"><td class="num" id="LN2552">2552</td><td class="line">    <span class='comment'>// We include digits.  A word shouldn't start with a digit, but handling</span></td></tr>
<tr class="codeline" data-linenumber="2553"><td class="num" id="LN2553">2553</td><td class="line">    <span class='comment'>// that is done separately.</span></td></tr>
<tr class="codeline" data-linenumber="2554"><td class="num" id="LN2554">2554</td><td class="line">    <span class='keyword'>for</span> (i = '0'; i &lt;= '9'; ++i)</td></tr>
<tr class="codeline" data-linenumber="2555"><td class="num" id="LN2555">2555</td><td class="line">	sp-&gt;st_isw[i] = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2556"><td class="num" id="LN2556">2556</td><td class="line">    <span class='keyword'>for</span> (i = 'A'; i &lt;= 'Z'; ++i)</td></tr>
<tr class="codeline" data-linenumber="2557"><td class="num" id="LN2557">2557</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2558"><td class="num" id="LN2558">2558</td><td class="line">	sp-&gt;st_isw[i] = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2559"><td class="num" id="LN2559">2559</td><td class="line">	sp-&gt;st_isu[i] = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2560"><td class="num" id="LN2560">2560</td><td class="line">	sp-&gt;st_fold[i] = i + 0x20;</td></tr>
<tr class="codeline" data-linenumber="2561"><td class="num" id="LN2561">2561</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="2562"><td class="num" id="LN2562">2562</td><td class="line">    <span class='keyword'>for</span> (i = 'a'; i &lt;= 'z'; ++i)</td></tr>
<tr class="codeline" data-linenumber="2563"><td class="num" id="LN2563">2563</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2564"><td class="num" id="LN2564">2564</td><td class="line">	sp-&gt;st_isw[i] = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2565"><td class="num" id="LN2565">2565</td><td class="line">	sp-&gt;st_upper[i] = i - 0x20;</td></tr>
<tr class="codeline" data-linenumber="2566"><td class="num" id="LN2566">2566</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="2567"><td class="num" id="LN2567">2567</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="2568"><td class="num" id="LN2568">2568</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2569"><td class="num" id="LN2569">2569</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="2570"><td class="num" id="LN2570">2570</td><td class="line"> <span class='comment'>* Init the chartab used for spelling.  Only depends on 'encoding'.</span></td></tr>
<tr class="codeline" data-linenumber="2571"><td class="num" id="LN2571">2571</td><td class="line"> <span class='comment'>* Called once while starting up and when 'encoding' changes.</span></td></tr>
<tr class="codeline" data-linenumber="2572"><td class="num" id="LN2572">2572</td><td class="line"> <span class='comment'>* The default is to use isalpha(), but the spell file should define the word</span></td></tr>
<tr class="codeline" data-linenumber="2573"><td class="num" id="LN2573">2573</td><td class="line"> <span class='comment'>* characters to make it possible that 'encoding' differs from the current</span></td></tr>
<tr class="codeline" data-linenumber="2574"><td class="num" id="LN2574">2574</td><td class="line"> <span class='comment'>* locale.  For utf-8 we don't use isalpha() but our own functions.</span></td></tr>
<tr class="codeline" data-linenumber="2575"><td class="num" id="LN2575">2575</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="2576"><td class="num" id="LN2576">2576</td><td class="line">    <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="2577"><td class="num" id="LN2577">2577</td><td class="line">init_spell_chartab(<span class='keyword'>void</span>)</td></tr>
<tr class="codeline" data-linenumber="2578"><td class="num" id="LN2578">2578</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="2579"><td class="num" id="LN2579">2579</td><td class="line">    <span class='keyword'>int</span>	    i;</td></tr>
<tr class="codeline" data-linenumber="2580"><td class="num" id="LN2580">2580</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2581"><td class="num" id="LN2581">2581</td><td class="line">    did_set_spelltab = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2582"><td class="num" id="LN2582">2582</td><td class="line">    clear_spell_chartab(&amp;spelltab);</td></tr>
<tr class="codeline" data-linenumber="2583"><td class="num" id="LN2583">2583</td><td class="line">    <span class='keyword'>if</span> (enc_dbcs)</td></tr>
<tr class="codeline" data-linenumber="2584"><td class="num" id="LN2584">2584</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2585"><td class="num" id="LN2585">2585</td><td class="line">	<span class='comment'>// DBCS: assume double-wide characters are word characters.</span></td></tr>
<tr class="codeline" data-linenumber="2586"><td class="num" id="LN2586">2586</td><td class="line">	<span class='keyword'>for</span> (i = 128; i &lt;= 255; ++i)</td></tr>
<tr class="codeline" data-linenumber="2587"><td class="num" id="LN2587">2587</td><td class="line">	    <span class='keyword'>if</span> (<span class='macro'>MB_BYTE2LEN(i)<span class='macro_popup'>mb_bytelen_tab[i]</span></span> == 2)</td></tr>
<tr class="codeline" data-linenumber="2588"><td class="num" id="LN2588">2588</td><td class="line">		spelltab.st_isw[i] = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2589"><td class="num" id="LN2589">2589</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="2590"><td class="num" id="LN2590">2590</td><td class="line">    <span class='keyword'>else</span> <span class='keyword'>if</span> (enc_utf8)</td></tr>
<tr class="codeline" data-linenumber="2591"><td class="num" id="LN2591">2591</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2592"><td class="num" id="LN2592">2592</td><td class="line">	<span class='keyword'>for</span> (i = 128; i &lt; 256; ++i)</td></tr>
<tr class="codeline" data-linenumber="2593"><td class="num" id="LN2593">2593</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="2594"><td class="num" id="LN2594">2594</td><td class="line">	    <span class='keyword'>int</span> f = utf_fold(i);</td></tr>
<tr class="codeline" data-linenumber="2595"><td class="num" id="LN2595">2595</td><td class="line">	    <span class='keyword'>int</span> u = utf_toupper(i);</td></tr>
<tr class="codeline" data-linenumber="2596"><td class="num" id="LN2596">2596</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2597"><td class="num" id="LN2597">2597</td><td class="line">	    spelltab.st_isu[i] = utf_isupper(i);</td></tr>
<tr class="codeline" data-linenumber="2598"><td class="num" id="LN2598">2598</td><td class="line">	    spelltab.st_isw[i] = spelltab.st_isu[i] || utf_islower(i);</td></tr>
<tr class="codeline" data-linenumber="2599"><td class="num" id="LN2599">2599</td><td class="line">	    <span class='comment'>// The folded/upper-cased value is different between latin1 and</span></td></tr>
<tr class="codeline" data-linenumber="2600"><td class="num" id="LN2600">2600</td><td class="line">	    <span class='comment'>// utf8 for 0xb5, causing E763 for no good reason.  Use the latin1</span></td></tr>
<tr class="codeline" data-linenumber="2601"><td class="num" id="LN2601">2601</td><td class="line">	    <span class='comment'>// value for utf-8 to avoid this.</span></td></tr>
<tr class="codeline" data-linenumber="2602"><td class="num" id="LN2602">2602</td><td class="line">	    spelltab.st_fold[i] = (f &lt; 256) ? f : i;</td></tr>
<tr class="codeline" data-linenumber="2603"><td class="num" id="LN2603">2603</td><td class="line">	    spelltab.st_upper[i] = (u &lt; 256) ? u : i;</td></tr>
<tr class="codeline" data-linenumber="2604"><td class="num" id="LN2604">2604</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="2605"><td class="num" id="LN2605">2605</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="2606"><td class="num" id="LN2606">2606</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2607"><td class="num" id="LN2607">2607</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2608"><td class="num" id="LN2608">2608</td><td class="line">	<span class='comment'>// Rough guess: use locale-dependent library functions.</span></td></tr>
<tr class="codeline" data-linenumber="2609"><td class="num" id="LN2609">2609</td><td class="line">	<span class='keyword'>for</span> (i = 128; i &lt; 256; ++i)</td></tr>
<tr class="codeline" data-linenumber="2610"><td class="num" id="LN2610">2610</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="2611"><td class="num" id="LN2611">2611</td><td class="line">	    <span class='keyword'>if</span> (<span class='macro'>MB_ISUPPER(i)<span class='macro_popup'>vim_isupper(i)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2612"><td class="num" id="LN2612">2612</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="2613"><td class="num" id="LN2613">2613</td><td class="line">		spelltab.st_isw[i] = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2614"><td class="num" id="LN2614">2614</td><td class="line">		spelltab.st_isu[i] = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2615"><td class="num" id="LN2615">2615</td><td class="line">		spelltab.st_fold[i] = <span class='macro'>MB_TOLOWER(i)<span class='macro_popup'>vim_tolower(i)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2616"><td class="num" id="LN2616">2616</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="2617"><td class="num" id="LN2617">2617</td><td class="line">	    <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>MB_ISLOWER(i)<span class='macro_popup'>vim_islower(i)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2618"><td class="num" id="LN2618">2618</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="2619"><td class="num" id="LN2619">2619</td><td class="line">		spelltab.st_isw[i] = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2620"><td class="num" id="LN2620">2620</td><td class="line">		spelltab.st_upper[i] = <span class='macro'>MB_TOUPPER(i)<span class='macro_popup'>vim_toupper(i)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2621"><td class="num" id="LN2621">2621</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="2622"><td class="num" id="LN2622">2622</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="2623"><td class="num" id="LN2623">2623</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="2624"><td class="num" id="LN2624">2624</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="2625"><td class="num" id="LN2625">2625</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2626"><td class="num" id="LN2626">2626</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2627"><td class="num" id="LN2627">2627</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="2628"><td class="num" id="LN2628">2628</td><td class="line"> <span class='comment'>* Return TRUE if "p" points to a word character.</span></td></tr>
<tr class="codeline" data-linenumber="2629"><td class="num" id="LN2629">2629</td><td class="line"> <span class='comment'>* As a special case we see "midword" characters as word character when it is</span></td></tr>
<tr class="codeline" data-linenumber="2630"><td class="num" id="LN2630">2630</td><td class="line"> <span class='comment'>* followed by a word character.  This finds they'there but not 'they there'.</span></td></tr>
<tr class="codeline" data-linenumber="2631"><td class="num" id="LN2631">2631</td><td class="line"> <span class='comment'>* Thus this only works properly when past the first character of the word.</span></td></tr>
<tr class="codeline" data-linenumber="2632"><td class="num" id="LN2632">2632</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="2633"><td class="num" id="LN2633">2633</td><td class="line">    <span class='keyword'>int</span></td></tr>
<tr class="codeline" data-linenumber="2634"><td class="num" id="LN2634">2634</td><td class="line">spell_iswordp(</td></tr>
<tr class="codeline" data-linenumber="2635"><td class="num" id="LN2635">2635</td><td class="line">    char_u	*p,</td></tr>
<tr class="codeline" data-linenumber="2636"><td class="num" id="LN2636">2636</td><td class="line">    win_T	*wp)	    <span class='comment'>// buffer used</span></td></tr>
<tr class="codeline" data-linenumber="2637"><td class="num" id="LN2637">2637</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="2638"><td class="num" id="LN2638">2638</td><td class="line">    char_u	*s;</td></tr>
<tr class="codeline" data-linenumber="2639"><td class="num" id="LN2639">2639</td><td class="line">    <span class='keyword'>int</span>		l;</td></tr>
<tr class="codeline" data-linenumber="2640"><td class="num" id="LN2640">2640</td><td class="line">    <span class='keyword'>int</span>		c;</td></tr>
<tr class="codeline" data-linenumber="2641"><td class="num" id="LN2641">2641</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2642"><td class="num" id="LN2642">2642</td><td class="line">    <span class='keyword'>if</span> (has_mbyte)</td></tr>
<tr class="codeline" data-linenumber="2643"><td class="num" id="LN2643">2643</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2644"><td class="num" id="LN2644">2644</td><td class="line">	l = mb_ptr2len(p);</td></tr>
<tr class="codeline" data-linenumber="2645"><td class="num" id="LN2645">2645</td><td class="line">	s = p;</td></tr>
<tr class="codeline" data-linenumber="2646"><td class="num" id="LN2646">2646</td><td class="line">	<span class='keyword'>if</span> (l == 1)</td></tr>
<tr class="codeline" data-linenumber="2647"><td class="num" id="LN2647">2647</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="2648"><td class="num" id="LN2648">2648</td><td class="line">	    <span class='comment'>// be quick for ASCII</span></td></tr>
<tr class="codeline" data-linenumber="2649"><td class="num" id="LN2649">2649</td><td class="line">	    <span class='keyword'>if</span> (wp-&gt;w_s-&gt;b_spell_ismw[*p])</td></tr>
<tr class="codeline" data-linenumber="2650"><td class="num" id="LN2650">2650</td><td class="line">		s = p + 1;		<span class='comment'>// skip a mid-word character</span></td></tr>
<tr class="codeline" data-linenumber="2651"><td class="num" id="LN2651">2651</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="2652"><td class="num" id="LN2652">2652</td><td class="line">	<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2653"><td class="num" id="LN2653">2653</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="2654"><td class="num" id="LN2654">2654</td><td class="line">	    c = mb_ptr2char(p);</td></tr>
<tr class="codeline" data-linenumber="2655"><td class="num" id="LN2655">2655</td><td class="line">	    <span class='keyword'>if</span> (c &lt; 256 ? wp-&gt;w_s-&gt;b_spell_ismw[c]</td></tr>
<tr class="codeline" data-linenumber="2656"><td class="num" id="LN2656">2656</td><td class="line">		    : (wp-&gt;w_s-&gt;b_spell_ismw_mb != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span></td></tr>
<tr class="codeline" data-linenumber="2657"><td class="num" id="LN2657">2657</td><td class="line">			   &amp;&amp; vim_strchr(wp-&gt;w_s-&gt;b_spell_ismw_mb, c) != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>))</td></tr>
<tr class="codeline" data-linenumber="2658"><td class="num" id="LN2658">2658</td><td class="line">		s = p + l;</td></tr>
<tr class="codeline" data-linenumber="2659"><td class="num" id="LN2659">2659</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="2660"><td class="num" id="LN2660">2660</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2661"><td class="num" id="LN2661">2661</td><td class="line">	c = mb_ptr2char(s);</td></tr>
<tr class="codeline" data-linenumber="2662"><td class="num" id="LN2662">2662</td><td class="line">	<span class='keyword'>if</span> (c &gt; 255)</td></tr>
<tr class="codeline" data-linenumber="2663"><td class="num" id="LN2663">2663</td><td class="line">	    <span class='keyword'>return</span> spell_mb_isword_class(mb_get_class(s), wp);</td></tr>
<tr class="codeline" data-linenumber="2664"><td class="num" id="LN2664">2664</td><td class="line">	<span class='keyword'>return</span> spelltab.st_isw[c];</td></tr>
<tr class="codeline" data-linenumber="2665"><td class="num" id="LN2665">2665</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="2666"><td class="num" id="LN2666">2666</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2667"><td class="num" id="LN2667">2667</td><td class="line">    <span class='keyword'>return</span> spelltab.st_isw[wp-&gt;w_s-&gt;b_spell_ismw[*p] ? p[1] : p[0]];</td></tr>
<tr class="codeline" data-linenumber="2668"><td class="num" id="LN2668">2668</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="2669"><td class="num" id="LN2669">2669</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2670"><td class="num" id="LN2670">2670</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="2671"><td class="num" id="LN2671">2671</td><td class="line"> <span class='comment'>* Return TRUE if "p" points to a word character.</span></td></tr>
<tr class="codeline" data-linenumber="2672"><td class="num" id="LN2672">2672</td><td class="line"> <span class='comment'>* Unlike spell_iswordp() this doesn't check for "midword" characters.</span></td></tr>
<tr class="codeline" data-linenumber="2673"><td class="num" id="LN2673">2673</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="2674"><td class="num" id="LN2674">2674</td><td class="line">    <span class='keyword'>int</span></td></tr>
<tr class="codeline" data-linenumber="2675"><td class="num" id="LN2675">2675</td><td class="line">spell_iswordp_nmw(char_u *p, win_T *wp)</td></tr>
<tr class="codeline" data-linenumber="2676"><td class="num" id="LN2676">2676</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="2677"><td class="num" id="LN2677">2677</td><td class="line">    <span class='keyword'>int</span>		c;</td></tr>
<tr class="codeline" data-linenumber="2678"><td class="num" id="LN2678">2678</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2679"><td class="num" id="LN2679">2679</td><td class="line">    <span class='keyword'>if</span> (has_mbyte)</td></tr>
<tr class="codeline" data-linenumber="2680"><td class="num" id="LN2680">2680</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2681"><td class="num" id="LN2681">2681</td><td class="line">	c = mb_ptr2char(p);</td></tr>
<tr class="codeline" data-linenumber="2682"><td class="num" id="LN2682">2682</td><td class="line">	<span class='keyword'>if</span> (c &gt; 255)</td></tr>
<tr class="codeline" data-linenumber="2683"><td class="num" id="LN2683">2683</td><td class="line">	    <span class='keyword'>return</span> spell_mb_isword_class(mb_get_class(p), wp);</td></tr>
<tr class="codeline" data-linenumber="2684"><td class="num" id="LN2684">2684</td><td class="line">	<span class='keyword'>return</span> spelltab.st_isw[c];</td></tr>
<tr class="codeline" data-linenumber="2685"><td class="num" id="LN2685">2685</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="2686"><td class="num" id="LN2686">2686</td><td class="line">    <span class='keyword'>return</span> spelltab.st_isw[*p];</td></tr>
<tr class="codeline" data-linenumber="2687"><td class="num" id="LN2687">2687</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="2688"><td class="num" id="LN2688">2688</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2689"><td class="num" id="LN2689">2689</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="2690"><td class="num" id="LN2690">2690</td><td class="line"> <span class='comment'>* Return TRUE if word class indicates a word character.</span></td></tr>
<tr class="codeline" data-linenumber="2691"><td class="num" id="LN2691">2691</td><td class="line"> <span class='comment'>* Only for characters above 255.</span></td></tr>
<tr class="codeline" data-linenumber="2692"><td class="num" id="LN2692">2692</td><td class="line"> <span class='comment'>* Unicode subscript and superscript are not considered word characters.</span></td></tr>
<tr class="codeline" data-linenumber="2693"><td class="num" id="LN2693">2693</td><td class="line"> <span class='comment'>* See also dbcs_class() and utf_class() in mbyte.c.</span></td></tr>
<tr class="codeline" data-linenumber="2694"><td class="num" id="LN2694">2694</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="2695"><td class="num" id="LN2695">2695</td><td class="line">    <span class='keyword'>static</span> <span class='keyword'>int</span></td></tr>
<tr class="codeline" data-linenumber="2696"><td class="num" id="LN2696">2696</td><td class="line">spell_mb_isword_class(<span class='keyword'>int</span> cl, win_T *wp)</td></tr>
<tr class="codeline" data-linenumber="2697"><td class="num" id="LN2697">2697</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="2698"><td class="num" id="LN2698">2698</td><td class="line">    <span class='keyword'>if</span> (wp-&gt;w_s-&gt;b_cjk)</td></tr>
<tr class="codeline" data-linenumber="2699"><td class="num" id="LN2699">2699</td><td class="line">	<span class='comment'>// East Asian characters are not considered word characters.</span></td></tr>
<tr class="codeline" data-linenumber="2700"><td class="num" id="LN2700">2700</td><td class="line">	<span class='keyword'>return</span> cl == 2 || cl == 0x2800;</td></tr>
<tr class="codeline" data-linenumber="2701"><td class="num" id="LN2701">2701</td><td class="line">    <span class='keyword'>return</span> cl &gt;= 2 &amp;&amp; cl != 0x2070 &amp;&amp; cl != 0x2080 &amp;&amp; cl != 3;</td></tr>
<tr class="codeline" data-linenumber="2702"><td class="num" id="LN2702">2702</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="2703"><td class="num" id="LN2703">2703</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2704"><td class="num" id="LN2704">2704</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="2705"><td class="num" id="LN2705">2705</td><td class="line"> <span class='comment'>* Return TRUE if "p" points to a word character.</span></td></tr>
<tr class="codeline" data-linenumber="2706"><td class="num" id="LN2706">2706</td><td class="line"> <span class='comment'>* Wide version of spell_iswordp().</span></td></tr>
<tr class="codeline" data-linenumber="2707"><td class="num" id="LN2707">2707</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="2708"><td class="num" id="LN2708">2708</td><td class="line">    <span class='keyword'>static</span> <span class='keyword'>int</span></td></tr>
<tr class="codeline" data-linenumber="2709"><td class="num" id="LN2709">2709</td><td class="line">spell_iswordp_w(<span class='keyword'>int</span> *p, win_T *wp)</td></tr>
<tr class="codeline" data-linenumber="2710"><td class="num" id="LN2710">2710</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="2711"><td class="num" id="LN2711">2711</td><td class="line">    <span class='keyword'>int</span>		*s;</td></tr>
<tr class="codeline" data-linenumber="2712"><td class="num" id="LN2712">2712</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2713"><td class="num" id="LN2713">2713</td><td class="line">    <span class='keyword'>if</span> (*p &lt; 256 ? wp-&gt;w_s-&gt;b_spell_ismw[*p]</td></tr>
<tr class="codeline" data-linenumber="2714"><td class="num" id="LN2714">2714</td><td class="line">		 : (wp-&gt;w_s-&gt;b_spell_ismw_mb != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span></td></tr>
<tr class="codeline" data-linenumber="2715"><td class="num" id="LN2715">2715</td><td class="line">			     &amp;&amp; vim_strchr(wp-&gt;w_s-&gt;b_spell_ismw_mb, *p) != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>))</td></tr>
<tr class="codeline" data-linenumber="2716"><td class="num" id="LN2716">2716</td><td class="line">	s = p + 1;</td></tr>
<tr class="codeline" data-linenumber="2717"><td class="num" id="LN2717">2717</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2718"><td class="num" id="LN2718">2718</td><td class="line">	s = p;</td></tr>
<tr class="codeline" data-linenumber="2719"><td class="num" id="LN2719">2719</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2720"><td class="num" id="LN2720">2720</td><td class="line">    <span class='keyword'>if</span> (*s &gt; 255)</td></tr>
<tr class="codeline" data-linenumber="2721"><td class="num" id="LN2721">2721</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2722"><td class="num" id="LN2722">2722</td><td class="line">	<span class='keyword'>if</span> (enc_utf8)</td></tr>
<tr class="codeline" data-linenumber="2723"><td class="num" id="LN2723">2723</td><td class="line">	    <span class='keyword'>return</span> spell_mb_isword_class(utf_class(*s), wp);</td></tr>
<tr class="codeline" data-linenumber="2724"><td class="num" id="LN2724">2724</td><td class="line">	<span class='keyword'>if</span> (enc_dbcs)</td></tr>
<tr class="codeline" data-linenumber="2725"><td class="num" id="LN2725">2725</td><td class="line">	    <span class='keyword'>return</span> spell_mb_isword_class(</td></tr>
<tr class="codeline" data-linenumber="2726"><td class="num" id="LN2726">2726</td><td class="line">				dbcs_class((<span class='keyword'>unsigned</span>)*s &gt;&gt; 8, *s &amp; 0xff), wp);</td></tr>
<tr class="codeline" data-linenumber="2727"><td class="num" id="LN2727">2727</td><td class="line">	<span class='keyword'>return</span> 0;</td></tr>
<tr class="codeline" data-linenumber="2728"><td class="num" id="LN2728">2728</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="2729"><td class="num" id="LN2729">2729</td><td class="line">    <span class='keyword'>return</span> spelltab.st_isw[*s];</td></tr>
<tr class="codeline" data-linenumber="2730"><td class="num" id="LN2730">2730</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="2731"><td class="num" id="LN2731">2731</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2732"><td class="num" id="LN2732">2732</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="2733"><td class="num" id="LN2733">2733</td><td class="line"> <span class='comment'>* Case-fold "str[len]" into "buf[buflen]".  The result is NUL terminated.</span></td></tr>
<tr class="codeline" data-linenumber="2734"><td class="num" id="LN2734">2734</td><td class="line"> <span class='comment'>* Uses the character definitions from the .spl file.</span></td></tr>
<tr class="codeline" data-linenumber="2735"><td class="num" id="LN2735">2735</td><td class="line"> <span class='comment'>* When using a multi-byte 'encoding' the length may change!</span></td></tr>
<tr class="codeline" data-linenumber="2736"><td class="num" id="LN2736">2736</td><td class="line"> <span class='comment'>* Returns FAIL when something wrong.</span></td></tr>
<tr class="codeline" data-linenumber="2737"><td class="num" id="LN2737">2737</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="2738"><td class="num" id="LN2738">2738</td><td class="line">    <span class='keyword'>int</span></td></tr>
<tr class="codeline" data-linenumber="2739"><td class="num" id="LN2739">2739</td><td class="line">spell_casefold(</td></tr>
<tr class="codeline" data-linenumber="2740"><td class="num" id="LN2740">2740</td><td class="line">    char_u	*str,</td></tr>
<tr class="codeline" data-linenumber="2741"><td class="num" id="LN2741">2741</td><td class="line">    <span class='keyword'>int</span>		len,</td></tr>
<tr class="codeline" data-linenumber="2742"><td class="num" id="LN2742">2742</td><td class="line">    char_u	*buf,</td></tr>
<tr class="codeline" data-linenumber="2743"><td class="num" id="LN2743">2743</td><td class="line">    <span class='keyword'>int</span>		buflen)</td></tr>
<tr class="codeline" data-linenumber="2744"><td class="num" id="LN2744">2744</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="2745"><td class="num" id="LN2745">2745</td><td class="line">    <span class='keyword'>int</span>		i;</td></tr>
<tr class="codeline" data-linenumber="2746"><td class="num" id="LN2746">2746</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2747"><td class="num" id="LN2747">2747</td><td class="line">    <span class='keyword'>if</span> (len &gt;= buflen)</td></tr>
<tr class="codeline" data-linenumber="2748"><td class="num" id="LN2748">2748</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2749"><td class="num" id="LN2749">2749</td><td class="line">	buf[0] = <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2750"><td class="num" id="LN2750">2750</td><td class="line">	<span class='keyword'>return</span> <span class='macro'>FAIL<span class='macro_popup'>0</span></span>;		<span class='comment'>// result will not fit</span></td></tr>
<tr class="codeline" data-linenumber="2751"><td class="num" id="LN2751">2751</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="2752"><td class="num" id="LN2752">2752</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2753"><td class="num" id="LN2753">2753</td><td class="line">    <span class='keyword'>if</span> (has_mbyte)</td></tr>
<tr class="codeline" data-linenumber="2754"><td class="num" id="LN2754">2754</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2755"><td class="num" id="LN2755">2755</td><td class="line">	<span class='keyword'>int</span>	outi = 0;</td></tr>
<tr class="codeline" data-linenumber="2756"><td class="num" id="LN2756">2756</td><td class="line">	char_u	*p;</td></tr>
<tr class="codeline" data-linenumber="2757"><td class="num" id="LN2757">2757</td><td class="line">	<span class='keyword'>int</span>	c;</td></tr>
<tr class="codeline" data-linenumber="2758"><td class="num" id="LN2758">2758</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2759"><td class="num" id="LN2759">2759</td><td class="line">	<span class='comment'>// Fold one character at a time.</span></td></tr>
<tr class="codeline" data-linenumber="2760"><td class="num" id="LN2760">2760</td><td class="line">	<span class='keyword'>for</span> (p = str; p &lt; str + len; )</td></tr>
<tr class="codeline" data-linenumber="2761"><td class="num" id="LN2761">2761</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="2762"><td class="num" id="LN2762">2762</td><td class="line">	    <span class='keyword'>if</span> (outi + <span class='macro'>MB_MAXBYTES<span class='macro_popup'>21</span></span> &gt; buflen)</td></tr>
<tr class="codeline" data-linenumber="2763"><td class="num" id="LN2763">2763</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="2764"><td class="num" id="LN2764">2764</td><td class="line">		buf[outi] = <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2765"><td class="num" id="LN2765">2765</td><td class="line">		<span class='keyword'>return</span> <span class='macro'>FAIL<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2766"><td class="num" id="LN2766">2766</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="2767"><td class="num" id="LN2767">2767</td><td class="line">	    c = mb_cptr2char_adv(&amp;p);</td></tr>
<tr class="codeline" data-linenumber="2768"><td class="num" id="LN2768">2768</td><td class="line">	    outi += mb_char2bytes(<span class='macro'>SPELL_TOFOLD(c)<span class='macro_popup'>(enc_utf8 &amp;&amp; (c) &gt;= 128 ? utf_fold(c) : (c) &lt; 256<br> ? (int)spelltab.st_fold[c] : (int)towlower(c))</span></span>, buf + outi);</td></tr>
<tr class="codeline" data-linenumber="2769"><td class="num" id="LN2769">2769</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="2770"><td class="num" id="LN2770">2770</td><td class="line">	buf[outi] = <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2771"><td class="num" id="LN2771">2771</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="2772"><td class="num" id="LN2772">2772</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2773"><td class="num" id="LN2773">2773</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2774"><td class="num" id="LN2774">2774</td><td class="line">	<span class='comment'>// Be quick for non-multibyte encodings.</span></td></tr>
<tr class="codeline" data-linenumber="2775"><td class="num" id="LN2775">2775</td><td class="line">	<span class='keyword'>for</span> (i = 0; i &lt; len; ++i)</td></tr>
<tr class="codeline" data-linenumber="2776"><td class="num" id="LN2776">2776</td><td class="line">	    buf[i] = spelltab.st_fold[str[i]];</td></tr>
<tr class="codeline" data-linenumber="2777"><td class="num" id="LN2777">2777</td><td class="line">	buf[i] = <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2778"><td class="num" id="LN2778">2778</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="2779"><td class="num" id="LN2779">2779</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2780"><td class="num" id="LN2780">2780</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>OK<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2781"><td class="num" id="LN2781">2781</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="2782"><td class="num" id="LN2782">2782</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2783"><td class="num" id="LN2783">2783</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="2784"><td class="num" id="LN2784">2784</td><td class="line"> <span class='comment'>* Check if the word at line "lnum" column "col" is required to start with a</span></td></tr>
<tr class="codeline" data-linenumber="2785"><td class="num" id="LN2785">2785</td><td class="line"> <span class='comment'>* capital.  This uses 'spellcapcheck' of the current buffer.</span></td></tr>
<tr class="codeline" data-linenumber="2786"><td class="num" id="LN2786">2786</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="2787"><td class="num" id="LN2787">2787</td><td class="line">    <span class='keyword'>int</span></td></tr>
<tr class="codeline" data-linenumber="2788"><td class="num" id="LN2788">2788</td><td class="line">check_need_cap(linenr_T lnum, colnr_T col)</td></tr>
<tr class="codeline" data-linenumber="2789"><td class="num" id="LN2789">2789</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="2790"><td class="num" id="LN2790">2790</td><td class="line">    <span class='keyword'>int</span>		need_cap = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2791"><td class="num" id="LN2791">2791</td><td class="line">    char_u	*line;</td></tr>
<tr class="codeline" data-linenumber="2792"><td class="num" id="LN2792">2792</td><td class="line">    char_u	*line_copy = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2793"><td class="num" id="LN2793">2793</td><td class="line">    char_u	*p;</td></tr>
<tr class="codeline" data-linenumber="2794"><td class="num" id="LN2794">2794</td><td class="line">    colnr_T	endcol;</td></tr>
<tr class="codeline" data-linenumber="2795"><td class="num" id="LN2795">2795</td><td class="line">    regmatch_T	regmatch;</td></tr>
<tr class="codeline" data-linenumber="2796"><td class="num" id="LN2796">2796</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2797"><td class="num" id="LN2797">2797</td><td class="line">    <span class='keyword'>if</span> (curwin-&gt;w_s-&gt;b_cap_prog == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2798"><td class="num" id="LN2798">2798</td><td class="line">	<span class='keyword'>return</span> <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2799"><td class="num" id="LN2799">2799</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2800"><td class="num" id="LN2800">2800</td><td class="line">    line = ml_get_curline();</td></tr>
<tr class="codeline" data-linenumber="2801"><td class="num" id="LN2801">2801</td><td class="line">    endcol = 0;</td></tr>
<tr class="codeline" data-linenumber="2802"><td class="num" id="LN2802">2802</td><td class="line">    <span class='keyword'>if</span> (getwhitecols(line) &gt;= (<span class='keyword'>int</span>)col)</td></tr>
<tr class="codeline" data-linenumber="2803"><td class="num" id="LN2803">2803</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2804"><td class="num" id="LN2804">2804</td><td class="line">	<span class='comment'>// At start of line, check if previous line is empty or sentence</span></td></tr>
<tr class="codeline" data-linenumber="2805"><td class="num" id="LN2805">2805</td><td class="line">	<span class='comment'>// ends there.</span></td></tr>
<tr class="codeline" data-linenumber="2806"><td class="num" id="LN2806">2806</td><td class="line">	<span class='keyword'>if</span> (lnum == 1)</td></tr>
<tr class="codeline" data-linenumber="2807"><td class="num" id="LN2807">2807</td><td class="line">	    need_cap = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2808"><td class="num" id="LN2808">2808</td><td class="line">	<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2809"><td class="num" id="LN2809">2809</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="2810"><td class="num" id="LN2810">2810</td><td class="line">	    line = ml_get(lnum - 1);</td></tr>
<tr class="codeline" data-linenumber="2811"><td class="num" id="LN2811">2811</td><td class="line">	    <span class='keyword'>if</span> (*skipwhite(line) == <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2812"><td class="num" id="LN2812">2812</td><td class="line">		need_cap = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2813"><td class="num" id="LN2813">2813</td><td class="line">	    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2814"><td class="num" id="LN2814">2814</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="2815"><td class="num" id="LN2815">2815</td><td class="line">		<span class='comment'>// Append a space in place of the line break.</span></td></tr>
<tr class="codeline" data-linenumber="2816"><td class="num" id="LN2816">2816</td><td class="line">		line_copy = concat_str(line, (char_u *)<span class='string_literal'>" "</span>);</td></tr>
<tr class="codeline" data-linenumber="2817"><td class="num" id="LN2817">2817</td><td class="line">		line = line_copy;</td></tr>
<tr class="codeline" data-linenumber="2818"><td class="num" id="LN2818">2818</td><td class="line">		endcol = (colnr_T)<span class='macro'>STRLEN(line)<span class='macro_popup'>strlen((char *)(line))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2819"><td class="num" id="LN2819">2819</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="2820"><td class="num" id="LN2820">2820</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="2821"><td class="num" id="LN2821">2821</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="2822"><td class="num" id="LN2822">2822</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2823"><td class="num" id="LN2823">2823</td><td class="line">	endcol = col;</td></tr>
<tr class="codeline" data-linenumber="2824"><td class="num" id="LN2824">2824</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2825"><td class="num" id="LN2825">2825</td><td class="line">    <span class='keyword'>if</span> (endcol &gt; 0)</td></tr>
<tr class="codeline" data-linenumber="2826"><td class="num" id="LN2826">2826</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2827"><td class="num" id="LN2827">2827</td><td class="line">	<span class='comment'>// Check if sentence ends before the bad word.</span></td></tr>
<tr class="codeline" data-linenumber="2828"><td class="num" id="LN2828">2828</td><td class="line">	regmatch.regprog = curwin-&gt;w_s-&gt;b_cap_prog;</td></tr>
<tr class="codeline" data-linenumber="2829"><td class="num" id="LN2829">2829</td><td class="line">	regmatch.rm_ic = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2830"><td class="num" id="LN2830">2830</td><td class="line">	p = line + endcol;</td></tr>
<tr class="codeline" data-linenumber="2831"><td class="num" id="LN2831">2831</td><td class="line">	<span class='keyword'>for</span> (;;)</td></tr>
<tr class="codeline" data-linenumber="2832"><td class="num" id="LN2832">2832</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="2833"><td class="num" id="LN2833">2833</td><td class="line">	    <span class='macro'>MB_PTR_BACK(line, p)<span class='macro_popup'>p -= has_mbyte ? ((*mb_head_off)(line, p - 1) + 1) : 1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2834"><td class="num" id="LN2834">2834</td><td class="line">	    <span class='keyword'>if</span> (p == line || spell_iswordp_nmw(p, curwin))</td></tr>
<tr class="codeline" data-linenumber="2835"><td class="num" id="LN2835">2835</td><td class="line">		<span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="2836"><td class="num" id="LN2836">2836</td><td class="line">	    <span class='keyword'>if</span> (vim_regexec(&amp;regmatch, p, 0)</td></tr>
<tr class="codeline" data-linenumber="2837"><td class="num" id="LN2837">2837</td><td class="line">					 &amp;&amp; regmatch.endp[0] == line + endcol)</td></tr>
<tr class="codeline" data-linenumber="2838"><td class="num" id="LN2838">2838</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="2839"><td class="num" id="LN2839">2839</td><td class="line">		need_cap = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2840"><td class="num" id="LN2840">2840</td><td class="line">		<span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="2841"><td class="num" id="LN2841">2841</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="2842"><td class="num" id="LN2842">2842</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="2843"><td class="num" id="LN2843">2843</td><td class="line">	curwin-&gt;w_s-&gt;b_cap_prog = regmatch.regprog;</td></tr>
<tr class="codeline" data-linenumber="2844"><td class="num" id="LN2844">2844</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="2845"><td class="num" id="LN2845">2845</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2846"><td class="num" id="LN2846">2846</td><td class="line">    vim_free(line_copy);</td></tr>
<tr class="codeline" data-linenumber="2847"><td class="num" id="LN2847">2847</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2848"><td class="num" id="LN2848">2848</td><td class="line">    <span class='keyword'>return</span> need_cap;</td></tr>
<tr class="codeline" data-linenumber="2849"><td class="num" id="LN2849">2849</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="2850"><td class="num" id="LN2850">2850</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2851"><td class="num" id="LN2851">2851</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2852"><td class="num" id="LN2852">2852</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="2853"><td class="num" id="LN2853">2853</td><td class="line"> <span class='comment'>* ":spellrepall"</span></td></tr>
<tr class="codeline" data-linenumber="2854"><td class="num" id="LN2854">2854</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="2855"><td class="num" id="LN2855">2855</td><td class="line">    <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="2856"><td class="num" id="LN2856">2856</td><td class="line">ex_spellrepall(exarg_T *eap <span class='macro'>UNUSED<span class='macro_popup'>__attribute__((unused))</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2857"><td class="num" id="LN2857">2857</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="2858"><td class="num" id="LN2858">2858</td><td class="line">    pos_T	pos = curwin-&gt;w_cursor;</td></tr>
<tr class="codeline" data-linenumber="2859"><td class="num" id="LN2859">2859</td><td class="line">    char_u	*frompat;</td></tr>
<tr class="codeline" data-linenumber="2860"><td class="num" id="LN2860">2860</td><td class="line">    <span class='keyword'>int</span>		addlen;</td></tr>
<tr class="codeline" data-linenumber="2861"><td class="num" id="LN2861">2861</td><td class="line">    char_u	*line;</td></tr>
<tr class="codeline" data-linenumber="2862"><td class="num" id="LN2862">2862</td><td class="line">    char_u	*p;</td></tr>
<tr class="codeline" data-linenumber="2863"><td class="num" id="LN2863">2863</td><td class="line">    <span class='keyword'>int</span>		save_ws = p_ws;</td></tr>
<tr class="codeline" data-linenumber="2864"><td class="num" id="LN2864">2864</td><td class="line">    linenr_T	prev_lnum = 0;</td></tr>
<tr class="codeline" data-linenumber="2865"><td class="num" id="LN2865">2865</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2866"><td class="num" id="LN2866">2866</td><td class="line">    <span class='keyword'>if</span> (repl_from == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span> || repl_to == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2867"><td class="num" id="LN2867">2867</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2868"><td class="num" id="LN2868">2868</td><td class="line">	emsg(<span class='macro'>_(<span class='string_literal'>"E752: No previous spell replacement"</span>)<span class='macro_popup'>dcgettext (((void*)0), (char *)("E752: No previous spell replacement"<br>), 5)</span></span>);</td></tr>
<tr class="codeline" data-linenumber="2869"><td class="num" id="LN2869">2869</td><td class="line">	<span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="2870"><td class="num" id="LN2870">2870</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="2871"><td class="num" id="LN2871">2871</td><td class="line">    addlen = (<span class='keyword'>int</span>)(<span class='macro'>STRLEN(repl_to)<span class='macro_popup'>strlen((char *)(repl_to))</span></span> - <span class='macro'>STRLEN(repl_from)<span class='macro_popup'>strlen((char *)(repl_from))</span></span>);</td></tr>
<tr class="codeline" data-linenumber="2872"><td class="num" id="LN2872">2872</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2873"><td class="num" id="LN2873">2873</td><td class="line">    frompat = alloc(<span class='macro'>STRLEN(repl_from)<span class='macro_popup'>strlen((char *)(repl_from))</span></span> + 7);</td></tr>
<tr class="codeline" data-linenumber="2874"><td class="num" id="LN2874">2874</td><td class="line">    <span class='keyword'>if</span> (frompat == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2875"><td class="num" id="LN2875">2875</td><td class="line">	<span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="2876"><td class="num" id="LN2876">2876</td><td class="line">    <span class='macro'>sprintf((<span class='keyword'>char</span> *)frompat, <span class='string_literal'>"\\V\\&lt;%s\\&gt;"</span>, repl_from)<span class='macro_popup'>__builtin___sprintf_chk ((char *)frompat, 1 - 1, __builtin_object_size<br> ((char *)frompat, 1 &gt; 1), "\\V\\&lt;%s\\&gt;", repl_from)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2877"><td class="num" id="LN2877">2877</td><td class="line">    p_ws = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2878"><td class="num" id="LN2878">2878</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2879"><td class="num" id="LN2879">2879</td><td class="line">    sub_nsubs = 0;</td></tr>
<tr class="codeline" data-linenumber="2880"><td class="num" id="LN2880">2880</td><td class="line">    sub_nlines = 0;</td></tr>
<tr class="codeline" data-linenumber="2881"><td class="num" id="LN2881">2881</td><td class="line">    curwin-&gt;w_cursor.lnum = 0;</td></tr>
<tr class="codeline" data-linenumber="2882"><td class="num" id="LN2882">2882</td><td class="line">    <span class='keyword'>while</span> (!got_int)</td></tr>
<tr class="codeline" data-linenumber="2883"><td class="num" id="LN2883">2883</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2884"><td class="num" id="LN2884">2884</td><td class="line">	<span class='keyword'>if</span> (do_search(<span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>, '/', '/', frompat, 1L, <span class='macro'>SEARCH_KEEP<span class='macro_popup'>0x400</span></span>, <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>) == 0</td></tr>
<tr class="codeline" data-linenumber="2885"><td class="num" id="LN2885">2885</td><td class="line">						   || u_save_cursor() == <span class='macro'>FAIL<span class='macro_popup'>0</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2886"><td class="num" id="LN2886">2886</td><td class="line">	    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="2887"><td class="num" id="LN2887">2887</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2888"><td class="num" id="LN2888">2888</td><td class="line">	<span class='comment'>// Only replace when the right word isn't there yet.  This happens</span></td></tr>
<tr class="codeline" data-linenumber="2889"><td class="num" id="LN2889">2889</td><td class="line">	<span class='comment'>// when changing "etc" to "etc.".</span></td></tr>
<tr class="codeline" data-linenumber="2890"><td class="num" id="LN2890">2890</td><td class="line">	line = ml_get_curline();</td></tr>
<tr class="codeline" data-linenumber="2891"><td class="num" id="LN2891">2891</td><td class="line">	<span class='keyword'>if</span> (addlen &lt;= 0 || <span class='macro'>STRNCMP(line + curwin-&gt;w_cursor.col,<span class='macro_popup'>strncmp((char *)(line + curwin-&gt;w_cursor.col), (char *)(repl_to<br>), (size_t)(strlen((char *)(repl_to))))</span></span></td></tr>
<tr class="codeline" data-linenumber="2892"><td class="num" id="LN2892">2892</td><td class="line">					       <span class='macro'>repl_to, STRLEN(repl_to))<span class='macro_popup'>strncmp((char *)(line + curwin-&gt;w_cursor.col), (char *)(repl_to<br>), (size_t)(strlen((char *)(repl_to))))</span></span> != 0)</td></tr>
<tr class="codeline" data-linenumber="2893"><td class="num" id="LN2893">2893</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="2894"><td class="num" id="LN2894">2894</td><td class="line">	    p = alloc(<span class='macro'>STRLEN(line)<span class='macro_popup'>strlen((char *)(line))</span></span> + addlen + 1);</td></tr>
<tr class="codeline" data-linenumber="2895"><td class="num" id="LN2895">2895</td><td class="line">	    <span class='keyword'>if</span> (p == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2896"><td class="num" id="LN2896">2896</td><td class="line">		<span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="2897"><td class="num" id="LN2897">2897</td><td class="line">	    <span class='macro'>mch_memmove(p, line, curwin-&gt;w_cursor.col)<span class='macro_popup'>memmove((char *)(p), (char *)(line), curwin-&gt;w_cursor.col)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2898"><td class="num" id="LN2898">2898</td><td class="line">	    <span class='macro'>STRCPY(p + curwin-&gt;w_cursor.col, repl_to)<span class='macro_popup'>strcpy((char *)(p + curwin-&gt;w_cursor.col), (char *)(repl_to<br>))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2899"><td class="num" id="LN2899">2899</td><td class="line">	    <span class='macro'>STRCAT(p, line + curwin-&gt;w_cursor.col + STRLEN(repl_from))<span class='macro_popup'>strcat((char *)(p), (char *)(line + curwin-&gt;w_cursor.col +<br> strlen((char *)(repl_from))))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2900"><td class="num" id="LN2900">2900</td><td class="line">	    ml_replace(curwin-&gt;w_cursor.lnum, p, <span class='macro'>FALSE<span class='macro_popup'>0</span></span>);</td></tr>
<tr class="codeline" data-linenumber="2901"><td class="num" id="LN2901">2901</td><td class="line">	    changed_bytes(curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.col);</td></tr>
<tr class="codeline" data-linenumber="2902"><td class="num" id="LN2902">2902</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2903"><td class="num" id="LN2903">2903</td><td class="line">	    <span class='keyword'>if</span> (curwin-&gt;w_cursor.lnum != prev_lnum)</td></tr>
<tr class="codeline" data-linenumber="2904"><td class="num" id="LN2904">2904</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="2905"><td class="num" id="LN2905">2905</td><td class="line">		++sub_nlines;</td></tr>
<tr class="codeline" data-linenumber="2906"><td class="num" id="LN2906">2906</td><td class="line">		prev_lnum = curwin-&gt;w_cursor.lnum;</td></tr>
<tr class="codeline" data-linenumber="2907"><td class="num" id="LN2907">2907</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="2908"><td class="num" id="LN2908">2908</td><td class="line">	    ++sub_nsubs;</td></tr>
<tr class="codeline" data-linenumber="2909"><td class="num" id="LN2909">2909</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="2910"><td class="num" id="LN2910">2910</td><td class="line">	curwin-&gt;w_cursor.col += (colnr_T)<span class='macro'>STRLEN(repl_to)<span class='macro_popup'>strlen((char *)(repl_to))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2911"><td class="num" id="LN2911">2911</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="2912"><td class="num" id="LN2912">2912</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2913"><td class="num" id="LN2913">2913</td><td class="line">    p_ws = save_ws;</td></tr>
<tr class="codeline" data-linenumber="2914"><td class="num" id="LN2914">2914</td><td class="line">    curwin-&gt;w_cursor = pos;</td></tr>
<tr class="codeline" data-linenumber="2915"><td class="num" id="LN2915">2915</td><td class="line">    vim_free(frompat);</td></tr>
<tr class="codeline" data-linenumber="2916"><td class="num" id="LN2916">2916</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2917"><td class="num" id="LN2917">2917</td><td class="line">    <span class='keyword'>if</span> (sub_nsubs == 0)</td></tr>
<tr class="codeline" data-linenumber="2918"><td class="num" id="LN2918">2918</td><td class="line">	semsg(<span class='macro'>_(<span class='string_literal'>"E753: Not found: %s"</span>)<span class='macro_popup'>dcgettext (((void*)0), (char *)("E753: Not found: %s"), 5)</span></span>, repl_from);</td></tr>
<tr class="codeline" data-linenumber="2919"><td class="num" id="LN2919">2919</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2920"><td class="num" id="LN2920">2920</td><td class="line">	do_sub_msg(<span class='macro'>FALSE<span class='macro_popup'>0</span></span>);</td></tr>
<tr class="codeline" data-linenumber="2921"><td class="num" id="LN2921">2921</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="2922"><td class="num" id="LN2922">2922</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2923"><td class="num" id="LN2923">2923</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="2924"><td class="num" id="LN2924">2924</td><td class="line"> <span class='comment'>* Make a copy of "word", with the first letter upper or lower cased, to</span></td></tr>
<tr class="codeline" data-linenumber="2925"><td class="num" id="LN2925">2925</td><td class="line"> <span class='comment'>* "wcopy[MAXWLEN]".  "word" must not be empty.</span></td></tr>
<tr class="codeline" data-linenumber="2926"><td class="num" id="LN2926">2926</td><td class="line"> <span class='comment'>* The result is NUL terminated.</span></td></tr>
<tr class="codeline" data-linenumber="2927"><td class="num" id="LN2927">2927</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="2928"><td class="num" id="LN2928">2928</td><td class="line">    <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="2929"><td class="num" id="LN2929">2929</td><td class="line">onecap_copy(</td></tr>
<tr class="codeline" data-linenumber="2930"><td class="num" id="LN2930">2930</td><td class="line">    char_u	*word,</td></tr>
<tr class="codeline" data-linenumber="2931"><td class="num" id="LN2931">2931</td><td class="line">    char_u	*wcopy,</td></tr>
<tr class="codeline" data-linenumber="2932"><td class="num" id="LN2932">2932</td><td class="line">    <span class='keyword'>int</span>		upper)	    <span class='comment'>// TRUE: first letter made upper case</span></td></tr>
<tr class="codeline" data-linenumber="2933"><td class="num" id="LN2933">2933</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="2934"><td class="num" id="LN2934">2934</td><td class="line">    char_u	*p;</td></tr>
<tr class="codeline" data-linenumber="2935"><td class="num" id="LN2935">2935</td><td class="line">    <span class='keyword'>int</span>		c;</td></tr>
<tr class="codeline" data-linenumber="2936"><td class="num" id="LN2936">2936</td><td class="line">    <span class='keyword'>int</span>		l;</td></tr>
<tr class="codeline" data-linenumber="2937"><td class="num" id="LN2937">2937</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2938"><td class="num" id="LN2938">2938</td><td class="line">    p = word;</td></tr>
<tr class="codeline" data-linenumber="2939"><td class="num" id="LN2939">2939</td><td class="line">    <span class='keyword'>if</span> (has_mbyte)</td></tr>
<tr class="codeline" data-linenumber="2940"><td class="num" id="LN2940">2940</td><td class="line">	c = mb_cptr2char_adv(&amp;p);</td></tr>
<tr class="codeline" data-linenumber="2941"><td class="num" id="LN2941">2941</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2942"><td class="num" id="LN2942">2942</td><td class="line">	c = *p++;</td></tr>
<tr class="codeline" data-linenumber="2943"><td class="num" id="LN2943">2943</td><td class="line">    <span class='keyword'>if</span> (upper)</td></tr>
<tr class="codeline" data-linenumber="2944"><td class="num" id="LN2944">2944</td><td class="line">	c = <span class='macro'>SPELL_TOUPPER(c)<span class='macro_popup'>(enc_utf8 &amp;&amp; (c) &gt;= 128 ? utf_toupper(c) : (c) &lt;<br> 256 ? (int)spelltab.st_upper[c] : (int)towupper(c))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2945"><td class="num" id="LN2945">2945</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2946"><td class="num" id="LN2946">2946</td><td class="line">	c = <span class='macro'>SPELL_TOFOLD(c)<span class='macro_popup'>(enc_utf8 &amp;&amp; (c) &gt;= 128 ? utf_fold(c) : (c) &lt; 256<br> ? (int)spelltab.st_fold[c] : (int)towlower(c))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2947"><td class="num" id="LN2947">2947</td><td class="line">    <span class='keyword'>if</span> (has_mbyte)</td></tr>
<tr class="codeline" data-linenumber="2948"><td class="num" id="LN2948">2948</td><td class="line">	l = mb_char2bytes(c, wcopy);</td></tr>
<tr class="codeline" data-linenumber="2949"><td class="num" id="LN2949">2949</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2950"><td class="num" id="LN2950">2950</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2951"><td class="num" id="LN2951">2951</td><td class="line">	l = 1;</td></tr>
<tr class="codeline" data-linenumber="2952"><td class="num" id="LN2952">2952</td><td class="line">	wcopy[0] = c;</td></tr>
<tr class="codeline" data-linenumber="2953"><td class="num" id="LN2953">2953</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="2954"><td class="num" id="LN2954">2954</td><td class="line">    vim_strncpy(wcopy + l, p, <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span> - l - 1);</td></tr>
<tr class="codeline" data-linenumber="2955"><td class="num" id="LN2955">2955</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="2956"><td class="num" id="LN2956">2956</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2957"><td class="num" id="LN2957">2957</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="2958"><td class="num" id="LN2958">2958</td><td class="line"> <span class='comment'>* Make a copy of "word" with all the letters upper cased into</span></td></tr>
<tr class="codeline" data-linenumber="2959"><td class="num" id="LN2959">2959</td><td class="line"> <span class='comment'>* "wcopy[MAXWLEN]".  The result is NUL terminated.</span></td></tr>
<tr class="codeline" data-linenumber="2960"><td class="num" id="LN2960">2960</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="2961"><td class="num" id="LN2961">2961</td><td class="line">    <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="2962"><td class="num" id="LN2962">2962</td><td class="line">allcap_copy(char_u *word, char_u *wcopy)</td></tr>
<tr class="codeline" data-linenumber="2963"><td class="num" id="LN2963">2963</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="2964"><td class="num" id="LN2964">2964</td><td class="line">    char_u	*s;</td></tr>
<tr class="codeline" data-linenumber="2965"><td class="num" id="LN2965">2965</td><td class="line">    char_u	*d;</td></tr>
<tr class="codeline" data-linenumber="2966"><td class="num" id="LN2966">2966</td><td class="line">    <span class='keyword'>int</span>		c;</td></tr>
<tr class="codeline" data-linenumber="2967"><td class="num" id="LN2967">2967</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2968"><td class="num" id="LN2968">2968</td><td class="line">    d = wcopy;</td></tr>
<tr class="codeline" data-linenumber="2969"><td class="num" id="LN2969">2969</td><td class="line">    <span class='keyword'>for</span> (s = word; *s != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>; )</td></tr>
<tr class="codeline" data-linenumber="2970"><td class="num" id="LN2970">2970</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="2971"><td class="num" id="LN2971">2971</td><td class="line">	<span class='keyword'>if</span> (has_mbyte)</td></tr>
<tr class="codeline" data-linenumber="2972"><td class="num" id="LN2972">2972</td><td class="line">	    c = mb_cptr2char_adv(&amp;s);</td></tr>
<tr class="codeline" data-linenumber="2973"><td class="num" id="LN2973">2973</td><td class="line">	<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2974"><td class="num" id="LN2974">2974</td><td class="line">	    c = *s++;</td></tr>
<tr class="codeline" data-linenumber="2975"><td class="num" id="LN2975">2975</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2976"><td class="num" id="LN2976">2976</td><td class="line">	<span class='comment'>// We only change 0xdf to SS when we are certain latin1 is used.  It</span></td></tr>
<tr class="codeline" data-linenumber="2977"><td class="num" id="LN2977">2977</td><td class="line">	<span class='comment'>// would cause weird errors in other 8-bit encodings.</span></td></tr>
<tr class="codeline" data-linenumber="2978"><td class="num" id="LN2978">2978</td><td class="line">	<span class='keyword'>if</span> (enc_latin1like &amp;&amp; c == 0xdf)</td></tr>
<tr class="codeline" data-linenumber="2979"><td class="num" id="LN2979">2979</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="2980"><td class="num" id="LN2980">2980</td><td class="line">	    c = 'S';</td></tr>
<tr class="codeline" data-linenumber="2981"><td class="num" id="LN2981">2981</td><td class="line">	    <span class='keyword'>if</span> (d - wcopy &gt;= <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span> - 1)</td></tr>
<tr class="codeline" data-linenumber="2982"><td class="num" id="LN2982">2982</td><td class="line">		<span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="2983"><td class="num" id="LN2983">2983</td><td class="line">	    *d++ = c;</td></tr>
<tr class="codeline" data-linenumber="2984"><td class="num" id="LN2984">2984</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="2985"><td class="num" id="LN2985">2985</td><td class="line">	<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2986"><td class="num" id="LN2986">2986</td><td class="line">	    c = <span class='macro'>SPELL_TOUPPER(c)<span class='macro_popup'>(enc_utf8 &amp;&amp; (c) &gt;= 128 ? utf_toupper(c) : (c) &lt;<br> 256 ? (int)spelltab.st_upper[c] : (int)towupper(c))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="2987"><td class="num" id="LN2987">2987</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="2988"><td class="num" id="LN2988">2988</td><td class="line">	<span class='keyword'>if</span> (has_mbyte)</td></tr>
<tr class="codeline" data-linenumber="2989"><td class="num" id="LN2989">2989</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="2990"><td class="num" id="LN2990">2990</td><td class="line">	    <span class='keyword'>if</span> (d - wcopy &gt;= <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span> - <span class='macro'>MB_MAXBYTES<span class='macro_popup'>21</span></span>)</td></tr>
<tr class="codeline" data-linenumber="2991"><td class="num" id="LN2991">2991</td><td class="line">		<span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="2992"><td class="num" id="LN2992">2992</td><td class="line">	    d += mb_char2bytes(c, d);</td></tr>
<tr class="codeline" data-linenumber="2993"><td class="num" id="LN2993">2993</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="2994"><td class="num" id="LN2994">2994</td><td class="line">	<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="2995"><td class="num" id="LN2995">2995</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="2996"><td class="num" id="LN2996">2996</td><td class="line">	    <span class='keyword'>if</span> (d - wcopy &gt;= <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span> - 1)</td></tr>
<tr class="codeline" data-linenumber="2997"><td class="num" id="LN2997">2997</td><td class="line">		<span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="2998"><td class="num" id="LN2998">2998</td><td class="line">	    *d++ = c;</td></tr>
<tr class="codeline" data-linenumber="2999"><td class="num" id="LN2999">2999</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="3000"><td class="num" id="LN3000">3000</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="3001"><td class="num" id="LN3001">3001</td><td class="line">    *d = <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3002"><td class="num" id="LN3002">3002</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="3003"><td class="num" id="LN3003">3003</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3004"><td class="num" id="LN3004">3004</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="3005"><td class="num" id="LN3005">3005</td><td class="line"> <span class='comment'>* Case-folding may change the number of bytes: Count nr of chars in</span></td></tr>
<tr class="codeline" data-linenumber="3006"><td class="num" id="LN3006">3006</td><td class="line"> <span class='comment'>* fword[flen] and return the byte length of that many chars in "word".</span></td></tr>
<tr class="codeline" data-linenumber="3007"><td class="num" id="LN3007">3007</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="3008"><td class="num" id="LN3008">3008</td><td class="line">    <span class='keyword'>int</span></td></tr>
<tr class="codeline" data-linenumber="3009"><td class="num" id="LN3009">3009</td><td class="line">nofold_len(char_u *fword, <span class='keyword'>int</span> flen, char_u *word)</td></tr>
<tr class="codeline" data-linenumber="3010"><td class="num" id="LN3010">3010</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="3011"><td class="num" id="LN3011">3011</td><td class="line">    char_u	*p;</td></tr>
<tr class="codeline" data-linenumber="3012"><td class="num" id="LN3012">3012</td><td class="line">    <span class='keyword'>int</span>		i = 0;</td></tr>
<tr class="codeline" data-linenumber="3013"><td class="num" id="LN3013">3013</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3014"><td class="num" id="LN3014">3014</td><td class="line">    <span class='keyword'>for</span> (p = fword; p &lt; fword + flen; <span class='macro'>MB_PTR_ADV(p)<span class='macro_popup'>p += (*mb_ptr2len)(p)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3015"><td class="num" id="LN3015">3015</td><td class="line">	++i;</td></tr>
<tr class="codeline" data-linenumber="3016"><td class="num" id="LN3016">3016</td><td class="line">    <span class='keyword'>for</span> (p = word; i &gt; 0; <span class='macro'>MB_PTR_ADV(p)<span class='macro_popup'>p += (*mb_ptr2len)(p)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3017"><td class="num" id="LN3017">3017</td><td class="line">	--i;</td></tr>
<tr class="codeline" data-linenumber="3018"><td class="num" id="LN3018">3018</td><td class="line">    <span class='keyword'>return</span> (<span class='keyword'>int</span>)(p - word);</td></tr>
<tr class="codeline" data-linenumber="3019"><td class="num" id="LN3019">3019</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="3020"><td class="num" id="LN3020">3020</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3021"><td class="num" id="LN3021">3021</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="3022"><td class="num" id="LN3022">3022</td><td class="line"> <span class='comment'>* Copy "fword" to "cword", fixing case according to "flags".</span></td></tr>
<tr class="codeline" data-linenumber="3023"><td class="num" id="LN3023">3023</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="3024"><td class="num" id="LN3024">3024</td><td class="line">    <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="3025"><td class="num" id="LN3025">3025</td><td class="line">make_case_word(char_u *fword, char_u *cword, <span class='keyword'>int</span> flags)</td></tr>
<tr class="codeline" data-linenumber="3026"><td class="num" id="LN3026">3026</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="3027"><td class="num" id="LN3027">3027</td><td class="line">    <span class='keyword'>if</span> (flags &amp; <span class='macro'>WF_ALLCAP<span class='macro_popup'>0x04</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3028"><td class="num" id="LN3028">3028</td><td class="line">	<span class='comment'>// Make it all upper-case</span></td></tr>
<tr class="codeline" data-linenumber="3029"><td class="num" id="LN3029">3029</td><td class="line">	allcap_copy(fword, cword);</td></tr>
<tr class="codeline" data-linenumber="3030"><td class="num" id="LN3030">3030</td><td class="line">    <span class='keyword'>else</span> <span class='keyword'>if</span> (flags &amp; <span class='macro'>WF_ONECAP<span class='macro_popup'>0x02</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3031"><td class="num" id="LN3031">3031</td><td class="line">	<span class='comment'>// Make the first letter upper-case</span></td></tr>
<tr class="codeline" data-linenumber="3032"><td class="num" id="LN3032">3032</td><td class="line">	onecap_copy(fword, cword, <span class='macro'>TRUE<span class='macro_popup'>1</span></span>);</td></tr>
<tr class="codeline" data-linenumber="3033"><td class="num" id="LN3033">3033</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="3034"><td class="num" id="LN3034">3034</td><td class="line">	<span class='comment'>// Use goodword as-is.</span></td></tr>
<tr class="codeline" data-linenumber="3035"><td class="num" id="LN3035">3035</td><td class="line">	<span class='macro'>STRCPY(cword, fword)<span class='macro_popup'>strcpy((char *)(cword), (char *)(fword))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3036"><td class="num" id="LN3036">3036</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="3037"><td class="num" id="LN3037">3037</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3038"><td class="num" id="LN3038">3038</td><td class="line"><span class='directive'>#if defined(FEAT_EVAL) || defined(PROTO)</span></td></tr>
<tr class="codeline" data-linenumber="3039"><td class="num" id="LN3039">3039</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="3040"><td class="num" id="LN3040">3040</td><td class="line"> <span class='comment'>* Soundfold a string, for soundfold().</span></td></tr>
<tr class="codeline" data-linenumber="3041"><td class="num" id="LN3041">3041</td><td class="line"> <span class='comment'>* Result is in allocated memory, NULL for an error.</span></td></tr>
<tr class="codeline" data-linenumber="3042"><td class="num" id="LN3042">3042</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="3043"><td class="num" id="LN3043">3043</td><td class="line">    char_u *</td></tr>
<tr class="codeline" data-linenumber="3044"><td class="num" id="LN3044">3044</td><td class="line">eval_soundfold(char_u *word)</td></tr>
<tr class="codeline" data-linenumber="3045"><td class="num" id="LN3045">3045</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="3046"><td class="num" id="LN3046">3046</td><td class="line">    langp_T	*lp;</td></tr>
<tr class="codeline" data-linenumber="3047"><td class="num" id="LN3047">3047</td><td class="line">    char_u	sound[<span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>];</td></tr>
<tr class="codeline" data-linenumber="3048"><td class="num" id="LN3048">3048</td><td class="line">    <span class='keyword'>int</span>		lpi;</td></tr>
<tr class="codeline" data-linenumber="3049"><td class="num" id="LN3049">3049</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3050"><td class="num" id="LN3050">3050</td><td class="line">    <span class='keyword'>if</span> (curwin-&gt;<span class='macro'>w_p_spell<span class='macro_popup'>w_onebuf_opt.wo_spell</span></span> &amp;&amp; *curwin-&gt;w_s-&gt;b_p_spl != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3051"><td class="num" id="LN3051">3051</td><td class="line">	<span class='comment'>// Use the sound-folding of the first language that supports it.</span></td></tr>
<tr class="codeline" data-linenumber="3052"><td class="num" id="LN3052">3052</td><td class="line">	<span class='keyword'>for</span> (lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi)</td></tr>
<tr class="codeline" data-linenumber="3053"><td class="num" id="LN3053">3053</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="3054"><td class="num" id="LN3054">3054</td><td class="line">	    lp = <span class='macro'>LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi)<span class='macro_popup'>(((langp_T *)(curwin-&gt;w_s-&gt;b_langp).ga_data) + (lpi))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3055"><td class="num" id="LN3055">3055</td><td class="line">	    <span class='keyword'>if</span> (lp-&gt;lp_slang-&gt;sl_sal.ga_len &gt; 0)</td></tr>
<tr class="codeline" data-linenumber="3056"><td class="num" id="LN3056">3056</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="3057"><td class="num" id="LN3057">3057</td><td class="line">		<span class='comment'>// soundfold the word</span></td></tr>
<tr class="codeline" data-linenumber="3058"><td class="num" id="LN3058">3058</td><td class="line">		spell_soundfold(lp-&gt;lp_slang, word, <span class='macro'>FALSE<span class='macro_popup'>0</span></span>, sound);</td></tr>
<tr class="codeline" data-linenumber="3059"><td class="num" id="LN3059">3059</td><td class="line">		<span class='keyword'>return</span> vim_strsave(sound);</td></tr>
<tr class="codeline" data-linenumber="3060"><td class="num" id="LN3060">3060</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="3061"><td class="num" id="LN3061">3061</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="3062"><td class="num" id="LN3062">3062</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3063"><td class="num" id="LN3063">3063</td><td class="line">    <span class='comment'>// No language with sound folding, return word as-is.</span></td></tr>
<tr class="codeline" data-linenumber="3064"><td class="num" id="LN3064">3064</td><td class="line">    <span class='keyword'>return</span> vim_strsave(word);</td></tr>
<tr class="codeline" data-linenumber="3065"><td class="num" id="LN3065">3065</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="3066"><td class="num" id="LN3066">3066</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="3067"><td class="num" id="LN3067">3067</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3068"><td class="num" id="LN3068">3068</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="3069"><td class="num" id="LN3069">3069</td><td class="line"> <span class='comment'>* Turn "inword" into its sound-a-like equivalent in "res[MAXWLEN]".</span></td></tr>
<tr class="codeline" data-linenumber="3070"><td class="num" id="LN3070">3070</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="3071"><td class="num" id="LN3071">3071</td><td class="line"> <span class='comment'>* There are many ways to turn a word into a sound-a-like representation.  The</span></td></tr>
<tr class="codeline" data-linenumber="3072"><td class="num" id="LN3072">3072</td><td class="line"> <span class='comment'>* oldest is Soundex (1918!).   A nice overview can be found in "Approximate</span></td></tr>
<tr class="codeline" data-linenumber="3073"><td class="num" id="LN3073">3073</td><td class="line"> <span class='comment'>* swedish name matching - survey and test of different algorithms" by Klas</span></td></tr>
<tr class="codeline" data-linenumber="3074"><td class="num" id="LN3074">3074</td><td class="line"> <span class='comment'>* Erikson.</span></td></tr>
<tr class="codeline" data-linenumber="3075"><td class="num" id="LN3075">3075</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="3076"><td class="num" id="LN3076">3076</td><td class="line"> <span class='comment'>* We support two methods:</span></td></tr>
<tr class="codeline" data-linenumber="3077"><td class="num" id="LN3077">3077</td><td class="line"> <span class='comment'>* 1. SOFOFROM/SOFOTO do a simple character mapping.</span></td></tr>
<tr class="codeline" data-linenumber="3078"><td class="num" id="LN3078">3078</td><td class="line"> <span class='comment'>* 2. SAL items define a more advanced sound-folding (and much slower).</span></td></tr>
<tr class="codeline" data-linenumber="3079"><td class="num" id="LN3079">3079</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="3080"><td class="num" id="LN3080">3080</td><td class="line">    <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="3081"><td class="num" id="LN3081">3081</td><td class="line">spell_soundfold(</td></tr>
<tr class="codeline" data-linenumber="3082"><td class="num" id="LN3082">3082</td><td class="line">    slang_T	*slang,</td></tr>
<tr class="codeline" data-linenumber="3083"><td class="num" id="LN3083">3083</td><td class="line">    char_u	*inword,</td></tr>
<tr class="codeline" data-linenumber="3084"><td class="num" id="LN3084">3084</td><td class="line">    <span class='keyword'>int</span>		folded,	    <span class='comment'>// "inword" is already case-folded</span></td></tr>
<tr class="codeline" data-linenumber="3085"><td class="num" id="LN3085">3085</td><td class="line">    char_u	*res)</td></tr>
<tr class="codeline" data-linenumber="3086"><td class="num" id="LN3086">3086</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="3087"><td class="num" id="LN3087">3087</td><td class="line">    char_u	fword[<span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>];</td></tr>
<tr class="codeline" data-linenumber="3088"><td class="num" id="LN3088">3088</td><td class="line">    char_u	*word;</td></tr>
<tr class="codeline" data-linenumber="3089"><td class="num" id="LN3089">3089</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3090"><td class="num" id="LN3090">3090</td><td class="line">    <span class='keyword'>if</span> (slang-&gt;sl_sofo)</td></tr>
<tr class="codeline" data-linenumber="3091"><td class="num" id="LN3091">3091</td><td class="line">	<span class='comment'>// SOFOFROM and SOFOTO used</span></td></tr>
<tr class="codeline" data-linenumber="3092"><td class="num" id="LN3092">3092</td><td class="line">	spell_soundfold_sofo(slang, inword, res);</td></tr>
<tr class="codeline" data-linenumber="3093"><td class="num" id="LN3093">3093</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="3094"><td class="num" id="LN3094">3094</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="3095"><td class="num" id="LN3095">3095</td><td class="line">	<span class='comment'>// SAL items used.  Requires the word to be case-folded.</span></td></tr>
<tr class="codeline" data-linenumber="3096"><td class="num" id="LN3096">3096</td><td class="line">	<span class='keyword'>if</span> (folded)</td></tr>
<tr class="codeline" data-linenumber="3097"><td class="num" id="LN3097">3097</td><td class="line">	    word = inword;</td></tr>
<tr class="codeline" data-linenumber="3098"><td class="num" id="LN3098">3098</td><td class="line">	<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="3099"><td class="num" id="LN3099">3099</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="3100"><td class="num" id="LN3100">3100</td><td class="line">	    (<span class='keyword'>void</span>)spell_casefold(inword, (<span class='keyword'>int</span>)<span class='macro'>STRLEN(inword)<span class='macro_popup'>strlen((char *)(inword))</span></span>, fword, <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>);</td></tr>
<tr class="codeline" data-linenumber="3101"><td class="num" id="LN3101">3101</td><td class="line">	    word = fword;</td></tr>
<tr class="codeline" data-linenumber="3102"><td class="num" id="LN3102">3102</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="3103"><td class="num" id="LN3103">3103</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3104"><td class="num" id="LN3104">3104</td><td class="line">	<span class='keyword'>if</span> (has_mbyte)</td></tr>
<tr class="codeline" data-linenumber="3105"><td class="num" id="LN3105">3105</td><td class="line">	    spell_soundfold_wsal(slang, word, res);</td></tr>
<tr class="codeline" data-linenumber="3106"><td class="num" id="LN3106">3106</td><td class="line">	<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="3107"><td class="num" id="LN3107">3107</td><td class="line">	    spell_soundfold_sal(slang, word, res);</td></tr>
<tr class="codeline" data-linenumber="3108"><td class="num" id="LN3108">3108</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="3109"><td class="num" id="LN3109">3109</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="3110"><td class="num" id="LN3110">3110</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3111"><td class="num" id="LN3111">3111</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="3112"><td class="num" id="LN3112">3112</td><td class="line"> <span class='comment'>* Perform sound folding of "inword" into "res" according to SOFOFROM and</span></td></tr>
<tr class="codeline" data-linenumber="3113"><td class="num" id="LN3113">3113</td><td class="line"> <span class='comment'>* SOFOTO lines.</span></td></tr>
<tr class="codeline" data-linenumber="3114"><td class="num" id="LN3114">3114</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="3115"><td class="num" id="LN3115">3115</td><td class="line">    <span class='keyword'>static</span> <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="3116"><td class="num" id="LN3116">3116</td><td class="line">spell_soundfold_sofo(slang_T *slang, char_u *inword, char_u *res)</td></tr>
<tr class="codeline" data-linenumber="3117"><td class="num" id="LN3117">3117</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="3118"><td class="num" id="LN3118">3118</td><td class="line">    char_u	*s;</td></tr>
<tr class="codeline" data-linenumber="3119"><td class="num" id="LN3119">3119</td><td class="line">    <span class='keyword'>int</span>		ri = 0;</td></tr>
<tr class="codeline" data-linenumber="3120"><td class="num" id="LN3120">3120</td><td class="line">    <span class='keyword'>int</span>		c;</td></tr>
<tr class="codeline" data-linenumber="3121"><td class="num" id="LN3121">3121</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3122"><td class="num" id="LN3122">3122</td><td class="line">    <span class='keyword'>if</span> (has_mbyte)</td></tr>
<tr class="codeline" data-linenumber="3123"><td class="num" id="LN3123">3123</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="3124"><td class="num" id="LN3124">3124</td><td class="line">	<span class='keyword'>int</span>	prevc = 0;</td></tr>
<tr class="codeline" data-linenumber="3125"><td class="num" id="LN3125">3125</td><td class="line">	<span class='keyword'>int</span>	*ip;</td></tr>
<tr class="codeline" data-linenumber="3126"><td class="num" id="LN3126">3126</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3127"><td class="num" id="LN3127">3127</td><td class="line">	<span class='comment'>// The sl_sal_first[] table contains the translation for chars up to</span></td></tr>
<tr class="codeline" data-linenumber="3128"><td class="num" id="LN3128">3128</td><td class="line">	<span class='comment'>// 255, sl_sal the rest.</span></td></tr>
<tr class="codeline" data-linenumber="3129"><td class="num" id="LN3129">3129</td><td class="line">	<span class='keyword'>for</span> (s = inword; *s != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>; )</td></tr>
<tr class="codeline" data-linenumber="3130"><td class="num" id="LN3130">3130</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="3131"><td class="num" id="LN3131">3131</td><td class="line">	    c = mb_cptr2char_adv(&amp;s);</td></tr>
<tr class="codeline" data-linenumber="3132"><td class="num" id="LN3132">3132</td><td class="line">	    <span class='keyword'>if</span> (enc_utf8 ? utf_class(c) == 0 : <span class='macro'>VIM_ISWHITE(c)<span class='macro_popup'>((c) == ' ' || (c) == '\t')</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3133"><td class="num" id="LN3133">3133</td><td class="line">		c = ' ';</td></tr>
<tr class="codeline" data-linenumber="3134"><td class="num" id="LN3134">3134</td><td class="line">	    <span class='keyword'>else</span> <span class='keyword'>if</span> (c &lt; 256)</td></tr>
<tr class="codeline" data-linenumber="3135"><td class="num" id="LN3135">3135</td><td class="line">		c = slang-&gt;sl_sal_first[c];</td></tr>
<tr class="codeline" data-linenumber="3136"><td class="num" id="LN3136">3136</td><td class="line">	    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="3137"><td class="num" id="LN3137">3137</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="3138"><td class="num" id="LN3138">3138</td><td class="line">		ip = ((<span class='keyword'>int</span> **)slang-&gt;sl_sal.ga_data)[c &amp; 0xff];</td></tr>
<tr class="codeline" data-linenumber="3139"><td class="num" id="LN3139">3139</td><td class="line">		<span class='keyword'>if</span> (ip == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)		<span class='comment'>// empty list, can't match</span></td></tr>
<tr class="codeline" data-linenumber="3140"><td class="num" id="LN3140">3140</td><td class="line">		    c = <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3141"><td class="num" id="LN3141">3141</td><td class="line">		<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="3142"><td class="num" id="LN3142">3142</td><td class="line">		    <span class='keyword'>for</span> (;;)		<span class='comment'>// find "c" in the list</span></td></tr>
<tr class="codeline" data-linenumber="3143"><td class="num" id="LN3143">3143</td><td class="line">		    {</td></tr>
<tr class="codeline" data-linenumber="3144"><td class="num" id="LN3144">3144</td><td class="line">			<span class='keyword'>if</span> (*ip == 0)	<span class='comment'>// not found</span></td></tr>
<tr class="codeline" data-linenumber="3145"><td class="num" id="LN3145">3145</td><td class="line">			{</td></tr>
<tr class="codeline" data-linenumber="3146"><td class="num" id="LN3146">3146</td><td class="line">			    c = <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3147"><td class="num" id="LN3147">3147</td><td class="line">			    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="3148"><td class="num" id="LN3148">3148</td><td class="line">			}</td></tr>
<tr class="codeline" data-linenumber="3149"><td class="num" id="LN3149">3149</td><td class="line">			<span class='keyword'>if</span> (*ip == c)	<span class='comment'>// match!</span></td></tr>
<tr class="codeline" data-linenumber="3150"><td class="num" id="LN3150">3150</td><td class="line">			{</td></tr>
<tr class="codeline" data-linenumber="3151"><td class="num" id="LN3151">3151</td><td class="line">			    c = ip[1];</td></tr>
<tr class="codeline" data-linenumber="3152"><td class="num" id="LN3152">3152</td><td class="line">			    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="3153"><td class="num" id="LN3153">3153</td><td class="line">			}</td></tr>
<tr class="codeline" data-linenumber="3154"><td class="num" id="LN3154">3154</td><td class="line">			ip += 2;</td></tr>
<tr class="codeline" data-linenumber="3155"><td class="num" id="LN3155">3155</td><td class="line">		    }</td></tr>
<tr class="codeline" data-linenumber="3156"><td class="num" id="LN3156">3156</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="3157"><td class="num" id="LN3157">3157</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3158"><td class="num" id="LN3158">3158</td><td class="line">	    <span class='keyword'>if</span> (c != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span> &amp;&amp; c != prevc)</td></tr>
<tr class="codeline" data-linenumber="3159"><td class="num" id="LN3159">3159</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="3160"><td class="num" id="LN3160">3160</td><td class="line">		ri += mb_char2bytes(c, res + ri);</td></tr>
<tr class="codeline" data-linenumber="3161"><td class="num" id="LN3161">3161</td><td class="line">		<span class='keyword'>if</span> (ri + <span class='macro'>MB_MAXBYTES<span class='macro_popup'>21</span></span> &gt; <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3162"><td class="num" id="LN3162">3162</td><td class="line">		    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="3163"><td class="num" id="LN3163">3163</td><td class="line">		prevc = c;</td></tr>
<tr class="codeline" data-linenumber="3164"><td class="num" id="LN3164">3164</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="3165"><td class="num" id="LN3165">3165</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="3166"><td class="num" id="LN3166">3166</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="3167"><td class="num" id="LN3167">3167</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="3168"><td class="num" id="LN3168">3168</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="3169"><td class="num" id="LN3169">3169</td><td class="line">	<span class='comment'>// The sl_sal_first[] table contains the translation.</span></td></tr>
<tr class="codeline" data-linenumber="3170"><td class="num" id="LN3170">3170</td><td class="line">	<span class='keyword'>for</span> (s = inword; (c = *s) != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>; ++s)</td></tr>
<tr class="codeline" data-linenumber="3171"><td class="num" id="LN3171">3171</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="3172"><td class="num" id="LN3172">3172</td><td class="line">	    <span class='keyword'>if</span> (<span class='macro'>VIM_ISWHITE(c)<span class='macro_popup'>((c) == ' ' || (c) == '\t')</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3173"><td class="num" id="LN3173">3173</td><td class="line">		c = ' ';</td></tr>
<tr class="codeline" data-linenumber="3174"><td class="num" id="LN3174">3174</td><td class="line">	    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="3175"><td class="num" id="LN3175">3175</td><td class="line">		c = slang-&gt;sl_sal_first[c];</td></tr>
<tr class="codeline" data-linenumber="3176"><td class="num" id="LN3176">3176</td><td class="line">	    <span class='keyword'>if</span> (c != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span> &amp;&amp; (ri == 0 || res[ri - 1] != c))</td></tr>
<tr class="codeline" data-linenumber="3177"><td class="num" id="LN3177">3177</td><td class="line">		res[ri++] = c;</td></tr>
<tr class="codeline" data-linenumber="3178"><td class="num" id="LN3178">3178</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="3179"><td class="num" id="LN3179">3179</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="3180"><td class="num" id="LN3180">3180</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3181"><td class="num" id="LN3181">3181</td><td class="line">    res[ri] = <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3182"><td class="num" id="LN3182">3182</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="3183"><td class="num" id="LN3183">3183</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3184"><td class="num" id="LN3184">3184</td><td class="line">    <span class='keyword'>static</span> <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="3185"><td class="num" id="LN3185">3185</td><td class="line">spell_soundfold_sal(slang_T *slang, char_u *inword, char_u *res)</td></tr>
<tr class="codeline" data-linenumber="3186"><td class="num" id="LN3186">3186</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="3187"><td class="num" id="LN3187">3187</td><td class="line">    salitem_T	*smp;</td></tr>
<tr class="codeline" data-linenumber="3188"><td class="num" id="LN3188">3188</td><td class="line">    char_u	word[<span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>];</td></tr>
<tr class="codeline" data-linenumber="3189"><td class="num" id="LN3189">3189</td><td class="line">    char_u	*s = inword;</td></tr>
<tr class="codeline" data-linenumber="3190"><td class="num" id="LN3190">3190</td><td class="line">    char_u	*t;</td></tr>
<tr class="codeline" data-linenumber="3191"><td class="num" id="LN3191">3191</td><td class="line">    char_u	*pf;</td></tr>
<tr class="codeline" data-linenumber="3192"><td class="num" id="LN3192">3192</td><td class="line">    <span class='keyword'>int</span>		i, j, z;</td></tr>
<tr class="codeline" data-linenumber="3193"><td class="num" id="LN3193">3193</td><td class="line">    <span class='keyword'>int</span>		reslen;</td></tr>
<tr class="codeline" data-linenumber="3194"><td class="num" id="LN3194">3194</td><td class="line">    <span class='keyword'>int</span>		n, k = 0;</td></tr>
<tr class="codeline" data-linenumber="3195"><td class="num" id="LN3195">3195</td><td class="line">    <span class='keyword'>int</span>		z0;</td></tr>
<tr class="codeline" data-linenumber="3196"><td class="num" id="LN3196">3196</td><td class="line">    <span class='keyword'>int</span>		k0;</td></tr>
<tr class="codeline" data-linenumber="3197"><td class="num" id="LN3197">3197</td><td class="line">    <span class='keyword'>int</span>		n0;</td></tr>
<tr class="codeline" data-linenumber="3198"><td class="num" id="LN3198">3198</td><td class="line">    <span class='keyword'>int</span>		c;</td></tr>
<tr class="codeline" data-linenumber="3199"><td class="num" id="LN3199">3199</td><td class="line">    <span class='keyword'>int</span>		pri;</td></tr>
<tr class="codeline" data-linenumber="3200"><td class="num" id="LN3200">3200</td><td class="line">    <span class='keyword'>int</span>		p0 = -333;</td></tr>
<tr class="codeline" data-linenumber="3201"><td class="num" id="LN3201">3201</td><td class="line">    <span class='keyword'>int</span>		c0;</td></tr>
<tr class="codeline" data-linenumber="3202"><td class="num" id="LN3202">3202</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3203"><td class="num" id="LN3203">3203</td><td class="line">    <span class='comment'>// Remove accents, if wanted.  We actually remove all non-word characters.</span></td></tr>
<tr class="codeline" data-linenumber="3204"><td class="num" id="LN3204">3204</td><td class="line">    <span class='comment'>// But keep white space.  We need a copy, the word may be changed here.</span></td></tr>
<tr class="codeline" data-linenumber="3205"><td class="num" id="LN3205">3205</td><td class="line">    <span class='keyword'>if</span> (slang-&gt;sl_rem_accents)</td></tr>
<tr class="codeline" data-linenumber="3206"><td class="num" id="LN3206">3206</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="3207"><td class="num" id="LN3207">3207</td><td class="line">	t = word;</td></tr>
<tr class="codeline" data-linenumber="3208"><td class="num" id="LN3208">3208</td><td class="line">	<span class='keyword'>while</span> (*s != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3209"><td class="num" id="LN3209">3209</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="3210"><td class="num" id="LN3210">3210</td><td class="line">	    <span class='keyword'>if</span> (<span class='macro'>VIM_ISWHITE(*s)<span class='macro_popup'>((*s) == ' ' || (*s) == '\t')</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3211"><td class="num" id="LN3211">3211</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="3212"><td class="num" id="LN3212">3212</td><td class="line">		*t++ = ' ';</td></tr>
<tr class="codeline" data-linenumber="3213"><td class="num" id="LN3213">3213</td><td class="line">		s = skipwhite(s);</td></tr>
<tr class="codeline" data-linenumber="3214"><td class="num" id="LN3214">3214</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="3215"><td class="num" id="LN3215">3215</td><td class="line">	    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="3216"><td class="num" id="LN3216">3216</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="3217"><td class="num" id="LN3217">3217</td><td class="line">		<span class='keyword'>if</span> (spell_iswordp_nmw(s, curwin))</td></tr>
<tr class="codeline" data-linenumber="3218"><td class="num" id="LN3218">3218</td><td class="line">		    *t++ = *s;</td></tr>
<tr class="codeline" data-linenumber="3219"><td class="num" id="LN3219">3219</td><td class="line">		++s;</td></tr>
<tr class="codeline" data-linenumber="3220"><td class="num" id="LN3220">3220</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="3221"><td class="num" id="LN3221">3221</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="3222"><td class="num" id="LN3222">3222</td><td class="line">	*t = <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3223"><td class="num" id="LN3223">3223</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="3224"><td class="num" id="LN3224">3224</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="3225"><td class="num" id="LN3225">3225</td><td class="line">	vim_strncpy(word, s, <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span> - 1);</td></tr>
<tr class="codeline" data-linenumber="3226"><td class="num" id="LN3226">3226</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3227"><td class="num" id="LN3227">3227</td><td class="line">    smp = (salitem_T *)slang-&gt;sl_sal.ga_data;</td></tr>
<tr class="codeline" data-linenumber="3228"><td class="num" id="LN3228">3228</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3229"><td class="num" id="LN3229">3229</td><td class="line">    <span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="3230"><td class="num" id="LN3230">3230</td><td class="line">     <span class='comment'>* This comes from Aspell phonet.cpp.  Converted from C++ to C.</span></td></tr>
<tr class="codeline" data-linenumber="3231"><td class="num" id="LN3231">3231</td><td class="line">     <span class='comment'>* Changed to keep spaces.</span></td></tr>
<tr class="codeline" data-linenumber="3232"><td class="num" id="LN3232">3232</td><td class="line">     <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="3233"><td class="num" id="LN3233">3233</td><td class="line">    i = reslen = z = 0;</td></tr>
<tr class="codeline" data-linenumber="3234"><td class="num" id="LN3234">3234</td><td class="line">    <span class='keyword'>while</span> ((c = word[i]) != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3235"><td class="num" id="LN3235">3235</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="3236"><td class="num" id="LN3236">3236</td><td class="line">	<span class='comment'>// Start with the first rule that has the character in the word.</span></td></tr>
<tr class="codeline" data-linenumber="3237"><td class="num" id="LN3237">3237</td><td class="line">	n = slang-&gt;sl_sal_first[c];</td></tr>
<tr class="codeline" data-linenumber="3238"><td class="num" id="LN3238">3238</td><td class="line">	z0 = 0;</td></tr>
<tr class="codeline" data-linenumber="3239"><td class="num" id="LN3239">3239</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3240"><td class="num" id="LN3240">3240</td><td class="line">	<span class='keyword'>if</span> (n &gt;= 0)</td></tr>
<tr class="codeline" data-linenumber="3241"><td class="num" id="LN3241">3241</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="3242"><td class="num" id="LN3242">3242</td><td class="line">	    <span class='comment'>// check all rules for the same letter</span></td></tr>
<tr class="codeline" data-linenumber="3243"><td class="num" id="LN3243">3243</td><td class="line">	    <span class='keyword'>for</span> (; (s = smp[n].sm_lead)[0] == c; ++n)</td></tr>
<tr class="codeline" data-linenumber="3244"><td class="num" id="LN3244">3244</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="3245"><td class="num" id="LN3245">3245</td><td class="line">		<span class='comment'>// Quickly skip entries that don't match the word.  Most</span></td></tr>
<tr class="codeline" data-linenumber="3246"><td class="num" id="LN3246">3246</td><td class="line">		<span class='comment'>// entries are less then three chars, optimize for that.</span></td></tr>
<tr class="codeline" data-linenumber="3247"><td class="num" id="LN3247">3247</td><td class="line">		k = smp[n].sm_leadlen;</td></tr>
<tr class="codeline" data-linenumber="3248"><td class="num" id="LN3248">3248</td><td class="line">		<span class='keyword'>if</span> (k &gt; 1)</td></tr>
<tr class="codeline" data-linenumber="3249"><td class="num" id="LN3249">3249</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="3250"><td class="num" id="LN3250">3250</td><td class="line">		    <span class='keyword'>if</span> (word[i + 1] != s[1])</td></tr>
<tr class="codeline" data-linenumber="3251"><td class="num" id="LN3251">3251</td><td class="line">			<span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="3252"><td class="num" id="LN3252">3252</td><td class="line">		    <span class='keyword'>if</span> (k &gt; 2)</td></tr>
<tr class="codeline" data-linenumber="3253"><td class="num" id="LN3253">3253</td><td class="line">		    {</td></tr>
<tr class="codeline" data-linenumber="3254"><td class="num" id="LN3254">3254</td><td class="line">			<span class='keyword'>for</span> (j = 2; j &lt; k; ++j)</td></tr>
<tr class="codeline" data-linenumber="3255"><td class="num" id="LN3255">3255</td><td class="line">			    <span class='keyword'>if</span> (word[i + j] != s[j])</td></tr>
<tr class="codeline" data-linenumber="3256"><td class="num" id="LN3256">3256</td><td class="line">				<span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="3257"><td class="num" id="LN3257">3257</td><td class="line">			<span class='keyword'>if</span> (j &lt; k)</td></tr>
<tr class="codeline" data-linenumber="3258"><td class="num" id="LN3258">3258</td><td class="line">			    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="3259"><td class="num" id="LN3259">3259</td><td class="line">		    }</td></tr>
<tr class="codeline" data-linenumber="3260"><td class="num" id="LN3260">3260</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="3261"><td class="num" id="LN3261">3261</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3262"><td class="num" id="LN3262">3262</td><td class="line">		<span class='keyword'>if</span> ((pf = smp[n].sm_oneof) != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3263"><td class="num" id="LN3263">3263</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="3264"><td class="num" id="LN3264">3264</td><td class="line">		    <span class='comment'>// Check for match with one of the chars in "sm_oneof".</span></td></tr>
<tr class="codeline" data-linenumber="3265"><td class="num" id="LN3265">3265</td><td class="line">		    <span class='keyword'>while</span> (*pf != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span> &amp;&amp; *pf != word[i + k])</td></tr>
<tr class="codeline" data-linenumber="3266"><td class="num" id="LN3266">3266</td><td class="line">			++pf;</td></tr>
<tr class="codeline" data-linenumber="3267"><td class="num" id="LN3267">3267</td><td class="line">		    <span class='keyword'>if</span> (*pf == <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3268"><td class="num" id="LN3268">3268</td><td class="line">			<span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="3269"><td class="num" id="LN3269">3269</td><td class="line">		    ++k;</td></tr>
<tr class="codeline" data-linenumber="3270"><td class="num" id="LN3270">3270</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="3271"><td class="num" id="LN3271">3271</td><td class="line">		s = smp[n].sm_rules;</td></tr>
<tr class="codeline" data-linenumber="3272"><td class="num" id="LN3272">3272</td><td class="line">		pri = 5;    <span class='comment'>// default priority</span></td></tr>
<tr class="codeline" data-linenumber="3273"><td class="num" id="LN3273">3273</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3274"><td class="num" id="LN3274">3274</td><td class="line">		p0 = *s;</td></tr>
<tr class="codeline" data-linenumber="3275"><td class="num" id="LN3275">3275</td><td class="line">		k0 = k;</td></tr>
<tr class="codeline" data-linenumber="3276"><td class="num" id="LN3276">3276</td><td class="line">		<span class='keyword'>while</span> (*s == '-' &amp;&amp; k &gt; 1)</td></tr>
<tr class="codeline" data-linenumber="3277"><td class="num" id="LN3277">3277</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="3278"><td class="num" id="LN3278">3278</td><td class="line">		    k--;</td></tr>
<tr class="codeline" data-linenumber="3279"><td class="num" id="LN3279">3279</td><td class="line">		    s++;</td></tr>
<tr class="codeline" data-linenumber="3280"><td class="num" id="LN3280">3280</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="3281"><td class="num" id="LN3281">3281</td><td class="line">		<span class='keyword'>if</span> (*s == '&lt;')</td></tr>
<tr class="codeline" data-linenumber="3282"><td class="num" id="LN3282">3282</td><td class="line">		    s++;</td></tr>
<tr class="codeline" data-linenumber="3283"><td class="num" id="LN3283">3283</td><td class="line">		<span class='keyword'>if</span> (<span class='macro'>VIM_ISDIGIT(*s)<span class='macro_popup'>((unsigned)(*s) - '0' &lt; 10)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3284"><td class="num" id="LN3284">3284</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="3285"><td class="num" id="LN3285">3285</td><td class="line">		    <span class='comment'>// determine priority</span></td></tr>
<tr class="codeline" data-linenumber="3286"><td class="num" id="LN3286">3286</td><td class="line">		    pri = *s - '0';</td></tr>
<tr class="codeline" data-linenumber="3287"><td class="num" id="LN3287">3287</td><td class="line">		    s++;</td></tr>
<tr class="codeline" data-linenumber="3288"><td class="num" id="LN3288">3288</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="3289"><td class="num" id="LN3289">3289</td><td class="line">		<span class='keyword'>if</span> (*s == '^' &amp;&amp; *(s + 1) == '^')</td></tr>
<tr class="codeline" data-linenumber="3290"><td class="num" id="LN3290">3290</td><td class="line">		    s++;</td></tr>
<tr class="codeline" data-linenumber="3291"><td class="num" id="LN3291">3291</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3292"><td class="num" id="LN3292">3292</td><td class="line">		<span class='keyword'>if</span> (*s == <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span></td></tr>
<tr class="codeline" data-linenumber="3293"><td class="num" id="LN3293">3293</td><td class="line">			|| (*s == '^'</td></tr>
<tr class="codeline" data-linenumber="3294"><td class="num" id="LN3294">3294</td><td class="line">			    &amp;&amp; (i == 0 || !(word[i - 1] == ' '</td></tr>
<tr class="codeline" data-linenumber="3295"><td class="num" id="LN3295">3295</td><td class="line">				      || spell_iswordp(word + i - 1, curwin)))</td></tr>
<tr class="codeline" data-linenumber="3296"><td class="num" id="LN3296">3296</td><td class="line">			    &amp;&amp; (*(s + 1) != '$'</td></tr>
<tr class="codeline" data-linenumber="3297"><td class="num" id="LN3297">3297</td><td class="line">				|| (!spell_iswordp(word + i + k0, curwin))))</td></tr>
<tr class="codeline" data-linenumber="3298"><td class="num" id="LN3298">3298</td><td class="line">			|| (*s == '$' &amp;&amp; i &gt; 0</td></tr>
<tr class="codeline" data-linenumber="3299"><td class="num" id="LN3299">3299</td><td class="line">			    &amp;&amp; spell_iswordp(word + i - 1, curwin)</td></tr>
<tr class="codeline" data-linenumber="3300"><td class="num" id="LN3300">3300</td><td class="line">			    &amp;&amp; (!spell_iswordp(word + i + k0, curwin))))</td></tr>
<tr class="codeline" data-linenumber="3301"><td class="num" id="LN3301">3301</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="3302"><td class="num" id="LN3302">3302</td><td class="line">		    <span class='comment'>// search for followup rules, if:</span></td></tr>
<tr class="codeline" data-linenumber="3303"><td class="num" id="LN3303">3303</td><td class="line">		    <span class='comment'>// followup and k &gt; 1  and  NO '-' in searchstring</span></td></tr>
<tr class="codeline" data-linenumber="3304"><td class="num" id="LN3304">3304</td><td class="line">		    c0 = word[i + k - 1];</td></tr>
<tr class="codeline" data-linenumber="3305"><td class="num" id="LN3305">3305</td><td class="line">		    n0 = slang-&gt;sl_sal_first[c0];</td></tr>
<tr class="codeline" data-linenumber="3306"><td class="num" id="LN3306">3306</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3307"><td class="num" id="LN3307">3307</td><td class="line">		    <span class='keyword'>if</span> (slang-&gt;sl_followup &amp;&amp; k &gt; 1 &amp;&amp; n0 &gt;= 0</td></tr>
<tr class="codeline" data-linenumber="3308"><td class="num" id="LN3308">3308</td><td class="line">					   &amp;&amp; p0 != '-' &amp;&amp; word[i + k] != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3309"><td class="num" id="LN3309">3309</td><td class="line">		    {</td></tr>
<tr class="codeline" data-linenumber="3310"><td class="num" id="LN3310">3310</td><td class="line">			<span class='comment'>// test follow-up rule for "word[i + k]"</span></td></tr>
<tr class="codeline" data-linenumber="3311"><td class="num" id="LN3311">3311</td><td class="line">			<span class='keyword'>for</span> ( ; (s = smp[n0].sm_lead)[0] == c0; ++n0)</td></tr>
<tr class="codeline" data-linenumber="3312"><td class="num" id="LN3312">3312</td><td class="line">			{</td></tr>
<tr class="codeline" data-linenumber="3313"><td class="num" id="LN3313">3313</td><td class="line">			    <span class='comment'>// Quickly skip entries that don't match the word.</span></td></tr>
<tr class="codeline" data-linenumber="3314"><td class="num" id="LN3314">3314</td><td class="line">			    <span class='comment'>//</span></td></tr>
<tr class="codeline" data-linenumber="3315"><td class="num" id="LN3315">3315</td><td class="line">			    k0 = smp[n0].sm_leadlen;</td></tr>
<tr class="codeline" data-linenumber="3316"><td class="num" id="LN3316">3316</td><td class="line">			    <span class='keyword'>if</span> (k0 &gt; 1)</td></tr>
<tr class="codeline" data-linenumber="3317"><td class="num" id="LN3317">3317</td><td class="line">			    {</td></tr>
<tr class="codeline" data-linenumber="3318"><td class="num" id="LN3318">3318</td><td class="line">				<span class='keyword'>if</span> (word[i + k] != s[1])</td></tr>
<tr class="codeline" data-linenumber="3319"><td class="num" id="LN3319">3319</td><td class="line">				    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="3320"><td class="num" id="LN3320">3320</td><td class="line">				<span class='keyword'>if</span> (k0 &gt; 2)</td></tr>
<tr class="codeline" data-linenumber="3321"><td class="num" id="LN3321">3321</td><td class="line">				{</td></tr>
<tr class="codeline" data-linenumber="3322"><td class="num" id="LN3322">3322</td><td class="line">				    pf = word + i + k + 1;</td></tr>
<tr class="codeline" data-linenumber="3323"><td class="num" id="LN3323">3323</td><td class="line">				    <span class='keyword'>for</span> (j = 2; j &lt; k0; ++j)</td></tr>
<tr class="codeline" data-linenumber="3324"><td class="num" id="LN3324">3324</td><td class="line">					<span class='keyword'>if</span> (*pf++ != s[j])</td></tr>
<tr class="codeline" data-linenumber="3325"><td class="num" id="LN3325">3325</td><td class="line">					    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="3326"><td class="num" id="LN3326">3326</td><td class="line">				    <span class='keyword'>if</span> (j &lt; k0)</td></tr>
<tr class="codeline" data-linenumber="3327"><td class="num" id="LN3327">3327</td><td class="line">					<span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="3328"><td class="num" id="LN3328">3328</td><td class="line">				}</td></tr>
<tr class="codeline" data-linenumber="3329"><td class="num" id="LN3329">3329</td><td class="line">			    }</td></tr>
<tr class="codeline" data-linenumber="3330"><td class="num" id="LN3330">3330</td><td class="line">			    k0 += k - 1;</td></tr>
<tr class="codeline" data-linenumber="3331"><td class="num" id="LN3331">3331</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3332"><td class="num" id="LN3332">3332</td><td class="line">			    <span class='keyword'>if</span> ((pf = smp[n0].sm_oneof) != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3333"><td class="num" id="LN3333">3333</td><td class="line">			    {</td></tr>
<tr class="codeline" data-linenumber="3334"><td class="num" id="LN3334">3334</td><td class="line">				<span class='comment'>// Check for match with one of the chars in</span></td></tr>
<tr class="codeline" data-linenumber="3335"><td class="num" id="LN3335">3335</td><td class="line">				<span class='comment'>// "sm_oneof".</span></td></tr>
<tr class="codeline" data-linenumber="3336"><td class="num" id="LN3336">3336</td><td class="line">				<span class='keyword'>while</span> (*pf != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span> &amp;&amp; *pf != word[i + k0])</td></tr>
<tr class="codeline" data-linenumber="3337"><td class="num" id="LN3337">3337</td><td class="line">				    ++pf;</td></tr>
<tr class="codeline" data-linenumber="3338"><td class="num" id="LN3338">3338</td><td class="line">				<span class='keyword'>if</span> (*pf == <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3339"><td class="num" id="LN3339">3339</td><td class="line">				    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="3340"><td class="num" id="LN3340">3340</td><td class="line">				++k0;</td></tr>
<tr class="codeline" data-linenumber="3341"><td class="num" id="LN3341">3341</td><td class="line">			    }</td></tr>
<tr class="codeline" data-linenumber="3342"><td class="num" id="LN3342">3342</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3343"><td class="num" id="LN3343">3343</td><td class="line">			    p0 = 5;</td></tr>
<tr class="codeline" data-linenumber="3344"><td class="num" id="LN3344">3344</td><td class="line">			    s = smp[n0].sm_rules;</td></tr>
<tr class="codeline" data-linenumber="3345"><td class="num" id="LN3345">3345</td><td class="line">			    <span class='keyword'>while</span> (*s == '-')</td></tr>
<tr class="codeline" data-linenumber="3346"><td class="num" id="LN3346">3346</td><td class="line">			    {</td></tr>
<tr class="codeline" data-linenumber="3347"><td class="num" id="LN3347">3347</td><td class="line">				<span class='comment'>// "k0" gets NOT reduced because</span></td></tr>
<tr class="codeline" data-linenumber="3348"><td class="num" id="LN3348">3348</td><td class="line">				<span class='comment'>// "if (k0 == k)"</span></td></tr>
<tr class="codeline" data-linenumber="3349"><td class="num" id="LN3349">3349</td><td class="line">				s++;</td></tr>
<tr class="codeline" data-linenumber="3350"><td class="num" id="LN3350">3350</td><td class="line">			    }</td></tr>
<tr class="codeline" data-linenumber="3351"><td class="num" id="LN3351">3351</td><td class="line">			    <span class='keyword'>if</span> (*s == '&lt;')</td></tr>
<tr class="codeline" data-linenumber="3352"><td class="num" id="LN3352">3352</td><td class="line">				s++;</td></tr>
<tr class="codeline" data-linenumber="3353"><td class="num" id="LN3353">3353</td><td class="line">			    <span class='keyword'>if</span> (<span class='macro'>VIM_ISDIGIT(*s)<span class='macro_popup'>((unsigned)(*s) - '0' &lt; 10)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3354"><td class="num" id="LN3354">3354</td><td class="line">			    {</td></tr>
<tr class="codeline" data-linenumber="3355"><td class="num" id="LN3355">3355</td><td class="line">				p0 = *s - '0';</td></tr>
<tr class="codeline" data-linenumber="3356"><td class="num" id="LN3356">3356</td><td class="line">				s++;</td></tr>
<tr class="codeline" data-linenumber="3357"><td class="num" id="LN3357">3357</td><td class="line">			    }</td></tr>
<tr class="codeline" data-linenumber="3358"><td class="num" id="LN3358">3358</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3359"><td class="num" id="LN3359">3359</td><td class="line">			    <span class='keyword'>if</span> (*s == <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span></td></tr>
<tr class="codeline" data-linenumber="3360"><td class="num" id="LN3360">3360</td><td class="line">				    <span class='comment'>// *s == '^' cuts</span></td></tr>
<tr class="codeline" data-linenumber="3361"><td class="num" id="LN3361">3361</td><td class="line">				    || (*s == '$'</td></tr>
<tr class="codeline" data-linenumber="3362"><td class="num" id="LN3362">3362</td><td class="line">					    &amp;&amp; !spell_iswordp(word + i + k0,</td></tr>
<tr class="codeline" data-linenumber="3363"><td class="num" id="LN3363">3363</td><td class="line">								     curwin)))</td></tr>
<tr class="codeline" data-linenumber="3364"><td class="num" id="LN3364">3364</td><td class="line">			    {</td></tr>
<tr class="codeline" data-linenumber="3365"><td class="num" id="LN3365">3365</td><td class="line">				<span class='keyword'>if</span> (k0 == k)</td></tr>
<tr class="codeline" data-linenumber="3366"><td class="num" id="LN3366">3366</td><td class="line">				    <span class='comment'>// this is just a piece of the string</span></td></tr>
<tr class="codeline" data-linenumber="3367"><td class="num" id="LN3367">3367</td><td class="line">				    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="3368"><td class="num" id="LN3368">3368</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3369"><td class="num" id="LN3369">3369</td><td class="line">				<span class='keyword'>if</span> (p0 &lt; pri)</td></tr>
<tr class="codeline" data-linenumber="3370"><td class="num" id="LN3370">3370</td><td class="line">				    <span class='comment'>// priority too low</span></td></tr>
<tr class="codeline" data-linenumber="3371"><td class="num" id="LN3371">3371</td><td class="line">				    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="3372"><td class="num" id="LN3372">3372</td><td class="line">				<span class='comment'>// rule fits; stop search</span></td></tr>
<tr class="codeline" data-linenumber="3373"><td class="num" id="LN3373">3373</td><td class="line">				<span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="3374"><td class="num" id="LN3374">3374</td><td class="line">			    }</td></tr>
<tr class="codeline" data-linenumber="3375"><td class="num" id="LN3375">3375</td><td class="line">			}</td></tr>
<tr class="codeline" data-linenumber="3376"><td class="num" id="LN3376">3376</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3377"><td class="num" id="LN3377">3377</td><td class="line">			<span class='keyword'>if</span> (p0 &gt;= pri &amp;&amp; smp[n0].sm_lead[0] == c0)</td></tr>
<tr class="codeline" data-linenumber="3378"><td class="num" id="LN3378">3378</td><td class="line">			    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="3379"><td class="num" id="LN3379">3379</td><td class="line">		    }</td></tr>
<tr class="codeline" data-linenumber="3380"><td class="num" id="LN3380">3380</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3381"><td class="num" id="LN3381">3381</td><td class="line">		    <span class='comment'>// replace string</span></td></tr>
<tr class="codeline" data-linenumber="3382"><td class="num" id="LN3382">3382</td><td class="line">		    s = smp[n].sm_to;</td></tr>
<tr class="codeline" data-linenumber="3383"><td class="num" id="LN3383">3383</td><td class="line">		    <span class='keyword'>if</span> (s == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3384"><td class="num" id="LN3384">3384</td><td class="line">			s = (char_u *)<span class='string_literal'>""</span>;</td></tr>
<tr class="codeline" data-linenumber="3385"><td class="num" id="LN3385">3385</td><td class="line">		    pf = smp[n].sm_rules;</td></tr>
<tr class="codeline" data-linenumber="3386"><td class="num" id="LN3386">3386</td><td class="line">		    p0 = (vim_strchr(pf, '&lt;') != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>) ? 1 : 0;</td></tr>
<tr class="codeline" data-linenumber="3387"><td class="num" id="LN3387">3387</td><td class="line">		    <span class='keyword'>if</span> (p0 == 1 &amp;&amp; z == 0)</td></tr>
<tr class="codeline" data-linenumber="3388"><td class="num" id="LN3388">3388</td><td class="line">		    {</td></tr>
<tr class="codeline" data-linenumber="3389"><td class="num" id="LN3389">3389</td><td class="line">			<span class='comment'>// rule with '&lt;' is used</span></td></tr>
<tr class="codeline" data-linenumber="3390"><td class="num" id="LN3390">3390</td><td class="line">			<span class='keyword'>if</span> (reslen &gt; 0 &amp;&amp; *s != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span> &amp;&amp; (res[reslen - 1] == c</td></tr>
<tr class="codeline" data-linenumber="3391"><td class="num" id="LN3391">3391</td><td class="line">						    || res[reslen - 1] == *s))</td></tr>
<tr class="codeline" data-linenumber="3392"><td class="num" id="LN3392">3392</td><td class="line">			    reslen--;</td></tr>
<tr class="codeline" data-linenumber="3393"><td class="num" id="LN3393">3393</td><td class="line">			z0 = 1;</td></tr>
<tr class="codeline" data-linenumber="3394"><td class="num" id="LN3394">3394</td><td class="line">			z = 1;</td></tr>
<tr class="codeline" data-linenumber="3395"><td class="num" id="LN3395">3395</td><td class="line">			k0 = 0;</td></tr>
<tr class="codeline" data-linenumber="3396"><td class="num" id="LN3396">3396</td><td class="line">			<span class='keyword'>while</span> (*s != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span> &amp;&amp; word[i + k0] != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3397"><td class="num" id="LN3397">3397</td><td class="line">			{</td></tr>
<tr class="codeline" data-linenumber="3398"><td class="num" id="LN3398">3398</td><td class="line">			    word[i + k0] = *s;</td></tr>
<tr class="codeline" data-linenumber="3399"><td class="num" id="LN3399">3399</td><td class="line">			    k0++;</td></tr>
<tr class="codeline" data-linenumber="3400"><td class="num" id="LN3400">3400</td><td class="line">			    s++;</td></tr>
<tr class="codeline" data-linenumber="3401"><td class="num" id="LN3401">3401</td><td class="line">			}</td></tr>
<tr class="codeline" data-linenumber="3402"><td class="num" id="LN3402">3402</td><td class="line">			<span class='keyword'>if</span> (k &gt; k0)</td></tr>
<tr class="codeline" data-linenumber="3403"><td class="num" id="LN3403">3403</td><td class="line">			    <span class='macro'>STRMOVE(word + i + k0, word + i + k)<span class='macro_popup'>memmove((char *)((word + i + k0)), (char *)((word + i + k)), strlen<br>((char *)(word + i + k)) + 1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3404"><td class="num" id="LN3404">3404</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3405"><td class="num" id="LN3405">3405</td><td class="line">			<span class='comment'>// new "actual letter"</span></td></tr>
<tr class="codeline" data-linenumber="3406"><td class="num" id="LN3406">3406</td><td class="line">			c = word[i];</td></tr>
<tr class="codeline" data-linenumber="3407"><td class="num" id="LN3407">3407</td><td class="line">		    }</td></tr>
<tr class="codeline" data-linenumber="3408"><td class="num" id="LN3408">3408</td><td class="line">		    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="3409"><td class="num" id="LN3409">3409</td><td class="line">		    {</td></tr>
<tr class="codeline" data-linenumber="3410"><td class="num" id="LN3410">3410</td><td class="line">			<span class='comment'>// no '&lt;' rule used</span></td></tr>
<tr class="codeline" data-linenumber="3411"><td class="num" id="LN3411">3411</td><td class="line">			i += k - 1;</td></tr>
<tr class="codeline" data-linenumber="3412"><td class="num" id="LN3412">3412</td><td class="line">			z = 0;</td></tr>
<tr class="codeline" data-linenumber="3413"><td class="num" id="LN3413">3413</td><td class="line">			<span class='keyword'>while</span> (*s != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span> &amp;&amp; s[1] != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span> &amp;&amp; reslen &lt; <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3414"><td class="num" id="LN3414">3414</td><td class="line">			{</td></tr>
<tr class="codeline" data-linenumber="3415"><td class="num" id="LN3415">3415</td><td class="line">			    <span class='keyword'>if</span> (reslen == 0 || res[reslen - 1] != *s)</td></tr>
<tr class="codeline" data-linenumber="3416"><td class="num" id="LN3416">3416</td><td class="line">				res[reslen++] = *s;</td></tr>
<tr class="codeline" data-linenumber="3417"><td class="num" id="LN3417">3417</td><td class="line">			    s++;</td></tr>
<tr class="codeline" data-linenumber="3418"><td class="num" id="LN3418">3418</td><td class="line">			}</td></tr>
<tr class="codeline" data-linenumber="3419"><td class="num" id="LN3419">3419</td><td class="line">			<span class='comment'>// new "actual letter"</span></td></tr>
<tr class="codeline" data-linenumber="3420"><td class="num" id="LN3420">3420</td><td class="line">			c = *s;</td></tr>
<tr class="codeline" data-linenumber="3421"><td class="num" id="LN3421">3421</td><td class="line">			<span class='keyword'>if</span> (strstr((<span class='keyword'>char</span> *)pf, <span class='string_literal'>"^^"</span>) != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3422"><td class="num" id="LN3422">3422</td><td class="line">			{</td></tr>
<tr class="codeline" data-linenumber="3423"><td class="num" id="LN3423">3423</td><td class="line">			    <span class='keyword'>if</span> (c != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3424"><td class="num" id="LN3424">3424</td><td class="line">				res[reslen++] = c;</td></tr>
<tr class="codeline" data-linenumber="3425"><td class="num" id="LN3425">3425</td><td class="line">			    <span class='macro'>STRMOVE(word, word + i + 1)<span class='macro_popup'>memmove((char *)((word)), (char *)((word + i + 1)), strlen((char<br> *)(word + i + 1)) + 1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3426"><td class="num" id="LN3426">3426</td><td class="line">			    i = 0;</td></tr>
<tr class="codeline" data-linenumber="3427"><td class="num" id="LN3427">3427</td><td class="line">			    z0 = 1;</td></tr>
<tr class="codeline" data-linenumber="3428"><td class="num" id="LN3428">3428</td><td class="line">			}</td></tr>
<tr class="codeline" data-linenumber="3429"><td class="num" id="LN3429">3429</td><td class="line">		    }</td></tr>
<tr class="codeline" data-linenumber="3430"><td class="num" id="LN3430">3430</td><td class="line">		    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="3431"><td class="num" id="LN3431">3431</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="3432"><td class="num" id="LN3432">3432</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="3433"><td class="num" id="LN3433">3433</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="3434"><td class="num" id="LN3434">3434</td><td class="line">	<span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>VIM_ISWHITE(c)<span class='macro_popup'>((c) == ' ' || (c) == '\t')</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3435"><td class="num" id="LN3435">3435</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="3436"><td class="num" id="LN3436">3436</td><td class="line">	    c = ' ';</td></tr>
<tr class="codeline" data-linenumber="3437"><td class="num" id="LN3437">3437</td><td class="line">	    k = 1;</td></tr>
<tr class="codeline" data-linenumber="3438"><td class="num" id="LN3438">3438</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="3439"><td class="num" id="LN3439">3439</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3440"><td class="num" id="LN3440">3440</td><td class="line">	<span class='keyword'>if</span> (z0 == 0)</td></tr>
<tr class="codeline" data-linenumber="3441"><td class="num" id="LN3441">3441</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="3442"><td class="num" id="LN3442">3442</td><td class="line">	    <span class='keyword'>if</span> (k &amp;&amp; !p0 &amp;&amp; reslen &lt; <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span> &amp;&amp; c != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span></td></tr>
<tr class="codeline" data-linenumber="3443"><td class="num" id="LN3443">3443</td><td class="line">		    &amp;&amp; (!slang-&gt;sl_collapse || reslen == 0</td></tr>
<tr class="codeline" data-linenumber="3444"><td class="num" id="LN3444">3444</td><td class="line">						     || res[reslen - 1] != c))</td></tr>
<tr class="codeline" data-linenumber="3445"><td class="num" id="LN3445">3445</td><td class="line">		<span class='comment'>// condense only double letters</span></td></tr>
<tr class="codeline" data-linenumber="3446"><td class="num" id="LN3446">3446</td><td class="line">		res[reslen++] = c;</td></tr>
<tr class="codeline" data-linenumber="3447"><td class="num" id="LN3447">3447</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3448"><td class="num" id="LN3448">3448</td><td class="line">	    i++;</td></tr>
<tr class="codeline" data-linenumber="3449"><td class="num" id="LN3449">3449</td><td class="line">	    z = 0;</td></tr>
<tr class="codeline" data-linenumber="3450"><td class="num" id="LN3450">3450</td><td class="line">	    k = 0;</td></tr>
<tr class="codeline" data-linenumber="3451"><td class="num" id="LN3451">3451</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="3452"><td class="num" id="LN3452">3452</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="3453"><td class="num" id="LN3453">3453</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3454"><td class="num" id="LN3454">3454</td><td class="line">    res[reslen] = <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3455"><td class="num" id="LN3455">3455</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="3456"><td class="num" id="LN3456">3456</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3457"><td class="num" id="LN3457">3457</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="3458"><td class="num" id="LN3458">3458</td><td class="line"> <span class='comment'>* Turn "inword" into its sound-a-like equivalent in "res[MAXWLEN]".</span></td></tr>
<tr class="codeline" data-linenumber="3459"><td class="num" id="LN3459">3459</td><td class="line"> <span class='comment'>* Multi-byte version of spell_soundfold().</span></td></tr>
<tr class="codeline" data-linenumber="3460"><td class="num" id="LN3460">3460</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="3461"><td class="num" id="LN3461">3461</td><td class="line">    <span class='keyword'>static</span> <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="3462"><td class="num" id="LN3462">3462</td><td class="line">spell_soundfold_wsal(slang_T *slang, char_u *inword, char_u *res)</td></tr>
<tr class="codeline" data-linenumber="3463"><td class="num" id="LN3463">3463</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="3464"><td class="num" id="LN3464">3464</td><td class="line">    salitem_T	*smp = (salitem_T *)slang-&gt;sl_sal.ga_data;</td></tr>
<tr class="codeline" data-linenumber="3465"><td class="num" id="LN3465">3465</td><td class="line">    <span class='keyword'>int</span>		word[<span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>];</td></tr>
<tr class="codeline" data-linenumber="3466"><td class="num" id="LN3466">3466</td><td class="line">    <span class='keyword'>int</span>		wres[<span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>];</td></tr>
<tr class="codeline" data-linenumber="3467"><td class="num" id="LN3467">3467</td><td class="line">    <span class='keyword'>int</span>		l;</td></tr>
<tr class="codeline" data-linenumber="3468"><td class="num" id="LN3468">3468</td><td class="line">    char_u	*s;</td></tr>
<tr class="codeline" data-linenumber="3469"><td class="num" id="LN3469">3469</td><td class="line">    <span class='keyword'>int</span>		*ws;</td></tr>
<tr class="codeline" data-linenumber="3470"><td class="num" id="LN3470">3470</td><td class="line">    char_u	*t;</td></tr>
<tr class="codeline" data-linenumber="3471"><td class="num" id="LN3471">3471</td><td class="line">    <span class='keyword'>int</span>		*pf;</td></tr>
<tr class="codeline" data-linenumber="3472"><td class="num" id="LN3472">3472</td><td class="line">    <span class='keyword'>int</span>		i, j, z;</td></tr>
<tr class="codeline" data-linenumber="3473"><td class="num" id="LN3473">3473</td><td class="line">    <span class='keyword'>int</span>		reslen;</td></tr>
<tr class="codeline" data-linenumber="3474"><td class="num" id="LN3474">3474</td><td class="line">    <span class='keyword'>int</span>		n, k = 0;</td></tr>
<tr class="codeline" data-linenumber="3475"><td class="num" id="LN3475">3475</td><td class="line">    <span class='keyword'>int</span>		z0;</td></tr>
<tr class="codeline" data-linenumber="3476"><td class="num" id="LN3476">3476</td><td class="line">    <span class='keyword'>int</span>		k0;</td></tr>
<tr class="codeline" data-linenumber="3477"><td class="num" id="LN3477">3477</td><td class="line">    <span class='keyword'>int</span>		n0;</td></tr>
<tr class="codeline" data-linenumber="3478"><td class="num" id="LN3478">3478</td><td class="line">    <span class='keyword'>int</span>		c;</td></tr>
<tr class="codeline" data-linenumber="3479"><td class="num" id="LN3479">3479</td><td class="line">    <span class='keyword'>int</span>		pri;</td></tr>
<tr class="codeline" data-linenumber="3480"><td class="num" id="LN3480">3480</td><td class="line">    <span class='keyword'>int</span>		p0 = -333;</td></tr>
<tr class="codeline" data-linenumber="3481"><td class="num" id="LN3481">3481</td><td class="line">    <span class='keyword'>int</span>		c0;</td></tr>
<tr class="codeline" data-linenumber="3482"><td class="num" id="LN3482">3482</td><td class="line">    <span class='keyword'>int</span>		did_white = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3483"><td class="num" id="LN3483">3483</td><td class="line">    <span class='keyword'>int</span>		wordlen;</td></tr>
<tr class="codeline" data-linenumber="3484"><td class="num" id="LN3484">3484</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3485"><td class="num" id="LN3485">3485</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3486"><td class="num" id="LN3486">3486</td><td class="line">    <span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="3487"><td class="num" id="LN3487">3487</td><td class="line">     <span class='comment'>* Convert the multi-byte string to a wide-character string.</span></td></tr>
<tr class="codeline" data-linenumber="3488"><td class="num" id="LN3488">3488</td><td class="line">     <span class='comment'>* Remove accents, if wanted.  We actually remove all non-word characters.</span></td></tr>
<tr class="codeline" data-linenumber="3489"><td class="num" id="LN3489">3489</td><td class="line">     <span class='comment'>* But keep white space.</span></td></tr>
<tr class="codeline" data-linenumber="3490"><td class="num" id="LN3490">3490</td><td class="line">     <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="3491"><td class="num" id="LN3491">3491</td><td class="line">    wordlen = 0;</td></tr>
<tr class="codeline" data-linenumber="3492"><td class="num" id="LN3492">3492</td><td class="line">    <span class='keyword'>for</span> (s = inword; *s != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>; )</td></tr>
<tr class="codeline" data-linenumber="3493"><td class="num" id="LN3493">3493</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="3494"><td class="num" id="LN3494">3494</td><td class="line">	t = s;</td></tr>
<tr class="codeline" data-linenumber="3495"><td class="num" id="LN3495">3495</td><td class="line">	c = mb_cptr2char_adv(&amp;s);</td></tr>
<tr class="codeline" data-linenumber="3496"><td class="num" id="LN3496">3496</td><td class="line">	<span class='keyword'>if</span> (slang-&gt;sl_rem_accents)</td></tr>
<tr class="codeline" data-linenumber="3497"><td class="num" id="LN3497">3497</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="3498"><td class="num" id="LN3498">3498</td><td class="line">	    <span class='keyword'>if</span> (enc_utf8 ? utf_class(c) == 0 : <span class='macro'>VIM_ISWHITE(c)<span class='macro_popup'>((c) == ' ' || (c) == '\t')</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3499"><td class="num" id="LN3499">3499</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="3500"><td class="num" id="LN3500">3500</td><td class="line">		<span class='keyword'>if</span> (did_white)</td></tr>
<tr class="codeline" data-linenumber="3501"><td class="num" id="LN3501">3501</td><td class="line">		    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="3502"><td class="num" id="LN3502">3502</td><td class="line">		c = ' ';</td></tr>
<tr class="codeline" data-linenumber="3503"><td class="num" id="LN3503">3503</td><td class="line">		did_white = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3504"><td class="num" id="LN3504">3504</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="3505"><td class="num" id="LN3505">3505</td><td class="line">	    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="3506"><td class="num" id="LN3506">3506</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="3507"><td class="num" id="LN3507">3507</td><td class="line">		did_white = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3508"><td class="num" id="LN3508">3508</td><td class="line">		<span class='keyword'>if</span> (!spell_iswordp_nmw(t, curwin))</td></tr>
<tr class="codeline" data-linenumber="3509"><td class="num" id="LN3509">3509</td><td class="line">		    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="3510"><td class="num" id="LN3510">3510</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="3511"><td class="num" id="LN3511">3511</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="3512"><td class="num" id="LN3512">3512</td><td class="line">	word[wordlen++] = c;</td></tr>
<tr class="codeline" data-linenumber="3513"><td class="num" id="LN3513">3513</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="3514"><td class="num" id="LN3514">3514</td><td class="line">    word[wordlen] = <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3515"><td class="num" id="LN3515">3515</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3516"><td class="num" id="LN3516">3516</td><td class="line">    <span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="3517"><td class="num" id="LN3517">3517</td><td class="line">     <span class='comment'>* This algorithm comes from Aspell phonet.cpp.</span></td></tr>
<tr class="codeline" data-linenumber="3518"><td class="num" id="LN3518">3518</td><td class="line">     <span class='comment'>* Converted from C++ to C.  Added support for multi-byte chars.</span></td></tr>
<tr class="codeline" data-linenumber="3519"><td class="num" id="LN3519">3519</td><td class="line">     <span class='comment'>* Changed to keep spaces.</span></td></tr>
<tr class="codeline" data-linenumber="3520"><td class="num" id="LN3520">3520</td><td class="line">     <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="3521"><td class="num" id="LN3521">3521</td><td class="line">    i = reslen = z = 0;</td></tr>
<tr class="codeline" data-linenumber="3522"><td class="num" id="LN3522">3522</td><td class="line">    <span class='keyword'>while</span> ((c = word[i]) != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3523"><td class="num" id="LN3523">3523</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="3524"><td class="num" id="LN3524">3524</td><td class="line">	<span class='comment'>// Start with the first rule that has the character in the word.</span></td></tr>
<tr class="codeline" data-linenumber="3525"><td class="num" id="LN3525">3525</td><td class="line">	n = slang-&gt;sl_sal_first[c &amp; 0xff];</td></tr>
<tr class="codeline" data-linenumber="3526"><td class="num" id="LN3526">3526</td><td class="line">	z0 = 0;</td></tr>
<tr class="codeline" data-linenumber="3527"><td class="num" id="LN3527">3527</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3528"><td class="num" id="LN3528">3528</td><td class="line">	<span class='keyword'>if</span> (n &gt;= 0)</td></tr>
<tr class="codeline" data-linenumber="3529"><td class="num" id="LN3529">3529</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="3530"><td class="num" id="LN3530">3530</td><td class="line">	    <span class='comment'>// Check all rules for the same index byte.</span></td></tr>
<tr class="codeline" data-linenumber="3531"><td class="num" id="LN3531">3531</td><td class="line">	    <span class='comment'>// If c is 0x300 need extra check for the end of the array, as</span></td></tr>
<tr class="codeline" data-linenumber="3532"><td class="num" id="LN3532">3532</td><td class="line">	    <span class='comment'>// (c &amp; 0xff) is NUL.</span></td></tr>
<tr class="codeline" data-linenumber="3533"><td class="num" id="LN3533">3533</td><td class="line">	    <span class='keyword'>for</span> (; ((ws = smp[n].sm_lead_w)[0] &amp; 0xff) == (c &amp; 0xff)</td></tr>
<tr class="codeline" data-linenumber="3534"><td class="num" id="LN3534">3534</td><td class="line">							 &amp;&amp; ws[0] != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>; ++n)</td></tr>
<tr class="codeline" data-linenumber="3535"><td class="num" id="LN3535">3535</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="3536"><td class="num" id="LN3536">3536</td><td class="line">		<span class='comment'>// Quickly skip entries that don't match the word.  Most</span></td></tr>
<tr class="codeline" data-linenumber="3537"><td class="num" id="LN3537">3537</td><td class="line">		<span class='comment'>// entries are less then three chars, optimize for that.</span></td></tr>
<tr class="codeline" data-linenumber="3538"><td class="num" id="LN3538">3538</td><td class="line">		<span class='keyword'>if</span> (c != ws[0])</td></tr>
<tr class="codeline" data-linenumber="3539"><td class="num" id="LN3539">3539</td><td class="line">		    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="3540"><td class="num" id="LN3540">3540</td><td class="line">		k = smp[n].sm_leadlen;</td></tr>
<tr class="codeline" data-linenumber="3541"><td class="num" id="LN3541">3541</td><td class="line">		<span class='keyword'>if</span> (k &gt; 1)</td></tr>
<tr class="codeline" data-linenumber="3542"><td class="num" id="LN3542">3542</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="3543"><td class="num" id="LN3543">3543</td><td class="line">		    <span class='keyword'>if</span> (word[i + 1] != ws[1])</td></tr>
<tr class="codeline" data-linenumber="3544"><td class="num" id="LN3544">3544</td><td class="line">			<span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="3545"><td class="num" id="LN3545">3545</td><td class="line">		    <span class='keyword'>if</span> (k &gt; 2)</td></tr>
<tr class="codeline" data-linenumber="3546"><td class="num" id="LN3546">3546</td><td class="line">		    {</td></tr>
<tr class="codeline" data-linenumber="3547"><td class="num" id="LN3547">3547</td><td class="line">			<span class='keyword'>for</span> (j = 2; j &lt; k; ++j)</td></tr>
<tr class="codeline" data-linenumber="3548"><td class="num" id="LN3548">3548</td><td class="line">			    <span class='keyword'>if</span> (word[i + j] != ws[j])</td></tr>
<tr class="codeline" data-linenumber="3549"><td class="num" id="LN3549">3549</td><td class="line">				<span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="3550"><td class="num" id="LN3550">3550</td><td class="line">			<span class='keyword'>if</span> (j &lt; k)</td></tr>
<tr class="codeline" data-linenumber="3551"><td class="num" id="LN3551">3551</td><td class="line">			    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="3552"><td class="num" id="LN3552">3552</td><td class="line">		    }</td></tr>
<tr class="codeline" data-linenumber="3553"><td class="num" id="LN3553">3553</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="3554"><td class="num" id="LN3554">3554</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3555"><td class="num" id="LN3555">3555</td><td class="line">		<span class='keyword'>if</span> ((pf = smp[n].sm_oneof_w) != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3556"><td class="num" id="LN3556">3556</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="3557"><td class="num" id="LN3557">3557</td><td class="line">		    <span class='comment'>// Check for match with one of the chars in "sm_oneof".</span></td></tr>
<tr class="codeline" data-linenumber="3558"><td class="num" id="LN3558">3558</td><td class="line">		    <span class='keyword'>while</span> (*pf != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span> &amp;&amp; *pf != word[i + k])</td></tr>
<tr class="codeline" data-linenumber="3559"><td class="num" id="LN3559">3559</td><td class="line">			++pf;</td></tr>
<tr class="codeline" data-linenumber="3560"><td class="num" id="LN3560">3560</td><td class="line">		    <span class='keyword'>if</span> (*pf == <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3561"><td class="num" id="LN3561">3561</td><td class="line">			<span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="3562"><td class="num" id="LN3562">3562</td><td class="line">		    ++k;</td></tr>
<tr class="codeline" data-linenumber="3563"><td class="num" id="LN3563">3563</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="3564"><td class="num" id="LN3564">3564</td><td class="line">		s = smp[n].sm_rules;</td></tr>
<tr class="codeline" data-linenumber="3565"><td class="num" id="LN3565">3565</td><td class="line">		pri = 5;    <span class='comment'>// default priority</span></td></tr>
<tr class="codeline" data-linenumber="3566"><td class="num" id="LN3566">3566</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3567"><td class="num" id="LN3567">3567</td><td class="line">		p0 = *s;</td></tr>
<tr class="codeline" data-linenumber="3568"><td class="num" id="LN3568">3568</td><td class="line">		k0 = k;</td></tr>
<tr class="codeline" data-linenumber="3569"><td class="num" id="LN3569">3569</td><td class="line">		<span class='keyword'>while</span> (*s == '-' &amp;&amp; k &gt; 1)</td></tr>
<tr class="codeline" data-linenumber="3570"><td class="num" id="LN3570">3570</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="3571"><td class="num" id="LN3571">3571</td><td class="line">		    k--;</td></tr>
<tr class="codeline" data-linenumber="3572"><td class="num" id="LN3572">3572</td><td class="line">		    s++;</td></tr>
<tr class="codeline" data-linenumber="3573"><td class="num" id="LN3573">3573</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="3574"><td class="num" id="LN3574">3574</td><td class="line">		<span class='keyword'>if</span> (*s == '&lt;')</td></tr>
<tr class="codeline" data-linenumber="3575"><td class="num" id="LN3575">3575</td><td class="line">		    s++;</td></tr>
<tr class="codeline" data-linenumber="3576"><td class="num" id="LN3576">3576</td><td class="line">		<span class='keyword'>if</span> (<span class='macro'>VIM_ISDIGIT(*s)<span class='macro_popup'>((unsigned)(*s) - '0' &lt; 10)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3577"><td class="num" id="LN3577">3577</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="3578"><td class="num" id="LN3578">3578</td><td class="line">		    <span class='comment'>// determine priority</span></td></tr>
<tr class="codeline" data-linenumber="3579"><td class="num" id="LN3579">3579</td><td class="line">		    pri = *s - '0';</td></tr>
<tr class="codeline" data-linenumber="3580"><td class="num" id="LN3580">3580</td><td class="line">		    s++;</td></tr>
<tr class="codeline" data-linenumber="3581"><td class="num" id="LN3581">3581</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="3582"><td class="num" id="LN3582">3582</td><td class="line">		<span class='keyword'>if</span> (*s == '^' &amp;&amp; *(s + 1) == '^')</td></tr>
<tr class="codeline" data-linenumber="3583"><td class="num" id="LN3583">3583</td><td class="line">		    s++;</td></tr>
<tr class="codeline" data-linenumber="3584"><td class="num" id="LN3584">3584</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3585"><td class="num" id="LN3585">3585</td><td class="line">		<span class='keyword'>if</span> (*s == <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span></td></tr>
<tr class="codeline" data-linenumber="3586"><td class="num" id="LN3586">3586</td><td class="line">			|| (*s == '^'</td></tr>
<tr class="codeline" data-linenumber="3587"><td class="num" id="LN3587">3587</td><td class="line">			    &amp;&amp; (i == 0 || !(word[i - 1] == ' '</td></tr>
<tr class="codeline" data-linenumber="3588"><td class="num" id="LN3588">3588</td><td class="line">				    || spell_iswordp_w(word + i - 1, curwin)))</td></tr>
<tr class="codeline" data-linenumber="3589"><td class="num" id="LN3589">3589</td><td class="line">			    &amp;&amp; (*(s + 1) != '$'</td></tr>
<tr class="codeline" data-linenumber="3590"><td class="num" id="LN3590">3590</td><td class="line">				|| (!spell_iswordp_w(word + i + k0, curwin))))</td></tr>
<tr class="codeline" data-linenumber="3591"><td class="num" id="LN3591">3591</td><td class="line">			|| (*s == '$' &amp;&amp; i &gt; 0</td></tr>
<tr class="codeline" data-linenumber="3592"><td class="num" id="LN3592">3592</td><td class="line">			    &amp;&amp; spell_iswordp_w(word + i - 1, curwin)</td></tr>
<tr class="codeline" data-linenumber="3593"><td class="num" id="LN3593">3593</td><td class="line">			    &amp;&amp; (!spell_iswordp_w(word + i + k0, curwin))))</td></tr>
<tr class="codeline" data-linenumber="3594"><td class="num" id="LN3594">3594</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="3595"><td class="num" id="LN3595">3595</td><td class="line">		    <span class='comment'>// search for followup rules, if:</span></td></tr>
<tr class="codeline" data-linenumber="3596"><td class="num" id="LN3596">3596</td><td class="line">		    <span class='comment'>// followup and k &gt; 1  and  NO '-' in searchstring</span></td></tr>
<tr class="codeline" data-linenumber="3597"><td class="num" id="LN3597">3597</td><td class="line">		    c0 = word[i + k - 1];</td></tr>
<tr class="codeline" data-linenumber="3598"><td class="num" id="LN3598">3598</td><td class="line">		    n0 = slang-&gt;sl_sal_first[c0 &amp; 0xff];</td></tr>
<tr class="codeline" data-linenumber="3599"><td class="num" id="LN3599">3599</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3600"><td class="num" id="LN3600">3600</td><td class="line">		    <span class='keyword'>if</span> (slang-&gt;sl_followup &amp;&amp; k &gt; 1 &amp;&amp; n0 &gt;= 0</td></tr>
<tr class="codeline" data-linenumber="3601"><td class="num" id="LN3601">3601</td><td class="line">					   &amp;&amp; p0 != '-' &amp;&amp; word[i + k] != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3602"><td class="num" id="LN3602">3602</td><td class="line">		    {</td></tr>
<tr class="codeline" data-linenumber="3603"><td class="num" id="LN3603">3603</td><td class="line">			<span class='comment'>// Test follow-up rule for "word[i + k]"; loop over</span></td></tr>
<tr class="codeline" data-linenumber="3604"><td class="num" id="LN3604">3604</td><td class="line">			<span class='comment'>// all entries with the same index byte.</span></td></tr>
<tr class="codeline" data-linenumber="3605"><td class="num" id="LN3605">3605</td><td class="line">			<span class='keyword'>for</span> ( ; ((ws = smp[n0].sm_lead_w)[0] &amp; 0xff)</td></tr>
<tr class="codeline" data-linenumber="3606"><td class="num" id="LN3606">3606</td><td class="line">							 == (c0 &amp; 0xff); ++n0)</td></tr>
<tr class="codeline" data-linenumber="3607"><td class="num" id="LN3607">3607</td><td class="line">			{</td></tr>
<tr class="codeline" data-linenumber="3608"><td class="num" id="LN3608">3608</td><td class="line">			    <span class='comment'>// Quickly skip entries that don't match the word.</span></td></tr>
<tr class="codeline" data-linenumber="3609"><td class="num" id="LN3609">3609</td><td class="line">			    <span class='keyword'>if</span> (c0 != ws[0])</td></tr>
<tr class="codeline" data-linenumber="3610"><td class="num" id="LN3610">3610</td><td class="line">				<span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="3611"><td class="num" id="LN3611">3611</td><td class="line">			    k0 = smp[n0].sm_leadlen;</td></tr>
<tr class="codeline" data-linenumber="3612"><td class="num" id="LN3612">3612</td><td class="line">			    <span class='keyword'>if</span> (k0 &gt; 1)</td></tr>
<tr class="codeline" data-linenumber="3613"><td class="num" id="LN3613">3613</td><td class="line">			    {</td></tr>
<tr class="codeline" data-linenumber="3614"><td class="num" id="LN3614">3614</td><td class="line">				<span class='keyword'>if</span> (word[i + k] != ws[1])</td></tr>
<tr class="codeline" data-linenumber="3615"><td class="num" id="LN3615">3615</td><td class="line">				    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="3616"><td class="num" id="LN3616">3616</td><td class="line">				<span class='keyword'>if</span> (k0 &gt; 2)</td></tr>
<tr class="codeline" data-linenumber="3617"><td class="num" id="LN3617">3617</td><td class="line">				{</td></tr>
<tr class="codeline" data-linenumber="3618"><td class="num" id="LN3618">3618</td><td class="line">				    pf = word + i + k + 1;</td></tr>
<tr class="codeline" data-linenumber="3619"><td class="num" id="LN3619">3619</td><td class="line">				    <span class='keyword'>for</span> (j = 2; j &lt; k0; ++j)</td></tr>
<tr class="codeline" data-linenumber="3620"><td class="num" id="LN3620">3620</td><td class="line">					<span class='keyword'>if</span> (*pf++ != ws[j])</td></tr>
<tr class="codeline" data-linenumber="3621"><td class="num" id="LN3621">3621</td><td class="line">					    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="3622"><td class="num" id="LN3622">3622</td><td class="line">				    <span class='keyword'>if</span> (j &lt; k0)</td></tr>
<tr class="codeline" data-linenumber="3623"><td class="num" id="LN3623">3623</td><td class="line">					<span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="3624"><td class="num" id="LN3624">3624</td><td class="line">				}</td></tr>
<tr class="codeline" data-linenumber="3625"><td class="num" id="LN3625">3625</td><td class="line">			    }</td></tr>
<tr class="codeline" data-linenumber="3626"><td class="num" id="LN3626">3626</td><td class="line">			    k0 += k - 1;</td></tr>
<tr class="codeline" data-linenumber="3627"><td class="num" id="LN3627">3627</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3628"><td class="num" id="LN3628">3628</td><td class="line">			    <span class='keyword'>if</span> ((pf = smp[n0].sm_oneof_w) != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3629"><td class="num" id="LN3629">3629</td><td class="line">			    {</td></tr>
<tr class="codeline" data-linenumber="3630"><td class="num" id="LN3630">3630</td><td class="line">				<span class='comment'>// Check for match with one of the chars in</span></td></tr>
<tr class="codeline" data-linenumber="3631"><td class="num" id="LN3631">3631</td><td class="line">				<span class='comment'>// "sm_oneof".</span></td></tr>
<tr class="codeline" data-linenumber="3632"><td class="num" id="LN3632">3632</td><td class="line">				<span class='keyword'>while</span> (*pf != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span> &amp;&amp; *pf != word[i + k0])</td></tr>
<tr class="codeline" data-linenumber="3633"><td class="num" id="LN3633">3633</td><td class="line">				    ++pf;</td></tr>
<tr class="codeline" data-linenumber="3634"><td class="num" id="LN3634">3634</td><td class="line">				<span class='keyword'>if</span> (*pf == <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3635"><td class="num" id="LN3635">3635</td><td class="line">				    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="3636"><td class="num" id="LN3636">3636</td><td class="line">				++k0;</td></tr>
<tr class="codeline" data-linenumber="3637"><td class="num" id="LN3637">3637</td><td class="line">			    }</td></tr>
<tr class="codeline" data-linenumber="3638"><td class="num" id="LN3638">3638</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3639"><td class="num" id="LN3639">3639</td><td class="line">			    p0 = 5;</td></tr>
<tr class="codeline" data-linenumber="3640"><td class="num" id="LN3640">3640</td><td class="line">			    s = smp[n0].sm_rules;</td></tr>
<tr class="codeline" data-linenumber="3641"><td class="num" id="LN3641">3641</td><td class="line">			    <span class='keyword'>while</span> (*s == '-')</td></tr>
<tr class="codeline" data-linenumber="3642"><td class="num" id="LN3642">3642</td><td class="line">			    {</td></tr>
<tr class="codeline" data-linenumber="3643"><td class="num" id="LN3643">3643</td><td class="line">				<span class='comment'>// "k0" gets NOT reduced because</span></td></tr>
<tr class="codeline" data-linenumber="3644"><td class="num" id="LN3644">3644</td><td class="line">				<span class='comment'>// "if (k0 == k)"</span></td></tr>
<tr class="codeline" data-linenumber="3645"><td class="num" id="LN3645">3645</td><td class="line">				s++;</td></tr>
<tr class="codeline" data-linenumber="3646"><td class="num" id="LN3646">3646</td><td class="line">			    }</td></tr>
<tr class="codeline" data-linenumber="3647"><td class="num" id="LN3647">3647</td><td class="line">			    <span class='keyword'>if</span> (*s == '&lt;')</td></tr>
<tr class="codeline" data-linenumber="3648"><td class="num" id="LN3648">3648</td><td class="line">				s++;</td></tr>
<tr class="codeline" data-linenumber="3649"><td class="num" id="LN3649">3649</td><td class="line">			    <span class='keyword'>if</span> (<span class='macro'>VIM_ISDIGIT(*s)<span class='macro_popup'>((unsigned)(*s) - '0' &lt; 10)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3650"><td class="num" id="LN3650">3650</td><td class="line">			    {</td></tr>
<tr class="codeline" data-linenumber="3651"><td class="num" id="LN3651">3651</td><td class="line">				p0 = *s - '0';</td></tr>
<tr class="codeline" data-linenumber="3652"><td class="num" id="LN3652">3652</td><td class="line">				s++;</td></tr>
<tr class="codeline" data-linenumber="3653"><td class="num" id="LN3653">3653</td><td class="line">			    }</td></tr>
<tr class="codeline" data-linenumber="3654"><td class="num" id="LN3654">3654</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3655"><td class="num" id="LN3655">3655</td><td class="line">			    <span class='keyword'>if</span> (*s == <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span></td></tr>
<tr class="codeline" data-linenumber="3656"><td class="num" id="LN3656">3656</td><td class="line">				    <span class='comment'>// *s == '^' cuts</span></td></tr>
<tr class="codeline" data-linenumber="3657"><td class="num" id="LN3657">3657</td><td class="line">				    || (*s == '$'</td></tr>
<tr class="codeline" data-linenumber="3658"><td class="num" id="LN3658">3658</td><td class="line">					 &amp;&amp; !spell_iswordp_w(word + i + k0,</td></tr>
<tr class="codeline" data-linenumber="3659"><td class="num" id="LN3659">3659</td><td class="line">								     curwin)))</td></tr>
<tr class="codeline" data-linenumber="3660"><td class="num" id="LN3660">3660</td><td class="line">			    {</td></tr>
<tr class="codeline" data-linenumber="3661"><td class="num" id="LN3661">3661</td><td class="line">				<span class='keyword'>if</span> (k0 == k)</td></tr>
<tr class="codeline" data-linenumber="3662"><td class="num" id="LN3662">3662</td><td class="line">				    <span class='comment'>// this is just a piece of the string</span></td></tr>
<tr class="codeline" data-linenumber="3663"><td class="num" id="LN3663">3663</td><td class="line">				    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="3664"><td class="num" id="LN3664">3664</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3665"><td class="num" id="LN3665">3665</td><td class="line">				<span class='keyword'>if</span> (p0 &lt; pri)</td></tr>
<tr class="codeline" data-linenumber="3666"><td class="num" id="LN3666">3666</td><td class="line">				    <span class='comment'>// priority too low</span></td></tr>
<tr class="codeline" data-linenumber="3667"><td class="num" id="LN3667">3667</td><td class="line">				    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="3668"><td class="num" id="LN3668">3668</td><td class="line">				<span class='comment'>// rule fits; stop search</span></td></tr>
<tr class="codeline" data-linenumber="3669"><td class="num" id="LN3669">3669</td><td class="line">				<span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="3670"><td class="num" id="LN3670">3670</td><td class="line">			    }</td></tr>
<tr class="codeline" data-linenumber="3671"><td class="num" id="LN3671">3671</td><td class="line">			}</td></tr>
<tr class="codeline" data-linenumber="3672"><td class="num" id="LN3672">3672</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3673"><td class="num" id="LN3673">3673</td><td class="line">			<span class='keyword'>if</span> (p0 &gt;= pri &amp;&amp; (smp[n0].sm_lead_w[0] &amp; 0xff)</td></tr>
<tr class="codeline" data-linenumber="3674"><td class="num" id="LN3674">3674</td><td class="line">							       == (c0 &amp; 0xff))</td></tr>
<tr class="codeline" data-linenumber="3675"><td class="num" id="LN3675">3675</td><td class="line">			    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="3676"><td class="num" id="LN3676">3676</td><td class="line">		    }</td></tr>
<tr class="codeline" data-linenumber="3677"><td class="num" id="LN3677">3677</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3678"><td class="num" id="LN3678">3678</td><td class="line">		    <span class='comment'>// replace string</span></td></tr>
<tr class="codeline" data-linenumber="3679"><td class="num" id="LN3679">3679</td><td class="line">		    ws = smp[n].sm_to_w;</td></tr>
<tr class="codeline" data-linenumber="3680"><td class="num" id="LN3680">3680</td><td class="line">		    s = smp[n].sm_rules;</td></tr>
<tr class="codeline" data-linenumber="3681"><td class="num" id="LN3681">3681</td><td class="line">		    p0 = (vim_strchr(s, '&lt;') != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>) ? 1 : 0;</td></tr>
<tr class="codeline" data-linenumber="3682"><td class="num" id="LN3682">3682</td><td class="line">		    <span class='keyword'>if</span> (p0 == 1 &amp;&amp; z == 0)</td></tr>
<tr class="codeline" data-linenumber="3683"><td class="num" id="LN3683">3683</td><td class="line">		    {</td></tr>
<tr class="codeline" data-linenumber="3684"><td class="num" id="LN3684">3684</td><td class="line">			<span class='comment'>// rule with '&lt;' is used</span></td></tr>
<tr class="codeline" data-linenumber="3685"><td class="num" id="LN3685">3685</td><td class="line">			<span class='keyword'>if</span> (reslen &gt; 0 &amp;&amp; ws != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span> &amp;&amp; *ws != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span></td></tr>
<tr class="codeline" data-linenumber="3686"><td class="num" id="LN3686">3686</td><td class="line">				&amp;&amp; (wres[reslen - 1] == c</td></tr>
<tr class="codeline" data-linenumber="3687"><td class="num" id="LN3687">3687</td><td class="line">						    || wres[reslen - 1] == *ws))</td></tr>
<tr class="codeline" data-linenumber="3688"><td class="num" id="LN3688">3688</td><td class="line">			    reslen--;</td></tr>
<tr class="codeline" data-linenumber="3689"><td class="num" id="LN3689">3689</td><td class="line">			z0 = 1;</td></tr>
<tr class="codeline" data-linenumber="3690"><td class="num" id="LN3690">3690</td><td class="line">			z = 1;</td></tr>
<tr class="codeline" data-linenumber="3691"><td class="num" id="LN3691">3691</td><td class="line">			k0 = 0;</td></tr>
<tr class="codeline" data-linenumber="3692"><td class="num" id="LN3692">3692</td><td class="line">			<span class='keyword'>if</span> (ws != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3693"><td class="num" id="LN3693">3693</td><td class="line">			    <span class='keyword'>while</span> (*ws != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span> &amp;&amp; word[i + k0] != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3694"><td class="num" id="LN3694">3694</td><td class="line">			    {</td></tr>
<tr class="codeline" data-linenumber="3695"><td class="num" id="LN3695">3695</td><td class="line">				word[i + k0] = *ws;</td></tr>
<tr class="codeline" data-linenumber="3696"><td class="num" id="LN3696">3696</td><td class="line">				k0++;</td></tr>
<tr class="codeline" data-linenumber="3697"><td class="num" id="LN3697">3697</td><td class="line">				ws++;</td></tr>
<tr class="codeline" data-linenumber="3698"><td class="num" id="LN3698">3698</td><td class="line">			    }</td></tr>
<tr class="codeline" data-linenumber="3699"><td class="num" id="LN3699">3699</td><td class="line">			<span class='keyword'>if</span> (k &gt; k0)</td></tr>
<tr class="codeline" data-linenumber="3700"><td class="num" id="LN3700">3700</td><td class="line">			    <span class='macro'>mch_memmove(word + i + k0, word + i + k,<span class='macro_popup'>memmove((char *)(word + i + k0), (char *)(word + i + k), sizeof<br>(int) * (wordlen - (i + k) + 1))</span></span></td></tr>
<tr class="codeline" data-linenumber="3701"><td class="num" id="LN3701">3701</td><td class="line">				    <span class='keyword'><span class='macro'>sizeof</span>(<span class='keyword'>int</span>) * (wordlen - (i + k) + 1))<span class='macro_popup'>memmove((char *)(word + i + k0), (char *)(word + i + k), sizeof<br>(int) * (wordlen - (i + k) + 1))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3702"><td class="num" id="LN3702">3702</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3703"><td class="num" id="LN3703">3703</td><td class="line">			<span class='comment'>// new "actual letter"</span></td></tr>
<tr class="codeline" data-linenumber="3704"><td class="num" id="LN3704">3704</td><td class="line">			c = word[i];</td></tr>
<tr class="codeline" data-linenumber="3705"><td class="num" id="LN3705">3705</td><td class="line">		    }</td></tr>
<tr class="codeline" data-linenumber="3706"><td class="num" id="LN3706">3706</td><td class="line">		    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="3707"><td class="num" id="LN3707">3707</td><td class="line">		    {</td></tr>
<tr class="codeline" data-linenumber="3708"><td class="num" id="LN3708">3708</td><td class="line">			<span class='comment'>// no '&lt;' rule used</span></td></tr>
<tr class="codeline" data-linenumber="3709"><td class="num" id="LN3709">3709</td><td class="line">			i += k - 1;</td></tr>
<tr class="codeline" data-linenumber="3710"><td class="num" id="LN3710">3710</td><td class="line">			z = 0;</td></tr>
<tr class="codeline" data-linenumber="3711"><td class="num" id="LN3711">3711</td><td class="line">			<span class='keyword'>if</span> (ws != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3712"><td class="num" id="LN3712">3712</td><td class="line">			    <span class='keyword'>while</span> (*ws != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span> &amp;&amp; ws[1] != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span></td></tr>
<tr class="codeline" data-linenumber="3713"><td class="num" id="LN3713">3713</td><td class="line">							  &amp;&amp; reslen &lt; <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3714"><td class="num" id="LN3714">3714</td><td class="line">			    {</td></tr>
<tr class="codeline" data-linenumber="3715"><td class="num" id="LN3715">3715</td><td class="line">				<span class='keyword'>if</span> (reslen == 0 || wres[reslen - 1] != *ws)</td></tr>
<tr class="codeline" data-linenumber="3716"><td class="num" id="LN3716">3716</td><td class="line">				    wres[reslen++] = *ws;</td></tr>
<tr class="codeline" data-linenumber="3717"><td class="num" id="LN3717">3717</td><td class="line">				ws++;</td></tr>
<tr class="codeline" data-linenumber="3718"><td class="num" id="LN3718">3718</td><td class="line">			    }</td></tr>
<tr class="codeline" data-linenumber="3719"><td class="num" id="LN3719">3719</td><td class="line">			<span class='comment'>// new "actual letter"</span></td></tr>
<tr class="codeline" data-linenumber="3720"><td class="num" id="LN3720">3720</td><td class="line">			<span class='keyword'>if</span> (ws == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3721"><td class="num" id="LN3721">3721</td><td class="line">			    c = <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3722"><td class="num" id="LN3722">3722</td><td class="line">			<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="3723"><td class="num" id="LN3723">3723</td><td class="line">			    c = *ws;</td></tr>
<tr class="codeline" data-linenumber="3724"><td class="num" id="LN3724">3724</td><td class="line">			<span class='keyword'>if</span> (strstr((<span class='keyword'>char</span> *)s, <span class='string_literal'>"^^"</span>) != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3725"><td class="num" id="LN3725">3725</td><td class="line">			{</td></tr>
<tr class="codeline" data-linenumber="3726"><td class="num" id="LN3726">3726</td><td class="line">			    <span class='keyword'>if</span> (c != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3727"><td class="num" id="LN3727">3727</td><td class="line">				wres[reslen++] = c;</td></tr>
<tr class="codeline" data-linenumber="3728"><td class="num" id="LN3728">3728</td><td class="line">			    <span class='macro'>mch_memmove(word, word + i + 1,<span class='macro_popup'>memmove((char *)(word), (char *)(word + i + 1), sizeof(int) *<br> (wordlen - (i + 1) + 1))</span></span></td></tr>
<tr class="codeline" data-linenumber="3729"><td class="num" id="LN3729">3729</td><td class="line">				       <span class='keyword'><span class='macro'>sizeof</span>(<span class='keyword'>int</span>) * (wordlen - (i + 1) + 1))<span class='macro_popup'>memmove((char *)(word), (char *)(word + i + 1), sizeof(int) *<br> (wordlen - (i + 1) + 1))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3730"><td class="num" id="LN3730">3730</td><td class="line">			    i = 0;</td></tr>
<tr class="codeline" data-linenumber="3731"><td class="num" id="LN3731">3731</td><td class="line">			    z0 = 1;</td></tr>
<tr class="codeline" data-linenumber="3732"><td class="num" id="LN3732">3732</td><td class="line">			}</td></tr>
<tr class="codeline" data-linenumber="3733"><td class="num" id="LN3733">3733</td><td class="line">		    }</td></tr>
<tr class="codeline" data-linenumber="3734"><td class="num" id="LN3734">3734</td><td class="line">		    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="3735"><td class="num" id="LN3735">3735</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="3736"><td class="num" id="LN3736">3736</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="3737"><td class="num" id="LN3737">3737</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="3738"><td class="num" id="LN3738">3738</td><td class="line">	<span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>VIM_ISWHITE(c)<span class='macro_popup'>((c) == ' ' || (c) == '\t')</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3739"><td class="num" id="LN3739">3739</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="3740"><td class="num" id="LN3740">3740</td><td class="line">	    c = ' ';</td></tr>
<tr class="codeline" data-linenumber="3741"><td class="num" id="LN3741">3741</td><td class="line">	    k = 1;</td></tr>
<tr class="codeline" data-linenumber="3742"><td class="num" id="LN3742">3742</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="3743"><td class="num" id="LN3743">3743</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3744"><td class="num" id="LN3744">3744</td><td class="line">	<span class='keyword'>if</span> (z0 == 0)</td></tr>
<tr class="codeline" data-linenumber="3745"><td class="num" id="LN3745">3745</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="3746"><td class="num" id="LN3746">3746</td><td class="line">	    <span class='keyword'>if</span> (k &amp;&amp; !p0 &amp;&amp; reslen &lt; <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span> &amp;&amp; c != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span></td></tr>
<tr class="codeline" data-linenumber="3747"><td class="num" id="LN3747">3747</td><td class="line">		    &amp;&amp; (!slang-&gt;sl_collapse || reslen == 0</td></tr>
<tr class="codeline" data-linenumber="3748"><td class="num" id="LN3748">3748</td><td class="line">						     || wres[reslen - 1] != c))</td></tr>
<tr class="codeline" data-linenumber="3749"><td class="num" id="LN3749">3749</td><td class="line">		<span class='comment'>// condense only double letters</span></td></tr>
<tr class="codeline" data-linenumber="3750"><td class="num" id="LN3750">3750</td><td class="line">		wres[reslen++] = c;</td></tr>
<tr class="codeline" data-linenumber="3751"><td class="num" id="LN3751">3751</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3752"><td class="num" id="LN3752">3752</td><td class="line">	    i++;</td></tr>
<tr class="codeline" data-linenumber="3753"><td class="num" id="LN3753">3753</td><td class="line">	    z = 0;</td></tr>
<tr class="codeline" data-linenumber="3754"><td class="num" id="LN3754">3754</td><td class="line">	    k = 0;</td></tr>
<tr class="codeline" data-linenumber="3755"><td class="num" id="LN3755">3755</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="3756"><td class="num" id="LN3756">3756</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="3757"><td class="num" id="LN3757">3757</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3758"><td class="num" id="LN3758">3758</td><td class="line">    <span class='comment'>// Convert wide characters in "wres" to a multi-byte string in "res".</span></td></tr>
<tr class="codeline" data-linenumber="3759"><td class="num" id="LN3759">3759</td><td class="line">    l = 0;</td></tr>
<tr class="codeline" data-linenumber="3760"><td class="num" id="LN3760">3760</td><td class="line">    <span class='keyword'>for</span> (n = 0; n &lt; reslen; ++n)</td></tr>
<tr class="codeline" data-linenumber="3761"><td class="num" id="LN3761">3761</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="3762"><td class="num" id="LN3762">3762</td><td class="line">	l += mb_char2bytes(wres[n], res + l);</td></tr>
<tr class="codeline" data-linenumber="3763"><td class="num" id="LN3763">3763</td><td class="line">	<span class='keyword'>if</span> (l + <span class='macro'>MB_MAXBYTES<span class='macro_popup'>21</span></span> &gt; <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3764"><td class="num" id="LN3764">3764</td><td class="line">	    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="3765"><td class="num" id="LN3765">3765</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="3766"><td class="num" id="LN3766">3766</td><td class="line">    res[l] = <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3767"><td class="num" id="LN3767">3767</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="3768"><td class="num" id="LN3768">3768</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3769"><td class="num" id="LN3769">3769</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="3770"><td class="num" id="LN3770">3770</td><td class="line"> <span class='comment'>* ":spellinfo"</span></td></tr>
<tr class="codeline" data-linenumber="3771"><td class="num" id="LN3771">3771</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="3772"><td class="num" id="LN3772">3772</td><td class="line">    <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="3773"><td class="num" id="LN3773">3773</td><td class="line">ex_spellinfo(exarg_T *eap <span class='macro'>UNUSED<span class='macro_popup'>__attribute__((unused))</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3774"><td class="num" id="LN3774">3774</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="3775"><td class="num" id="LN3775">3775</td><td class="line">    <span class='keyword'>int</span>		lpi;</td></tr>
<tr class="codeline" data-linenumber="3776"><td class="num" id="LN3776">3776</td><td class="line">    langp_T	*lp;</td></tr>
<tr class="codeline" data-linenumber="3777"><td class="num" id="LN3777">3777</td><td class="line">    char_u	*p;</td></tr>
<tr class="codeline" data-linenumber="3778"><td class="num" id="LN3778">3778</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3779"><td class="num" id="LN3779">3779</td><td class="line">    <span class='keyword'>if</span> (no_spell_checking(curwin))</td></tr>
<tr class="codeline" data-linenumber="3780"><td class="num" id="LN3780">3780</td><td class="line">	<span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="3781"><td class="num" id="LN3781">3781</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3782"><td class="num" id="LN3782">3782</td><td class="line">    msg_start();</td></tr>
<tr class="codeline" data-linenumber="3783"><td class="num" id="LN3783">3783</td><td class="line">    <span class='keyword'>for</span> (lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len &amp;&amp; !got_int; ++lpi)</td></tr>
<tr class="codeline" data-linenumber="3784"><td class="num" id="LN3784">3784</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="3785"><td class="num" id="LN3785">3785</td><td class="line">	lp = <span class='macro'>LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi)<span class='macro_popup'>(((langp_T *)(curwin-&gt;w_s-&gt;b_langp).ga_data) + (lpi))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3786"><td class="num" id="LN3786">3786</td><td class="line">	msg_puts(<span class='string_literal'>"file: "</span>);</td></tr>
<tr class="codeline" data-linenumber="3787"><td class="num" id="LN3787">3787</td><td class="line">	msg_puts((<span class='keyword'>char</span> *)lp-&gt;lp_slang-&gt;sl_fname);</td></tr>
<tr class="codeline" data-linenumber="3788"><td class="num" id="LN3788">3788</td><td class="line">	msg_putchar('\n');</td></tr>
<tr class="codeline" data-linenumber="3789"><td class="num" id="LN3789">3789</td><td class="line">	p = lp-&gt;lp_slang-&gt;sl_info;</td></tr>
<tr class="codeline" data-linenumber="3790"><td class="num" id="LN3790">3790</td><td class="line">	<span class='keyword'>if</span> (p != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3791"><td class="num" id="LN3791">3791</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="3792"><td class="num" id="LN3792">3792</td><td class="line">	    msg_puts((<span class='keyword'>char</span> *)p);</td></tr>
<tr class="codeline" data-linenumber="3793"><td class="num" id="LN3793">3793</td><td class="line">	    msg_putchar('\n');</td></tr>
<tr class="codeline" data-linenumber="3794"><td class="num" id="LN3794">3794</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="3795"><td class="num" id="LN3795">3795</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="3796"><td class="num" id="LN3796">3796</td><td class="line">    msg_end();</td></tr>
<tr class="codeline" data-linenumber="3797"><td class="num" id="LN3797">3797</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="3798"><td class="num" id="LN3798">3798</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3799"><td class="num" id="LN3799">3799</td><td class="line"><span class='directive'>#define <span class='macro'>DUMPFLAG_KEEPCASE<span class='macro_popup'>1</span></span>   1	// round 2: keep-case tree</span></td></tr>
<tr class="codeline" data-linenumber="3800"><td class="num" id="LN3800">3800</td><td class="line"><span class='directive'>#define <span class='macro'>DUMPFLAG_COUNT<span class='macro_popup'>2</span></span>	    2	// include word count</span></td></tr>
<tr class="codeline" data-linenumber="3801"><td class="num" id="LN3801">3801</td><td class="line"><span class='directive'>#define <span class='macro'>DUMPFLAG_ICASE<span class='macro_popup'>4</span></span>	    4	// ignore case when finding matches</span></td></tr>
<tr class="codeline" data-linenumber="3802"><td class="num" id="LN3802">3802</td><td class="line"><span class='directive'>#define <span class='macro'>DUMPFLAG_ONECAP<span class='macro_popup'>8</span></span>	    8	// pattern starts with capital</span></td></tr>
<tr class="codeline" data-linenumber="3803"><td class="num" id="LN3803">3803</td><td class="line"><span class='directive'>#define <span class='macro'>DUMPFLAG_ALLCAP<span class='macro_popup'>16</span></span>	    16	// pattern is all capitals</span></td></tr>
<tr class="codeline" data-linenumber="3804"><td class="num" id="LN3804">3804</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3805"><td class="num" id="LN3805">3805</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="3806"><td class="num" id="LN3806">3806</td><td class="line"> <span class='comment'>* ":spelldump"</span></td></tr>
<tr class="codeline" data-linenumber="3807"><td class="num" id="LN3807">3807</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="3808"><td class="num" id="LN3808">3808</td><td class="line">    <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="3809"><td class="num" id="LN3809">3809</td><td class="line">ex_spelldump(exarg_T *eap)</td></tr>
<tr class="codeline" data-linenumber="3810"><td class="num" id="LN3810">3810</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="3811"><td class="num" id="LN3811">3811</td><td class="line">    char_u  *spl;</td></tr>
<tr class="codeline" data-linenumber="3812"><td class="num" id="LN3812">3812</td><td class="line">    <span class='keyword'>long</span>    dummy;</td></tr>
<tr class="codeline" data-linenumber="3813"><td class="num" id="LN3813">3813</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3814"><td class="num" id="LN3814">3814</td><td class="line">    <span class='keyword'>if</span> (no_spell_checking(curwin))</td></tr>
<tr class="codeline" data-linenumber="3815"><td class="num" id="LN3815">3815</td><td class="line">	<span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="3816"><td class="num" id="LN3816">3816</td><td class="line">    get_option_value((char_u*)<span class='string_literal'>"spl"</span>, &amp;dummy, &amp;spl, <span class='macro'>OPT_LOCAL<span class='macro_popup'>0x04</span></span>);</td></tr>
<tr class="codeline" data-linenumber="3817"><td class="num" id="LN3817">3817</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3818"><td class="num" id="LN3818">3818</td><td class="line">    <span class='comment'>// Create a new empty buffer in a new window.</span></td></tr>
<tr class="codeline" data-linenumber="3819"><td class="num" id="LN3819">3819</td><td class="line">    do_cmdline_cmd((char_u *)<span class='string_literal'>"new"</span>);</td></tr>
<tr class="codeline" data-linenumber="3820"><td class="num" id="LN3820">3820</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3821"><td class="num" id="LN3821">3821</td><td class="line">    <span class='comment'>// enable spelling locally in the new window</span></td></tr>
<tr class="codeline" data-linenumber="3822"><td class="num" id="LN3822">3822</td><td class="line">    set_option_value((char_u*)<span class='string_literal'>"spell"</span>, <span class='macro'>TRUE<span class='macro_popup'>1</span></span>, (char_u*)<span class='string_literal'>""</span>, <span class='macro'>OPT_LOCAL<span class='macro_popup'>0x04</span></span>);</td></tr>
<tr class="codeline" data-linenumber="3823"><td class="num" id="LN3823">3823</td><td class="line">    set_option_value((char_u*)<span class='string_literal'>"spl"</span>,  dummy, spl, <span class='macro'>OPT_LOCAL<span class='macro_popup'>0x04</span></span>);</td></tr>
<tr class="codeline" data-linenumber="3824"><td class="num" id="LN3824">3824</td><td class="line">    vim_free(spl);</td></tr>
<tr class="codeline" data-linenumber="3825"><td class="num" id="LN3825">3825</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3826"><td class="num" id="LN3826">3826</td><td class="line">    <span class='keyword'>if</span> (!<span class='macro'>BUFEMPTY()<span class='macro_popup'>(curbuf-&gt;b_ml.ml_line_count == 1 &amp;&amp; *ml_get((linenr_T<br>)1) == '\000')</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3827"><td class="num" id="LN3827">3827</td><td class="line">	<span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="3828"><td class="num" id="LN3828">3828</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3829"><td class="num" id="LN3829">3829</td><td class="line">    spell_dump_compl(<span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>, 0, <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>, eap-&gt;forceit ? <span class='macro'>DUMPFLAG_COUNT<span class='macro_popup'>2</span></span> : 0);</td></tr>
<tr class="codeline" data-linenumber="3830"><td class="num" id="LN3830">3830</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3831"><td class="num" id="LN3831">3831</td><td class="line">    <span class='comment'>// Delete the empty line that we started with.</span></td></tr>
<tr class="codeline" data-linenumber="3832"><td class="num" id="LN3832">3832</td><td class="line">    <span class='keyword'>if</span> (curbuf-&gt;b_ml.ml_line_count &gt; 1)</td></tr>
<tr class="codeline" data-linenumber="3833"><td class="num" id="LN3833">3833</td><td class="line">	ml_delete(curbuf-&gt;b_ml.ml_line_count);</td></tr>
<tr class="codeline" data-linenumber="3834"><td class="num" id="LN3834">3834</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3835"><td class="num" id="LN3835">3835</td><td class="line">    redraw_later(<span class='macro'>NOT_VALID<span class='macro_popup'>40</span></span>);</td></tr>
<tr class="codeline" data-linenumber="3836"><td class="num" id="LN3836">3836</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="3837"><td class="num" id="LN3837">3837</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3838"><td class="num" id="LN3838">3838</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="3839"><td class="num" id="LN3839">3839</td><td class="line"> <span class='comment'>* Go through all possible words and:</span></td></tr>
<tr class="codeline" data-linenumber="3840"><td class="num" id="LN3840">3840</td><td class="line"> <span class='comment'>* 1. When "pat" is NULL: dump a list of all words in the current buffer.</span></td></tr>
<tr class="codeline" data-linenumber="3841"><td class="num" id="LN3841">3841</td><td class="line"> <span class='comment'>*	"ic" and "dir" are not used.</span></td></tr>
<tr class="codeline" data-linenumber="3842"><td class="num" id="LN3842">3842</td><td class="line"> <span class='comment'>* 2. When "pat" is not NULL: add matching words to insert mode completion.</span></td></tr>
<tr class="codeline" data-linenumber="3843"><td class="num" id="LN3843">3843</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="3844"><td class="num" id="LN3844">3844</td><td class="line">    <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="3845"><td class="num" id="LN3845">3845</td><td class="line">spell_dump_compl(</td></tr>
<tr class="codeline" data-linenumber="3846"><td class="num" id="LN3846">3846</td><td class="line">    char_u	*pat,	    <span class='comment'>// leading part of the word</span></td></tr>
<tr class="codeline" data-linenumber="3847"><td class="num" id="LN3847">3847</td><td class="line">    <span class='keyword'>int</span>		ic,	    <span class='comment'>// ignore case</span></td></tr>
<tr class="codeline" data-linenumber="3848"><td class="num" id="LN3848">3848</td><td class="line">    <span class='keyword'>int</span>		*dir,	    <span class='comment'>// direction for adding matches</span></td></tr>
<tr class="codeline" data-linenumber="3849"><td class="num" id="LN3849">3849</td><td class="line">    <span class='keyword'>int</span>		dumpflags_arg)	<span class='comment'>// DUMPFLAG_*</span></td></tr>
<tr class="codeline" data-linenumber="3850"><td class="num" id="LN3850">3850</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="3851"><td class="num" id="LN3851">3851</td><td class="line">    langp_T	*lp;</td></tr>
<tr class="codeline" data-linenumber="3852"><td class="num" id="LN3852">3852</td><td class="line">    slang_T	*slang;</td></tr>
<tr class="codeline" data-linenumber="3853"><td class="num" id="LN3853">3853</td><td class="line">    idx_T	arridx[<span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>];</td></tr>
<tr class="codeline" data-linenumber="3854"><td class="num" id="LN3854">3854</td><td class="line">    <span class='keyword'>int</span>		curi[<span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>];</td></tr>
<tr class="codeline" data-linenumber="3855"><td class="num" id="LN3855">3855</td><td class="line">    char_u	word[<span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>];</td></tr>
<tr class="codeline" data-linenumber="3856"><td class="num" id="LN3856">3856</td><td class="line">    <span class='keyword'>int</span>		c;</td></tr>
<tr class="codeline" data-linenumber="3857"><td class="num" id="LN3857">3857</td><td class="line">    char_u	*byts;</td></tr>
<tr class="codeline" data-linenumber="3858"><td class="num" id="LN3858">3858</td><td class="line">    idx_T	*idxs;</td></tr>
<tr class="codeline" data-linenumber="3859"><td class="num" id="LN3859">3859</td><td class="line">    linenr_T	lnum = 0;</td></tr>
<tr class="codeline" data-linenumber="3860"><td class="num" id="LN3860">3860</td><td class="line">    <span class='keyword'>int</span>		round;</td></tr>
<tr class="codeline" data-linenumber="3861"><td class="num" id="LN3861">3861</td><td class="line">    <span class='keyword'>int</span>		depth;</td></tr>
<tr class="codeline" data-linenumber="3862"><td class="num" id="LN3862">3862</td><td class="line">    <span class='keyword'>int</span>		n;</td></tr>
<tr class="codeline" data-linenumber="3863"><td class="num" id="LN3863">3863</td><td class="line">    <span class='keyword'>int</span>		flags;</td></tr>
<tr class="codeline" data-linenumber="3864"><td class="num" id="LN3864">3864</td><td class="line">    char_u	*region_names = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;	    <span class='comment'>// region names being used</span></td></tr>
<tr class="codeline" data-linenumber="3865"><td class="num" id="LN3865">3865</td><td class="line">    <span class='keyword'>int</span>		do_region = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;	    <span class='comment'>// dump region names and numbers</span></td></tr>
<tr class="codeline" data-linenumber="3866"><td class="num" id="LN3866">3866</td><td class="line">    char_u	*p;</td></tr>
<tr class="codeline" data-linenumber="3867"><td class="num" id="LN3867">3867</td><td class="line">    <span class='keyword'>int</span>		lpi;</td></tr>
<tr class="codeline" data-linenumber="3868"><td class="num" id="LN3868">3868</td><td class="line">    <span class='keyword'>int</span>		dumpflags = dumpflags_arg;</td></tr>
<tr class="codeline" data-linenumber="3869"><td class="num" id="LN3869">3869</td><td class="line">    <span class='keyword'>int</span>		patlen;</td></tr>
<tr class="codeline" data-linenumber="3870"><td class="num" id="LN3870">3870</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3871"><td class="num" id="LN3871">3871</td><td class="line">    <span class='comment'>// When ignoring case or when the pattern starts with capital pass this on</span></td></tr>
<tr class="codeline" data-linenumber="3872"><td class="num" id="LN3872">3872</td><td class="line">    <span class='comment'>// to dump_word().</span></td></tr>
<tr class="codeline" data-linenumber="3873"><td class="num" id="LN3873">3873</td><td class="line">    <span class='keyword'>if</span> (pat != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3874"><td class="num" id="LN3874">3874</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="3875"><td class="num" id="LN3875">3875</td><td class="line">	<span class='keyword'>if</span> (ic)</td></tr>
<tr class="codeline" data-linenumber="3876"><td class="num" id="LN3876">3876</td><td class="line">	    dumpflags |= <span class='macro'>DUMPFLAG_ICASE<span class='macro_popup'>4</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3877"><td class="num" id="LN3877">3877</td><td class="line">	<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="3878"><td class="num" id="LN3878">3878</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="3879"><td class="num" id="LN3879">3879</td><td class="line">	    n = captype(pat, <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>);</td></tr>
<tr class="codeline" data-linenumber="3880"><td class="num" id="LN3880">3880</td><td class="line">	    <span class='keyword'>if</span> (n == <span class='macro'>WF_ONECAP<span class='macro_popup'>0x02</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3881"><td class="num" id="LN3881">3881</td><td class="line">		dumpflags |= <span class='macro'>DUMPFLAG_ONECAP<span class='macro_popup'>8</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3882"><td class="num" id="LN3882">3882</td><td class="line">	    <span class='keyword'>else</span> <span class='keyword'>if</span> (n == <span class='macro'>WF_ALLCAP<span class='macro_popup'>0x04</span></span> &amp;&amp; (<span class='keyword'>int</span>)<span class='macro'>STRLEN(pat)<span class='macro_popup'>strlen((char *)(pat))</span></span> &gt; mb_ptr2len(pat))</td></tr>
<tr class="codeline" data-linenumber="3883"><td class="num" id="LN3883">3883</td><td class="line">		dumpflags |= <span class='macro'>DUMPFLAG_ALLCAP<span class='macro_popup'>16</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3884"><td class="num" id="LN3884">3884</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="3885"><td class="num" id="LN3885">3885</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="3886"><td class="num" id="LN3886">3886</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3887"><td class="num" id="LN3887">3887</td><td class="line">    <span class='comment'>// Find out if we can support regions: All languages must support the same</span></td></tr>
<tr class="codeline" data-linenumber="3888"><td class="num" id="LN3888">3888</td><td class="line">    <span class='comment'>// regions or none at all.</span></td></tr>
<tr class="codeline" data-linenumber="3889"><td class="num" id="LN3889">3889</td><td class="line">    <span class='keyword'>for</span> (lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi)</td></tr>
<tr class="codeline" data-linenumber="3890"><td class="num" id="LN3890">3890</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="3891"><td class="num" id="LN3891">3891</td><td class="line">	lp = <span class='macro'>LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi)<span class='macro_popup'>(((langp_T *)(curwin-&gt;w_s-&gt;b_langp).ga_data) + (lpi))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3892"><td class="num" id="LN3892">3892</td><td class="line">	p = lp-&gt;lp_slang-&gt;sl_regions;</td></tr>
<tr class="codeline" data-linenumber="3893"><td class="num" id="LN3893">3893</td><td class="line">	<span class='keyword'>if</span> (p[0] != 0)</td></tr>
<tr class="codeline" data-linenumber="3894"><td class="num" id="LN3894">3894</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="3895"><td class="num" id="LN3895">3895</td><td class="line">	    <span class='keyword'>if</span> (region_names == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)	    <span class='comment'>// first language with regions</span></td></tr>
<tr class="codeline" data-linenumber="3896"><td class="num" id="LN3896">3896</td><td class="line">		region_names = p;</td></tr>
<tr class="codeline" data-linenumber="3897"><td class="num" id="LN3897">3897</td><td class="line">	    <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>STRCMP(region_names, p)<span class='macro_popup'>strcmp((char *)(region_names), (char *)(p))</span></span> != 0)</td></tr>
<tr class="codeline" data-linenumber="3898"><td class="num" id="LN3898">3898</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="3899"><td class="num" id="LN3899">3899</td><td class="line">		do_region = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;	    <span class='comment'>// region names are different</span></td></tr>
<tr class="codeline" data-linenumber="3900"><td class="num" id="LN3900">3900</td><td class="line">		<span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="3901"><td class="num" id="LN3901">3901</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="3902"><td class="num" id="LN3902">3902</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="3903"><td class="num" id="LN3903">3903</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="3904"><td class="num" id="LN3904">3904</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3905"><td class="num" id="LN3905">3905</td><td class="line">    <span class='keyword'>if</span> (do_region &amp;&amp; region_names != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3906"><td class="num" id="LN3906">3906</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="3907"><td class="num" id="LN3907">3907</td><td class="line">	<span class='keyword'>if</span> (pat == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3908"><td class="num" id="LN3908">3908</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="3909"><td class="num" id="LN3909">3909</td><td class="line">	    vim_snprintf((<span class='keyword'>char</span> *)IObuff, <span class='macro'>IOSIZE<span class='macro_popup'>(1024+1)</span></span>, <span class='string_literal'>"/regions=%s"</span>, region_names);</td></tr>
<tr class="codeline" data-linenumber="3910"><td class="num" id="LN3910">3910</td><td class="line">	    ml_append(lnum++, IObuff, (colnr_T)0, <span class='macro'>FALSE<span class='macro_popup'>0</span></span>);</td></tr>
<tr class="codeline" data-linenumber="3911"><td class="num" id="LN3911">3911</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="3912"><td class="num" id="LN3912">3912</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="3913"><td class="num" id="LN3913">3913</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="3914"><td class="num" id="LN3914">3914</td><td class="line">	do_region = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3915"><td class="num" id="LN3915">3915</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3916"><td class="num" id="LN3916">3916</td><td class="line">    <span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="3917"><td class="num" id="LN3917">3917</td><td class="line">     <span class='comment'>* Loop over all files loaded for the entries in 'spelllang'.</span></td></tr>
<tr class="codeline" data-linenumber="3918"><td class="num" id="LN3918">3918</td><td class="line">     <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="3919"><td class="num" id="LN3919">3919</td><td class="line">    <span class='keyword'>for</span> (lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi)</td></tr>
<tr class="codeline" data-linenumber="3920"><td class="num" id="LN3920">3920</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="3921"><td class="num" id="LN3921">3921</td><td class="line">	lp = <span class='macro'>LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi)<span class='macro_popup'>(((langp_T *)(curwin-&gt;w_s-&gt;b_langp).ga_data) + (lpi))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3922"><td class="num" id="LN3922">3922</td><td class="line">	slang = lp-&gt;lp_slang;</td></tr>
<tr class="codeline" data-linenumber="3923"><td class="num" id="LN3923">3923</td><td class="line">	<span class='keyword'>if</span> (slang-&gt;sl_fbyts == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)	    <span class='comment'>// reloading failed</span></td></tr>
<tr class="codeline" data-linenumber="3924"><td class="num" id="LN3924">3924</td><td class="line">	    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="3925"><td class="num" id="LN3925">3925</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3926"><td class="num" id="LN3926">3926</td><td class="line">	<span class='keyword'>if</span> (pat == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3927"><td class="num" id="LN3927">3927</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="3928"><td class="num" id="LN3928">3928</td><td class="line">	    vim_snprintf((<span class='keyword'>char</span> *)IObuff, <span class='macro'>IOSIZE<span class='macro_popup'>(1024+1)</span></span>, <span class='string_literal'>"# file: %s"</span>, slang-&gt;sl_fname);</td></tr>
<tr class="codeline" data-linenumber="3929"><td class="num" id="LN3929">3929</td><td class="line">	    ml_append(lnum++, IObuff, (colnr_T)0, <span class='macro'>FALSE<span class='macro_popup'>0</span></span>);</td></tr>
<tr class="codeline" data-linenumber="3930"><td class="num" id="LN3930">3930</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="3931"><td class="num" id="LN3931">3931</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3932"><td class="num" id="LN3932">3932</td><td class="line">	<span class='comment'>// When matching with a pattern and there are no prefixes only use</span></td></tr>
<tr class="codeline" data-linenumber="3933"><td class="num" id="LN3933">3933</td><td class="line">	<span class='comment'>// parts of the tree that match "pat".</span></td></tr>
<tr class="codeline" data-linenumber="3934"><td class="num" id="LN3934">3934</td><td class="line">	<span class='keyword'>if</span> (pat != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span> &amp;&amp; slang-&gt;sl_pbyts == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3935"><td class="num" id="LN3935">3935</td><td class="line">	    patlen = (<span class='keyword'>int</span>)<span class='macro'>STRLEN(pat)<span class='macro_popup'>strlen((char *)(pat))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3936"><td class="num" id="LN3936">3936</td><td class="line">	<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="3937"><td class="num" id="LN3937">3937</td><td class="line">	    patlen = -1;</td></tr>
<tr class="codeline" data-linenumber="3938"><td class="num" id="LN3938">3938</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3939"><td class="num" id="LN3939">3939</td><td class="line">	<span class='comment'>// round 1: case-folded tree</span></td></tr>
<tr class="codeline" data-linenumber="3940"><td class="num" id="LN3940">3940</td><td class="line">	<span class='comment'>// round 2: keep-case tree</span></td></tr>
<tr class="codeline" data-linenumber="3941"><td class="num" id="LN3941">3941</td><td class="line">	<span class='keyword'>for</span> (round = 1; round &lt;= 2; ++round)</td></tr>
<tr class="codeline" data-linenumber="3942"><td class="num" id="LN3942">3942</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="3943"><td class="num" id="LN3943">3943</td><td class="line">	    <span class='keyword'>if</span> (round == 1)</td></tr>
<tr class="codeline" data-linenumber="3944"><td class="num" id="LN3944">3944</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="3945"><td class="num" id="LN3945">3945</td><td class="line">		dumpflags &amp;= ~<span class='macro'>DUMPFLAG_KEEPCASE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3946"><td class="num" id="LN3946">3946</td><td class="line">		byts = slang-&gt;sl_fbyts;</td></tr>
<tr class="codeline" data-linenumber="3947"><td class="num" id="LN3947">3947</td><td class="line">		idxs = slang-&gt;sl_fidxs;</td></tr>
<tr class="codeline" data-linenumber="3948"><td class="num" id="LN3948">3948</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="3949"><td class="num" id="LN3949">3949</td><td class="line">	    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="3950"><td class="num" id="LN3950">3950</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="3951"><td class="num" id="LN3951">3951</td><td class="line">		dumpflags |= <span class='macro'>DUMPFLAG_KEEPCASE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3952"><td class="num" id="LN3952">3952</td><td class="line">		byts = slang-&gt;sl_kbyts;</td></tr>
<tr class="codeline" data-linenumber="3953"><td class="num" id="LN3953">3953</td><td class="line">		idxs = slang-&gt;sl_kidxs;</td></tr>
<tr class="codeline" data-linenumber="3954"><td class="num" id="LN3954">3954</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="3955"><td class="num" id="LN3955">3955</td><td class="line">	    <span class='keyword'>if</span> (byts == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="3956"><td class="num" id="LN3956">3956</td><td class="line">		<span class='keyword'>continue</span>;		<span class='comment'>// array is empty</span></td></tr>
<tr class="codeline" data-linenumber="3957"><td class="num" id="LN3957">3957</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3958"><td class="num" id="LN3958">3958</td><td class="line">	    depth = 0;</td></tr>
<tr class="codeline" data-linenumber="3959"><td class="num" id="LN3959">3959</td><td class="line">	    arridx[0] = 0;</td></tr>
<tr class="codeline" data-linenumber="3960"><td class="num" id="LN3960">3960</td><td class="line">	    curi[0] = 1;</td></tr>
<tr class="codeline" data-linenumber="3961"><td class="num" id="LN3961">3961</td><td class="line">	    <span class='keyword'>while</span> (depth &gt;= 0 &amp;&amp; !got_int</td></tr>
<tr class="codeline" data-linenumber="3962"><td class="num" id="LN3962">3962</td><td class="line">				  &amp;&amp; (pat == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span> || !ins_compl_interrupted()))</td></tr>
<tr class="codeline" data-linenumber="3963"><td class="num" id="LN3963">3963</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="3964"><td class="num" id="LN3964">3964</td><td class="line">		<span class='keyword'>if</span> (curi[depth] &gt; byts[arridx[depth]])</td></tr>
<tr class="codeline" data-linenumber="3965"><td class="num" id="LN3965">3965</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="3966"><td class="num" id="LN3966">3966</td><td class="line">		    <span class='comment'>// Done all bytes at this node, go up one level.</span></td></tr>
<tr class="codeline" data-linenumber="3967"><td class="num" id="LN3967">3967</td><td class="line">		    --depth;</td></tr>
<tr class="codeline" data-linenumber="3968"><td class="num" id="LN3968">3968</td><td class="line">		    line_breakcheck();</td></tr>
<tr class="codeline" data-linenumber="3969"><td class="num" id="LN3969">3969</td><td class="line">		    ins_compl_check_keys(50, <span class='macro'>FALSE<span class='macro_popup'>0</span></span>);</td></tr>
<tr class="codeline" data-linenumber="3970"><td class="num" id="LN3970">3970</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="3971"><td class="num" id="LN3971">3971</td><td class="line">		<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="3972"><td class="num" id="LN3972">3972</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="3973"><td class="num" id="LN3973">3973</td><td class="line">		    <span class='comment'>// Do one more byte at this node.</span></td></tr>
<tr class="codeline" data-linenumber="3974"><td class="num" id="LN3974">3974</td><td class="line">		    n = arridx[depth] + curi[depth];</td></tr>
<tr class="codeline" data-linenumber="3975"><td class="num" id="LN3975">3975</td><td class="line">		    ++curi[depth];</td></tr>
<tr class="codeline" data-linenumber="3976"><td class="num" id="LN3976">3976</td><td class="line">		    c = byts[n];</td></tr>
<tr class="codeline" data-linenumber="3977"><td class="num" id="LN3977">3977</td><td class="line">		    <span class='keyword'>if</span> (c == 0)</td></tr>
<tr class="codeline" data-linenumber="3978"><td class="num" id="LN3978">3978</td><td class="line">		    {</td></tr>
<tr class="codeline" data-linenumber="3979"><td class="num" id="LN3979">3979</td><td class="line">			<span class='comment'>// End of word, deal with the word.</span></td></tr>
<tr class="codeline" data-linenumber="3980"><td class="num" id="LN3980">3980</td><td class="line">			<span class='comment'>// Don't use keep-case words in the fold-case tree,</span></td></tr>
<tr class="codeline" data-linenumber="3981"><td class="num" id="LN3981">3981</td><td class="line">			<span class='comment'>// they will appear in the keep-case tree.</span></td></tr>
<tr class="codeline" data-linenumber="3982"><td class="num" id="LN3982">3982</td><td class="line">			<span class='comment'>// Only use the word when the region matches.</span></td></tr>
<tr class="codeline" data-linenumber="3983"><td class="num" id="LN3983">3983</td><td class="line">			flags = (<span class='keyword'>int</span>)idxs[n];</td></tr>
<tr class="codeline" data-linenumber="3984"><td class="num" id="LN3984">3984</td><td class="line">			<span class='keyword'>if</span> ((round == 2 || (flags &amp; <span class='macro'>WF_KEEPCAP<span class='macro_popup'>0x80</span></span>) == 0)</td></tr>
<tr class="codeline" data-linenumber="3985"><td class="num" id="LN3985">3985</td><td class="line">				&amp;&amp; (flags &amp; <span class='macro'>WF_NEEDCOMP<span class='macro_popup'>0x0200</span></span>) == 0</td></tr>
<tr class="codeline" data-linenumber="3986"><td class="num" id="LN3986">3986</td><td class="line">				&amp;&amp; (do_region</td></tr>
<tr class="codeline" data-linenumber="3987"><td class="num" id="LN3987">3987</td><td class="line">				    || (flags &amp; <span class='macro'>WF_REGION<span class='macro_popup'>0x01</span></span>) == 0</td></tr>
<tr class="codeline" data-linenumber="3988"><td class="num" id="LN3988">3988</td><td class="line">				    || (((<span class='keyword'>unsigned</span>)flags &gt;&gt; 16)</td></tr>
<tr class="codeline" data-linenumber="3989"><td class="num" id="LN3989">3989</td><td class="line">						       &amp; lp-&gt;lp_region) != 0))</td></tr>
<tr class="codeline" data-linenumber="3990"><td class="num" id="LN3990">3990</td><td class="line">			{</td></tr>
<tr class="codeline" data-linenumber="3991"><td class="num" id="LN3991">3991</td><td class="line">			    word[depth] = <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3992"><td class="num" id="LN3992">3992</td><td class="line">			    <span class='keyword'>if</span> (!do_region)</td></tr>
<tr class="codeline" data-linenumber="3993"><td class="num" id="LN3993">3993</td><td class="line">				flags &amp;= ~<span class='macro'>WF_REGION<span class='macro_popup'>0x01</span></span>;</td></tr>
<tr class="codeline" data-linenumber="3994"><td class="num" id="LN3994">3994</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="3995"><td class="num" id="LN3995">3995</td><td class="line">			    <span class='comment'>// Dump the basic word if there is no prefix or</span></td></tr>
<tr class="codeline" data-linenumber="3996"><td class="num" id="LN3996">3996</td><td class="line">			    <span class='comment'>// when it's the first one.</span></td></tr>
<tr class="codeline" data-linenumber="3997"><td class="num" id="LN3997">3997</td><td class="line">			    c = (<span class='keyword'>unsigned</span>)flags &gt;&gt; 24;</td></tr>
<tr class="codeline" data-linenumber="3998"><td class="num" id="LN3998">3998</td><td class="line">			    <span class='keyword'>if</span> (c == 0 || curi[depth] == 2)</td></tr>
<tr class="codeline" data-linenumber="3999"><td class="num" id="LN3999">3999</td><td class="line">			    {</td></tr>
<tr class="codeline" data-linenumber="4000"><td class="num" id="LN4000">4000</td><td class="line">				dump_word(slang, word, pat, dir,</td></tr>
<tr class="codeline" data-linenumber="4001"><td class="num" id="LN4001">4001</td><td class="line">						      dumpflags, flags, lnum);</td></tr>
<tr class="codeline" data-linenumber="4002"><td class="num" id="LN4002">4002</td><td class="line">				<span class='keyword'>if</span> (pat == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="4003"><td class="num" id="LN4003">4003</td><td class="line">				    ++lnum;</td></tr>
<tr class="codeline" data-linenumber="4004"><td class="num" id="LN4004">4004</td><td class="line">			    }</td></tr>
<tr class="codeline" data-linenumber="4005"><td class="num" id="LN4005">4005</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4006"><td class="num" id="LN4006">4006</td><td class="line">			    <span class='comment'>// Apply the prefix, if there is one.</span></td></tr>
<tr class="codeline" data-linenumber="4007"><td class="num" id="LN4007">4007</td><td class="line">			    <span class='keyword'>if</span> (c != 0)</td></tr>
<tr class="codeline" data-linenumber="4008"><td class="num" id="LN4008">4008</td><td class="line">				lnum = dump_prefixes(slang, word, pat, dir,</td></tr>
<tr class="codeline" data-linenumber="4009"><td class="num" id="LN4009">4009</td><td class="line">						      dumpflags, flags, lnum);</td></tr>
<tr class="codeline" data-linenumber="4010"><td class="num" id="LN4010">4010</td><td class="line">			}</td></tr>
<tr class="codeline" data-linenumber="4011"><td class="num" id="LN4011">4011</td><td class="line">		    }</td></tr>
<tr class="codeline" data-linenumber="4012"><td class="num" id="LN4012">4012</td><td class="line">		    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="4013"><td class="num" id="LN4013">4013</td><td class="line">		    {</td></tr>
<tr class="codeline" data-linenumber="4014"><td class="num" id="LN4014">4014</td><td class="line">			<span class='comment'>// Normal char, go one level deeper.</span></td></tr>
<tr class="codeline" data-linenumber="4015"><td class="num" id="LN4015">4015</td><td class="line">			word[depth++] = c;</td></tr>
<tr class="codeline" data-linenumber="4016"><td class="num" id="LN4016">4016</td><td class="line">			arridx[depth] = idxs[n];</td></tr>
<tr class="codeline" data-linenumber="4017"><td class="num" id="LN4017">4017</td><td class="line">			curi[depth] = 1;</td></tr>
<tr class="codeline" data-linenumber="4018"><td class="num" id="LN4018">4018</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4019"><td class="num" id="LN4019">4019</td><td class="line">			<span class='comment'>// Check if this characters matches with the pattern.</span></td></tr>
<tr class="codeline" data-linenumber="4020"><td class="num" id="LN4020">4020</td><td class="line">			<span class='comment'>// If not skip the whole tree below it.</span></td></tr>
<tr class="codeline" data-linenumber="4021"><td class="num" id="LN4021">4021</td><td class="line">			<span class='comment'>// Always ignore case here, dump_word() will check</span></td></tr>
<tr class="codeline" data-linenumber="4022"><td class="num" id="LN4022">4022</td><td class="line">			<span class='comment'>// proper case later.  This isn't exactly right when</span></td></tr>
<tr class="codeline" data-linenumber="4023"><td class="num" id="LN4023">4023</td><td class="line">			<span class='comment'>// length changes for multi-byte characters with</span></td></tr>
<tr class="codeline" data-linenumber="4024"><td class="num" id="LN4024">4024</td><td class="line">			<span class='comment'>// ignore case...</span></td></tr>
<tr class="codeline" data-linenumber="4025"><td class="num" id="LN4025">4025</td><td class="line">			<span class='keyword'>if</span> (depth &lt;= patlen</td></tr>
<tr class="codeline" data-linenumber="4026"><td class="num" id="LN4026">4026</td><td class="line">					&amp;&amp; <span class='macro'>MB_STRNICMP(word, pat, depth)<span class='macro_popup'>mb_strnicmp((char_u *)(word), (char_u *)(pat), (int)(depth))</span></span> != 0)</td></tr>
<tr class="codeline" data-linenumber="4027"><td class="num" id="LN4027">4027</td><td class="line">			    --depth;</td></tr>
<tr class="codeline" data-linenumber="4028"><td class="num" id="LN4028">4028</td><td class="line">		    }</td></tr>
<tr class="codeline" data-linenumber="4029"><td class="num" id="LN4029">4029</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="4030"><td class="num" id="LN4030">4030</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="4031"><td class="num" id="LN4031">4031</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="4032"><td class="num" id="LN4032">4032</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="4033"><td class="num" id="LN4033">4033</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="4034"><td class="num" id="LN4034">4034</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4035"><td class="num" id="LN4035">4035</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="4036"><td class="num" id="LN4036">4036</td><td class="line"> <span class='comment'>* Dump one word: apply case modifications and append a line to the buffer.</span></td></tr>
<tr class="codeline" data-linenumber="4037"><td class="num" id="LN4037">4037</td><td class="line"> <span class='comment'>* When "lnum" is zero add insert mode completion.</span></td></tr>
<tr class="codeline" data-linenumber="4038"><td class="num" id="LN4038">4038</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="4039"><td class="num" id="LN4039">4039</td><td class="line">    <span class='keyword'>static</span> <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="4040"><td class="num" id="LN4040">4040</td><td class="line">dump_word(</td></tr>
<tr class="codeline" data-linenumber="4041"><td class="num" id="LN4041">4041</td><td class="line">    slang_T	*slang,</td></tr>
<tr class="codeline" data-linenumber="4042"><td class="num" id="LN4042">4042</td><td class="line">    char_u	*word,</td></tr>
<tr class="codeline" data-linenumber="4043"><td class="num" id="LN4043">4043</td><td class="line">    char_u	*pat,</td></tr>
<tr class="codeline" data-linenumber="4044"><td class="num" id="LN4044">4044</td><td class="line">    <span class='keyword'>int</span>		*dir,</td></tr>
<tr class="codeline" data-linenumber="4045"><td class="num" id="LN4045">4045</td><td class="line">    <span class='keyword'>int</span>		dumpflags,</td></tr>
<tr class="codeline" data-linenumber="4046"><td class="num" id="LN4046">4046</td><td class="line">    <span class='keyword'>int</span>		wordflags,</td></tr>
<tr class="codeline" data-linenumber="4047"><td class="num" id="LN4047">4047</td><td class="line">    linenr_T	lnum)</td></tr>
<tr class="codeline" data-linenumber="4048"><td class="num" id="LN4048">4048</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="4049"><td class="num" id="LN4049">4049</td><td class="line">    <span class='keyword'>int</span>		keepcap = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="4050"><td class="num" id="LN4050">4050</td><td class="line">    char_u	*p;</td></tr>
<tr class="codeline" data-linenumber="4051"><td class="num" id="LN4051">4051</td><td class="line">    char_u	*tw;</td></tr>
<tr class="codeline" data-linenumber="4052"><td class="num" id="LN4052">4052</td><td class="line">    char_u	cword[<span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>];</td></tr>
<tr class="codeline" data-linenumber="4053"><td class="num" id="LN4053">4053</td><td class="line">    char_u	badword[<span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span> + 10];</td></tr>
<tr class="codeline" data-linenumber="4054"><td class="num" id="LN4054">4054</td><td class="line">    <span class='keyword'>int</span>		i;</td></tr>
<tr class="codeline" data-linenumber="4055"><td class="num" id="LN4055">4055</td><td class="line">    <span class='keyword'>int</span>		flags = wordflags;</td></tr>
<tr class="codeline" data-linenumber="4056"><td class="num" id="LN4056">4056</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4057"><td class="num" id="LN4057">4057</td><td class="line">    <span class='keyword'>if</span> (dumpflags &amp; <span class='macro'>DUMPFLAG_ONECAP<span class='macro_popup'>8</span></span>)</td></tr>
<tr class="codeline" data-linenumber="4058"><td class="num" id="LN4058">4058</td><td class="line">	flags |= <span class='macro'>WF_ONECAP<span class='macro_popup'>0x02</span></span>;</td></tr>
<tr class="codeline" data-linenumber="4059"><td class="num" id="LN4059">4059</td><td class="line">    <span class='keyword'>if</span> (dumpflags &amp; <span class='macro'>DUMPFLAG_ALLCAP<span class='macro_popup'>16</span></span>)</td></tr>
<tr class="codeline" data-linenumber="4060"><td class="num" id="LN4060">4060</td><td class="line">	flags |= <span class='macro'>WF_ALLCAP<span class='macro_popup'>0x04</span></span>;</td></tr>
<tr class="codeline" data-linenumber="4061"><td class="num" id="LN4061">4061</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4062"><td class="num" id="LN4062">4062</td><td class="line">    <span class='keyword'>if</span> ((dumpflags &amp; <span class='macro'>DUMPFLAG_KEEPCASE<span class='macro_popup'>1</span></span>) == 0 &amp;&amp; (flags &amp; <span class='macro'>WF_CAPMASK<span class='macro_popup'>(0x02 | 0x04 | 0x80 | 0x40)</span></span>) != 0)</td></tr>
<tr class="codeline" data-linenumber="4063"><td class="num" id="LN4063">4063</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="4064"><td class="num" id="LN4064">4064</td><td class="line">	<span class='comment'>// Need to fix case according to "flags".</span></td></tr>
<tr class="codeline" data-linenumber="4065"><td class="num" id="LN4065">4065</td><td class="line">	make_case_word(word, cword, flags);</td></tr>
<tr class="codeline" data-linenumber="4066"><td class="num" id="LN4066">4066</td><td class="line">	p = cword;</td></tr>
<tr class="codeline" data-linenumber="4067"><td class="num" id="LN4067">4067</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="4068"><td class="num" id="LN4068">4068</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="4069"><td class="num" id="LN4069">4069</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="4070"><td class="num" id="LN4070">4070</td><td class="line">	p = word;</td></tr>
<tr class="codeline" data-linenumber="4071"><td class="num" id="LN4071">4071</td><td class="line">	<span class='keyword'>if</span> ((dumpflags &amp; <span class='macro'>DUMPFLAG_KEEPCASE<span class='macro_popup'>1</span></span>)</td></tr>
<tr class="codeline" data-linenumber="4072"><td class="num" id="LN4072">4072</td><td class="line">		&amp;&amp; ((captype(word, <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>) &amp; <span class='macro'>WF_KEEPCAP<span class='macro_popup'>0x80</span></span>) == 0</td></tr>
<tr class="codeline" data-linenumber="4073"><td class="num" id="LN4073">4073</td><td class="line">						 || (flags &amp; <span class='macro'>WF_FIXCAP<span class='macro_popup'>0x40</span></span>) != 0))</td></tr>
<tr class="codeline" data-linenumber="4074"><td class="num" id="LN4074">4074</td><td class="line">	    keepcap = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="4075"><td class="num" id="LN4075">4075</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="4076"><td class="num" id="LN4076">4076</td><td class="line">    tw = p;</td></tr>
<tr class="codeline" data-linenumber="4077"><td class="num" id="LN4077">4077</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4078"><td class="num" id="LN4078">4078</td><td class="line">    <span class='keyword'>if</span> (pat == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="4079"><td class="num" id="LN4079">4079</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="4080"><td class="num" id="LN4080">4080</td><td class="line">	<span class='comment'>// Add flags and regions after a slash.</span></td></tr>
<tr class="codeline" data-linenumber="4081"><td class="num" id="LN4081">4081</td><td class="line">	<span class='keyword'>if</span> ((flags &amp; (<span class='macro'>WF_BANNED<span class='macro_popup'>0x10</span></span> | <span class='macro'>WF_RARE<span class='macro_popup'>0x08</span></span> | <span class='macro'>WF_REGION<span class='macro_popup'>0x01</span></span>)) || keepcap)</td></tr>
<tr class="codeline" data-linenumber="4082"><td class="num" id="LN4082">4082</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="4083"><td class="num" id="LN4083">4083</td><td class="line">	    <span class='macro'>STRCPY(badword, p)<span class='macro_popup'>strcpy((char *)(badword), (char *)(p))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="4084"><td class="num" id="LN4084">4084</td><td class="line">	    <span class='macro'>STRCAT(badword, <span class='string_literal'>"/"</span>)<span class='macro_popup'>strcat((char *)(badword), (char *)("/"))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="4085"><td class="num" id="LN4085">4085</td><td class="line">	    <span class='keyword'>if</span> (keepcap)</td></tr>
<tr class="codeline" data-linenumber="4086"><td class="num" id="LN4086">4086</td><td class="line">		<span class='macro'>STRCAT(badword, <span class='string_literal'>"="</span>)<span class='macro_popup'>strcat((char *)(badword), (char *)("="))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="4087"><td class="num" id="LN4087">4087</td><td class="line">	    <span class='keyword'>if</span> (flags &amp; <span class='macro'>WF_BANNED<span class='macro_popup'>0x10</span></span>)</td></tr>
<tr class="codeline" data-linenumber="4088"><td class="num" id="LN4088">4088</td><td class="line">		<span class='macro'>STRCAT(badword, <span class='string_literal'>"!"</span>)<span class='macro_popup'>strcat((char *)(badword), (char *)("!"))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="4089"><td class="num" id="LN4089">4089</td><td class="line">	    <span class='keyword'>else</span> <span class='keyword'>if</span> (flags &amp; <span class='macro'>WF_RARE<span class='macro_popup'>0x08</span></span>)</td></tr>
<tr class="codeline" data-linenumber="4090"><td class="num" id="LN4090">4090</td><td class="line">		<span class='macro'>STRCAT(badword, <span class='string_literal'>"?"</span>)<span class='macro_popup'>strcat((char *)(badword), (char *)("?"))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="4091"><td class="num" id="LN4091">4091</td><td class="line">	    <span class='keyword'>if</span> (flags &amp; <span class='macro'>WF_REGION<span class='macro_popup'>0x01</span></span>)</td></tr>
<tr class="codeline" data-linenumber="4092"><td class="num" id="LN4092">4092</td><td class="line">		<span class='keyword'>for</span> (i = 0; i &lt; 7; ++i)</td></tr>
<tr class="codeline" data-linenumber="4093"><td class="num" id="LN4093">4093</td><td class="line">		    <span class='keyword'>if</span> (flags &amp; (0x10000 &lt;&lt; i))</td></tr>
<tr class="codeline" data-linenumber="4094"><td class="num" id="LN4094">4094</td><td class="line">			<span class='macro'>sprintf((<span class='keyword'>char</span> *)badword + STRLEN(badword), <span class='string_literal'>"%d"</span>, i + 1)<span class='macro_popup'>__builtin___sprintf_chk ((char *)badword + strlen((char *)(badword<br>)), 1 - 1, __builtin_object_size ((char *)badword + strlen((char<br> *)(badword)), 1 &gt; 1), "%d", i + 1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="4095"><td class="num" id="LN4095">4095</td><td class="line">	    p = badword;</td></tr>
<tr class="codeline" data-linenumber="4096"><td class="num" id="LN4096">4096</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="4097"><td class="num" id="LN4097">4097</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4098"><td class="num" id="LN4098">4098</td><td class="line">	<span class='keyword'>if</span> (dumpflags &amp; <span class='macro'>DUMPFLAG_COUNT<span class='macro_popup'>2</span></span>)</td></tr>
<tr class="codeline" data-linenumber="4099"><td class="num" id="LN4099">4099</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="4100"><td class="num" id="LN4100">4100</td><td class="line">	    hashitem_T  *hi;</td></tr>
<tr class="codeline" data-linenumber="4101"><td class="num" id="LN4101">4101</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4102"><td class="num" id="LN4102">4102</td><td class="line">	    <span class='comment'>// Include the word count for ":spelldump!".</span></td></tr>
<tr class="codeline" data-linenumber="4103"><td class="num" id="LN4103">4103</td><td class="line">	    hi = hash_find(&amp;slang-&gt;sl_wordcount, tw);</td></tr>
<tr class="codeline" data-linenumber="4104"><td class="num" id="LN4104">4104</td><td class="line">	    <span class='keyword'>if</span> (!<span class='macro'>HASHITEM_EMPTY(hi)<span class='macro_popup'>((hi)-&gt;hi_key == ((void*)0) || (hi)-&gt;hi_key == &amp;hash_removed<br>)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="4105"><td class="num" id="LN4105">4105</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="4106"><td class="num" id="LN4106">4106</td><td class="line">		vim_snprintf((<span class='keyword'>char</span> *)IObuff, <span class='macro'>IOSIZE<span class='macro_popup'>(1024+1)</span></span>, <span class='string_literal'>"%s\t%d"</span>,</td></tr>
<tr class="codeline" data-linenumber="4107"><td class="num" id="LN4107">4107</td><td class="line">						     tw, <span class='macro'>HI2WC(hi)<span class='macro_popup'>((wordcount_T *)((hi)-&gt;hi_key - __builtin_offsetof(wordcount_T<br>, wc_word)))</span></span>-&gt;wc_count);</td></tr>
<tr class="codeline" data-linenumber="4108"><td class="num" id="LN4108">4108</td><td class="line">		p = IObuff;</td></tr>
<tr class="codeline" data-linenumber="4109"><td class="num" id="LN4109">4109</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="4110"><td class="num" id="LN4110">4110</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="4111"><td class="num" id="LN4111">4111</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4112"><td class="num" id="LN4112">4112</td><td class="line">	ml_append(lnum, p, (colnr_T)0, <span class='macro'>FALSE<span class='macro_popup'>0</span></span>);</td></tr>
<tr class="codeline" data-linenumber="4113"><td class="num" id="LN4113">4113</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="4114"><td class="num" id="LN4114">4114</td><td class="line">    <span class='keyword'>else</span> <span class='keyword'>if</span> (((dumpflags &amp; <span class='macro'>DUMPFLAG_ICASE<span class='macro_popup'>4</span></span>)</td></tr>
<tr class="codeline" data-linenumber="4115"><td class="num" id="LN4115">4115</td><td class="line">		    ? <span class='macro'>MB_STRNICMP(p, pat, STRLEN(pat))<span class='macro_popup'>mb_strnicmp((char_u *)(p), (char_u *)(pat), (int)(strlen((char<br> *)(pat))))</span></span> == 0</td></tr>
<tr class="codeline" data-linenumber="4116"><td class="num" id="LN4116">4116</td><td class="line">		    : <span class='macro'>STRNCMP(p, pat, STRLEN(pat))<span class='macro_popup'>strncmp((char *)(p), (char *)(pat), (size_t)(strlen((char *)(<br>pat))))</span></span> == 0)</td></tr>
<tr class="codeline" data-linenumber="4117"><td class="num" id="LN4117">4117</td><td class="line">		&amp;&amp; ins_compl_add_infercase(p, (<span class='keyword'>int</span>)<span class='macro'>STRLEN(p)<span class='macro_popup'>strlen((char *)(p))</span></span>,</td></tr>
<tr class="codeline" data-linenumber="4118"><td class="num" id="LN4118">4118</td><td class="line">					  p_ic, <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>, *dir, <span class='macro'>FALSE<span class='macro_popup'>0</span></span>) == <span class='macro'>OK<span class='macro_popup'>1</span></span>)</td></tr>
<tr class="codeline" data-linenumber="4119"><td class="num" id="LN4119">4119</td><td class="line">	<span class='comment'>// if dir was BACKWARD then honor it just once</span></td></tr>
<tr class="codeline" data-linenumber="4120"><td class="num" id="LN4120">4120</td><td class="line">	*dir = <span class='macro'>FORWARD<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="4121"><td class="num" id="LN4121">4121</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="4122"><td class="num" id="LN4122">4122</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4123"><td class="num" id="LN4123">4123</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="4124"><td class="num" id="LN4124">4124</td><td class="line"> <span class='comment'>* For ":spelldump": Find matching prefixes for "word".  Prepend each to</span></td></tr>
<tr class="codeline" data-linenumber="4125"><td class="num" id="LN4125">4125</td><td class="line"> <span class='comment'>* "word" and append a line to the buffer.</span></td></tr>
<tr class="codeline" data-linenumber="4126"><td class="num" id="LN4126">4126</td><td class="line"> <span class='comment'>* When "lnum" is zero add insert mode completion.</span></td></tr>
<tr class="codeline" data-linenumber="4127"><td class="num" id="LN4127">4127</td><td class="line"> <span class='comment'>* Return the updated line number.</span></td></tr>
<tr class="codeline" data-linenumber="4128"><td class="num" id="LN4128">4128</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="4129"><td class="num" id="LN4129">4129</td><td class="line">    <span class='keyword'>static</span> linenr_T</td></tr>
<tr class="codeline" data-linenumber="4130"><td class="num" id="LN4130">4130</td><td class="line">dump_prefixes(</td></tr>
<tr class="codeline" data-linenumber="4131"><td class="num" id="LN4131">4131</td><td class="line">    slang_T	*slang,</td></tr>
<tr class="codeline" data-linenumber="4132"><td class="num" id="LN4132">4132</td><td class="line">    char_u	*word,	    <span class='comment'>// case-folded word</span></td></tr>
<tr class="codeline" data-linenumber="4133"><td class="num" id="LN4133">4133</td><td class="line">    char_u	*pat,</td></tr>
<tr class="codeline" data-linenumber="4134"><td class="num" id="LN4134">4134</td><td class="line">    <span class='keyword'>int</span>		*dir,</td></tr>
<tr class="codeline" data-linenumber="4135"><td class="num" id="LN4135">4135</td><td class="line">    <span class='keyword'>int</span>		dumpflags,</td></tr>
<tr class="codeline" data-linenumber="4136"><td class="num" id="LN4136">4136</td><td class="line">    <span class='keyword'>int</span>		flags,	    <span class='comment'>// flags with prefix ID</span></td></tr>
<tr class="codeline" data-linenumber="4137"><td class="num" id="LN4137">4137</td><td class="line">    linenr_T	startlnum)</td></tr>
<tr class="codeline" data-linenumber="4138"><td class="num" id="LN4138">4138</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="4139"><td class="num" id="LN4139">4139</td><td class="line">    idx_T	arridx[<span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>];</td></tr>
<tr class="codeline" data-linenumber="4140"><td class="num" id="LN4140">4140</td><td class="line">    <span class='keyword'>int</span>		curi[<span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>];</td></tr>
<tr class="codeline" data-linenumber="4141"><td class="num" id="LN4141">4141</td><td class="line">    char_u	prefix[<span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>];</td></tr>
<tr class="codeline" data-linenumber="4142"><td class="num" id="LN4142">4142</td><td class="line">    char_u	word_up[<span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span>];</td></tr>
<tr class="codeline" data-linenumber="4143"><td class="num" id="LN4143">4143</td><td class="line">    <span class='keyword'>int</span>		has_word_up = <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="4144"><td class="num" id="LN4144">4144</td><td class="line">    <span class='keyword'>int</span>		c;</td></tr>
<tr class="codeline" data-linenumber="4145"><td class="num" id="LN4145">4145</td><td class="line">    char_u	*byts;</td></tr>
<tr class="codeline" data-linenumber="4146"><td class="num" id="LN4146">4146</td><td class="line">    idx_T	*idxs;</td></tr>
<tr class="codeline" data-linenumber="4147"><td class="num" id="LN4147">4147</td><td class="line">    linenr_T	lnum = startlnum;</td></tr>
<tr class="codeline" data-linenumber="4148"><td class="num" id="LN4148">4148</td><td class="line">    <span class='keyword'>int</span>		depth;</td></tr>
<tr class="codeline" data-linenumber="4149"><td class="num" id="LN4149">4149</td><td class="line">    <span class='keyword'>int</span>		n;</td></tr>
<tr class="codeline" data-linenumber="4150"><td class="num" id="LN4150">4150</td><td class="line">    <span class='keyword'>int</span>		len;</td></tr>
<tr class="codeline" data-linenumber="4151"><td class="num" id="LN4151">4151</td><td class="line">    <span class='keyword'>int</span>		i;</td></tr>
<tr class="codeline" data-linenumber="4152"><td class="num" id="LN4152">4152</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4153"><td class="num" id="LN4153">4153</td><td class="line">    <span class='comment'>// If the word starts with a lower-case letter make the word with an</span></td></tr>
<tr class="codeline" data-linenumber="4154"><td class="num" id="LN4154">4154</td><td class="line">    <span class='comment'>// upper-case letter in word_up[].</span></td></tr>
<tr class="codeline" data-linenumber="4155"><td class="num" id="LN4155">4155</td><td class="line">    c = <span class='macro'>PTR2CHAR(word)<span class='macro_popup'>(has_mbyte ? mb_ptr2char(word) : (int)*(word))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="4156"><td class="num" id="LN4156">4156</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>SPELL_TOUPPER(c)<span class='macro_popup'>(enc_utf8 &amp;&amp; (c) &gt;= 128 ? utf_toupper(c) : (c) &lt;<br> 256 ? (int)spelltab.st_upper[c] : (int)towupper(c))</span></span> != c)</td></tr>
<tr class="codeline" data-linenumber="4157"><td class="num" id="LN4157">4157</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="4158"><td class="num" id="LN4158">4158</td><td class="line">	onecap_copy(word, word_up, <span class='macro'>TRUE<span class='macro_popup'>1</span></span>);</td></tr>
<tr class="codeline" data-linenumber="4159"><td class="num" id="LN4159">4159</td><td class="line">	has_word_up = <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="4160"><td class="num" id="LN4160">4160</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="4161"><td class="num" id="LN4161">4161</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4162"><td class="num" id="LN4162">4162</td><td class="line">    byts = slang-&gt;sl_pbyts;</td></tr>
<tr class="codeline" data-linenumber="4163"><td class="num" id="LN4163">4163</td><td class="line">    idxs = slang-&gt;sl_pidxs;</td></tr>
<tr class="codeline" data-linenumber="4164"><td class="num" id="LN4164">4164</td><td class="line">    <span class='keyword'>if</span> (byts != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)		<span class='comment'>// array not is empty</span></td></tr>
<tr class="codeline" data-linenumber="4165"><td class="num" id="LN4165">4165</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="4166"><td class="num" id="LN4166">4166</td><td class="line">	<span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="4167"><td class="num" id="LN4167">4167</td><td class="line">	 <span class='comment'>* Loop over all prefixes, building them byte-by-byte in prefix[].</span></td></tr>
<tr class="codeline" data-linenumber="4168"><td class="num" id="LN4168">4168</td><td class="line">	 <span class='comment'>* When at the end of a prefix check that it supports "flags".</span></td></tr>
<tr class="codeline" data-linenumber="4169"><td class="num" id="LN4169">4169</td><td class="line">	 <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="4170"><td class="num" id="LN4170">4170</td><td class="line">	depth = 0;</td></tr>
<tr class="codeline" data-linenumber="4171"><td class="num" id="LN4171">4171</td><td class="line">	arridx[0] = 0;</td></tr>
<tr class="codeline" data-linenumber="4172"><td class="num" id="LN4172">4172</td><td class="line">	curi[0] = 1;</td></tr>
<tr class="codeline" data-linenumber="4173"><td class="num" id="LN4173">4173</td><td class="line">	<span class='keyword'>while</span> (depth &gt;= 0 &amp;&amp; !got_int)</td></tr>
<tr class="codeline" data-linenumber="4174"><td class="num" id="LN4174">4174</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="4175"><td class="num" id="LN4175">4175</td><td class="line">	    n = arridx[depth];</td></tr>
<tr class="codeline" data-linenumber="4176"><td class="num" id="LN4176">4176</td><td class="line">	    len = byts[n];</td></tr>
<tr class="codeline" data-linenumber="4177"><td class="num" id="LN4177">4177</td><td class="line">	    <span class='keyword'>if</span> (curi[depth] &gt; len)</td></tr>
<tr class="codeline" data-linenumber="4178"><td class="num" id="LN4178">4178</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="4179"><td class="num" id="LN4179">4179</td><td class="line">		<span class='comment'>// Done all bytes at this node, go up one level.</span></td></tr>
<tr class="codeline" data-linenumber="4180"><td class="num" id="LN4180">4180</td><td class="line">		--depth;</td></tr>
<tr class="codeline" data-linenumber="4181"><td class="num" id="LN4181">4181</td><td class="line">		line_breakcheck();</td></tr>
<tr class="codeline" data-linenumber="4182"><td class="num" id="LN4182">4182</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="4183"><td class="num" id="LN4183">4183</td><td class="line">	    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="4184"><td class="num" id="LN4184">4184</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="4185"><td class="num" id="LN4185">4185</td><td class="line">		<span class='comment'>// Do one more byte at this node.</span></td></tr>
<tr class="codeline" data-linenumber="4186"><td class="num" id="LN4186">4186</td><td class="line">		n += curi[depth];</td></tr>
<tr class="codeline" data-linenumber="4187"><td class="num" id="LN4187">4187</td><td class="line">		++curi[depth];</td></tr>
<tr class="codeline" data-linenumber="4188"><td class="num" id="LN4188">4188</td><td class="line">		c = byts[n];</td></tr>
<tr class="codeline" data-linenumber="4189"><td class="num" id="LN4189">4189</td><td class="line">		<span class='keyword'>if</span> (c == 0)</td></tr>
<tr class="codeline" data-linenumber="4190"><td class="num" id="LN4190">4190</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="4191"><td class="num" id="LN4191">4191</td><td class="line">		    <span class='comment'>// End of prefix, find out how many IDs there are.</span></td></tr>
<tr class="codeline" data-linenumber="4192"><td class="num" id="LN4192">4192</td><td class="line">		    <span class='keyword'>for</span> (i = 1; i &lt; len; ++i)</td></tr>
<tr class="codeline" data-linenumber="4193"><td class="num" id="LN4193">4193</td><td class="line">			<span class='keyword'>if</span> (byts[n + i] != 0)</td></tr>
<tr class="codeline" data-linenumber="4194"><td class="num" id="LN4194">4194</td><td class="line">			    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="4195"><td class="num" id="LN4195">4195</td><td class="line">		    curi[depth] += i - 1;</td></tr>
<tr class="codeline" data-linenumber="4196"><td class="num" id="LN4196">4196</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4197"><td class="num" id="LN4197">4197</td><td class="line">		    c = valid_word_prefix(i, n, flags, word, slang, <span class='macro'>FALSE<span class='macro_popup'>0</span></span>);</td></tr>
<tr class="codeline" data-linenumber="4198"><td class="num" id="LN4198">4198</td><td class="line">		    <span class='keyword'>if</span> (c != 0)</td></tr>
<tr class="codeline" data-linenumber="4199"><td class="num" id="LN4199">4199</td><td class="line">		    {</td></tr>
<tr class="codeline" data-linenumber="4200"><td class="num" id="LN4200">4200</td><td class="line">			vim_strncpy(prefix + depth, word, <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span> - depth - 1);</td></tr>
<tr class="codeline" data-linenumber="4201"><td class="num" id="LN4201">4201</td><td class="line">			dump_word(slang, prefix, pat, dir, dumpflags,</td></tr>
<tr class="codeline" data-linenumber="4202"><td class="num" id="LN4202">4202</td><td class="line">				(c &amp; <span class='macro'>WF_RAREPFX<span class='macro_popup'>(0x01 &lt;&lt; 24)</span></span>) ? (flags | <span class='macro'>WF_RARE<span class='macro_popup'>0x08</span></span>)</td></tr>
<tr class="codeline" data-linenumber="4203"><td class="num" id="LN4203">4203</td><td class="line">							       : flags, lnum);</td></tr>
<tr class="codeline" data-linenumber="4204"><td class="num" id="LN4204">4204</td><td class="line">			<span class='keyword'>if</span> (lnum != 0)</td></tr>
<tr class="codeline" data-linenumber="4205"><td class="num" id="LN4205">4205</td><td class="line">			    ++lnum;</td></tr>
<tr class="codeline" data-linenumber="4206"><td class="num" id="LN4206">4206</td><td class="line">		    }</td></tr>
<tr class="codeline" data-linenumber="4207"><td class="num" id="LN4207">4207</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4208"><td class="num" id="LN4208">4208</td><td class="line">		    <span class='comment'>// Check for prefix that matches the word when the</span></td></tr>
<tr class="codeline" data-linenumber="4209"><td class="num" id="LN4209">4209</td><td class="line">		    <span class='comment'>// first letter is upper-case, but only if the prefix has</span></td></tr>
<tr class="codeline" data-linenumber="4210"><td class="num" id="LN4210">4210</td><td class="line">		    <span class='comment'>// a condition.</span></td></tr>
<tr class="codeline" data-linenumber="4211"><td class="num" id="LN4211">4211</td><td class="line">		    <span class='keyword'>if</span> (has_word_up)</td></tr>
<tr class="codeline" data-linenumber="4212"><td class="num" id="LN4212">4212</td><td class="line">		    {</td></tr>
<tr class="codeline" data-linenumber="4213"><td class="num" id="LN4213">4213</td><td class="line">			c = valid_word_prefix(i, n, flags, word_up, slang,</td></tr>
<tr class="codeline" data-linenumber="4214"><td class="num" id="LN4214">4214</td><td class="line">									<span class='macro'>TRUE<span class='macro_popup'>1</span></span>);</td></tr>
<tr class="codeline" data-linenumber="4215"><td class="num" id="LN4215">4215</td><td class="line">			<span class='keyword'>if</span> (c != 0)</td></tr>
<tr class="codeline" data-linenumber="4216"><td class="num" id="LN4216">4216</td><td class="line">			{</td></tr>
<tr class="codeline" data-linenumber="4217"><td class="num" id="LN4217">4217</td><td class="line">			    vim_strncpy(prefix + depth, word_up,</td></tr>
<tr class="codeline" data-linenumber="4218"><td class="num" id="LN4218">4218</td><td class="line">							 <span class='macro'>MAXWLEN<span class='macro_popup'>254</span></span> - depth - 1);</td></tr>
<tr class="codeline" data-linenumber="4219"><td class="num" id="LN4219">4219</td><td class="line">			    dump_word(slang, prefix, pat, dir, dumpflags,</td></tr>
<tr class="codeline" data-linenumber="4220"><td class="num" id="LN4220">4220</td><td class="line">				    (c &amp; <span class='macro'>WF_RAREPFX<span class='macro_popup'>(0x01 &lt;&lt; 24)</span></span>) ? (flags | <span class='macro'>WF_RARE<span class='macro_popup'>0x08</span></span>)</td></tr>
<tr class="codeline" data-linenumber="4221"><td class="num" id="LN4221">4221</td><td class="line">							       : flags, lnum);</td></tr>
<tr class="codeline" data-linenumber="4222"><td class="num" id="LN4222">4222</td><td class="line">			    <span class='keyword'>if</span> (lnum != 0)</td></tr>
<tr class="codeline" data-linenumber="4223"><td class="num" id="LN4223">4223</td><td class="line">				++lnum;</td></tr>
<tr class="codeline" data-linenumber="4224"><td class="num" id="LN4224">4224</td><td class="line">			}</td></tr>
<tr class="codeline" data-linenumber="4225"><td class="num" id="LN4225">4225</td><td class="line">		    }</td></tr>
<tr class="codeline" data-linenumber="4226"><td class="num" id="LN4226">4226</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="4227"><td class="num" id="LN4227">4227</td><td class="line">		<span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="4228"><td class="num" id="LN4228">4228</td><td class="line">		{</td></tr>
<tr class="codeline" data-linenumber="4229"><td class="num" id="LN4229">4229</td><td class="line">		    <span class='comment'>// Normal char, go one level deeper.</span></td></tr>
<tr class="codeline" data-linenumber="4230"><td class="num" id="LN4230">4230</td><td class="line">		    prefix[depth++] = c;</td></tr>
<tr class="codeline" data-linenumber="4231"><td class="num" id="LN4231">4231</td><td class="line">		    arridx[depth] = idxs[n];</td></tr>
<tr class="codeline" data-linenumber="4232"><td class="num" id="LN4232">4232</td><td class="line">		    curi[depth] = 1;</td></tr>
<tr class="codeline" data-linenumber="4233"><td class="num" id="LN4233">4233</td><td class="line">		}</td></tr>
<tr class="codeline" data-linenumber="4234"><td class="num" id="LN4234">4234</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="4235"><td class="num" id="LN4235">4235</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="4236"><td class="num" id="LN4236">4236</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="4237"><td class="num" id="LN4237">4237</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4238"><td class="num" id="LN4238">4238</td><td class="line">    <span class='keyword'>return</span> lnum;</td></tr>
<tr class="codeline" data-linenumber="4239"><td class="num" id="LN4239">4239</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="4240"><td class="num" id="LN4240">4240</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4241"><td class="num" id="LN4241">4241</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="4242"><td class="num" id="LN4242">4242</td><td class="line"> <span class='comment'>* Move "p" to the end of word "start".</span></td></tr>
<tr class="codeline" data-linenumber="4243"><td class="num" id="LN4243">4243</td><td class="line"> <span class='comment'>* Uses the spell-checking word characters.</span></td></tr>
<tr class="codeline" data-linenumber="4244"><td class="num" id="LN4244">4244</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="4245"><td class="num" id="LN4245">4245</td><td class="line">    char_u *</td></tr>
<tr class="codeline" data-linenumber="4246"><td class="num" id="LN4246">4246</td><td class="line">spell_to_word_end(char_u *start, win_T *win)</td></tr>
<tr class="codeline" data-linenumber="4247"><td class="num" id="LN4247">4247</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="4248"><td class="num" id="LN4248">4248</td><td class="line">    char_u  *p = start;</td></tr>
<tr class="codeline" data-linenumber="4249"><td class="num" id="LN4249">4249</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4250"><td class="num" id="LN4250">4250</td><td class="line">    <span class='keyword'>while</span> (*p != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span> &amp;&amp; spell_iswordp(p, win))</td></tr>
<tr class="codeline" data-linenumber="4251"><td class="num" id="LN4251">4251</td><td class="line">	<span class='macro'>MB_PTR_ADV(p)<span class='macro_popup'>p += (*mb_ptr2len)(p)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="4252"><td class="num" id="LN4252">4252</td><td class="line">    <span class='keyword'>return</span> p;</td></tr>
<tr class="codeline" data-linenumber="4253"><td class="num" id="LN4253">4253</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="4254"><td class="num" id="LN4254">4254</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4255"><td class="num" id="LN4255">4255</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="4256"><td class="num" id="LN4256">4256</td><td class="line"> <span class='comment'>* For Insert mode completion CTRL-X s:</span></td></tr>
<tr class="codeline" data-linenumber="4257"><td class="num" id="LN4257">4257</td><td class="line"> <span class='comment'>* Find start of the word in front of column "startcol".</span></td></tr>
<tr class="codeline" data-linenumber="4258"><td class="num" id="LN4258">4258</td><td class="line"> <span class='comment'>* We don't check if it is badly spelled, with completion we can only change</span></td></tr>
<tr class="codeline" data-linenumber="4259"><td class="num" id="LN4259">4259</td><td class="line"> <span class='comment'>* the word in front of the cursor.</span></td></tr>
<tr class="codeline" data-linenumber="4260"><td class="num" id="LN4260">4260</td><td class="line"> <span class='comment'>* Returns the column number of the word.</span></td></tr>
<tr class="codeline" data-linenumber="4261"><td class="num" id="LN4261">4261</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="4262"><td class="num" id="LN4262">4262</td><td class="line">    <span class='keyword'>int</span></td></tr>
<tr class="codeline" data-linenumber="4263"><td class="num" id="LN4263">4263</td><td class="line">spell_word_start(<span class='keyword'>int</span> startcol)</td></tr>
<tr class="codeline" data-linenumber="4264"><td class="num" id="LN4264">4264</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="4265"><td class="num" id="LN4265">4265</td><td class="line">    char_u	*line;</td></tr>
<tr class="codeline" data-linenumber="4266"><td class="num" id="LN4266">4266</td><td class="line">    char_u	*p;</td></tr>
<tr class="codeline" data-linenumber="4267"><td class="num" id="LN4267">4267</td><td class="line">    <span class='keyword'>int</span>		col = 0;</td></tr>
<tr class="codeline" data-linenumber="4268"><td class="num" id="LN4268">4268</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4269"><td class="num" id="LN4269">4269</td><td class="line">    <span class='keyword'>if</span> (no_spell_checking(curwin))</td></tr>
<tr class="codeline" data-linenumber="4270"><td class="num" id="LN4270">4270</td><td class="line">	<span class='keyword'>return</span> startcol;</td></tr>
<tr class="codeline" data-linenumber="4271"><td class="num" id="LN4271">4271</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4272"><td class="num" id="LN4272">4272</td><td class="line">    <span class='comment'>// Find a word character before "startcol".</span></td></tr>
<tr class="codeline" data-linenumber="4273"><td class="num" id="LN4273">4273</td><td class="line">    line = ml_get_curline();</td></tr>
<tr class="codeline" data-linenumber="4274"><td class="num" id="LN4274">4274</td><td class="line">    <span class='keyword'>for</span> (p = line + startcol; p &gt; line; )</td></tr>
<tr class="codeline" data-linenumber="4275"><td class="num" id="LN4275">4275</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="4276"><td class="num" id="LN4276">4276</td><td class="line">	<span class='macro'>MB_PTR_BACK(line, p)<span class='macro_popup'>p -= has_mbyte ? ((*mb_head_off)(line, p - 1) + 1) : 1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="4277"><td class="num" id="LN4277">4277</td><td class="line">	<span class='keyword'>if</span> (spell_iswordp_nmw(p, curwin))</td></tr>
<tr class="codeline" data-linenumber="4278"><td class="num" id="LN4278">4278</td><td class="line">	    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="4279"><td class="num" id="LN4279">4279</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="4280"><td class="num" id="LN4280">4280</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4281"><td class="num" id="LN4281">4281</td><td class="line">    <span class='comment'>// Go back to start of the word.</span></td></tr>
<tr class="codeline" data-linenumber="4282"><td class="num" id="LN4282">4282</td><td class="line">    <span class='keyword'>while</span> (p &gt; line)</td></tr>
<tr class="codeline" data-linenumber="4283"><td class="num" id="LN4283">4283</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="4284"><td class="num" id="LN4284">4284</td><td class="line">	col = (<span class='keyword'>int</span>)(p - line);</td></tr>
<tr class="codeline" data-linenumber="4285"><td class="num" id="LN4285">4285</td><td class="line">	<span class='macro'>MB_PTR_BACK(line, p)<span class='macro_popup'>p -= has_mbyte ? ((*mb_head_off)(line, p - 1) + 1) : 1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="4286"><td class="num" id="LN4286">4286</td><td class="line">	<span class='keyword'>if</span> (!spell_iswordp(p, curwin))</td></tr>
<tr class="codeline" data-linenumber="4287"><td class="num" id="LN4287">4287</td><td class="line">	    <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="4288"><td class="num" id="LN4288">4288</td><td class="line">	col = 0;</td></tr>
<tr class="codeline" data-linenumber="4289"><td class="num" id="LN4289">4289</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="4290"><td class="num" id="LN4290">4290</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4291"><td class="num" id="LN4291">4291</td><td class="line">    <span class='keyword'>return</span> col;</td></tr>
<tr class="codeline" data-linenumber="4292"><td class="num" id="LN4292">4292</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="4293"><td class="num" id="LN4293">4293</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4294"><td class="num" id="LN4294">4294</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="4295"><td class="num" id="LN4295">4295</td><td class="line"> <span class='comment'>* Need to check for 'spellcapcheck' now, the word is removed before</span></td></tr>
<tr class="codeline" data-linenumber="4296"><td class="num" id="LN4296">4296</td><td class="line"> <span class='comment'>* expand_spelling() is called.  Therefore the ugly global variable.</span></td></tr>
<tr class="codeline" data-linenumber="4297"><td class="num" id="LN4297">4297</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="4298"><td class="num" id="LN4298">4298</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> spell_expand_need_cap;</td></tr>
<tr class="codeline" data-linenumber="4299"><td class="num" id="LN4299">4299</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4300"><td class="num" id="LN4300">4300</td><td class="line">    <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="4301"><td class="num" id="LN4301">4301</td><td class="line">spell_expand_check_cap(colnr_T col)</td></tr>
<tr class="codeline" data-linenumber="4302"><td class="num" id="LN4302">4302</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="4303"><td class="num" id="LN4303">4303</td><td class="line">    spell_expand_need_cap = check_need_cap(curwin-&gt;w_cursor.lnum, col);</td></tr>
<tr class="codeline" data-linenumber="4304"><td class="num" id="LN4304">4304</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="4305"><td class="num" id="LN4305">4305</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4306"><td class="num" id="LN4306">4306</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="4307"><td class="num" id="LN4307">4307</td><td class="line"> <span class='comment'>* Get list of spelling suggestions.</span></td></tr>
<tr class="codeline" data-linenumber="4308"><td class="num" id="LN4308">4308</td><td class="line"> <span class='comment'>* Used for Insert mode completion CTRL-X ?.</span></td></tr>
<tr class="codeline" data-linenumber="4309"><td class="num" id="LN4309">4309</td><td class="line"> <span class='comment'>* Returns the number of matches.  The matches are in "matchp[]", array of</span></td></tr>
<tr class="codeline" data-linenumber="4310"><td class="num" id="LN4310">4310</td><td class="line"> <span class='comment'>* allocated strings.</span></td></tr>
<tr class="codeline" data-linenumber="4311"><td class="num" id="LN4311">4311</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="4312"><td class="num" id="LN4312">4312</td><td class="line">    <span class='keyword'>int</span></td></tr>
<tr class="codeline" data-linenumber="4313"><td class="num" id="LN4313">4313</td><td class="line">expand_spelling(</td></tr>
<tr class="codeline" data-linenumber="4314"><td class="num" id="LN4314">4314</td><td class="line">    linenr_T	lnum <span class='macro'>UNUSED<span class='macro_popup'>__attribute__((unused))</span></span>,</td></tr>
<tr class="codeline" data-linenumber="4315"><td class="num" id="LN4315">4315</td><td class="line">    char_u	*pat,</td></tr>
<tr class="codeline" data-linenumber="4316"><td class="num" id="LN4316">4316</td><td class="line">    char_u	***matchp)</td></tr>
<tr class="codeline" data-linenumber="4317"><td class="num" id="LN4317">4317</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="4318"><td class="num" id="LN4318">4318</td><td class="line">    garray_T	ga;</td></tr>
<tr class="codeline" data-linenumber="4319"><td class="num" id="LN4319">4319</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4320"><td class="num" id="LN4320">4320</td><td class="line">    spell_suggest_list(&amp;ga, pat, 100, spell_expand_need_cap, <span class='macro'>TRUE<span class='macro_popup'>1</span></span>);</td></tr>
<tr class="codeline" data-linenumber="4321"><td class="num" id="LN4321">4321</td><td class="line">    *matchp = ga.ga_data;</td></tr>
<tr class="codeline" data-linenumber="4322"><td class="num" id="LN4322">4322</td><td class="line">    <span class='keyword'>return</span> ga.ga_len;</td></tr>
<tr class="codeline" data-linenumber="4323"><td class="num" id="LN4323">4323</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="4324"><td class="num" id="LN4324">4324</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4325"><td class="num" id="LN4325">4325</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="4326"><td class="num" id="LN4326">4326</td><td class="line"> <span class='comment'>* Return TRUE if "val" is a valid 'spelllang' value.</span></td></tr>
<tr class="codeline" data-linenumber="4327"><td class="num" id="LN4327">4327</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="4328"><td class="num" id="LN4328">4328</td><td class="line">    <span class='keyword'>int</span></td></tr>
<tr class="codeline" data-linenumber="4329"><td class="num" id="LN4329">4329</td><td class="line">valid_spelllang(char_u *val)</td></tr>
<tr class="codeline" data-linenumber="4330"><td class="num" id="LN4330">4330</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="4331"><td class="num" id="LN4331">4331</td><td class="line">    <span class='keyword'>return</span> valid_name(val, <span class='string_literal'>".-_,@"</span>);</td></tr>
<tr class="codeline" data-linenumber="4332"><td class="num" id="LN4332">4332</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="4333"><td class="num" id="LN4333">4333</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4334"><td class="num" id="LN4334">4334</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="4335"><td class="num" id="LN4335">4335</td><td class="line"> <span class='comment'>* Return TRUE if "val" is a valid 'spellfile' value.</span></td></tr>
<tr class="codeline" data-linenumber="4336"><td class="num" id="LN4336">4336</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="4337"><td class="num" id="LN4337">4337</td><td class="line">    <span class='keyword'>int</span></td></tr>
<tr class="codeline" data-linenumber="4338"><td class="num" id="LN4338">4338</td><td class="line">valid_spellfile(char_u *val)</td></tr>
<tr class="codeline" data-linenumber="4339"><td class="num" id="LN4339">4339</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="4340"><td class="num" id="LN4340">4340</td><td class="line">    char_u *s;</td></tr>
<tr class="codeline" data-linenumber="4341"><td class="num" id="LN4341">4341</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4342"><td class="num" id="LN4342">4342</td><td class="line">    <span class='keyword'>for</span> (s = val; *s != <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>; ++s)</td></tr>
<tr class="codeline" data-linenumber="4343"><td class="num" id="LN4343">4343</td><td class="line">	<span class='keyword'>if</span> (!vim_isfilec(*s) &amp;&amp; *s != ',' &amp;&amp; *s != ' ')</td></tr>
<tr class="codeline" data-linenumber="4344"><td class="num" id="LN4344">4344</td><td class="line">	    <span class='keyword'>return</span> <span class='macro'>FALSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="4345"><td class="num" id="LN4345">4345</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>TRUE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="4346"><td class="num" id="LN4346">4346</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="4347"><td class="num" id="LN4347">4347</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4348"><td class="num" id="LN4348">4348</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="4349"><td class="num" id="LN4349">4349</td><td class="line"> <span class='comment'>* Handle side effects of setting 'spell'.</span></td></tr>
<tr class="codeline" data-linenumber="4350"><td class="num" id="LN4350">4350</td><td class="line"> <span class='comment'>* Return an error message or NULL for success.</span></td></tr>
<tr class="codeline" data-linenumber="4351"><td class="num" id="LN4351">4351</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="4352"><td class="num" id="LN4352">4352</td><td class="line">    <span class='keyword'>char</span> *</td></tr>
<tr class="codeline" data-linenumber="4353"><td class="num" id="LN4353">4353</td><td class="line">did_set_spell_option(<span class='keyword'>int</span> is_spellfile)</td></tr>
<tr class="codeline" data-linenumber="4354"><td class="num" id="LN4354">4354</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="4355"><td class="num" id="LN4355">4355</td><td class="line">    <span class='keyword'>char</span>    *errmsg = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="4356"><td class="num" id="LN4356">4356</td><td class="line">    win_T   *wp;</td></tr>
<tr class="codeline" data-linenumber="4357"><td class="num" id="LN4357">4357</td><td class="line">    <span class='keyword'>int</span>	    l;</td></tr>
<tr class="codeline" data-linenumber="4358"><td class="num" id="LN4358">4358</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4359"><td class="num" id="LN4359">4359</td><td class="line">    <span class='keyword'>if</span> (is_spellfile)</td></tr>
<tr class="codeline" data-linenumber="4360"><td class="num" id="LN4360">4360</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="4361"><td class="num" id="LN4361">4361</td><td class="line">	l = (<span class='keyword'>int</span>)<span class='macro'>STRLEN(curwin-&gt;w_s-&gt;b_p_spf)<span class='macro_popup'>strlen((char *)(curwin-&gt;w_s-&gt;b_p_spf))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="4362"><td class="num" id="LN4362">4362</td><td class="line">	<span class='keyword'>if</span> (l &gt; 0 &amp;&amp; (l &lt; 4</td></tr>
<tr class="codeline" data-linenumber="4363"><td class="num" id="LN4363">4363</td><td class="line">			|| <span class='macro'>STRCMP(curwin-&gt;w_s-&gt;b_p_spf + l - 4, <span class='string_literal'>".add"</span>)<span class='macro_popup'>strcmp((char *)(curwin-&gt;w_s-&gt;b_p_spf + l - 4), (char *)<br>(".add"))</span></span> != 0))</td></tr>
<tr class="codeline" data-linenumber="4364"><td class="num" id="LN4364">4364</td><td class="line">	    errmsg = e_invarg;</td></tr>
<tr class="codeline" data-linenumber="4365"><td class="num" id="LN4365">4365</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="4366"><td class="num" id="LN4366">4366</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4367"><td class="num" id="LN4367">4367</td><td class="line">    <span class='keyword'>if</span> (errmsg == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="4368"><td class="num" id="LN4368">4368</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="4369"><td class="num" id="LN4369">4369</td><td class="line">	<span class='macro'>FOR_ALL_WINDOWS(wp)<span class='macro_popup'>for (wp = firstwin; wp != ((void*)0); wp = wp-&gt;w_next)</span></span></td></tr>
<tr class="codeline" data-linenumber="4370"><td class="num" id="LN4370">4370</td><td class="line">	    <span class='keyword'>if</span> (wp-&gt;w_buffer == curbuf &amp;&amp; wp-&gt;<span class='macro'>w_p_spell<span class='macro_popup'>w_onebuf_opt.wo_spell</span></span>)</td></tr>
<tr class="codeline" data-linenumber="4371"><td class="num" id="LN4371">4371</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="4372"><td class="num" id="LN4372">4372</td><td class="line">		errmsg = did_set_spelllang(wp);</td></tr>
<tr class="codeline" data-linenumber="4373"><td class="num" id="LN4373">4373</td><td class="line">		<span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="4374"><td class="num" id="LN4374">4374</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="4375"><td class="num" id="LN4375">4375</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="4376"><td class="num" id="LN4376">4376</td><td class="line">    <span class='keyword'>return</span> errmsg;</td></tr>
<tr class="codeline" data-linenumber="4377"><td class="num" id="LN4377">4377</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="4378"><td class="num" id="LN4378">4378</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4379"><td class="num" id="LN4379">4379</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="4380"><td class="num" id="LN4380">4380</td><td class="line"> <span class='comment'>* Set curbuf-&gt;b_cap_prog to the regexp program for 'spellcapcheck'.</span></td></tr>
<tr class="codeline" data-linenumber="4381"><td class="num" id="LN4381">4381</td><td class="line"> <span class='comment'>* Return error message when failed, NULL when OK.</span></td></tr>
<tr class="codeline" data-linenumber="4382"><td class="num" id="LN4382">4382</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="4383"><td class="num" id="LN4383">4383</td><td class="line">    <span class='keyword'>char</span> *</td></tr>
<tr class="codeline" data-linenumber="4384"><td class="num" id="LN4384">4384</td><td class="line">compile_cap_prog(synblock_T *synblock)</td></tr>
<tr class="codeline" data-linenumber="4385"><td class="num" id="LN4385">4385</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="4386"><td class="num" id="LN4386">4386</td><td class="line">    regprog_T   *rp = synblock-&gt;b_cap_prog;</td></tr>
<tr class="codeline" data-linenumber="4387"><td class="num" id="LN4387">4387</td><td class="line">    char_u	*re;</td></tr>
<tr class="codeline" data-linenumber="4388"><td class="num" id="LN4388">4388</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4389"><td class="num" id="LN4389">4389</td><td class="line">    <span class='keyword'>if</span> (synblock-&gt;b_p_spc == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span> || *synblock-&gt;b_p_spc == <span class='macro'>NUL<span class='macro_popup'>'\000'</span></span>)</td></tr>
<tr class="codeline" data-linenumber="4390"><td class="num" id="LN4390">4390</td><td class="line">	synblock-&gt;b_cap_prog = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="4391"><td class="num" id="LN4391">4391</td><td class="line">    <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="4392"><td class="num" id="LN4392">4392</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="4393"><td class="num" id="LN4393">4393</td><td class="line">	<span class='comment'>// Prepend a ^ so that we only match at one column</span></td></tr>
<tr class="codeline" data-linenumber="4394"><td class="num" id="LN4394">4394</td><td class="line">	re = concat_str((char_u *)<span class='string_literal'>"^"</span>, synblock-&gt;b_p_spc);</td></tr>
<tr class="codeline" data-linenumber="4395"><td class="num" id="LN4395">4395</td><td class="line">	<span class='keyword'>if</span> (re != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="4396"><td class="num" id="LN4396">4396</td><td class="line">	{</td></tr>
<tr class="codeline" data-linenumber="4397"><td class="num" id="LN4397">4397</td><td class="line">	    synblock-&gt;b_cap_prog = vim_regcomp(re, <span class='macro'>RE_MAGIC<span class='macro_popup'>1</span></span>);</td></tr>
<tr class="codeline" data-linenumber="4398"><td class="num" id="LN4398">4398</td><td class="line">	    vim_free(re);</td></tr>
<tr class="codeline" data-linenumber="4399"><td class="num" id="LN4399">4399</td><td class="line">	    <span class='keyword'>if</span> (synblock-&gt;b_cap_prog == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="4400"><td class="num" id="LN4400">4400</td><td class="line">	    {</td></tr>
<tr class="codeline" data-linenumber="4401"><td class="num" id="LN4401">4401</td><td class="line">		synblock-&gt;b_cap_prog = rp; <span class='comment'>// restore the previous program</span></td></tr>
<tr class="codeline" data-linenumber="4402"><td class="num" id="LN4402">4402</td><td class="line">		<span class='keyword'>return</span> e_invarg;</td></tr>
<tr class="codeline" data-linenumber="4403"><td class="num" id="LN4403">4403</td><td class="line">	    }</td></tr>
<tr class="codeline" data-linenumber="4404"><td class="num" id="LN4404">4404</td><td class="line">	}</td></tr>
<tr class="codeline" data-linenumber="4405"><td class="num" id="LN4405">4405</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="4406"><td class="num" id="LN4406">4406</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4407"><td class="num" id="LN4407">4407</td><td class="line">    vim_regfree(rp);</td></tr>
<tr class="codeline" data-linenumber="4408"><td class="num" id="LN4408">4408</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="4409"><td class="num" id="LN4409">4409</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="4410"><td class="num" id="LN4410">4410</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="4411"><td class="num" id="LN4411">4411</td><td class="line"><span class='directive'>#endif  // FEAT_SPELL</span></td></tr>
</table></body></html>
