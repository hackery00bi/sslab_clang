<!doctype html>
<html>
<head>
<title>./../lib/common/bitstream.h</title>

<style type="text/css">
body { color:#000000; background-color:#ffffff }
body { font-family:Helvetica, sans-serif; font-size:10pt }
h1 { font-size:14pt }
.FileName { margin-top: 5px; margin-bottom: 5px; display: inline; }
.FileNav { margin-left: 5px; margin-right: 5px; display: inline; }
.FileNav a { text-decoration:none; font-size: larger; }
.divider { margin-top: 30px; margin-bottom: 30px; height: 15px; }
.divider { background-color: gray; }
.code { border-collapse:collapse; width:100%; }
.code { font-family: "Monospace", monospace; font-size:10pt }
.code { line-height: 1.2em }
.comment { color: green; font-style: oblique }
.keyword { color: blue }
.string_literal { color: red }
.directive { color: darkmagenta }

/* Macros and variables could have pop-up notes hidden by default.
  - Macro pop-up:    expansion of the macro
  - Variable pop-up: value (table) of the variable */
.macro_popup, .variable_popup { display: none; }

/* Pop-up appears on mouse-hover event. */
.macro:hover .macro_popup, .variable:hover .variable_popup {
  display: block;
  padding: 2px;
  -webkit-border-radius:5px;
  -webkit-box-shadow:1px 1px 7px #000;
  border-radius:5px;
  box-shadow:1px 1px 7px #000;
  position: absolute;
  top: -1em;
  left:10em;
  z-index: 1
}

.macro_popup {
  border: 2px solid red;
  background-color:#FFF0F0;
  font-weight: normal;
}

.variable_popup {
  border: 2px solid blue;
  background-color:#F0F0FF;
  font-weight: bold;
  font-family: Helvetica, sans-serif;
  font-size: 9pt;
}

/* Pop-up notes needs a relative position as a base where they pops up. */
.macro, .variable {
  background-color: PaleGoldenRod;
  position: relative;
}
.macro { color: DarkMagenta; }

#tooltiphint {
  position: fixed;
  width: 50em;
  margin-left: -25em;
  left: 50%;
  padding: 10px;
  border: 1px solid #b0b0b0;
  border-radius: 2px;
  box-shadow: 1px 1px 7px black;
  background-color: #c0c0c0;
  z-index: 2;
}

.num { width:2.5em; padding-right:2ex; background-color:#eeeeee }
.num { text-align:right; font-size:8pt }
.num { color:#444444 }
.line { padding-left: 1ex; border-left: 3px solid #ccc }
.line { white-space: pre }
.msg { -webkit-box-shadow:1px 1px 7px #000 }
.msg { box-shadow:1px 1px 7px #000 }
.msg { -webkit-border-radius:5px }
.msg { border-radius:5px }
.msg { font-family:Helvetica, sans-serif; font-size:8pt }
.msg { float:left }
.msg { padding:0.25em 1ex 0.25em 1ex }
.msg { margin-top:10px; margin-bottom:10px }
.msg { font-weight:bold }
.msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }
.msgT { padding:0x; spacing:0x }
.msgEvent { background-color:#fff8b4; color:#000000 }
.msgControl { background-color:#bbbbbb; color:#000000 }
.msgNote { background-color:#ddeeff; color:#000000 }
.mrange { background-color:#dfddf3 }
.mrange { border-bottom:1px solid #6F9DBE }
.PathIndex { font-weight: bold; padding:0px 5px; margin-right:5px; }
.PathIndex { -webkit-border-radius:8px }
.PathIndex { border-radius:8px }
.PathIndexEvent { background-color:#bfba87 }
.PathIndexControl { background-color:#8c8c8c }
.PathIndexPopUp { background-color: #879abc; }
.PathNav a { text-decoration:none; font-size: larger }
.CodeInsertionHint { font-weight: bold; background-color: #10dd10 }
.CodeRemovalHint { background-color:#de1010 }
.CodeRemovalHint { border-bottom:1px solid #6F9DBE }
.selected{ background-color:orange !important; }

table.simpletable {
  padding: 5px;
  font-size:12pt;
  margin:20px;
  border-collapse: collapse; border-spacing: 0px;
}
td.rowname {
  text-align: right;
  vertical-align: top;
  font-weight: bold;
  color:#444444;
  padding-right:2ex;
}

/* Hidden text. */
input.spoilerhider + label {
  cursor: pointer;
  text-decoration: underline;
  display: block;
}
input.spoilerhider {
 display: none;
}
input.spoilerhider ~ .spoiler {
  overflow: hidden;
  margin: 10px auto 0;
  height: 0;
  opacity: 0;
}
input.spoilerhider:checked + label + .spoiler{
  height: auto;
  opacity: 1;
}
</style>
</head>
<body>
<!-- BUGDESC Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 -->

<!-- BUGTYPE Potential insecure memory buffer bounds restriction in call 'memset' -->

<!-- BUGCATEGORY Security -->

<!-- BUGFILE /tmp/sslab_clang/c_zstd/zstd/programs/./../lib/common/bitstream.h -->

<!-- FILENAME bitstream.h -->

<!-- FUNCTIONNAME BIT_initDStream -->

<!-- ISSUEHASHCONTENTOFLINEINCONTEXT 64734b203688414d58408ba91d665548 -->

<!-- BUGLINE 274 -->

<!-- BUGCOLUMN 24 -->

<!-- BUGPATHLENGTH 1 -->

<!-- BUGMETAEND -->
<!-- REPORTHEADER -->
<h3>Bug Summary</h3>
<table class="simpletable">
<tr><td class="rowname">File:</td><td>/tmp/sslab_clang/c_zstd/zstd/programs/./../lib/common/bitstream.h</td></tr>
<tr><td class="rowname">Warning:</td><td><a href="#EndPath">line 274, column 24</a><br />Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11</td></tr>

</table>
<!-- REPORTSUMMARYEXTRA -->
<h3>Annotated Source Code</h3>
<p>Press <a href="#" onclick="toggleHelp(); return false;">'?'</a>
   to see keyboard shortcuts</p>
<input type="checkbox" class="spoilerhider" id="showinvocation" />
<label for="showinvocation" >Show analyzer invocation</label>
<div class="spoiler">clang -cc1 -cc1 -triple x86_64-unknown-linux-gnu -analyze -disable-free -main-file-name fileio.c -analyzer-store=region -analyzer-opt-analyze-nested-blocks -analyzer-checker=core -analyzer-checker=apiModeling -analyzer-checker=unix -analyzer-checker=deadcode -analyzer-checker=security.insecureAPI.UncheckedReturn -analyzer-checker=security.insecureAPI.getpw -analyzer-checker=security.insecureAPI.gets -analyzer-checker=security.insecureAPI.mktemp -analyzer-checker=security.insecureAPI.mkstemp -analyzer-checker=security.insecureAPI.vfork -analyzer-checker=nullability.NullPassedToNonnull -analyzer-checker=nullability.NullReturnedFromNonnull -analyzer-output plist -w -setup-static-analyzer -mrelocation-model static -mframe-pointer=none -fmath-errno -fno-rounding-math -mconstructor-aliases -munwind-tables -target-cpu x86-64 -fno-split-dwarf-inlining -debugger-tuning=gdb -resource-dir /llvm-project/build/lib/clang/12.0.0 -D BACKTRACE_ENABLE=0 -D XXH_NAMESPACE=ZSTD_ -D ZSTD_MULTITHREAD -D ZSTD_GZCOMPRESS -D ZSTD_GZDECOMPRESS -D ZSTD_LZMACOMPRESS -D ZSTD_LZMADECOMPRESS -D ZSTD_LZ4COMPRESS -D ZSTD_LZ4DECOMPRESS -D ZSTD_LEGACY_SUPPORT=5 -internal-isystem /usr/local/include -internal-isystem /llvm-project/build/lib/clang/12.0.0/include -internal-externc-isystem /usr/include/x86_64-linux-gnu -internal-externc-isystem /include -internal-externc-isystem /usr/include -O3 -fdebug-compilation-dir /tmp/sslab_clang/c_zstd/zstd/programs -ferror-limit 19 -fgnuc-version=4.2.1 -vectorize-loops -vectorize-slp -analyzer-checker core -analyzer-checker cplusplus -analyzer-checker nullability -analyzer-checker optin -analyzer-checker security -analyzer-checker unix -analyzer-checker osx -analyzer-checker fuchsia -analyzer-checker webkit -analyzer-output=html -faddrsig -o /tmp/scan-build-2020-11-23-162036-2464-1 -x c fileio.c
</div>
<div id='tooltiphint' hidden="true">
  <p>Keyboard shortcuts: </p>
  <ul>
    <li>Use 'j/k' keys for keyboard navigation</li>
    <li>Use 'Shift+S' to show/hide relevant lines</li>
    <li>Use '?' to toggle this window</li>
  </ul>
  <a href="#" onclick="toggleHelp(); return false;">Close</a>
</div>
<script type='text/javascript'>
var relevant_lines = {"1958": {"274": 1}};

var filterCounterexample = function (hide) {
  var tables = document.getElementsByClassName("code");
  for (var t=0; t<tables.length; t++) {
    var table = tables[t];
    var file_id = table.getAttribute("data-fileid");
    var lines_in_fid = relevant_lines[file_id];
    if (!lines_in_fid) {
      lines_in_fid = {};
    }
    var lines = table.getElementsByClassName("codeline");
    for (var i=0; i<lines.length; i++) {
        var el = lines[i];
        var lineNo = el.getAttribute("data-linenumber");
        if (!lines_in_fid[lineNo]) {
          if (hide) {
            el.setAttribute("hidden", "");
          } else {
            el.removeAttribute("hidden");
          }
        }
    }
  }
}

window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.key == "S") {
    var checked = document.getElementsByName("showCounterexample")[0].checked;
    filterCounterexample(!checked);
    document.getElementsByName("showCounterexample")[0].checked = !checked;
  } else {
    return;
  }
  event.preventDefault();
}, true);

document.addEventListener("DOMContentLoaded", function() {
    document.querySelector('input[name="showCounterexample"]').onchange=
        function (event) {
      filterCounterexample(this.checked);
    };
});
</script>

<form>
    <input type="checkbox" name="showCounterexample" id="showCounterexample" />
    <label for="showCounterexample">
       Show only relevant lines
    </label>
</form>

<script type='text/javascript'>
var digitMatcher = new RegExp("[0-9]+");

var querySelectorAllArray = function(selector) {
  return Array.prototype.slice.call(
    document.querySelectorAll(selector));
}

document.addEventListener("DOMContentLoaded", function() {
    querySelectorAllArray(".PathNav > a").forEach(
        function(currentValue, currentIndex) {
            var hrefValue = currentValue.getAttribute("href");
            currentValue.onclick = function() {
                scrollTo(document.querySelector(hrefValue));
                return false;
            };
        });
});

var findNum = function() {
    var s = document.querySelector(".selected");
    if (!s || s.id == "EndPath") {
        return 0;
    }
    var out = parseInt(digitMatcher.exec(s.id)[0]);
    return out;
};

var scrollTo = function(el) {
    querySelectorAllArray(".selected").forEach(function(s) {
        s.classList.remove("selected");
    });
    el.classList.add("selected");
    window.scrollBy(0, el.getBoundingClientRect().top -
        (window.innerHeight / 2));
}

var move = function(num, up, numItems) {
  if (num == 1 && up || num == numItems - 1 && !up) {
    return 0;
  } else if (num == 0 && up) {
    return numItems - 1;
  } else if (num == 0 && !up) {
    return 1 % numItems;
  }
  return up ? num - 1 : num + 1;
}

var numToId = function(num) {
  if (num == 0) {
    return document.getElementById("EndPath")
  }
  return document.getElementById("Path" + num);
};

var navigateTo = function(up) {
  var numItems = document.querySelectorAll(
      ".line > .msgEvent, .line > .msgControl").length;
  var currentSelected = findNum();
  var newSelected = move(currentSelected, up, numItems);
  var newEl = numToId(newSelected, numItems);

  // Scroll element into center.
  scrollTo(newEl);
};

window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.key == "j") {
    navigateTo(/*up=*/false);
  } else if (event.key == "k") {
    navigateTo(/*up=*/true);
  } else {
    return;
  }
  event.preventDefault();
}, true);
</script>
  
<script type='text/javascript'>

var toggleHelp = function() {
    var hint = document.querySelector("#tooltiphint");
    var attributeName = "hidden";
    if (hint.hasAttribute(attributeName)) {
      hint.removeAttribute(attributeName);
    } else {
      hint.setAttribute("hidden", "true");
    }
};
window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.key == "?") {
    toggleHelp();
  } else {
    return;
  }
  event.preventDefault();
});
</script>
<table class="code" data-fileid="1958">
<tr class="codeline" data-linenumber="1"><td class="num" id="LN1">1</td><td class="line"><span class='comment'>/* ******************************************************************</span></td></tr>
<tr class="codeline" data-linenumber="2"><td class="num" id="LN2">2</td><td class="line"> <span class='comment'>* bitstream</span></td></tr>
<tr class="codeline" data-linenumber="3"><td class="num" id="LN3">3</td><td class="line"> <span class='comment'>* Part of FSE library</span></td></tr>
<tr class="codeline" data-linenumber="4"><td class="num" id="LN4">4</td><td class="line"> <span class='comment'>* Copyright (c) 2013-2020, Yann Collet, Facebook, Inc.</span></td></tr>
<tr class="codeline" data-linenumber="5"><td class="num" id="LN5">5</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="6"><td class="num" id="LN6">6</td><td class="line"> <span class='comment'>* You can contact the author at :</span></td></tr>
<tr class="codeline" data-linenumber="7"><td class="num" id="LN7">7</td><td class="line"> <span class='comment'>* - Source repository : https://github.com/Cyan4973/FiniteStateEntropy</span></td></tr>
<tr class="codeline" data-linenumber="8"><td class="num" id="LN8">8</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="9"><td class="num" id="LN9">9</td><td class="line"> <span class='comment'>* This source code is licensed under both the BSD-style license (found in the</span></td></tr>
<tr class="codeline" data-linenumber="10"><td class="num" id="LN10">10</td><td class="line"> <span class='comment'>* LICENSE file in the root directory of this source tree) and the GPLv2 (found</span></td></tr>
<tr class="codeline" data-linenumber="11"><td class="num" id="LN11">11</td><td class="line"> <span class='comment'>* in the COPYING file in the root directory of this source tree).</span></td></tr>
<tr class="codeline" data-linenumber="12"><td class="num" id="LN12">12</td><td class="line"> <span class='comment'>* You may select, at your option, one of the above-listed licenses.</span></td></tr>
<tr class="codeline" data-linenumber="13"><td class="num" id="LN13">13</td><td class="line"><span class='comment'>****************************************************************** */</span></td></tr>
<tr class="codeline" data-linenumber="14"><td class="num" id="LN14">14</td><td class="line"><span class='directive'>#ifndef BITSTREAM_H_MODULE</span></td></tr>
<tr class="codeline" data-linenumber="15"><td class="num" id="LN15">15</td><td class="line"><span class='directive'>#define BITSTREAM_H_MODULE</span></td></tr>
<tr class="codeline" data-linenumber="16"><td class="num" id="LN16">16</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="17"><td class="num" id="LN17">17</td><td class="line"><span class='directive'>#if defined (__cplusplus)</span></td></tr>
<tr class="codeline" data-linenumber="18"><td class="num" id="LN18">18</td><td class="line"><span class='keyword'>extern</span> <span class='string_literal'>"C"</span> {</td></tr>
<tr class="codeline" data-linenumber="19"><td class="num" id="LN19">19</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="20"><td class="num" id="LN20">20</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="21"><td class="num" id="LN21">21</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="22"><td class="num" id="LN22">22</td><td class="line"><span class='comment'>*  This API consists of small unitary functions, which must be inlined for best performance.</span></td></tr>
<tr class="codeline" data-linenumber="23"><td class="num" id="LN23">23</td><td class="line"><span class='comment'>*  Since link-time-optimization is not available for all compilers,</span></td></tr>
<tr class="codeline" data-linenumber="24"><td class="num" id="LN24">24</td><td class="line"><span class='comment'>*  these functions are defined into a .h to be included.</span></td></tr>
<tr class="codeline" data-linenumber="25"><td class="num" id="LN25">25</td><td class="line"><span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="26"><td class="num" id="LN26">26</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="27"><td class="num" id="LN27">27</td><td class="line"><span class='comment'>/*-****************************************</span></td></tr>
<tr class="codeline" data-linenumber="28"><td class="num" id="LN28">28</td><td class="line"><span class='comment'>*  Dependencies</span></td></tr>
<tr class="codeline" data-linenumber="29"><td class="num" id="LN29">29</td><td class="line"><span class='comment'>******************************************/</span></td></tr>
<tr class="codeline" data-linenumber="30"><td class="num" id="LN30">30</td><td class="line"><span class='directive'>#include "mem.h"            /* unaligned access routines */</span></td></tr>
<tr class="codeline" data-linenumber="31"><td class="num" id="LN31">31</td><td class="line"><span class='directive'>#include "compiler.h"       /* UNLIKELY() */</span></td></tr>
<tr class="codeline" data-linenumber="32"><td class="num" id="LN32">32</td><td class="line"><span class='directive'>#include "debug.h"          /* assert(), DEBUGLOG(), RAWLOG() */</span></td></tr>
<tr class="codeline" data-linenumber="33"><td class="num" id="LN33">33</td><td class="line"><span class='directive'>#include "error_private.h"  /* error codes and messages */</span></td></tr>
<tr class="codeline" data-linenumber="34"><td class="num" id="LN34">34</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="35"><td class="num" id="LN35">35</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="36"><td class="num" id="LN36">36</td><td class="line"><span class='comment'>/*=========================================</span></td></tr>
<tr class="codeline" data-linenumber="37"><td class="num" id="LN37">37</td><td class="line"><span class='comment'>*  Target specific</span></td></tr>
<tr class="codeline" data-linenumber="38"><td class="num" id="LN38">38</td><td class="line"><span class='comment'>=========================================*/</span></td></tr>
<tr class="codeline" data-linenumber="39"><td class="num" id="LN39">39</td><td class="line"><span class='directive'>#if defined(__BMI__) &amp;&amp; defined(<span class='macro'>__GNUC__<span class='macro_popup'>4</span></span>)</span></td></tr>
<tr class="codeline" data-linenumber="40"><td class="num" id="LN40">40</td><td class="line"><span class='directive'>#  include &lt;immintrin.h&gt;   /* support for bextr (experimental) */</span></td></tr>
<tr class="codeline" data-linenumber="41"><td class="num" id="LN41">41</td><td class="line"><span class='directive'>#elif defined(__ICCARM__)</span></td></tr>
<tr class="codeline" data-linenumber="42"><td class="num" id="LN42">42</td><td class="line"><span class='directive'>#  include &lt;intrinsics.h&gt;</span></td></tr>
<tr class="codeline" data-linenumber="43"><td class="num" id="LN43">43</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="44"><td class="num" id="LN44">44</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="45"><td class="num" id="LN45">45</td><td class="line"><span class='directive'>#define <span class='macro'>STREAM_ACCUMULATOR_MIN_32<span class='macro_popup'>25</span></span>  25</span></td></tr>
<tr class="codeline" data-linenumber="46"><td class="num" id="LN46">46</td><td class="line"><span class='directive'>#define <span class='macro'>STREAM_ACCUMULATOR_MIN_64<span class='macro_popup'>57</span></span>  57</span></td></tr>
<tr class="codeline" data-linenumber="47"><td class="num" id="LN47">47</td><td class="line"><span class='directive'>#define <span class='macro'>STREAM_ACCUMULATOR_MIN<span class='macro_popup'>((U32)(MEM_32bits() ? 25 : 57))</span></span>    ((U32)(MEM_32bits() ? <span class='macro'>STREAM_ACCUMULATOR_MIN_32<span class='macro_popup'>25</span></span> : <span class='macro'>STREAM_ACCUMULATOR_MIN_64<span class='macro_popup'>57</span></span>))</span></td></tr>
<tr class="codeline" data-linenumber="48"><td class="num" id="LN48">48</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="49"><td class="num" id="LN49">49</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="50"><td class="num" id="LN50">50</td><td class="line"><span class='comment'>/*-******************************************</span></td></tr>
<tr class="codeline" data-linenumber="51"><td class="num" id="LN51">51</td><td class="line"><span class='comment'>*  bitStream encoding API (write forward)</span></td></tr>
<tr class="codeline" data-linenumber="52"><td class="num" id="LN52">52</td><td class="line"><span class='comment'>********************************************/</span></td></tr>
<tr class="codeline" data-linenumber="53"><td class="num" id="LN53">53</td><td class="line"><span class='comment'>/* bitStream can mix input from multiple sources.</span></td></tr>
<tr class="codeline" data-linenumber="54"><td class="num" id="LN54">54</td><td class="line"> <span class='comment'>* A critical property of these streams is that they encode and decode in **reverse** direction.</span></td></tr>
<tr class="codeline" data-linenumber="55"><td class="num" id="LN55">55</td><td class="line"> <span class='comment'>* So the first bit sequence you add will be the last to be read, like a LIFO stack.</span></td></tr>
<tr class="codeline" data-linenumber="56"><td class="num" id="LN56">56</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="57"><td class="num" id="LN57">57</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> {</td></tr>
<tr class="codeline" data-linenumber="58"><td class="num" id="LN58">58</td><td class="line">    size_t bitContainer;</td></tr>
<tr class="codeline" data-linenumber="59"><td class="num" id="LN59">59</td><td class="line">    <span class='keyword'>unsigned</span> bitPos;</td></tr>
<tr class="codeline" data-linenumber="60"><td class="num" id="LN60">60</td><td class="line">    <span class='keyword'>char</span>*  startPtr;</td></tr>
<tr class="codeline" data-linenumber="61"><td class="num" id="LN61">61</td><td class="line">    <span class='keyword'>char</span>*  ptr;</td></tr>
<tr class="codeline" data-linenumber="62"><td class="num" id="LN62">62</td><td class="line">    <span class='keyword'>char</span>*  endPtr;</td></tr>
<tr class="codeline" data-linenumber="63"><td class="num" id="LN63">63</td><td class="line">} BIT_CStream_t;</td></tr>
<tr class="codeline" data-linenumber="64"><td class="num" id="LN64">64</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="65"><td class="num" id="LN65">65</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> size_t BIT_initCStream(BIT_CStream_t* bitC, <span class='keyword'>void</span>* dstBuffer, size_t dstCapacity);</td></tr>
<tr class="codeline" data-linenumber="66"><td class="num" id="LN66">66</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> <span class='keyword'>void</span>   BIT_addBits(BIT_CStream_t* bitC, size_t value, <span class='keyword'>unsigned</span> nbBits);</td></tr>
<tr class="codeline" data-linenumber="67"><td class="num" id="LN67">67</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> <span class='keyword'>void</span>   BIT_flushBits(BIT_CStream_t* bitC);</td></tr>
<tr class="codeline" data-linenumber="68"><td class="num" id="LN68">68</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> size_t BIT_closeCStream(BIT_CStream_t* bitC);</td></tr>
<tr class="codeline" data-linenumber="69"><td class="num" id="LN69">69</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="70"><td class="num" id="LN70">70</td><td class="line"><span class='comment'>/* Start with initCStream, providing the size of buffer to write into.</span></td></tr>
<tr class="codeline" data-linenumber="71"><td class="num" id="LN71">71</td><td class="line"><span class='comment'>*  bitStream will never write outside of this buffer.</span></td></tr>
<tr class="codeline" data-linenumber="72"><td class="num" id="LN72">72</td><td class="line"><span class='comment'>*  `dstCapacity` must be &gt;= sizeof(bitD-&gt;bitContainer), otherwise @return will be an error code.</span></td></tr>
<tr class="codeline" data-linenumber="73"><td class="num" id="LN73">73</td><td class="line"><span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="74"><td class="num" id="LN74">74</td><td class="line"><span class='comment'>*  bits are first added to a local register.</span></td></tr>
<tr class="codeline" data-linenumber="75"><td class="num" id="LN75">75</td><td class="line"><span class='comment'>*  Local register is size_t, hence 64-bits on 64-bits systems, or 32-bits on 32-bits systems.</span></td></tr>
<tr class="codeline" data-linenumber="76"><td class="num" id="LN76">76</td><td class="line"><span class='comment'>*  Writing data into memory is an explicit operation, performed by the flushBits function.</span></td></tr>
<tr class="codeline" data-linenumber="77"><td class="num" id="LN77">77</td><td class="line"><span class='comment'>*  Hence keep track how many bits are potentially stored into local register to avoid register overflow.</span></td></tr>
<tr class="codeline" data-linenumber="78"><td class="num" id="LN78">78</td><td class="line"><span class='comment'>*  After a flushBits, a maximum of 7 bits might still be stored into local register.</span></td></tr>
<tr class="codeline" data-linenumber="79"><td class="num" id="LN79">79</td><td class="line"><span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="80"><td class="num" id="LN80">80</td><td class="line"><span class='comment'>*  Avoid storing elements of more than 24 bits if you want compatibility with 32-bits bitstream readers.</span></td></tr>
<tr class="codeline" data-linenumber="81"><td class="num" id="LN81">81</td><td class="line"><span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="82"><td class="num" id="LN82">82</td><td class="line"><span class='comment'>*  Last operation is to close the bitStream.</span></td></tr>
<tr class="codeline" data-linenumber="83"><td class="num" id="LN83">83</td><td class="line"><span class='comment'>*  The function returns the final size of CStream in bytes.</span></td></tr>
<tr class="codeline" data-linenumber="84"><td class="num" id="LN84">84</td><td class="line"><span class='comment'>*  If data couldn't fit into `dstBuffer`, it will return a 0 ( == not storable)</span></td></tr>
<tr class="codeline" data-linenumber="85"><td class="num" id="LN85">85</td><td class="line"><span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="86"><td class="num" id="LN86">86</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="87"><td class="num" id="LN87">87</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="88"><td class="num" id="LN88">88</td><td class="line"><span class='comment'>/*-********************************************</span></td></tr>
<tr class="codeline" data-linenumber="89"><td class="num" id="LN89">89</td><td class="line"><span class='comment'>*  bitStream decoding API (read backward)</span></td></tr>
<tr class="codeline" data-linenumber="90"><td class="num" id="LN90">90</td><td class="line"><span class='comment'>**********************************************/</span></td></tr>
<tr class="codeline" data-linenumber="91"><td class="num" id="LN91">91</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> {</td></tr>
<tr class="codeline" data-linenumber="92"><td class="num" id="LN92">92</td><td class="line">    size_t   bitContainer;</td></tr>
<tr class="codeline" data-linenumber="93"><td class="num" id="LN93">93</td><td class="line">    <span class='keyword'>unsigned</span> bitsConsumed;</td></tr>
<tr class="codeline" data-linenumber="94"><td class="num" id="LN94">94</td><td class="line">    <span class='keyword'>const</span> <span class='keyword'>char</span>* ptr;</td></tr>
<tr class="codeline" data-linenumber="95"><td class="num" id="LN95">95</td><td class="line">    <span class='keyword'>const</span> <span class='keyword'>char</span>* start;</td></tr>
<tr class="codeline" data-linenumber="96"><td class="num" id="LN96">96</td><td class="line">    <span class='keyword'>const</span> <span class='keyword'>char</span>* limitPtr;</td></tr>
<tr class="codeline" data-linenumber="97"><td class="num" id="LN97">97</td><td class="line">} BIT_DStream_t;</td></tr>
<tr class="codeline" data-linenumber="98"><td class="num" id="LN98">98</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="99"><td class="num" id="LN99">99</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>enum</span> { BIT_DStream_unfinished = 0,</td></tr>
<tr class="codeline" data-linenumber="100"><td class="num" id="LN100">100</td><td class="line">               BIT_DStream_endOfBuffer = 1,</td></tr>
<tr class="codeline" data-linenumber="101"><td class="num" id="LN101">101</td><td class="line">               BIT_DStream_completed = 2,</td></tr>
<tr class="codeline" data-linenumber="102"><td class="num" id="LN102">102</td><td class="line">               BIT_DStream_overflow = 3 } BIT_DStream_status;  <span class='comment'>/* result of BIT_reloadDStream() */</span></td></tr>
<tr class="codeline" data-linenumber="103"><td class="num" id="LN103">103</td><td class="line">               <span class='comment'>/* 1,2,4,8 would be better for bitmap combinations, but slows down performance a bit ... :( */</span></td></tr>
<tr class="codeline" data-linenumber="104"><td class="num" id="LN104">104</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="105"><td class="num" id="LN105">105</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> size_t   BIT_initDStream(BIT_DStream_t* bitD, <span class='keyword'>const</span> <span class='keyword'>void</span>* srcBuffer, size_t srcSize);</td></tr>
<tr class="codeline" data-linenumber="106"><td class="num" id="LN106">106</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> size_t   BIT_readBits(BIT_DStream_t* bitD, <span class='keyword'>unsigned</span> nbBits);</td></tr>
<tr class="codeline" data-linenumber="107"><td class="num" id="LN107">107</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> BIT_DStream_status BIT_reloadDStream(BIT_DStream_t* bitD);</td></tr>
<tr class="codeline" data-linenumber="108"><td class="num" id="LN108">108</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> <span class='keyword'>unsigned</span> BIT_endOfDStream(<span class='keyword'>const</span> BIT_DStream_t* bitD);</td></tr>
<tr class="codeline" data-linenumber="109"><td class="num" id="LN109">109</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="110"><td class="num" id="LN110">110</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="111"><td class="num" id="LN111">111</td><td class="line"><span class='comment'>/* Start by invoking BIT_initDStream().</span></td></tr>
<tr class="codeline" data-linenumber="112"><td class="num" id="LN112">112</td><td class="line"><span class='comment'>*  A chunk of the bitStream is then stored into a local register.</span></td></tr>
<tr class="codeline" data-linenumber="113"><td class="num" id="LN113">113</td><td class="line"><span class='comment'>*  Local register size is 64-bits on 64-bits systems, 32-bits on 32-bits systems (size_t).</span></td></tr>
<tr class="codeline" data-linenumber="114"><td class="num" id="LN114">114</td><td class="line"><span class='comment'>*  You can then retrieve bitFields stored into the local register, **in reverse order**.</span></td></tr>
<tr class="codeline" data-linenumber="115"><td class="num" id="LN115">115</td><td class="line"><span class='comment'>*  Local register is explicitly reloaded from memory by the BIT_reloadDStream() method.</span></td></tr>
<tr class="codeline" data-linenumber="116"><td class="num" id="LN116">116</td><td class="line"><span class='comment'>*  A reload guarantee a minimum of ((8*sizeof(bitD-&gt;bitContainer))-7) bits when its result is BIT_DStream_unfinished.</span></td></tr>
<tr class="codeline" data-linenumber="117"><td class="num" id="LN117">117</td><td class="line"><span class='comment'>*  Otherwise, it can be less than that, so proceed accordingly.</span></td></tr>
<tr class="codeline" data-linenumber="118"><td class="num" id="LN118">118</td><td class="line"><span class='comment'>*  Checking if DStream has reached its end can be performed with BIT_endOfDStream().</span></td></tr>
<tr class="codeline" data-linenumber="119"><td class="num" id="LN119">119</td><td class="line"><span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="120"><td class="num" id="LN120">120</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="121"><td class="num" id="LN121">121</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="122"><td class="num" id="LN122">122</td><td class="line"><span class='comment'>/*-****************************************</span></td></tr>
<tr class="codeline" data-linenumber="123"><td class="num" id="LN123">123</td><td class="line"><span class='comment'>*  unsafe API</span></td></tr>
<tr class="codeline" data-linenumber="124"><td class="num" id="LN124">124</td><td class="line"><span class='comment'>******************************************/</span></td></tr>
<tr class="codeline" data-linenumber="125"><td class="num" id="LN125">125</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> <span class='keyword'>void</span> BIT_addBitsFast(BIT_CStream_t* bitC, size_t value, <span class='keyword'>unsigned</span> nbBits);</td></tr>
<tr class="codeline" data-linenumber="126"><td class="num" id="LN126">126</td><td class="line"><span class='comment'>/* faster, but works only if value is "clean", meaning all high bits above nbBits are 0 */</span></td></tr>
<tr class="codeline" data-linenumber="127"><td class="num" id="LN127">127</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="128"><td class="num" id="LN128">128</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> <span class='keyword'>void</span> BIT_flushBitsFast(BIT_CStream_t* bitC);</td></tr>
<tr class="codeline" data-linenumber="129"><td class="num" id="LN129">129</td><td class="line"><span class='comment'>/* unsafe version; does not check buffer overflow */</span></td></tr>
<tr class="codeline" data-linenumber="130"><td class="num" id="LN130">130</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="131"><td class="num" id="LN131">131</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> size_t BIT_readBitsFast(BIT_DStream_t* bitD, <span class='keyword'>unsigned</span> nbBits);</td></tr>
<tr class="codeline" data-linenumber="132"><td class="num" id="LN132">132</td><td class="line"><span class='comment'>/* faster, but works only if nbBits &gt;= 1 */</span></td></tr>
<tr class="codeline" data-linenumber="133"><td class="num" id="LN133">133</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="134"><td class="num" id="LN134">134</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="135"><td class="num" id="LN135">135</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="136"><td class="num" id="LN136">136</td><td class="line"><span class='comment'>/*-**************************************************************</span></td></tr>
<tr class="codeline" data-linenumber="137"><td class="num" id="LN137">137</td><td class="line"><span class='comment'>*  Internal functions</span></td></tr>
<tr class="codeline" data-linenumber="138"><td class="num" id="LN138">138</td><td class="line"><span class='comment'>****************************************************************/</span></td></tr>
<tr class="codeline" data-linenumber="139"><td class="num" id="LN139">139</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> <span class='keyword'>unsigned</span> BIT_highbit32 (U32 val)</td></tr>
<tr class="codeline" data-linenumber="140"><td class="num" id="LN140">140</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="141"><td class="num" id="LN141">141</td><td class="line">    <span class='macro'>assert(val != 0)<span class='macro_popup'>((void) sizeof ((val != 0) ? 1 : 0), __extension__ ({ if (val<br> != 0) ; else __assert_fail ("val != 0", "./../lib/common/bitstream.h"<br>, 141, __extension__ __PRETTY_FUNCTION__); }))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="142"><td class="num" id="LN142">142</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="143"><td class="num" id="LN143">143</td><td class="line"><span class='directive'>#   if defined(_MSC_VER)   /* Visual */</span></td></tr>
<tr class="codeline" data-linenumber="144"><td class="num" id="LN144">144</td><td class="line">        <span class='keyword'>unsigned</span> <span class='keyword'>long</span> r=0;</td></tr>
<tr class="codeline" data-linenumber="145"><td class="num" id="LN145">145</td><td class="line">        <span class='keyword'>return</span> _BitScanReverse ( &amp;r, val ) ? (<span class='keyword'>unsigned</span>)r : 0;</td></tr>
<tr class="codeline" data-linenumber="146"><td class="num" id="LN146">146</td><td class="line"><span class='directive'>#   elif defined(<span class='macro'>__GNUC__<span class='macro_popup'>4</span></span>) &amp;&amp; (<span class='macro'>__GNUC__<span class='macro_popup'>4</span></span> &gt;= 3)   /* Use GCC Intrinsic */</span></td></tr>
<tr class="codeline" data-linenumber="147"><td class="num" id="LN147">147</td><td class="line">        <span class='keyword'>return</span> __builtin_clz (val) ^ 31;</td></tr>
<tr class="codeline" data-linenumber="148"><td class="num" id="LN148">148</td><td class="line"><span class='directive'>#   elif defined(__ICCARM__)    /* IAR Intrinsic */</span></td></tr>
<tr class="codeline" data-linenumber="149"><td class="num" id="LN149">149</td><td class="line">        <span class='keyword'>return</span> 31 - __CLZ(val);</td></tr>
<tr class="codeline" data-linenumber="150"><td class="num" id="LN150">150</td><td class="line"><span class='directive'>#   else   /* Software version */</span></td></tr>
<tr class="codeline" data-linenumber="151"><td class="num" id="LN151">151</td><td class="line">        <span class='keyword'>static</span> <span class='keyword'>const</span> <span class='keyword'>unsigned</span> DeBruijnClz[32] = { 0,  9,  1, 10, 13, 21,  2, 29,</td></tr>
<tr class="codeline" data-linenumber="152"><td class="num" id="LN152">152</td><td class="line">                                                 11, 14, 16, 18, 22, 25,  3, 30,</td></tr>
<tr class="codeline" data-linenumber="153"><td class="num" id="LN153">153</td><td class="line">                                                  8, 12, 20, 28, 15, 17, 24,  7,</td></tr>
<tr class="codeline" data-linenumber="154"><td class="num" id="LN154">154</td><td class="line">                                                 19, 27, 23,  6, 26,  5,  4, 31 };</td></tr>
<tr class="codeline" data-linenumber="155"><td class="num" id="LN155">155</td><td class="line">        U32 v = val;</td></tr>
<tr class="codeline" data-linenumber="156"><td class="num" id="LN156">156</td><td class="line">        v |= v &gt;&gt; 1;</td></tr>
<tr class="codeline" data-linenumber="157"><td class="num" id="LN157">157</td><td class="line">        v |= v &gt;&gt; 2;</td></tr>
<tr class="codeline" data-linenumber="158"><td class="num" id="LN158">158</td><td class="line">        v |= v &gt;&gt; 4;</td></tr>
<tr class="codeline" data-linenumber="159"><td class="num" id="LN159">159</td><td class="line">        v |= v &gt;&gt; 8;</td></tr>
<tr class="codeline" data-linenumber="160"><td class="num" id="LN160">160</td><td class="line">        v |= v &gt;&gt; 16;</td></tr>
<tr class="codeline" data-linenumber="161"><td class="num" id="LN161">161</td><td class="line">        <span class='keyword'>return</span> DeBruijnClz[ (U32) (v * 0x07C4ACDDU) &gt;&gt; 27];</td></tr>
<tr class="codeline" data-linenumber="162"><td class="num" id="LN162">162</td><td class="line"><span class='directive'>#   endif</span></td></tr>
<tr class="codeline" data-linenumber="163"><td class="num" id="LN163">163</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="164"><td class="num" id="LN164">164</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="165"><td class="num" id="LN165">165</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="166"><td class="num" id="LN166">166</td><td class="line"><span class='comment'>/*=====    Local Constants   =====*/</span></td></tr>
<tr class="codeline" data-linenumber="167"><td class="num" id="LN167">167</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>const</span> <span class='keyword'>unsigned</span> BIT_mask[] = {</td></tr>
<tr class="codeline" data-linenumber="168"><td class="num" id="LN168">168</td><td class="line">    0,          1,         3,         7,         0xF,       0x1F,</td></tr>
<tr class="codeline" data-linenumber="169"><td class="num" id="LN169">169</td><td class="line">    0x3F,       0x7F,      0xFF,      0x1FF,     0x3FF,     0x7FF,</td></tr>
<tr class="codeline" data-linenumber="170"><td class="num" id="LN170">170</td><td class="line">    0xFFF,      0x1FFF,    0x3FFF,    0x7FFF,    0xFFFF,    0x1FFFF,</td></tr>
<tr class="codeline" data-linenumber="171"><td class="num" id="LN171">171</td><td class="line">    0x3FFFF,    0x7FFFF,   0xFFFFF,   0x1FFFFF,  0x3FFFFF,  0x7FFFFF,</td></tr>
<tr class="codeline" data-linenumber="172"><td class="num" id="LN172">172</td><td class="line">    0xFFFFFF,   0x1FFFFFF, 0x3FFFFFF, 0x7FFFFFF, 0xFFFFFFF, 0x1FFFFFFF,</td></tr>
<tr class="codeline" data-linenumber="173"><td class="num" id="LN173">173</td><td class="line">    0x3FFFFFFF, 0x7FFFFFFF}; <span class='comment'>/* up to 31 bits */</span></td></tr>
<tr class="codeline" data-linenumber="174"><td class="num" id="LN174">174</td><td class="line"><span class='directive'>#define <span class='macro'>BIT_MASK_SIZE<span class='macro_popup'>(sizeof(BIT_mask) / sizeof(BIT_mask[0]))</span></span> (sizeof(BIT_mask) / sizeof(BIT_mask[0]))</span></td></tr>
<tr class="codeline" data-linenumber="175"><td class="num" id="LN175">175</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="176"><td class="num" id="LN176">176</td><td class="line"><span class='comment'>/*-**************************************************************</span></td></tr>
<tr class="codeline" data-linenumber="177"><td class="num" id="LN177">177</td><td class="line"><span class='comment'>*  bitStream encoding</span></td></tr>
<tr class="codeline" data-linenumber="178"><td class="num" id="LN178">178</td><td class="line"><span class='comment'>****************************************************************/</span></td></tr>
<tr class="codeline" data-linenumber="179"><td class="num" id="LN179">179</td><td class="line"><span class='comment'>/*! BIT_initCStream() :</span></td></tr>
<tr class="codeline" data-linenumber="180"><td class="num" id="LN180">180</td><td class="line"> <span class='comment'>*  `dstCapacity` must be &gt; sizeof(size_t)</span></td></tr>
<tr class="codeline" data-linenumber="181"><td class="num" id="LN181">181</td><td class="line"> <span class='comment'>*  @return : 0 if success,</span></td></tr>
<tr class="codeline" data-linenumber="182"><td class="num" id="LN182">182</td><td class="line"> <span class='comment'>*            otherwise an error code (can be tested using ERR_isError()) */</span></td></tr>
<tr class="codeline" data-linenumber="183"><td class="num" id="LN183">183</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> size_t BIT_initCStream(BIT_CStream_t* bitC,</td></tr>
<tr class="codeline" data-linenumber="184"><td class="num" id="LN184">184</td><td class="line">                                  <span class='keyword'>void</span>* startPtr, size_t dstCapacity)</td></tr>
<tr class="codeline" data-linenumber="185"><td class="num" id="LN185">185</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="186"><td class="num" id="LN186">186</td><td class="line">    bitC-&gt;bitContainer = 0;</td></tr>
<tr class="codeline" data-linenumber="187"><td class="num" id="LN187">187</td><td class="line">    bitC-&gt;bitPos = 0;</td></tr>
<tr class="codeline" data-linenumber="188"><td class="num" id="LN188">188</td><td class="line">    bitC-&gt;startPtr = (<span class='keyword'>char</span>*)startPtr;</td></tr>
<tr class="codeline" data-linenumber="189"><td class="num" id="LN189">189</td><td class="line">    bitC-&gt;ptr = bitC-&gt;startPtr;</td></tr>
<tr class="codeline" data-linenumber="190"><td class="num" id="LN190">190</td><td class="line">    bitC-&gt;endPtr = bitC-&gt;startPtr + dstCapacity - <span class='keyword'>sizeof</span>(bitC-&gt;bitContainer);</td></tr>
<tr class="codeline" data-linenumber="191"><td class="num" id="LN191">191</td><td class="line">    <span class='keyword'>if</span> (dstCapacity &lt;= <span class='keyword'>sizeof</span>(bitC-&gt;bitContainer)) <span class='keyword'>return</span> <span class='macro'>ERROR(dstSize_tooSmall)<span class='macro_popup'>((size_t)-ZSTD_error_dstSize_tooSmall)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="192"><td class="num" id="LN192">192</td><td class="line">    <span class='keyword'>return</span> 0;</td></tr>
<tr class="codeline" data-linenumber="193"><td class="num" id="LN193">193</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="194"><td class="num" id="LN194">194</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="195"><td class="num" id="LN195">195</td><td class="line"><span class='comment'>/*! BIT_addBits() :</span></td></tr>
<tr class="codeline" data-linenumber="196"><td class="num" id="LN196">196</td><td class="line"> <span class='comment'>*  can add up to 31 bits into `bitC`.</span></td></tr>
<tr class="codeline" data-linenumber="197"><td class="num" id="LN197">197</td><td class="line"> <span class='comment'>*  Note : does not check for register overflow ! */</span></td></tr>
<tr class="codeline" data-linenumber="198"><td class="num" id="LN198">198</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> <span class='keyword'>void</span> BIT_addBits(BIT_CStream_t* bitC,</td></tr>
<tr class="codeline" data-linenumber="199"><td class="num" id="LN199">199</td><td class="line">                            size_t value, <span class='keyword'>unsigned</span> nbBits)</td></tr>
<tr class="codeline" data-linenumber="200"><td class="num" id="LN200">200</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="201"><td class="num" id="LN201">201</td><td class="line">    <span class='macro'>MEM_STATIC_ASSERT(BIT_MASK_SIZE == 32)<span class='macro_popup'>{ enum { MEM_static_assert = 1/(int)(!!((sizeof(BIT_mask) / sizeof<br>(BIT_mask[0])) == 32)) }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="202"><td class="num" id="LN202">202</td><td class="line">    <span class='macro'>assert(nbBits &lt; BIT_MASK_SIZE)<span class='macro_popup'>((void) sizeof ((nbBits &lt; (sizeof(BIT_mask) / sizeof(BIT_mask<br>[0]))) ? 1 : 0), __extension__ ({ if (nbBits &lt; (sizeof(BIT_mask<br>) / sizeof(BIT_mask[0]))) ; else __assert_fail ("nbBits &lt; BIT_MASK_SIZE"<br>, "./../lib/common/bitstream.h", 202, __extension__ __PRETTY_FUNCTION__<br>); }))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="203"><td class="num" id="LN203">203</td><td class="line">    <span class='macro'>assert(nbBits + bitC-&gt;bitPos &lt; <span class='keyword'>sizeof</span>(bitC-&gt;bitContainer) * 8)<span class='macro_popup'>((void) sizeof ((nbBits + bitC-&gt;bitPos &lt; sizeof(bitC-&gt;<br>bitContainer) * 8) ? 1 : 0), __extension__ ({ if (nbBits + bitC<br>-&gt;bitPos &lt; sizeof(bitC-&gt;bitContainer) * 8) ; else __assert_fail<br> ("nbBits + bitC-&gt;bitPos &lt; sizeof(bitC-&gt;bitContainer) * 8"<br>, "./../lib/common/bitstream.h", 203, __extension__ __PRETTY_FUNCTION__<br>); }))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="204"><td class="num" id="LN204">204</td><td class="line">    bitC-&gt;bitContainer |= (value &amp; BIT_mask[nbBits]) &lt;&lt; bitC-&gt;bitPos;</td></tr>
<tr class="codeline" data-linenumber="205"><td class="num" id="LN205">205</td><td class="line">    bitC-&gt;bitPos += nbBits;</td></tr>
<tr class="codeline" data-linenumber="206"><td class="num" id="LN206">206</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="207"><td class="num" id="LN207">207</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="208"><td class="num" id="LN208">208</td><td class="line"><span class='comment'>/*! BIT_addBitsFast() :</span></td></tr>
<tr class="codeline" data-linenumber="209"><td class="num" id="LN209">209</td><td class="line"> <span class='comment'>*  works only if `value` is _clean_,</span></td></tr>
<tr class="codeline" data-linenumber="210"><td class="num" id="LN210">210</td><td class="line"> <span class='comment'>*  meaning all high bits above nbBits are 0 */</span></td></tr>
<tr class="codeline" data-linenumber="211"><td class="num" id="LN211">211</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> <span class='keyword'>void</span> BIT_addBitsFast(BIT_CStream_t* bitC,</td></tr>
<tr class="codeline" data-linenumber="212"><td class="num" id="LN212">212</td><td class="line">                                size_t value, <span class='keyword'>unsigned</span> nbBits)</td></tr>
<tr class="codeline" data-linenumber="213"><td class="num" id="LN213">213</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="214"><td class="num" id="LN214">214</td><td class="line">    <span class='macro'>assert((value&gt;&gt;nbBits) == 0)<span class='macro_popup'>((void) sizeof (((value&gt;&gt;nbBits) == 0) ? 1 : 0), __extension__<br> ({ if ((value&gt;&gt;nbBits) == 0) ; else __assert_fail ("(value&gt;&gt;nbBits) == 0"<br>, "./../lib/common/bitstream.h", 214, __extension__ __PRETTY_FUNCTION__<br>); }))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="215"><td class="num" id="LN215">215</td><td class="line">    <span class='macro'>assert(nbBits + bitC-&gt;bitPos &lt; <span class='keyword'>sizeof</span>(bitC-&gt;bitContainer) * 8)<span class='macro_popup'>((void) sizeof ((nbBits + bitC-&gt;bitPos &lt; sizeof(bitC-&gt;<br>bitContainer) * 8) ? 1 : 0), __extension__ ({ if (nbBits + bitC<br>-&gt;bitPos &lt; sizeof(bitC-&gt;bitContainer) * 8) ; else __assert_fail<br> ("nbBits + bitC-&gt;bitPos &lt; sizeof(bitC-&gt;bitContainer) * 8"<br>, "./../lib/common/bitstream.h", 215, __extension__ __PRETTY_FUNCTION__<br>); }))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="216"><td class="num" id="LN216">216</td><td class="line">    bitC-&gt;bitContainer |= value &lt;&lt; bitC-&gt;bitPos;</td></tr>
<tr class="codeline" data-linenumber="217"><td class="num" id="LN217">217</td><td class="line">    bitC-&gt;bitPos += nbBits;</td></tr>
<tr class="codeline" data-linenumber="218"><td class="num" id="LN218">218</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="219"><td class="num" id="LN219">219</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="220"><td class="num" id="LN220">220</td><td class="line"><span class='comment'>/*! BIT_flushBitsFast() :</span></td></tr>
<tr class="codeline" data-linenumber="221"><td class="num" id="LN221">221</td><td class="line"> <span class='comment'>*  assumption : bitContainer has not overflowed</span></td></tr>
<tr class="codeline" data-linenumber="222"><td class="num" id="LN222">222</td><td class="line"> <span class='comment'>*  unsafe version; does not check buffer overflow */</span></td></tr>
<tr class="codeline" data-linenumber="223"><td class="num" id="LN223">223</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> <span class='keyword'>void</span> BIT_flushBitsFast(BIT_CStream_t* bitC)</td></tr>
<tr class="codeline" data-linenumber="224"><td class="num" id="LN224">224</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="225"><td class="num" id="LN225">225</td><td class="line">    size_t <span class='keyword'>const</span> nbBytes = bitC-&gt;bitPos &gt;&gt; 3;</td></tr>
<tr class="codeline" data-linenumber="226"><td class="num" id="LN226">226</td><td class="line">    <span class='macro'>assert(bitC-&gt;bitPos &lt; <span class='keyword'>sizeof</span>(bitC-&gt;bitContainer) * 8)<span class='macro_popup'>((void) sizeof ((bitC-&gt;bitPos &lt; sizeof(bitC-&gt;bitContainer<br>) * 8) ? 1 : 0), __extension__ ({ if (bitC-&gt;bitPos &lt; sizeof<br>(bitC-&gt;bitContainer) * 8) ; else __assert_fail ("bitC-&gt;bitPos &lt; sizeof(bitC-&gt;bitContainer) * 8"<br>, "./../lib/common/bitstream.h", 226, __extension__ __PRETTY_FUNCTION__<br>); }))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="227"><td class="num" id="LN227">227</td><td class="line">    <span class='macro'>assert(bitC-&gt;ptr &lt;= bitC-&gt;endPtr)<span class='macro_popup'>((void) sizeof ((bitC-&gt;ptr &lt;= bitC-&gt;endPtr) ? 1 : 0)<br>, __extension__ ({ if (bitC-&gt;ptr &lt;= bitC-&gt;endPtr) ; else<br> __assert_fail ("bitC-&gt;ptr &lt;= bitC-&gt;endPtr", "./../lib/common/bitstream.h"<br>, 227, __extension__ __PRETTY_FUNCTION__); }))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="228"><td class="num" id="LN228">228</td><td class="line">    MEM_writeLEST(bitC-&gt;ptr, bitC-&gt;bitContainer);</td></tr>
<tr class="codeline" data-linenumber="229"><td class="num" id="LN229">229</td><td class="line">    bitC-&gt;ptr += nbBytes;</td></tr>
<tr class="codeline" data-linenumber="230"><td class="num" id="LN230">230</td><td class="line">    bitC-&gt;bitPos &amp;= 7;</td></tr>
<tr class="codeline" data-linenumber="231"><td class="num" id="LN231">231</td><td class="line">    bitC-&gt;bitContainer &gt;&gt;= nbBytes*8;</td></tr>
<tr class="codeline" data-linenumber="232"><td class="num" id="LN232">232</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="233"><td class="num" id="LN233">233</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="234"><td class="num" id="LN234">234</td><td class="line"><span class='comment'>/*! BIT_flushBits() :</span></td></tr>
<tr class="codeline" data-linenumber="235"><td class="num" id="LN235">235</td><td class="line"> <span class='comment'>*  assumption : bitContainer has not overflowed</span></td></tr>
<tr class="codeline" data-linenumber="236"><td class="num" id="LN236">236</td><td class="line"> <span class='comment'>*  safe version; check for buffer overflow, and prevents it.</span></td></tr>
<tr class="codeline" data-linenumber="237"><td class="num" id="LN237">237</td><td class="line"> <span class='comment'>*  note : does not signal buffer overflow.</span></td></tr>
<tr class="codeline" data-linenumber="238"><td class="num" id="LN238">238</td><td class="line"> <span class='comment'>*  overflow will be revealed later on using BIT_closeCStream() */</span></td></tr>
<tr class="codeline" data-linenumber="239"><td class="num" id="LN239">239</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> <span class='keyword'>void</span> BIT_flushBits(BIT_CStream_t* bitC)</td></tr>
<tr class="codeline" data-linenumber="240"><td class="num" id="LN240">240</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="241"><td class="num" id="LN241">241</td><td class="line">    size_t <span class='keyword'>const</span> nbBytes = bitC-&gt;bitPos &gt;&gt; 3;</td></tr>
<tr class="codeline" data-linenumber="242"><td class="num" id="LN242">242</td><td class="line">    <span class='macro'>assert(bitC-&gt;bitPos &lt; <span class='keyword'>sizeof</span>(bitC-&gt;bitContainer) * 8)<span class='macro_popup'>((void) sizeof ((bitC-&gt;bitPos &lt; sizeof(bitC-&gt;bitContainer<br>) * 8) ? 1 : 0), __extension__ ({ if (bitC-&gt;bitPos &lt; sizeof<br>(bitC-&gt;bitContainer) * 8) ; else __assert_fail ("bitC-&gt;bitPos &lt; sizeof(bitC-&gt;bitContainer) * 8"<br>, "./../lib/common/bitstream.h", 242, __extension__ __PRETTY_FUNCTION__<br>); }))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="243"><td class="num" id="LN243">243</td><td class="line">    <span class='macro'>assert(bitC-&gt;ptr &lt;= bitC-&gt;endPtr)<span class='macro_popup'>((void) sizeof ((bitC-&gt;ptr &lt;= bitC-&gt;endPtr) ? 1 : 0)<br>, __extension__ ({ if (bitC-&gt;ptr &lt;= bitC-&gt;endPtr) ; else<br> __assert_fail ("bitC-&gt;ptr &lt;= bitC-&gt;endPtr", "./../lib/common/bitstream.h"<br>, 243, __extension__ __PRETTY_FUNCTION__); }))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="244"><td class="num" id="LN244">244</td><td class="line">    MEM_writeLEST(bitC-&gt;ptr, bitC-&gt;bitContainer);</td></tr>
<tr class="codeline" data-linenumber="245"><td class="num" id="LN245">245</td><td class="line">    bitC-&gt;ptr += nbBytes;</td></tr>
<tr class="codeline" data-linenumber="246"><td class="num" id="LN246">246</td><td class="line">    <span class='keyword'>if</span> (bitC-&gt;ptr &gt; bitC-&gt;endPtr) bitC-&gt;ptr = bitC-&gt;endPtr;</td></tr>
<tr class="codeline" data-linenumber="247"><td class="num" id="LN247">247</td><td class="line">    bitC-&gt;bitPos &amp;= 7;</td></tr>
<tr class="codeline" data-linenumber="248"><td class="num" id="LN248">248</td><td class="line">    bitC-&gt;bitContainer &gt;&gt;= nbBytes*8;</td></tr>
<tr class="codeline" data-linenumber="249"><td class="num" id="LN249">249</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="250"><td class="num" id="LN250">250</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="251"><td class="num" id="LN251">251</td><td class="line"><span class='comment'>/*! BIT_closeCStream() :</span></td></tr>
<tr class="codeline" data-linenumber="252"><td class="num" id="LN252">252</td><td class="line"> <span class='comment'>*  @return : size of CStream, in bytes,</span></td></tr>
<tr class="codeline" data-linenumber="253"><td class="num" id="LN253">253</td><td class="line"> <span class='comment'>*            or 0 if it could not fit into dstBuffer */</span></td></tr>
<tr class="codeline" data-linenumber="254"><td class="num" id="LN254">254</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> size_t BIT_closeCStream(BIT_CStream_t* bitC)</td></tr>
<tr class="codeline" data-linenumber="255"><td class="num" id="LN255">255</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="256"><td class="num" id="LN256">256</td><td class="line">    BIT_addBitsFast(bitC, 1, 1);   <span class='comment'>/* endMark */</span></td></tr>
<tr class="codeline" data-linenumber="257"><td class="num" id="LN257">257</td><td class="line">    BIT_flushBits(bitC);</td></tr>
<tr class="codeline" data-linenumber="258"><td class="num" id="LN258">258</td><td class="line">    <span class='keyword'>if</span> (bitC-&gt;ptr &gt;= bitC-&gt;endPtr) <span class='keyword'>return</span> 0; <span class='comment'>/* overflow detected */</span></td></tr>
<tr class="codeline" data-linenumber="259"><td class="num" id="LN259">259</td><td class="line">    <span class='keyword'>return</span> (bitC-&gt;ptr - bitC-&gt;startPtr) + (bitC-&gt;bitPos &gt; 0);</td></tr>
<tr class="codeline" data-linenumber="260"><td class="num" id="LN260">260</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="261"><td class="num" id="LN261">261</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="262"><td class="num" id="LN262">262</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="263"><td class="num" id="LN263">263</td><td class="line"><span class='comment'>/*-********************************************************</span></td></tr>
<tr class="codeline" data-linenumber="264"><td class="num" id="LN264">264</td><td class="line"><span class='comment'>*  bitStream decoding</span></td></tr>
<tr class="codeline" data-linenumber="265"><td class="num" id="LN265">265</td><td class="line"><span class='comment'>**********************************************************/</span></td></tr>
<tr class="codeline" data-linenumber="266"><td class="num" id="LN266">266</td><td class="line"><span class='comment'>/*! BIT_initDStream() :</span></td></tr>
<tr class="codeline" data-linenumber="267"><td class="num" id="LN267">267</td><td class="line"> <span class='comment'>*  Initialize a BIT_DStream_t.</span></td></tr>
<tr class="codeline" data-linenumber="268"><td class="num" id="LN268">268</td><td class="line"> <span class='comment'>* `bitD` : a pointer to an already allocated BIT_DStream_t structure.</span></td></tr>
<tr class="codeline" data-linenumber="269"><td class="num" id="LN269">269</td><td class="line"> <span class='comment'>* `srcSize` must be the *exact* size of the bitStream, in bytes.</span></td></tr>
<tr class="codeline" data-linenumber="270"><td class="num" id="LN270">270</td><td class="line"> <span class='comment'>* @return : size of stream (== srcSize), or an errorCode if a problem is detected</span></td></tr>
<tr class="codeline" data-linenumber="271"><td class="num" id="LN271">271</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="272"><td class="num" id="LN272">272</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> size_t BIT_initDStream(BIT_DStream_t* bitD, <span class='keyword'>const</span> <span class='keyword'>void</span>* srcBuffer, size_t srcSize)</td></tr>
<tr class="codeline" data-linenumber="273"><td class="num" id="LN273">273</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="274"><td class="num" id="LN274">274</td><td class="line">    <span class='keyword'>if</span> (srcSize &lt; 1) { <span class="mrange">memset</span>(bitD, 0, <span class='keyword'>sizeof</span>(*bitD)); <span class='keyword'>return</span> <span class='macro'>ERROR(srcSize_wrong)<span class='macro_popup'>((size_t)-ZSTD_error_srcSize_wrong)</span></span>; }</td></tr>
<tr><td class="num"></td><td class="line"><div id="EndPath" class="msg msgEvent" style="margin-left:24ex; max-width:58em">Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11</div></td></tr>
<tr class="codeline" data-linenumber="275"><td class="num" id="LN275">275</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="276"><td class="num" id="LN276">276</td><td class="line">    bitD-&gt;start = (<span class='keyword'>const</span> <span class='keyword'>char</span>*)srcBuffer;</td></tr>
<tr class="codeline" data-linenumber="277"><td class="num" id="LN277">277</td><td class="line">    bitD-&gt;limitPtr = bitD-&gt;start + <span class='keyword'>sizeof</span>(bitD-&gt;bitContainer);</td></tr>
<tr class="codeline" data-linenumber="278"><td class="num" id="LN278">278</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="279"><td class="num" id="LN279">279</td><td class="line">    <span class='keyword'>if</span> (srcSize &gt;=  <span class='keyword'>sizeof</span>(bitD-&gt;bitContainer)) {  <span class='comment'>/* normal case */</span></td></tr>
<tr class="codeline" data-linenumber="280"><td class="num" id="LN280">280</td><td class="line">        bitD-&gt;ptr   = (<span class='keyword'>const</span> <span class='keyword'>char</span>*)srcBuffer + srcSize - <span class='keyword'>sizeof</span>(bitD-&gt;bitContainer);</td></tr>
<tr class="codeline" data-linenumber="281"><td class="num" id="LN281">281</td><td class="line">        bitD-&gt;bitContainer = MEM_readLEST(bitD-&gt;ptr);</td></tr>
<tr class="codeline" data-linenumber="282"><td class="num" id="LN282">282</td><td class="line">        { BYTE <span class='keyword'>const</span> lastByte = ((<span class='keyword'>const</span> BYTE*)srcBuffer)[srcSize-1];</td></tr>
<tr class="codeline" data-linenumber="283"><td class="num" id="LN283">283</td><td class="line">          bitD-&gt;bitsConsumed = lastByte ? 8 - BIT_highbit32(lastByte) : 0;  <span class='comment'>/* ensures bitsConsumed is always set */</span></td></tr>
<tr class="codeline" data-linenumber="284"><td class="num" id="LN284">284</td><td class="line">          <span class='keyword'>if</span> (lastByte == 0) <span class='keyword'>return</span> <span class='macro'>ERROR(GENERIC)<span class='macro_popup'>((size_t)-ZSTD_error_GENERIC)</span></span>; <span class='comment'>/* endMark not present */</span> }</td></tr>
<tr class="codeline" data-linenumber="285"><td class="num" id="LN285">285</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="286"><td class="num" id="LN286">286</td><td class="line">        bitD-&gt;ptr   = bitD-&gt;start;</td></tr>
<tr class="codeline" data-linenumber="287"><td class="num" id="LN287">287</td><td class="line">        bitD-&gt;bitContainer = *(<span class='keyword'>const</span> BYTE*)(bitD-&gt;start);</td></tr>
<tr class="codeline" data-linenumber="288"><td class="num" id="LN288">288</td><td class="line">        <span class='keyword'>switch</span>(srcSize)</td></tr>
<tr class="codeline" data-linenumber="289"><td class="num" id="LN289">289</td><td class="line">        {</td></tr>
<tr class="codeline" data-linenumber="290"><td class="num" id="LN290">290</td><td class="line">        <span class='keyword'>case</span> 7: bitD-&gt;bitContainer += (size_t)(((<span class='keyword'>const</span> BYTE*)(srcBuffer))[6]) &lt;&lt; (<span class='keyword'>sizeof</span>(bitD-&gt;bitContainer)*8 - 16);</td></tr>
<tr class="codeline" data-linenumber="291"><td class="num" id="LN291">291</td><td class="line">                <span class='comment'>/* fall-through */</span></td></tr>
<tr class="codeline" data-linenumber="292"><td class="num" id="LN292">292</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="293"><td class="num" id="LN293">293</td><td class="line">        <span class='keyword'>case</span> 6: bitD-&gt;bitContainer += (size_t)(((<span class='keyword'>const</span> BYTE*)(srcBuffer))[5]) &lt;&lt; (<span class='keyword'>sizeof</span>(bitD-&gt;bitContainer)*8 - 24);</td></tr>
<tr class="codeline" data-linenumber="294"><td class="num" id="LN294">294</td><td class="line">                <span class='comment'>/* fall-through */</span></td></tr>
<tr class="codeline" data-linenumber="295"><td class="num" id="LN295">295</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="296"><td class="num" id="LN296">296</td><td class="line">        <span class='keyword'>case</span> 5: bitD-&gt;bitContainer += (size_t)(((<span class='keyword'>const</span> BYTE*)(srcBuffer))[4]) &lt;&lt; (<span class='keyword'>sizeof</span>(bitD-&gt;bitContainer)*8 - 32);</td></tr>
<tr class="codeline" data-linenumber="297"><td class="num" id="LN297">297</td><td class="line">                <span class='comment'>/* fall-through */</span></td></tr>
<tr class="codeline" data-linenumber="298"><td class="num" id="LN298">298</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="299"><td class="num" id="LN299">299</td><td class="line">        <span class='keyword'>case</span> 4: bitD-&gt;bitContainer += (size_t)(((<span class='keyword'>const</span> BYTE*)(srcBuffer))[3]) &lt;&lt; 24;</td></tr>
<tr class="codeline" data-linenumber="300"><td class="num" id="LN300">300</td><td class="line">                <span class='comment'>/* fall-through */</span></td></tr>
<tr class="codeline" data-linenumber="301"><td class="num" id="LN301">301</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="302"><td class="num" id="LN302">302</td><td class="line">        <span class='keyword'>case</span> 3: bitD-&gt;bitContainer += (size_t)(((<span class='keyword'>const</span> BYTE*)(srcBuffer))[2]) &lt;&lt; 16;</td></tr>
<tr class="codeline" data-linenumber="303"><td class="num" id="LN303">303</td><td class="line">                <span class='comment'>/* fall-through */</span></td></tr>
<tr class="codeline" data-linenumber="304"><td class="num" id="LN304">304</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="305"><td class="num" id="LN305">305</td><td class="line">        <span class='keyword'>case</span> 2: bitD-&gt;bitContainer += (size_t)(((<span class='keyword'>const</span> BYTE*)(srcBuffer))[1]) &lt;&lt;  8;</td></tr>
<tr class="codeline" data-linenumber="306"><td class="num" id="LN306">306</td><td class="line">                <span class='comment'>/* fall-through */</span></td></tr>
<tr class="codeline" data-linenumber="307"><td class="num" id="LN307">307</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="308"><td class="num" id="LN308">308</td><td class="line">        <span class='keyword'>default</span>: <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="309"><td class="num" id="LN309">309</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="310"><td class="num" id="LN310">310</td><td class="line">        {   BYTE <span class='keyword'>const</span> lastByte = ((<span class='keyword'>const</span> BYTE*)srcBuffer)[srcSize-1];</td></tr>
<tr class="codeline" data-linenumber="311"><td class="num" id="LN311">311</td><td class="line">            bitD-&gt;bitsConsumed = lastByte ? 8 - BIT_highbit32(lastByte) : 0;</td></tr>
<tr class="codeline" data-linenumber="312"><td class="num" id="LN312">312</td><td class="line">            <span class='keyword'>if</span> (lastByte == 0) <span class='keyword'>return</span> <span class='macro'>ERROR(corruption_detected)<span class='macro_popup'>((size_t)-ZSTD_error_corruption_detected)</span></span>;  <span class='comment'>/* endMark not present */</span></td></tr>
<tr class="codeline" data-linenumber="313"><td class="num" id="LN313">313</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="314"><td class="num" id="LN314">314</td><td class="line">        bitD-&gt;bitsConsumed += (U32)(<span class='keyword'>sizeof</span>(bitD-&gt;bitContainer) - srcSize)*8;</td></tr>
<tr class="codeline" data-linenumber="315"><td class="num" id="LN315">315</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="316"><td class="num" id="LN316">316</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="317"><td class="num" id="LN317">317</td><td class="line">    <span class='keyword'>return</span> srcSize;</td></tr>
<tr class="codeline" data-linenumber="318"><td class="num" id="LN318">318</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="319"><td class="num" id="LN319">319</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="320"><td class="num" id="LN320">320</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> size_t BIT_getUpperBits(size_t bitContainer, U32 <span class='keyword'>const</span> start)</td></tr>
<tr class="codeline" data-linenumber="321"><td class="num" id="LN321">321</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="322"><td class="num" id="LN322">322</td><td class="line">    <span class='keyword'>return</span> bitContainer &gt;&gt; start;</td></tr>
<tr class="codeline" data-linenumber="323"><td class="num" id="LN323">323</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="324"><td class="num" id="LN324">324</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="325"><td class="num" id="LN325">325</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> size_t BIT_getMiddleBits(size_t bitContainer, U32 <span class='keyword'>const</span> start, U32 <span class='keyword'>const</span> nbBits)</td></tr>
<tr class="codeline" data-linenumber="326"><td class="num" id="LN326">326</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="327"><td class="num" id="LN327">327</td><td class="line">    U32 <span class='keyword'>const</span> regMask = <span class='keyword'>sizeof</span>(bitContainer)*8 - 1;</td></tr>
<tr class="codeline" data-linenumber="328"><td class="num" id="LN328">328</td><td class="line">    <span class='comment'>/* if start &gt; regMask, bitstream is corrupted, and result is undefined */</span></td></tr>
<tr class="codeline" data-linenumber="329"><td class="num" id="LN329">329</td><td class="line">    <span class='macro'>assert(nbBits &lt; BIT_MASK_SIZE)<span class='macro_popup'>((void) sizeof ((nbBits &lt; (sizeof(BIT_mask) / sizeof(BIT_mask<br>[0]))) ? 1 : 0), __extension__ ({ if (nbBits &lt; (sizeof(BIT_mask<br>) / sizeof(BIT_mask[0]))) ; else __assert_fail ("nbBits &lt; BIT_MASK_SIZE"<br>, "./../lib/common/bitstream.h", 329, __extension__ __PRETTY_FUNCTION__<br>); }))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="330"><td class="num" id="LN330">330</td><td class="line">    <span class='keyword'>return</span> (bitContainer &gt;&gt; (start &amp; regMask)) &amp; BIT_mask[nbBits];</td></tr>
<tr class="codeline" data-linenumber="331"><td class="num" id="LN331">331</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="332"><td class="num" id="LN332">332</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="333"><td class="num" id="LN333">333</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> size_t BIT_getLowerBits(size_t bitContainer, U32 <span class='keyword'>const</span> nbBits)</td></tr>
<tr class="codeline" data-linenumber="334"><td class="num" id="LN334">334</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="335"><td class="num" id="LN335">335</td><td class="line">    <span class='macro'>assert(nbBits &lt; BIT_MASK_SIZE)<span class='macro_popup'>((void) sizeof ((nbBits &lt; (sizeof(BIT_mask) / sizeof(BIT_mask<br>[0]))) ? 1 : 0), __extension__ ({ if (nbBits &lt; (sizeof(BIT_mask<br>) / sizeof(BIT_mask[0]))) ; else __assert_fail ("nbBits &lt; BIT_MASK_SIZE"<br>, "./../lib/common/bitstream.h", 335, __extension__ __PRETTY_FUNCTION__<br>); }))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="336"><td class="num" id="LN336">336</td><td class="line">    <span class='keyword'>return</span> bitContainer &amp; BIT_mask[nbBits];</td></tr>
<tr class="codeline" data-linenumber="337"><td class="num" id="LN337">337</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="338"><td class="num" id="LN338">338</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="339"><td class="num" id="LN339">339</td><td class="line"><span class='comment'>/*! BIT_lookBits() :</span></td></tr>
<tr class="codeline" data-linenumber="340"><td class="num" id="LN340">340</td><td class="line"> <span class='comment'>*  Provides next n bits from local register.</span></td></tr>
<tr class="codeline" data-linenumber="341"><td class="num" id="LN341">341</td><td class="line"> <span class='comment'>*  local register is not modified.</span></td></tr>
<tr class="codeline" data-linenumber="342"><td class="num" id="LN342">342</td><td class="line"> <span class='comment'>*  On 32-bits, maxNbBits==24.</span></td></tr>
<tr class="codeline" data-linenumber="343"><td class="num" id="LN343">343</td><td class="line"> <span class='comment'>*  On 64-bits, maxNbBits==56.</span></td></tr>
<tr class="codeline" data-linenumber="344"><td class="num" id="LN344">344</td><td class="line"> <span class='comment'>* @return : value extracted */</span></td></tr>
<tr class="codeline" data-linenumber="345"><td class="num" id="LN345">345</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> size_t BIT_lookBits(<span class='keyword'>const</span> BIT_DStream_t* bitD, U32 nbBits)</td></tr>
<tr class="codeline" data-linenumber="346"><td class="num" id="LN346">346</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="347"><td class="num" id="LN347">347</td><td class="line">    <span class='comment'>/* arbitrate between double-shift and shift+mask */</span></td></tr>
<tr class="codeline" data-linenumber="348"><td class="num" id="LN348">348</td><td class="line"><span class='directive'>#if 1</span></td></tr>
<tr class="codeline" data-linenumber="349"><td class="num" id="LN349">349</td><td class="line">    <span class='comment'>/* if bitD-&gt;bitsConsumed + nbBits &gt; sizeof(bitD-&gt;bitContainer)*8,</span></td></tr>
<tr class="codeline" data-linenumber="350"><td class="num" id="LN350">350</td><td class="line">     <span class='comment'>* bitstream is likely corrupted, and result is undefined */</span></td></tr>
<tr class="codeline" data-linenumber="351"><td class="num" id="LN351">351</td><td class="line">    <span class='keyword'>return</span> BIT_getMiddleBits(bitD-&gt;bitContainer, (<span class='keyword'>sizeof</span>(bitD-&gt;bitContainer)*8) - bitD-&gt;bitsConsumed - nbBits, nbBits);</td></tr>
<tr class="codeline" data-linenumber="352"><td class="num" id="LN352">352</td><td class="line"><span class='directive'>#else</span></td></tr>
<tr class="codeline" data-linenumber="353"><td class="num" id="LN353">353</td><td class="line">    <span class='comment'>/* this code path is slower on my os-x laptop */</span></td></tr>
<tr class="codeline" data-linenumber="354"><td class="num" id="LN354">354</td><td class="line">    U32 <span class='keyword'>const</span> regMask = <span class='keyword'>sizeof</span>(bitD-&gt;bitContainer)*8 - 1;</td></tr>
<tr class="codeline" data-linenumber="355"><td class="num" id="LN355">355</td><td class="line">    <span class='keyword'>return</span> ((bitD-&gt;bitContainer &lt;&lt; (bitD-&gt;bitsConsumed &amp; regMask)) &gt;&gt; 1) &gt;&gt; ((regMask-nbBits) &amp; regMask);</td></tr>
<tr class="codeline" data-linenumber="356"><td class="num" id="LN356">356</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="357"><td class="num" id="LN357">357</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="358"><td class="num" id="LN358">358</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="359"><td class="num" id="LN359">359</td><td class="line"><span class='comment'>/*! BIT_lookBitsFast() :</span></td></tr>
<tr class="codeline" data-linenumber="360"><td class="num" id="LN360">360</td><td class="line"> <span class='comment'>*  unsafe version; only works if nbBits &gt;= 1 */</span></td></tr>
<tr class="codeline" data-linenumber="361"><td class="num" id="LN361">361</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> size_t BIT_lookBitsFast(<span class='keyword'>const</span> BIT_DStream_t* bitD, U32 nbBits)</td></tr>
<tr class="codeline" data-linenumber="362"><td class="num" id="LN362">362</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="363"><td class="num" id="LN363">363</td><td class="line">    U32 <span class='keyword'>const</span> regMask = <span class='keyword'>sizeof</span>(bitD-&gt;bitContainer)*8 - 1;</td></tr>
<tr class="codeline" data-linenumber="364"><td class="num" id="LN364">364</td><td class="line">    <span class='macro'>assert(nbBits &gt;= 1)<span class='macro_popup'>((void) sizeof ((nbBits &gt;= 1) ? 1 : 0), __extension__ ({ if<br> (nbBits &gt;= 1) ; else __assert_fail ("nbBits &gt;= 1", "./../lib/common/bitstream.h"<br>, 364, __extension__ __PRETTY_FUNCTION__); }))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="365"><td class="num" id="LN365">365</td><td class="line">    <span class='keyword'>return</span> (bitD-&gt;bitContainer &lt;&lt; (bitD-&gt;bitsConsumed &amp; regMask)) &gt;&gt; (((regMask+1)-nbBits) &amp; regMask);</td></tr>
<tr class="codeline" data-linenumber="366"><td class="num" id="LN366">366</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="367"><td class="num" id="LN367">367</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="368"><td class="num" id="LN368">368</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> <span class='keyword'>void</span> BIT_skipBits(BIT_DStream_t* bitD, U32 nbBits)</td></tr>
<tr class="codeline" data-linenumber="369"><td class="num" id="LN369">369</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="370"><td class="num" id="LN370">370</td><td class="line">    bitD-&gt;bitsConsumed += nbBits;</td></tr>
<tr class="codeline" data-linenumber="371"><td class="num" id="LN371">371</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="372"><td class="num" id="LN372">372</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="373"><td class="num" id="LN373">373</td><td class="line"><span class='comment'>/*! BIT_readBits() :</span></td></tr>
<tr class="codeline" data-linenumber="374"><td class="num" id="LN374">374</td><td class="line"> <span class='comment'>*  Read (consume) next n bits from local register and update.</span></td></tr>
<tr class="codeline" data-linenumber="375"><td class="num" id="LN375">375</td><td class="line"> <span class='comment'>*  Pay attention to not read more than nbBits contained into local register.</span></td></tr>
<tr class="codeline" data-linenumber="376"><td class="num" id="LN376">376</td><td class="line"> <span class='comment'>* @return : extracted value. */</span></td></tr>
<tr class="codeline" data-linenumber="377"><td class="num" id="LN377">377</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> size_t BIT_readBits(BIT_DStream_t* bitD, <span class='keyword'>unsigned</span> nbBits)</td></tr>
<tr class="codeline" data-linenumber="378"><td class="num" id="LN378">378</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="379"><td class="num" id="LN379">379</td><td class="line">    size_t <span class='keyword'>const</span> value = BIT_lookBits(bitD, nbBits);</td></tr>
<tr class="codeline" data-linenumber="380"><td class="num" id="LN380">380</td><td class="line">    BIT_skipBits(bitD, nbBits);</td></tr>
<tr class="codeline" data-linenumber="381"><td class="num" id="LN381">381</td><td class="line">    <span class='keyword'>return</span> value;</td></tr>
<tr class="codeline" data-linenumber="382"><td class="num" id="LN382">382</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="383"><td class="num" id="LN383">383</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="384"><td class="num" id="LN384">384</td><td class="line"><span class='comment'>/*! BIT_readBitsFast() :</span></td></tr>
<tr class="codeline" data-linenumber="385"><td class="num" id="LN385">385</td><td class="line"> <span class='comment'>*  unsafe version; only works only if nbBits &gt;= 1 */</span></td></tr>
<tr class="codeline" data-linenumber="386"><td class="num" id="LN386">386</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> size_t BIT_readBitsFast(BIT_DStream_t* bitD, <span class='keyword'>unsigned</span> nbBits)</td></tr>
<tr class="codeline" data-linenumber="387"><td class="num" id="LN387">387</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="388"><td class="num" id="LN388">388</td><td class="line">    size_t <span class='keyword'>const</span> value = BIT_lookBitsFast(bitD, nbBits);</td></tr>
<tr class="codeline" data-linenumber="389"><td class="num" id="LN389">389</td><td class="line">    <span class='macro'>assert(nbBits &gt;= 1)<span class='macro_popup'>((void) sizeof ((nbBits &gt;= 1) ? 1 : 0), __extension__ ({ if<br> (nbBits &gt;= 1) ; else __assert_fail ("nbBits &gt;= 1", "./../lib/common/bitstream.h"<br>, 389, __extension__ __PRETTY_FUNCTION__); }))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="390"><td class="num" id="LN390">390</td><td class="line">    BIT_skipBits(bitD, nbBits);</td></tr>
<tr class="codeline" data-linenumber="391"><td class="num" id="LN391">391</td><td class="line">    <span class='keyword'>return</span> value;</td></tr>
<tr class="codeline" data-linenumber="392"><td class="num" id="LN392">392</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="393"><td class="num" id="LN393">393</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="394"><td class="num" id="LN394">394</td><td class="line"><span class='comment'>/*! BIT_reloadDStreamFast() :</span></td></tr>
<tr class="codeline" data-linenumber="395"><td class="num" id="LN395">395</td><td class="line"> <span class='comment'>*  Similar to BIT_reloadDStream(), but with two differences:</span></td></tr>
<tr class="codeline" data-linenumber="396"><td class="num" id="LN396">396</td><td class="line"> <span class='comment'>*  1. bitsConsumed &lt;= sizeof(bitD-&gt;bitContainer)*8 must hold!</span></td></tr>
<tr class="codeline" data-linenumber="397"><td class="num" id="LN397">397</td><td class="line"> <span class='comment'>*  2. Returns BIT_DStream_overflow when bitD-&gt;ptr &lt; bitD-&gt;limitPtr, at this</span></td></tr>
<tr class="codeline" data-linenumber="398"><td class="num" id="LN398">398</td><td class="line"> <span class='comment'>*     point you must use BIT_reloadDStream() to reload.</span></td></tr>
<tr class="codeline" data-linenumber="399"><td class="num" id="LN399">399</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="400"><td class="num" id="LN400">400</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> BIT_DStream_status BIT_reloadDStreamFast(BIT_DStream_t* bitD)</td></tr>
<tr class="codeline" data-linenumber="401"><td class="num" id="LN401">401</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="402"><td class="num" id="LN402">402</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>UNLIKELY(bitD-&gt;ptr &lt; bitD-&gt;limitPtr)<span class='macro_popup'>(__builtin_expect((bitD-&gt;ptr &lt; bitD-&gt;limitPtr), 0))</span></span>)</td></tr>
<tr class="codeline" data-linenumber="403"><td class="num" id="LN403">403</td><td class="line">        <span class='keyword'>return</span> BIT_DStream_overflow;</td></tr>
<tr class="codeline" data-linenumber="404"><td class="num" id="LN404">404</td><td class="line">    <span class='macro'>assert(bitD-&gt;bitsConsumed &lt;= <span class='keyword'>sizeof</span>(bitD-&gt;bitContainer)*8)<span class='macro_popup'>((void) sizeof ((bitD-&gt;bitsConsumed &lt;= sizeof(bitD-&gt;<br>bitContainer)*8) ? 1 : 0), __extension__ ({ if (bitD-&gt;bitsConsumed<br> &lt;= sizeof(bitD-&gt;bitContainer)*8) ; else __assert_fail (<br>"bitD-&gt;bitsConsumed &lt;= sizeof(bitD-&gt;bitContainer)*8"<br>, "./../lib/common/bitstream.h", 404, __extension__ __PRETTY_FUNCTION__<br>); }))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="405"><td class="num" id="LN405">405</td><td class="line">    bitD-&gt;ptr -= bitD-&gt;bitsConsumed &gt;&gt; 3;</td></tr>
<tr class="codeline" data-linenumber="406"><td class="num" id="LN406">406</td><td class="line">    bitD-&gt;bitsConsumed &amp;= 7;</td></tr>
<tr class="codeline" data-linenumber="407"><td class="num" id="LN407">407</td><td class="line">    bitD-&gt;bitContainer = MEM_readLEST(bitD-&gt;ptr);</td></tr>
<tr class="codeline" data-linenumber="408"><td class="num" id="LN408">408</td><td class="line">    <span class='keyword'>return</span> BIT_DStream_unfinished;</td></tr>
<tr class="codeline" data-linenumber="409"><td class="num" id="LN409">409</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="410"><td class="num" id="LN410">410</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="411"><td class="num" id="LN411">411</td><td class="line"><span class='comment'>/*! BIT_reloadDStream() :</span></td></tr>
<tr class="codeline" data-linenumber="412"><td class="num" id="LN412">412</td><td class="line"> <span class='comment'>*  Refill `bitD` from buffer previously set in BIT_initDStream() .</span></td></tr>
<tr class="codeline" data-linenumber="413"><td class="num" id="LN413">413</td><td class="line"> <span class='comment'>*  This function is safe, it guarantees it will not read beyond src buffer.</span></td></tr>
<tr class="codeline" data-linenumber="414"><td class="num" id="LN414">414</td><td class="line"> <span class='comment'>* @return : status of `BIT_DStream_t` internal register.</span></td></tr>
<tr class="codeline" data-linenumber="415"><td class="num" id="LN415">415</td><td class="line"> <span class='comment'>*           when status == BIT_DStream_unfinished, internal register is filled with at least 25 or 57 bits */</span></td></tr>
<tr class="codeline" data-linenumber="416"><td class="num" id="LN416">416</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> BIT_DStream_status BIT_reloadDStream(BIT_DStream_t* bitD)</td></tr>
<tr class="codeline" data-linenumber="417"><td class="num" id="LN417">417</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="418"><td class="num" id="LN418">418</td><td class="line">    <span class='keyword'>if</span> (bitD-&gt;bitsConsumed &gt; (<span class='keyword'>sizeof</span>(bitD-&gt;bitContainer)*8))  <span class='comment'>/* overflow detected, like end of stream */</span></td></tr>
<tr class="codeline" data-linenumber="419"><td class="num" id="LN419">419</td><td class="line">        <span class='keyword'>return</span> BIT_DStream_overflow;</td></tr>
<tr class="codeline" data-linenumber="420"><td class="num" id="LN420">420</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="421"><td class="num" id="LN421">421</td><td class="line">    <span class='keyword'>if</span> (bitD-&gt;ptr &gt;= bitD-&gt;limitPtr) {</td></tr>
<tr class="codeline" data-linenumber="422"><td class="num" id="LN422">422</td><td class="line">        <span class='keyword'>return</span> BIT_reloadDStreamFast(bitD);</td></tr>
<tr class="codeline" data-linenumber="423"><td class="num" id="LN423">423</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="424"><td class="num" id="LN424">424</td><td class="line">    <span class='keyword'>if</span> (bitD-&gt;ptr == bitD-&gt;start) {</td></tr>
<tr class="codeline" data-linenumber="425"><td class="num" id="LN425">425</td><td class="line">        <span class='keyword'>if</span> (bitD-&gt;bitsConsumed &lt; <span class='keyword'>sizeof</span>(bitD-&gt;bitContainer)*8) <span class='keyword'>return</span> BIT_DStream_endOfBuffer;</td></tr>
<tr class="codeline" data-linenumber="426"><td class="num" id="LN426">426</td><td class="line">        <span class='keyword'>return</span> BIT_DStream_completed;</td></tr>
<tr class="codeline" data-linenumber="427"><td class="num" id="LN427">427</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="428"><td class="num" id="LN428">428</td><td class="line">    <span class='comment'>/* start &lt; ptr &lt; limitPtr */</span></td></tr>
<tr class="codeline" data-linenumber="429"><td class="num" id="LN429">429</td><td class="line">    {   U32 nbBytes = bitD-&gt;bitsConsumed &gt;&gt; 3;</td></tr>
<tr class="codeline" data-linenumber="430"><td class="num" id="LN430">430</td><td class="line">        BIT_DStream_status result = BIT_DStream_unfinished;</td></tr>
<tr class="codeline" data-linenumber="431"><td class="num" id="LN431">431</td><td class="line">        <span class='keyword'>if</span> (bitD-&gt;ptr - nbBytes &lt; bitD-&gt;start) {</td></tr>
<tr class="codeline" data-linenumber="432"><td class="num" id="LN432">432</td><td class="line">            nbBytes = (U32)(bitD-&gt;ptr - bitD-&gt;start);  <span class='comment'>/* ptr &gt; start */</span></td></tr>
<tr class="codeline" data-linenumber="433"><td class="num" id="LN433">433</td><td class="line">            result = BIT_DStream_endOfBuffer;</td></tr>
<tr class="codeline" data-linenumber="434"><td class="num" id="LN434">434</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="435"><td class="num" id="LN435">435</td><td class="line">        bitD-&gt;ptr -= nbBytes;</td></tr>
<tr class="codeline" data-linenumber="436"><td class="num" id="LN436">436</td><td class="line">        bitD-&gt;bitsConsumed -= nbBytes*8;</td></tr>
<tr class="codeline" data-linenumber="437"><td class="num" id="LN437">437</td><td class="line">        bitD-&gt;bitContainer = MEM_readLEST(bitD-&gt;ptr);   <span class='comment'>/* reminder : srcSize &gt; sizeof(bitD-&gt;bitContainer), otherwise bitD-&gt;ptr == bitD-&gt;start */</span></td></tr>
<tr class="codeline" data-linenumber="438"><td class="num" id="LN438">438</td><td class="line">        <span class='keyword'>return</span> result;</td></tr>
<tr class="codeline" data-linenumber="439"><td class="num" id="LN439">439</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="440"><td class="num" id="LN440">440</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="441"><td class="num" id="LN441">441</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="442"><td class="num" id="LN442">442</td><td class="line"><span class='comment'>/*! BIT_endOfDStream() :</span></td></tr>
<tr class="codeline" data-linenumber="443"><td class="num" id="LN443">443</td><td class="line"> <span class='comment'>* @return : 1 if DStream has _exactly_ reached its end (all bits consumed).</span></td></tr>
<tr class="codeline" data-linenumber="444"><td class="num" id="LN444">444</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="445"><td class="num" id="LN445">445</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> <span class='keyword'>unsigned</span> BIT_endOfDStream(<span class='keyword'>const</span> BIT_DStream_t* DStream)</td></tr>
<tr class="codeline" data-linenumber="446"><td class="num" id="LN446">446</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="447"><td class="num" id="LN447">447</td><td class="line">    <span class='keyword'>return</span> ((DStream-&gt;ptr == DStream-&gt;start) &amp;&amp; (DStream-&gt;bitsConsumed == <span class='keyword'>sizeof</span>(DStream-&gt;bitContainer)*8));</td></tr>
<tr class="codeline" data-linenumber="448"><td class="num" id="LN448">448</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="449"><td class="num" id="LN449">449</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="450"><td class="num" id="LN450">450</td><td class="line"><span class='directive'>#if defined (__cplusplus)</span></td></tr>
<tr class="codeline" data-linenumber="451"><td class="num" id="LN451">451</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="452"><td class="num" id="LN452">452</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="453"><td class="num" id="LN453">453</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="454"><td class="num" id="LN454">454</td><td class="line"><span class='directive'>#endif /* BITSTREAM_H_MODULE */</span></td></tr>
</table></body></html>
