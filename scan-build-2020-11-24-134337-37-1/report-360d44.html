<!doctype html>
<html>
<head>
<title>hyperloglog.c</title>

<style type="text/css">
body { color:#000000; background-color:#ffffff }
body { font-family:Helvetica, sans-serif; font-size:10pt }
h1 { font-size:14pt }
.FileName { margin-top: 5px; margin-bottom: 5px; display: inline; }
.FileNav { margin-left: 5px; margin-right: 5px; display: inline; }
.FileNav a { text-decoration:none; font-size: larger; }
.divider { margin-top: 30px; margin-bottom: 30px; height: 15px; }
.divider { background-color: gray; }
.code { border-collapse:collapse; width:100%; }
.code { font-family: "Monospace", monospace; font-size:10pt }
.code { line-height: 1.2em }
.comment { color: green; font-style: oblique }
.keyword { color: blue }
.string_literal { color: red }
.directive { color: darkmagenta }

/* Macros and variables could have pop-up notes hidden by default.
  - Macro pop-up:    expansion of the macro
  - Variable pop-up: value (table) of the variable */
.macro_popup, .variable_popup { display: none; }

/* Pop-up appears on mouse-hover event. */
.macro:hover .macro_popup, .variable:hover .variable_popup {
  display: block;
  padding: 2px;
  -webkit-border-radius:5px;
  -webkit-box-shadow:1px 1px 7px #000;
  border-radius:5px;
  box-shadow:1px 1px 7px #000;
  position: absolute;
  top: -1em;
  left:10em;
  z-index: 1
}

.macro_popup {
  border: 2px solid red;
  background-color:#FFF0F0;
  font-weight: normal;
}

.variable_popup {
  border: 2px solid blue;
  background-color:#F0F0FF;
  font-weight: bold;
  font-family: Helvetica, sans-serif;
  font-size: 9pt;
}

/* Pop-up notes needs a relative position as a base where they pops up. */
.macro, .variable {
  background-color: PaleGoldenRod;
  position: relative;
}
.macro { color: DarkMagenta; }

#tooltiphint {
  position: fixed;
  width: 50em;
  margin-left: -25em;
  left: 50%;
  padding: 10px;
  border: 1px solid #b0b0b0;
  border-radius: 2px;
  box-shadow: 1px 1px 7px black;
  background-color: #c0c0c0;
  z-index: 2;
}

.num { width:2.5em; padding-right:2ex; background-color:#eeeeee }
.num { text-align:right; font-size:8pt }
.num { color:#444444 }
.line { padding-left: 1ex; border-left: 3px solid #ccc }
.line { white-space: pre }
.msg { -webkit-box-shadow:1px 1px 7px #000 }
.msg { box-shadow:1px 1px 7px #000 }
.msg { -webkit-border-radius:5px }
.msg { border-radius:5px }
.msg { font-family:Helvetica, sans-serif; font-size:8pt }
.msg { float:left }
.msg { padding:0.25em 1ex 0.25em 1ex }
.msg { margin-top:10px; margin-bottom:10px }
.msg { font-weight:bold }
.msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }
.msgT { padding:0x; spacing:0x }
.msgEvent { background-color:#fff8b4; color:#000000 }
.msgControl { background-color:#bbbbbb; color:#000000 }
.msgNote { background-color:#ddeeff; color:#000000 }
.mrange { background-color:#dfddf3 }
.mrange { border-bottom:1px solid #6F9DBE }
.PathIndex { font-weight: bold; padding:0px 5px; margin-right:5px; }
.PathIndex { -webkit-border-radius:8px }
.PathIndex { border-radius:8px }
.PathIndexEvent { background-color:#bfba87 }
.PathIndexControl { background-color:#8c8c8c }
.PathIndexPopUp { background-color: #879abc; }
.PathNav a { text-decoration:none; font-size: larger }
.CodeInsertionHint { font-weight: bold; background-color: #10dd10 }
.CodeRemovalHint { background-color:#de1010 }
.CodeRemovalHint { border-bottom:1px solid #6F9DBE }
.selected{ background-color:orange !important; }

table.simpletable {
  padding: 5px;
  font-size:12pt;
  margin:20px;
  border-collapse: collapse; border-spacing: 0px;
}
td.rowname {
  text-align: right;
  vertical-align: top;
  font-weight: bold;
  color:#444444;
  padding-right:2ex;
}

/* Hidden text. */
input.spoilerhider + label {
  cursor: pointer;
  text-decoration: underline;
  display: block;
}
input.spoilerhider {
 display: none;
}
input.spoilerhider ~ .spoiler {
  overflow: hidden;
  margin: 10px auto 0;
  height: 0;
  opacity: 0;
}
input.spoilerhider:checked + label + .spoiler{
  height: auto;
  opacity: 1;
}
</style>
</head>
<body>
<!-- BUGDESC Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 -->

<!-- BUGTYPE Potential insecure memory buffer bounds restriction in call 'memset' -->

<!-- BUGCATEGORY Security -->

<!-- BUGFILE /tmp/sslab_clang/c_redis/redis/src/hyperloglog.c -->

<!-- FILENAME hyperloglog.c -->

<!-- FUNCTIONNAME pfcountCommand -->

<!-- ISSUEHASHCONTENTOFLINEINCONTEXT f5a6c1e719c0d0e3c7ae28eb86524185 -->

<!-- BUGLINE 1235 -->

<!-- BUGCOLUMN 9 -->

<!-- BUGPATHLENGTH 1 -->

<!-- BUGMETAEND -->
<!-- REPORTHEADER -->
<h3>Bug Summary</h3>
<table class="simpletable">
<tr><td class="rowname">File:</td><td>src/hyperloglog.c</td></tr>
<tr><td class="rowname">Warning:</td><td><a href="#EndPath">line 1235, column 9</a><br />Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11</td></tr>

</table>
<!-- REPORTSUMMARYEXTRA -->
<h3>Annotated Source Code</h3>
<p>Press <a href="#" onclick="toggleHelp(); return false;">'?'</a>
   to see keyboard shortcuts</p>
<input type="checkbox" class="spoilerhider" id="showinvocation" />
<label for="showinvocation" >Show analyzer invocation</label>
<div class="spoiler">clang -cc1 -cc1 -triple x86_64-unknown-linux-gnu -analyze -disable-free -main-file-name hyperloglog.c -analyzer-store=region -analyzer-opt-analyze-nested-blocks -analyzer-checker=core -analyzer-checker=apiModeling -analyzer-checker=unix -analyzer-checker=deadcode -analyzer-checker=security.insecureAPI.UncheckedReturn -analyzer-checker=security.insecureAPI.getpw -analyzer-checker=security.insecureAPI.gets -analyzer-checker=security.insecureAPI.mktemp -analyzer-checker=security.insecureAPI.mkstemp -analyzer-checker=security.insecureAPI.vfork -analyzer-checker=nullability.NullPassedToNonnull -analyzer-checker=nullability.NullReturnedFromNonnull -analyzer-output plist -w -setup-static-analyzer -mrelocation-model static -mframe-pointer=none -fmath-errno -fno-rounding-math -mconstructor-aliases -munwind-tables -target-cpu x86-64 -fno-split-dwarf-inlining -debugger-tuning=gdb -resource-dir /llvm-project/build/lib/clang/12.0.0 -D REDIS_STATIC= -I ../deps/hiredis -I ../deps/linenoise -I ../deps/lua/src -D USE_JEMALLOC -I ../deps/jemalloc/include -internal-isystem /usr/local/include -internal-isystem /llvm-project/build/lib/clang/12.0.0/include -internal-externc-isystem /usr/include/x86_64-linux-gnu -internal-externc-isystem /include -internal-externc-isystem /usr/include -O2 -Wno-missing-field-initializers -std=c11 -fdebug-compilation-dir /tmp/sslab_clang/c_redis/redis/src -ferror-limit 19 -fgnuc-version=4.2.1 -vectorize-loops -vectorize-slp -analyzer-checker core -analyzer-checker cplusplus -analyzer-checker nullability -analyzer-checker optin -analyzer-checker security -analyzer-checker unix -analyzer-checker osx -analyzer-checker fuchsia -analyzer-checker webkit -analyzer-output=html -faddrsig -o /tmp/scan-build-2020-11-24-134337-37-1 -x c hyperloglog.c
</div>
<div id='tooltiphint' hidden="true">
  <p>Keyboard shortcuts: </p>
  <ul>
    <li>Use 'j/k' keys for keyboard navigation</li>
    <li>Use 'Shift+S' to show/hide relevant lines</li>
    <li>Use '?' to toggle this window</li>
  </ul>
  <a href="#" onclick="toggleHelp(); return false;">Close</a>
</div>
<script type='text/javascript'>
var relevant_lines = {"1": {"1235": 1}};

var filterCounterexample = function (hide) {
  var tables = document.getElementsByClassName("code");
  for (var t=0; t<tables.length; t++) {
    var table = tables[t];
    var file_id = table.getAttribute("data-fileid");
    var lines_in_fid = relevant_lines[file_id];
    if (!lines_in_fid) {
      lines_in_fid = {};
    }
    var lines = table.getElementsByClassName("codeline");
    for (var i=0; i<lines.length; i++) {
        var el = lines[i];
        var lineNo = el.getAttribute("data-linenumber");
        if (!lines_in_fid[lineNo]) {
          if (hide) {
            el.setAttribute("hidden", "");
          } else {
            el.removeAttribute("hidden");
          }
        }
    }
  }
}

window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.key == "S") {
    var checked = document.getElementsByName("showCounterexample")[0].checked;
    filterCounterexample(!checked);
    document.getElementsByName("showCounterexample")[0].checked = !checked;
  } else {
    return;
  }
  event.preventDefault();
}, true);

document.addEventListener("DOMContentLoaded", function() {
    document.querySelector('input[name="showCounterexample"]').onchange=
        function (event) {
      filterCounterexample(this.checked);
    };
});
</script>

<form>
    <input type="checkbox" name="showCounterexample" id="showCounterexample" />
    <label for="showCounterexample">
       Show only relevant lines
    </label>
</form>

<script type='text/javascript'>
var digitMatcher = new RegExp("[0-9]+");

var querySelectorAllArray = function(selector) {
  return Array.prototype.slice.call(
    document.querySelectorAll(selector));
}

document.addEventListener("DOMContentLoaded", function() {
    querySelectorAllArray(".PathNav > a").forEach(
        function(currentValue, currentIndex) {
            var hrefValue = currentValue.getAttribute("href");
            currentValue.onclick = function() {
                scrollTo(document.querySelector(hrefValue));
                return false;
            };
        });
});

var findNum = function() {
    var s = document.querySelector(".selected");
    if (!s || s.id == "EndPath") {
        return 0;
    }
    var out = parseInt(digitMatcher.exec(s.id)[0]);
    return out;
};

var scrollTo = function(el) {
    querySelectorAllArray(".selected").forEach(function(s) {
        s.classList.remove("selected");
    });
    el.classList.add("selected");
    window.scrollBy(0, el.getBoundingClientRect().top -
        (window.innerHeight / 2));
}

var move = function(num, up, numItems) {
  if (num == 1 && up || num == numItems - 1 && !up) {
    return 0;
  } else if (num == 0 && up) {
    return numItems - 1;
  } else if (num == 0 && !up) {
    return 1 % numItems;
  }
  return up ? num - 1 : num + 1;
}

var numToId = function(num) {
  if (num == 0) {
    return document.getElementById("EndPath")
  }
  return document.getElementById("Path" + num);
};

var navigateTo = function(up) {
  var numItems = document.querySelectorAll(
      ".line > .msgEvent, .line > .msgControl").length;
  var currentSelected = findNum();
  var newSelected = move(currentSelected, up, numItems);
  var newEl = numToId(newSelected, numItems);

  // Scroll element into center.
  scrollTo(newEl);
};

window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.key == "j") {
    navigateTo(/*up=*/false);
  } else if (event.key == "k") {
    navigateTo(/*up=*/true);
  } else {
    return;
  }
  event.preventDefault();
}, true);
</script>
  
<script type='text/javascript'>

var toggleHelp = function() {
    var hint = document.querySelector("#tooltiphint");
    var attributeName = "hidden";
    if (hint.hasAttribute(attributeName)) {
      hint.removeAttribute(attributeName);
    } else {
      hint.setAttribute("hidden", "true");
    }
};
window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.key == "?") {
    toggleHelp();
  } else {
    return;
  }
  event.preventDefault();
});
</script>
<table class="code" data-fileid="1">
<tr class="codeline" data-linenumber="1"><td class="num" id="LN1">1</td><td class="line"><span class='comment'>/* hyperloglog.c - Redis HyperLogLog probabilistic cardinality approximation.</span></td></tr>
<tr class="codeline" data-linenumber="2"><td class="num" id="LN2">2</td><td class="line"> <span class='comment'>* This file implements the algorithm and the exported Redis commands.</span></td></tr>
<tr class="codeline" data-linenumber="3"><td class="num" id="LN3">3</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="4"><td class="num" id="LN4">4</td><td class="line"> <span class='comment'>* Copyright (c) 2014, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;</span></td></tr>
<tr class="codeline" data-linenumber="5"><td class="num" id="LN5">5</td><td class="line"> <span class='comment'>* All rights reserved.</span></td></tr>
<tr class="codeline" data-linenumber="6"><td class="num" id="LN6">6</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="7"><td class="num" id="LN7">7</td><td class="line"> <span class='comment'>* Redistribution and use in source and binary forms, with or without</span></td></tr>
<tr class="codeline" data-linenumber="8"><td class="num" id="LN8">8</td><td class="line"> <span class='comment'>* modification, are permitted provided that the following conditions are met:</span></td></tr>
<tr class="codeline" data-linenumber="9"><td class="num" id="LN9">9</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="10"><td class="num" id="LN10">10</td><td class="line"> <span class='comment'>*   * Redistributions of source code must retain the above copyright notice,</span></td></tr>
<tr class="codeline" data-linenumber="11"><td class="num" id="LN11">11</td><td class="line"> <span class='comment'>*     this list of conditions and the following disclaimer.</span></td></tr>
<tr class="codeline" data-linenumber="12"><td class="num" id="LN12">12</td><td class="line"> <span class='comment'>*   * Redistributions in binary form must reproduce the above copyright</span></td></tr>
<tr class="codeline" data-linenumber="13"><td class="num" id="LN13">13</td><td class="line"> <span class='comment'>*     notice, this list of conditions and the following disclaimer in the</span></td></tr>
<tr class="codeline" data-linenumber="14"><td class="num" id="LN14">14</td><td class="line"> <span class='comment'>*     documentation and/or other materials provided with the distribution.</span></td></tr>
<tr class="codeline" data-linenumber="15"><td class="num" id="LN15">15</td><td class="line"> <span class='comment'>*   * Neither the name of Redis nor the names of its contributors may be used</span></td></tr>
<tr class="codeline" data-linenumber="16"><td class="num" id="LN16">16</td><td class="line"> <span class='comment'>*     to endorse or promote products derived from this software without</span></td></tr>
<tr class="codeline" data-linenumber="17"><td class="num" id="LN17">17</td><td class="line"> <span class='comment'>*     specific prior written permission.</span></td></tr>
<tr class="codeline" data-linenumber="18"><td class="num" id="LN18">18</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="19"><td class="num" id="LN19">19</td><td class="line"> <span class='comment'>* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"</span></td></tr>
<tr class="codeline" data-linenumber="20"><td class="num" id="LN20">20</td><td class="line"> <span class='comment'>* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span></td></tr>
<tr class="codeline" data-linenumber="21"><td class="num" id="LN21">21</td><td class="line"> <span class='comment'>* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span></td></tr>
<tr class="codeline" data-linenumber="22"><td class="num" id="LN22">22</td><td class="line"> <span class='comment'>* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</span></td></tr>
<tr class="codeline" data-linenumber="23"><td class="num" id="LN23">23</td><td class="line"> <span class='comment'>* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span></td></tr>
<tr class="codeline" data-linenumber="24"><td class="num" id="LN24">24</td><td class="line"> <span class='comment'>* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span></td></tr>
<tr class="codeline" data-linenumber="25"><td class="num" id="LN25">25</td><td class="line"> <span class='comment'>* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span></td></tr>
<tr class="codeline" data-linenumber="26"><td class="num" id="LN26">26</td><td class="line"> <span class='comment'>* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span></td></tr>
<tr class="codeline" data-linenumber="27"><td class="num" id="LN27">27</td><td class="line"> <span class='comment'>* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span></td></tr>
<tr class="codeline" data-linenumber="28"><td class="num" id="LN28">28</td><td class="line"> <span class='comment'>* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span></td></tr>
<tr class="codeline" data-linenumber="29"><td class="num" id="LN29">29</td><td class="line"> <span class='comment'>* POSSIBILITY OF SUCH DAMAGE.</span></td></tr>
<tr class="codeline" data-linenumber="30"><td class="num" id="LN30">30</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="31"><td class="num" id="LN31">31</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="32"><td class="num" id="LN32">32</td><td class="line"><span class='directive'>#include "server.h"</span></td></tr>
<tr class="codeline" data-linenumber="33"><td class="num" id="LN33">33</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="34"><td class="num" id="LN34">34</td><td class="line"><span class='directive'>#include &lt;stdint.h&gt;</span></td></tr>
<tr class="codeline" data-linenumber="35"><td class="num" id="LN35">35</td><td class="line"><span class='directive'>#include &lt;math.h&gt;</span></td></tr>
<tr class="codeline" data-linenumber="36"><td class="num" id="LN36">36</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="37"><td class="num" id="LN37">37</td><td class="line"><span class='comment'>/* The Redis HyperLogLog implementation is based on the following ideas:</span></td></tr>
<tr class="codeline" data-linenumber="38"><td class="num" id="LN38">38</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="39"><td class="num" id="LN39">39</td><td class="line"> <span class='comment'>* * The use of a 64 bit hash function as proposed in [1], in order to estimate</span></td></tr>
<tr class="codeline" data-linenumber="40"><td class="num" id="LN40">40</td><td class="line"> <span class='comment'>*   cardinalities larger than 10^9, at the cost of just 1 additional bit per</span></td></tr>
<tr class="codeline" data-linenumber="41"><td class="num" id="LN41">41</td><td class="line"> <span class='comment'>*   register.</span></td></tr>
<tr class="codeline" data-linenumber="42"><td class="num" id="LN42">42</td><td class="line"> <span class='comment'>* * The use of 16384 6-bit registers for a great level of accuracy, using</span></td></tr>
<tr class="codeline" data-linenumber="43"><td class="num" id="LN43">43</td><td class="line"> <span class='comment'>*   a total of 12k per key.</span></td></tr>
<tr class="codeline" data-linenumber="44"><td class="num" id="LN44">44</td><td class="line"> <span class='comment'>* * The use of the Redis string data type. No new type is introduced.</span></td></tr>
<tr class="codeline" data-linenumber="45"><td class="num" id="LN45">45</td><td class="line"> <span class='comment'>* * No attempt is made to compress the data structure as in [1]. Also the</span></td></tr>
<tr class="codeline" data-linenumber="46"><td class="num" id="LN46">46</td><td class="line"> <span class='comment'>*   algorithm used is the original HyperLogLog Algorithm as in [2], with</span></td></tr>
<tr class="codeline" data-linenumber="47"><td class="num" id="LN47">47</td><td class="line"> <span class='comment'>*   the only difference that a 64 bit hash function is used, so no correction</span></td></tr>
<tr class="codeline" data-linenumber="48"><td class="num" id="LN48">48</td><td class="line"> <span class='comment'>*   is performed for values near 2^32 as in [1].</span></td></tr>
<tr class="codeline" data-linenumber="49"><td class="num" id="LN49">49</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="50"><td class="num" id="LN50">50</td><td class="line"> <span class='comment'>* [1] Heule, Nunkesser, Hall: HyperLogLog in Practice: Algorithmic</span></td></tr>
<tr class="codeline" data-linenumber="51"><td class="num" id="LN51">51</td><td class="line"> <span class='comment'>*     Engineering of a State of The Art Cardinality Estimation Algorithm.</span></td></tr>
<tr class="codeline" data-linenumber="52"><td class="num" id="LN52">52</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="53"><td class="num" id="LN53">53</td><td class="line"> <span class='comment'>* [2] P. Flajolet, Ã‰ric Fusy, O. Gandouet, and F. Meunier. Hyperloglog: The</span></td></tr>
<tr class="codeline" data-linenumber="54"><td class="num" id="LN54">54</td><td class="line"> <span class='comment'>*     analysis of a near-optimal cardinality estimation algorithm.</span></td></tr>
<tr class="codeline" data-linenumber="55"><td class="num" id="LN55">55</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="56"><td class="num" id="LN56">56</td><td class="line"> <span class='comment'>* Redis uses two representations:</span></td></tr>
<tr class="codeline" data-linenumber="57"><td class="num" id="LN57">57</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="58"><td class="num" id="LN58">58</td><td class="line"> <span class='comment'>* 1) A "dense" representation where every entry is represented by</span></td></tr>
<tr class="codeline" data-linenumber="59"><td class="num" id="LN59">59</td><td class="line"> <span class='comment'>*    a 6-bit integer.</span></td></tr>
<tr class="codeline" data-linenumber="60"><td class="num" id="LN60">60</td><td class="line"> <span class='comment'>* 2) A "sparse" representation using run length compression suitable</span></td></tr>
<tr class="codeline" data-linenumber="61"><td class="num" id="LN61">61</td><td class="line"> <span class='comment'>*    for representing HyperLogLogs with many registers set to 0 in</span></td></tr>
<tr class="codeline" data-linenumber="62"><td class="num" id="LN62">62</td><td class="line"> <span class='comment'>*    a memory efficient way.</span></td></tr>
<tr class="codeline" data-linenumber="63"><td class="num" id="LN63">63</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="64"><td class="num" id="LN64">64</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="65"><td class="num" id="LN65">65</td><td class="line"> <span class='comment'>* HLL header</span></td></tr>
<tr class="codeline" data-linenumber="66"><td class="num" id="LN66">66</td><td class="line"> <span class='comment'>* ===</span></td></tr>
<tr class="codeline" data-linenumber="67"><td class="num" id="LN67">67</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="68"><td class="num" id="LN68">68</td><td class="line"> <span class='comment'>* Both the dense and sparse representation have a 16 byte header as follows:</span></td></tr>
<tr class="codeline" data-linenumber="69"><td class="num" id="LN69">69</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="70"><td class="num" id="LN70">70</td><td class="line"> <span class='comment'>* +------+---+-----+----------+</span></td></tr>
<tr class="codeline" data-linenumber="71"><td class="num" id="LN71">71</td><td class="line"> <span class='comment'>* | HYLL | E | N/U | Cardin.  |</span></td></tr>
<tr class="codeline" data-linenumber="72"><td class="num" id="LN72">72</td><td class="line"> <span class='comment'>* +------+---+-----+----------+</span></td></tr>
<tr class="codeline" data-linenumber="73"><td class="num" id="LN73">73</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="74"><td class="num" id="LN74">74</td><td class="line"> <span class='comment'>* The first 4 bytes are a magic string set to the bytes "HYLL".</span></td></tr>
<tr class="codeline" data-linenumber="75"><td class="num" id="LN75">75</td><td class="line"> <span class='comment'>* "E" is one byte encoding, currently set to HLL_DENSE or</span></td></tr>
<tr class="codeline" data-linenumber="76"><td class="num" id="LN76">76</td><td class="line"> <span class='comment'>* HLL_SPARSE. N/U are three not used bytes.</span></td></tr>
<tr class="codeline" data-linenumber="77"><td class="num" id="LN77">77</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="78"><td class="num" id="LN78">78</td><td class="line"> <span class='comment'>* The "Cardin." field is a 64 bit integer stored in little endian format</span></td></tr>
<tr class="codeline" data-linenumber="79"><td class="num" id="LN79">79</td><td class="line"> <span class='comment'>* with the latest cardinality computed that can be reused if the data</span></td></tr>
<tr class="codeline" data-linenumber="80"><td class="num" id="LN80">80</td><td class="line"> <span class='comment'>* structure was not modified since the last computation (this is useful</span></td></tr>
<tr class="codeline" data-linenumber="81"><td class="num" id="LN81">81</td><td class="line"> <span class='comment'>* because there are high probabilities that HLLADD operations don't</span></td></tr>
<tr class="codeline" data-linenumber="82"><td class="num" id="LN82">82</td><td class="line"> <span class='comment'>* modify the actual data structure and hence the approximated cardinality).</span></td></tr>
<tr class="codeline" data-linenumber="83"><td class="num" id="LN83">83</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="84"><td class="num" id="LN84">84</td><td class="line"> <span class='comment'>* When the most significant bit in the most significant byte of the cached</span></td></tr>
<tr class="codeline" data-linenumber="85"><td class="num" id="LN85">85</td><td class="line"> <span class='comment'>* cardinality is set, it means that the data structure was modified and</span></td></tr>
<tr class="codeline" data-linenumber="86"><td class="num" id="LN86">86</td><td class="line"> <span class='comment'>* we can't reuse the cached value that must be recomputed.</span></td></tr>
<tr class="codeline" data-linenumber="87"><td class="num" id="LN87">87</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="88"><td class="num" id="LN88">88</td><td class="line"> <span class='comment'>* Dense representation</span></td></tr>
<tr class="codeline" data-linenumber="89"><td class="num" id="LN89">89</td><td class="line"> <span class='comment'>* ===</span></td></tr>
<tr class="codeline" data-linenumber="90"><td class="num" id="LN90">90</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="91"><td class="num" id="LN91">91</td><td class="line"> <span class='comment'>* The dense representation used by Redis is the following:</span></td></tr>
<tr class="codeline" data-linenumber="92"><td class="num" id="LN92">92</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="93"><td class="num" id="LN93">93</td><td class="line"> <span class='comment'>* +--------+--------+--------+------//      //--+</span></td></tr>
<tr class="codeline" data-linenumber="94"><td class="num" id="LN94">94</td><td class="line"> <span class='comment'>* |11000000|22221111|33333322|55444444 ....     |</span></td></tr>
<tr class="codeline" data-linenumber="95"><td class="num" id="LN95">95</td><td class="line"> <span class='comment'>* +--------+--------+--------+------//      //--+</span></td></tr>
<tr class="codeline" data-linenumber="96"><td class="num" id="LN96">96</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="97"><td class="num" id="LN97">97</td><td class="line"> <span class='comment'>* The 6 bits counters are encoded one after the other starting from the</span></td></tr>
<tr class="codeline" data-linenumber="98"><td class="num" id="LN98">98</td><td class="line"> <span class='comment'>* LSB to the MSB, and using the next bytes as needed.</span></td></tr>
<tr class="codeline" data-linenumber="99"><td class="num" id="LN99">99</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="100"><td class="num" id="LN100">100</td><td class="line"> <span class='comment'>* Sparse representation</span></td></tr>
<tr class="codeline" data-linenumber="101"><td class="num" id="LN101">101</td><td class="line"> <span class='comment'>* ===</span></td></tr>
<tr class="codeline" data-linenumber="102"><td class="num" id="LN102">102</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="103"><td class="num" id="LN103">103</td><td class="line"> <span class='comment'>* The sparse representation encodes registers using a run length</span></td></tr>
<tr class="codeline" data-linenumber="104"><td class="num" id="LN104">104</td><td class="line"> <span class='comment'>* encoding composed of three opcodes, two using one byte, and one using</span></td></tr>
<tr class="codeline" data-linenumber="105"><td class="num" id="LN105">105</td><td class="line"> <span class='comment'>* of two bytes. The opcodes are called ZERO, XZERO and VAL.</span></td></tr>
<tr class="codeline" data-linenumber="106"><td class="num" id="LN106">106</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="107"><td class="num" id="LN107">107</td><td class="line"> <span class='comment'>* ZERO opcode is represented as 00xxxxxx. The 6-bit integer represented</span></td></tr>
<tr class="codeline" data-linenumber="108"><td class="num" id="LN108">108</td><td class="line"> <span class='comment'>* by the six bits 'xxxxxx', plus 1, means that there are N registers set</span></td></tr>
<tr class="codeline" data-linenumber="109"><td class="num" id="LN109">109</td><td class="line"> <span class='comment'>* to 0. This opcode can represent from 1 to 64 contiguous registers set</span></td></tr>
<tr class="codeline" data-linenumber="110"><td class="num" id="LN110">110</td><td class="line"> <span class='comment'>* to the value of 0.</span></td></tr>
<tr class="codeline" data-linenumber="111"><td class="num" id="LN111">111</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="112"><td class="num" id="LN112">112</td><td class="line"> <span class='comment'>* XZERO opcode is represented by two bytes 01xxxxxx yyyyyyyy. The 14-bit</span></td></tr>
<tr class="codeline" data-linenumber="113"><td class="num" id="LN113">113</td><td class="line"> <span class='comment'>* integer represented by the bits 'xxxxxx' as most significant bits and</span></td></tr>
<tr class="codeline" data-linenumber="114"><td class="num" id="LN114">114</td><td class="line"> <span class='comment'>* 'yyyyyyyy' as least significant bits, plus 1, means that there are N</span></td></tr>
<tr class="codeline" data-linenumber="115"><td class="num" id="LN115">115</td><td class="line"> <span class='comment'>* registers set to 0. This opcode can represent from 0 to 16384 contiguous</span></td></tr>
<tr class="codeline" data-linenumber="116"><td class="num" id="LN116">116</td><td class="line"> <span class='comment'>* registers set to the value of 0.</span></td></tr>
<tr class="codeline" data-linenumber="117"><td class="num" id="LN117">117</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="118"><td class="num" id="LN118">118</td><td class="line"> <span class='comment'>* VAL opcode is represented as 1vvvvvxx. It contains a 5-bit integer</span></td></tr>
<tr class="codeline" data-linenumber="119"><td class="num" id="LN119">119</td><td class="line"> <span class='comment'>* representing the value of a register, and a 2-bit integer representing</span></td></tr>
<tr class="codeline" data-linenumber="120"><td class="num" id="LN120">120</td><td class="line"> <span class='comment'>* the number of contiguous registers set to that value 'vvvvv'.</span></td></tr>
<tr class="codeline" data-linenumber="121"><td class="num" id="LN121">121</td><td class="line"> <span class='comment'>* To obtain the value and run length, the integers vvvvv and xx must be</span></td></tr>
<tr class="codeline" data-linenumber="122"><td class="num" id="LN122">122</td><td class="line"> <span class='comment'>* incremented by one. This opcode can represent values from 1 to 32,</span></td></tr>
<tr class="codeline" data-linenumber="123"><td class="num" id="LN123">123</td><td class="line"> <span class='comment'>* repeated from 1 to 4 times.</span></td></tr>
<tr class="codeline" data-linenumber="124"><td class="num" id="LN124">124</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="125"><td class="num" id="LN125">125</td><td class="line"> <span class='comment'>* The sparse representation can't represent registers with a value greater</span></td></tr>
<tr class="codeline" data-linenumber="126"><td class="num" id="LN126">126</td><td class="line"> <span class='comment'>* than 32, however it is very unlikely that we find such a register in an</span></td></tr>
<tr class="codeline" data-linenumber="127"><td class="num" id="LN127">127</td><td class="line"> <span class='comment'>* HLL with a cardinality where the sparse representation is still more</span></td></tr>
<tr class="codeline" data-linenumber="128"><td class="num" id="LN128">128</td><td class="line"> <span class='comment'>* memory efficient than the dense representation. When this happens the</span></td></tr>
<tr class="codeline" data-linenumber="129"><td class="num" id="LN129">129</td><td class="line"> <span class='comment'>* HLL is converted to the dense representation.</span></td></tr>
<tr class="codeline" data-linenumber="130"><td class="num" id="LN130">130</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="131"><td class="num" id="LN131">131</td><td class="line"> <span class='comment'>* The sparse representation is purely positional. For example a sparse</span></td></tr>
<tr class="codeline" data-linenumber="132"><td class="num" id="LN132">132</td><td class="line"> <span class='comment'>* representation of an empty HLL is just: XZERO:16384.</span></td></tr>
<tr class="codeline" data-linenumber="133"><td class="num" id="LN133">133</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="134"><td class="num" id="LN134">134</td><td class="line"> <span class='comment'>* An HLL having only 3 non-zero registers at position 1000, 1020, 1021</span></td></tr>
<tr class="codeline" data-linenumber="135"><td class="num" id="LN135">135</td><td class="line"> <span class='comment'>* respectively set to 2, 3, 3, is represented by the following three</span></td></tr>
<tr class="codeline" data-linenumber="136"><td class="num" id="LN136">136</td><td class="line"> <span class='comment'>* opcodes:</span></td></tr>
<tr class="codeline" data-linenumber="137"><td class="num" id="LN137">137</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="138"><td class="num" id="LN138">138</td><td class="line"> <span class='comment'>* XZERO:1000 (Registers 0-999 are set to 0)</span></td></tr>
<tr class="codeline" data-linenumber="139"><td class="num" id="LN139">139</td><td class="line"> <span class='comment'>* VAL:2,1    (1 register set to value 2, that is register 1000)</span></td></tr>
<tr class="codeline" data-linenumber="140"><td class="num" id="LN140">140</td><td class="line"> <span class='comment'>* ZERO:19    (Registers 1001-1019 set to 0)</span></td></tr>
<tr class="codeline" data-linenumber="141"><td class="num" id="LN141">141</td><td class="line"> <span class='comment'>* VAL:3,2    (2 registers set to value 3, that is registers 1020,1021)</span></td></tr>
<tr class="codeline" data-linenumber="142"><td class="num" id="LN142">142</td><td class="line"> <span class='comment'>* XZERO:15362 (Registers 1022-16383 set to 0)</span></td></tr>
<tr class="codeline" data-linenumber="143"><td class="num" id="LN143">143</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="144"><td class="num" id="LN144">144</td><td class="line"> <span class='comment'>* In the example the sparse representation used just 7 bytes instead</span></td></tr>
<tr class="codeline" data-linenumber="145"><td class="num" id="LN145">145</td><td class="line"> <span class='comment'>* of 12k in order to represent the HLL registers. In general for low</span></td></tr>
<tr class="codeline" data-linenumber="146"><td class="num" id="LN146">146</td><td class="line"> <span class='comment'>* cardinality there is a big win in terms of space efficiency, traded</span></td></tr>
<tr class="codeline" data-linenumber="147"><td class="num" id="LN147">147</td><td class="line"> <span class='comment'>* with CPU time since the sparse representation is slower to access:</span></td></tr>
<tr class="codeline" data-linenumber="148"><td class="num" id="LN148">148</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="149"><td class="num" id="LN149">149</td><td class="line"> <span class='comment'>* The following table shows average cardinality vs bytes used, 100</span></td></tr>
<tr class="codeline" data-linenumber="150"><td class="num" id="LN150">150</td><td class="line"> <span class='comment'>* samples per cardinality (when the set was not representable because</span></td></tr>
<tr class="codeline" data-linenumber="151"><td class="num" id="LN151">151</td><td class="line"> <span class='comment'>* of registers with too big value, the dense representation size was used</span></td></tr>
<tr class="codeline" data-linenumber="152"><td class="num" id="LN152">152</td><td class="line"> <span class='comment'>* as a sample).</span></td></tr>
<tr class="codeline" data-linenumber="153"><td class="num" id="LN153">153</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="154"><td class="num" id="LN154">154</td><td class="line"> <span class='comment'>* 100 267</span></td></tr>
<tr class="codeline" data-linenumber="155"><td class="num" id="LN155">155</td><td class="line"> <span class='comment'>* 200 485</span></td></tr>
<tr class="codeline" data-linenumber="156"><td class="num" id="LN156">156</td><td class="line"> <span class='comment'>* 300 678</span></td></tr>
<tr class="codeline" data-linenumber="157"><td class="num" id="LN157">157</td><td class="line"> <span class='comment'>* 400 859</span></td></tr>
<tr class="codeline" data-linenumber="158"><td class="num" id="LN158">158</td><td class="line"> <span class='comment'>* 500 1033</span></td></tr>
<tr class="codeline" data-linenumber="159"><td class="num" id="LN159">159</td><td class="line"> <span class='comment'>* 600 1205</span></td></tr>
<tr class="codeline" data-linenumber="160"><td class="num" id="LN160">160</td><td class="line"> <span class='comment'>* 700 1375</span></td></tr>
<tr class="codeline" data-linenumber="161"><td class="num" id="LN161">161</td><td class="line"> <span class='comment'>* 800 1544</span></td></tr>
<tr class="codeline" data-linenumber="162"><td class="num" id="LN162">162</td><td class="line"> <span class='comment'>* 900 1713</span></td></tr>
<tr class="codeline" data-linenumber="163"><td class="num" id="LN163">163</td><td class="line"> <span class='comment'>* 1000 1882</span></td></tr>
<tr class="codeline" data-linenumber="164"><td class="num" id="LN164">164</td><td class="line"> <span class='comment'>* 2000 3480</span></td></tr>
<tr class="codeline" data-linenumber="165"><td class="num" id="LN165">165</td><td class="line"> <span class='comment'>* 3000 4879</span></td></tr>
<tr class="codeline" data-linenumber="166"><td class="num" id="LN166">166</td><td class="line"> <span class='comment'>* 4000 6089</span></td></tr>
<tr class="codeline" data-linenumber="167"><td class="num" id="LN167">167</td><td class="line"> <span class='comment'>* 5000 7138</span></td></tr>
<tr class="codeline" data-linenumber="168"><td class="num" id="LN168">168</td><td class="line"> <span class='comment'>* 6000 8042</span></td></tr>
<tr class="codeline" data-linenumber="169"><td class="num" id="LN169">169</td><td class="line"> <span class='comment'>* 7000 8823</span></td></tr>
<tr class="codeline" data-linenumber="170"><td class="num" id="LN170">170</td><td class="line"> <span class='comment'>* 8000 9500</span></td></tr>
<tr class="codeline" data-linenumber="171"><td class="num" id="LN171">171</td><td class="line"> <span class='comment'>* 9000 10088</span></td></tr>
<tr class="codeline" data-linenumber="172"><td class="num" id="LN172">172</td><td class="line"> <span class='comment'>* 10000 10591</span></td></tr>
<tr class="codeline" data-linenumber="173"><td class="num" id="LN173">173</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="174"><td class="num" id="LN174">174</td><td class="line"> <span class='comment'>* The dense representation uses 12288 bytes, so there is a big win up to</span></td></tr>
<tr class="codeline" data-linenumber="175"><td class="num" id="LN175">175</td><td class="line"> <span class='comment'>* a cardinality of ~2000-3000. For bigger cardinalities the constant times</span></td></tr>
<tr class="codeline" data-linenumber="176"><td class="num" id="LN176">176</td><td class="line"> <span class='comment'>* involved in updating the sparse representation is not justified by the</span></td></tr>
<tr class="codeline" data-linenumber="177"><td class="num" id="LN177">177</td><td class="line"> <span class='comment'>* memory savings. The exact maximum length of the sparse representation</span></td></tr>
<tr class="codeline" data-linenumber="178"><td class="num" id="LN178">178</td><td class="line"> <span class='comment'>* when this implementation switches to the dense representation is</span></td></tr>
<tr class="codeline" data-linenumber="179"><td class="num" id="LN179">179</td><td class="line"> <span class='comment'>* configured via the define server.hll_sparse_max_bytes.</span></td></tr>
<tr class="codeline" data-linenumber="180"><td class="num" id="LN180">180</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="181"><td class="num" id="LN181">181</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="182"><td class="num" id="LN182">182</td><td class="line"><span class='keyword'>struct</span> hllhdr {</td></tr>
<tr class="codeline" data-linenumber="183"><td class="num" id="LN183">183</td><td class="line">    <span class='keyword'>char</span> magic[4];      <span class='comment'>/* "HYLL" */</span></td></tr>
<tr class="codeline" data-linenumber="184"><td class="num" id="LN184">184</td><td class="line">    uint8_t encoding;   <span class='comment'>/* HLL_DENSE or HLL_SPARSE. */</span></td></tr>
<tr class="codeline" data-linenumber="185"><td class="num" id="LN185">185</td><td class="line">    uint8_t notused[3]; <span class='comment'>/* Reserved for future use, must be zero. */</span></td></tr>
<tr class="codeline" data-linenumber="186"><td class="num" id="LN186">186</td><td class="line">    uint8_t card[8];    <span class='comment'>/* Cached cardinality, little endian. */</span></td></tr>
<tr class="codeline" data-linenumber="187"><td class="num" id="LN187">187</td><td class="line">    uint8_t registers[]; <span class='comment'>/* Data bytes. */</span></td></tr>
<tr class="codeline" data-linenumber="188"><td class="num" id="LN188">188</td><td class="line">};</td></tr>
<tr class="codeline" data-linenumber="189"><td class="num" id="LN189">189</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="190"><td class="num" id="LN190">190</td><td class="line"><span class='comment'>/* The cached cardinality MSB is used to signal validity of the cached value. */</span></td></tr>
<tr class="codeline" data-linenumber="191"><td class="num" id="LN191">191</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_INVALIDATE_CACHE(hdr)<span class='macro_popup'>(hdr)-&gt;card[7] |= (1&lt;&lt;7)</span></span> (hdr)-&gt;card[7] |= (1&lt;&lt;7)</span></td></tr>
<tr class="codeline" data-linenumber="192"><td class="num" id="LN192">192</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_VALID_CACHE(hdr)<span class='macro_popup'>(((hdr)-&gt;card[7] &amp; (1&lt;&lt;7)) == 0)</span></span> (((hdr)-&gt;card[7] &amp; (1&lt;&lt;7)) == 0)</span></td></tr>
<tr class="codeline" data-linenumber="193"><td class="num" id="LN193">193</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="194"><td class="num" id="LN194">194</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_P<span class='macro_popup'>14</span></span> 14 /* The greater is P, the smaller the error. */</span></td></tr>
<tr class="codeline" data-linenumber="195"><td class="num" id="LN195">195</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_Q<span class='macro_popup'>(64-14)</span></span> (64-<span class='macro'>HLL_P<span class='macro_popup'>14</span></span>) /* The number of bits of the hash value used for</span></td></tr>
<tr class="codeline" data-linenumber="196"><td class="num" id="LN196">196</td><td class="line">                            <span class='directive'>determining the number of leading zeros. */</span></td></tr>
<tr class="codeline" data-linenumber="197"><td class="num" id="LN197">197</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_REGISTERS<span class='macro_popup'>(1&lt;&lt;14)</span></span> (1&lt;&lt;<span class='macro'>HLL_P<span class='macro_popup'>14</span></span>) /* With P=14, 16384 registers. */</span></td></tr>
<tr class="codeline" data-linenumber="198"><td class="num" id="LN198">198</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_P_MASK<span class='macro_popup'>((1&lt;&lt;14)-1)</span></span> (<span class='macro'>HLL_REGISTERS<span class='macro_popup'>(1&lt;&lt;14)</span></span>-1) /* Mask to index register. */</span></td></tr>
<tr class="codeline" data-linenumber="199"><td class="num" id="LN199">199</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_BITS<span class='macro_popup'>6</span></span> 6 /* Enough to count up to 63 leading zeroes. */</span></td></tr>
<tr class="codeline" data-linenumber="200"><td class="num" id="LN200">200</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_REGISTER_MAX<span class='macro_popup'>((1&lt;&lt;6)-1)</span></span> ((1&lt;&lt;<span class='macro'>HLL_BITS<span class='macro_popup'>6</span></span>)-1)</span></td></tr>
<tr class="codeline" data-linenumber="201"><td class="num" id="LN201">201</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_HDR_SIZE<span class='macro_popup'>sizeof(struct hllhdr)</span></span> sizeof(struct hllhdr)</span></td></tr>
<tr class="codeline" data-linenumber="202"><td class="num" id="LN202">202</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_DENSE_SIZE<span class='macro_popup'>(sizeof(struct hllhdr)+(((1&lt;&lt;14)*6 +7)/8))</span></span> (<span class='macro'>HLL_HDR_SIZE<span class='macro_popup'>sizeof(struct hllhdr)</span></span>+((<span class='macro'>HLL_REGISTERS<span class='macro_popup'>(1&lt;&lt;14)</span></span>*<span class='macro'>HLL_BITS<span class='macro_popup'>6</span></span>+7)/8))</span></td></tr>
<tr class="codeline" data-linenumber="203"><td class="num" id="LN203">203</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_DENSE<span class='macro_popup'>0</span></span> 0 /* Dense encoding. */</span></td></tr>
<tr class="codeline" data-linenumber="204"><td class="num" id="LN204">204</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_SPARSE<span class='macro_popup'>1</span></span> 1 /* Sparse encoding. */</span></td></tr>
<tr class="codeline" data-linenumber="205"><td class="num" id="LN205">205</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_RAW<span class='macro_popup'>255</span></span> 255 /* Only used internally, never exposed. */</span></td></tr>
<tr class="codeline" data-linenumber="206"><td class="num" id="LN206">206</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_MAX_ENCODING<span class='macro_popup'>1</span></span> 1</span></td></tr>
<tr class="codeline" data-linenumber="207"><td class="num" id="LN207">207</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="208"><td class="num" id="LN208">208</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>char</span> *invalid_hll_err = <span class='string_literal'>"-INVALIDOBJ Corrupted HLL object detected\r\n"</span>;</td></tr>
<tr class="codeline" data-linenumber="209"><td class="num" id="LN209">209</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="210"><td class="num" id="LN210">210</td><td class="line"><span class='comment'>/* =========================== Low level bit macros ========================= */</span></td></tr>
<tr class="codeline" data-linenumber="211"><td class="num" id="LN211">211</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="212"><td class="num" id="LN212">212</td><td class="line"><span class='comment'>/* Macros to access the dense representation.</span></td></tr>
<tr class="codeline" data-linenumber="213"><td class="num" id="LN213">213</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="214"><td class="num" id="LN214">214</td><td class="line"> <span class='comment'>* We need to get and set 6 bit counters in an array of 8 bit bytes.</span></td></tr>
<tr class="codeline" data-linenumber="215"><td class="num" id="LN215">215</td><td class="line"> <span class='comment'>* We use macros to make sure the code is inlined since speed is critical</span></td></tr>
<tr class="codeline" data-linenumber="216"><td class="num" id="LN216">216</td><td class="line"> <span class='comment'>* especially in order to compute the approximated cardinality in</span></td></tr>
<tr class="codeline" data-linenumber="217"><td class="num" id="LN217">217</td><td class="line"> <span class='comment'>* HLLCOUNT where we need to access all the registers at once.</span></td></tr>
<tr class="codeline" data-linenumber="218"><td class="num" id="LN218">218</td><td class="line"> <span class='comment'>* For the same reason we also want to avoid conditionals in this code path.</span></td></tr>
<tr class="codeline" data-linenumber="219"><td class="num" id="LN219">219</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="220"><td class="num" id="LN220">220</td><td class="line"> <span class='comment'>* +--------+--------+--------+------//</span></td></tr>
<tr class="codeline" data-linenumber="221"><td class="num" id="LN221">221</td><td class="line"> <span class='comment'>* |11000000|22221111|33333322|55444444</span></td></tr>
<tr class="codeline" data-linenumber="222"><td class="num" id="LN222">222</td><td class="line"> <span class='comment'>* +--------+--------+--------+------//</span></td></tr>
<tr class="codeline" data-linenumber="223"><td class="num" id="LN223">223</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="224"><td class="num" id="LN224">224</td><td class="line"> <span class='comment'>* Note: in the above representation the most significant bit (MSB)</span></td></tr>
<tr class="codeline" data-linenumber="225"><td class="num" id="LN225">225</td><td class="line"> <span class='comment'>* of every byte is on the left. We start using bits from the LSB to MSB,</span></td></tr>
<tr class="codeline" data-linenumber="226"><td class="num" id="LN226">226</td><td class="line"> <span class='comment'>* and so forth passing to the next byte.</span></td></tr>
<tr class="codeline" data-linenumber="227"><td class="num" id="LN227">227</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="228"><td class="num" id="LN228">228</td><td class="line"> <span class='comment'>* Example, we want to access to counter at pos = 1 ("111111" in the</span></td></tr>
<tr class="codeline" data-linenumber="229"><td class="num" id="LN229">229</td><td class="line"> <span class='comment'>* illustration above).</span></td></tr>
<tr class="codeline" data-linenumber="230"><td class="num" id="LN230">230</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="231"><td class="num" id="LN231">231</td><td class="line"> <span class='comment'>* The index of the first byte b0 containing our data is:</span></td></tr>
<tr class="codeline" data-linenumber="232"><td class="num" id="LN232">232</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="233"><td class="num" id="LN233">233</td><td class="line"> <span class='comment'>*  b0 = 6 * pos / 8 = 0</span></td></tr>
<tr class="codeline" data-linenumber="234"><td class="num" id="LN234">234</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="235"><td class="num" id="LN235">235</td><td class="line"> <span class='comment'>*   +--------+</span></td></tr>
<tr class="codeline" data-linenumber="236"><td class="num" id="LN236">236</td><td class="line"> <span class='comment'>*   |11000000|  &lt;- Our byte at b0</span></td></tr>
<tr class="codeline" data-linenumber="237"><td class="num" id="LN237">237</td><td class="line"> <span class='comment'>*   +--------+</span></td></tr>
<tr class="codeline" data-linenumber="238"><td class="num" id="LN238">238</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="239"><td class="num" id="LN239">239</td><td class="line"> <span class='comment'>* The position of the first bit (counting from the LSB = 0) in the byte</span></td></tr>
<tr class="codeline" data-linenumber="240"><td class="num" id="LN240">240</td><td class="line"> <span class='comment'>* is given by:</span></td></tr>
<tr class="codeline" data-linenumber="241"><td class="num" id="LN241">241</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="242"><td class="num" id="LN242">242</td><td class="line"> <span class='comment'>*  fb = 6 * pos % 8 -&gt; 6</span></td></tr>
<tr class="codeline" data-linenumber="243"><td class="num" id="LN243">243</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="244"><td class="num" id="LN244">244</td><td class="line"> <span class='comment'>* Right shift b0 of 'fb' bits.</span></td></tr>
<tr class="codeline" data-linenumber="245"><td class="num" id="LN245">245</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="246"><td class="num" id="LN246">246</td><td class="line"> <span class='comment'>*   +--------+</span></td></tr>
<tr class="codeline" data-linenumber="247"><td class="num" id="LN247">247</td><td class="line"> <span class='comment'>*   |11000000|  &lt;- Initial value of b0</span></td></tr>
<tr class="codeline" data-linenumber="248"><td class="num" id="LN248">248</td><td class="line"> <span class='comment'>*   |00000011|  &lt;- After right shift of 6 pos.</span></td></tr>
<tr class="codeline" data-linenumber="249"><td class="num" id="LN249">249</td><td class="line"> <span class='comment'>*   +--------+</span></td></tr>
<tr class="codeline" data-linenumber="250"><td class="num" id="LN250">250</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="251"><td class="num" id="LN251">251</td><td class="line"> <span class='comment'>* Left shift b1 of bits 8-fb bits (2 bits)</span></td></tr>
<tr class="codeline" data-linenumber="252"><td class="num" id="LN252">252</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="253"><td class="num" id="LN253">253</td><td class="line"> <span class='comment'>*   +--------+</span></td></tr>
<tr class="codeline" data-linenumber="254"><td class="num" id="LN254">254</td><td class="line"> <span class='comment'>*   |22221111|  &lt;- Initial value of b1</span></td></tr>
<tr class="codeline" data-linenumber="255"><td class="num" id="LN255">255</td><td class="line"> <span class='comment'>*   |22111100|  &lt;- After left shift of 2 bits.</span></td></tr>
<tr class="codeline" data-linenumber="256"><td class="num" id="LN256">256</td><td class="line"> <span class='comment'>*   +--------+</span></td></tr>
<tr class="codeline" data-linenumber="257"><td class="num" id="LN257">257</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="258"><td class="num" id="LN258">258</td><td class="line"> <span class='comment'>* OR the two bits, and finally AND with 111111 (63 in decimal) to</span></td></tr>
<tr class="codeline" data-linenumber="259"><td class="num" id="LN259">259</td><td class="line"> <span class='comment'>* clean the higher order bits we are not interested in:</span></td></tr>
<tr class="codeline" data-linenumber="260"><td class="num" id="LN260">260</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="261"><td class="num" id="LN261">261</td><td class="line"> <span class='comment'>*   +--------+</span></td></tr>
<tr class="codeline" data-linenumber="262"><td class="num" id="LN262">262</td><td class="line"> <span class='comment'>*   |00000011|  &lt;- b0 right shifted</span></td></tr>
<tr class="codeline" data-linenumber="263"><td class="num" id="LN263">263</td><td class="line"> <span class='comment'>*   |22111100|  &lt;- b1 left shifted</span></td></tr>
<tr class="codeline" data-linenumber="264"><td class="num" id="LN264">264</td><td class="line"> <span class='comment'>*   |22111111|  &lt;- b0 OR b1</span></td></tr>
<tr class="codeline" data-linenumber="265"><td class="num" id="LN265">265</td><td class="line"> <span class='comment'>*   |  111111|  &lt;- (b0 OR b1) AND 63, our value.</span></td></tr>
<tr class="codeline" data-linenumber="266"><td class="num" id="LN266">266</td><td class="line"> <span class='comment'>*   +--------+</span></td></tr>
<tr class="codeline" data-linenumber="267"><td class="num" id="LN267">267</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="268"><td class="num" id="LN268">268</td><td class="line"> <span class='comment'>* We can try with a different example, like pos = 0. In this case</span></td></tr>
<tr class="codeline" data-linenumber="269"><td class="num" id="LN269">269</td><td class="line"> <span class='comment'>* the 6-bit counter is actually contained in a single byte.</span></td></tr>
<tr class="codeline" data-linenumber="270"><td class="num" id="LN270">270</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="271"><td class="num" id="LN271">271</td><td class="line"> <span class='comment'>*  b0 = 6 * pos / 8 = 0</span></td></tr>
<tr class="codeline" data-linenumber="272"><td class="num" id="LN272">272</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="273"><td class="num" id="LN273">273</td><td class="line"> <span class='comment'>*   +--------+</span></td></tr>
<tr class="codeline" data-linenumber="274"><td class="num" id="LN274">274</td><td class="line"> <span class='comment'>*   |11000000|  &lt;- Our byte at b0</span></td></tr>
<tr class="codeline" data-linenumber="275"><td class="num" id="LN275">275</td><td class="line"> <span class='comment'>*   +--------+</span></td></tr>
<tr class="codeline" data-linenumber="276"><td class="num" id="LN276">276</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="277"><td class="num" id="LN277">277</td><td class="line"> <span class='comment'>*  fb = 6 * pos % 8 = 0</span></td></tr>
<tr class="codeline" data-linenumber="278"><td class="num" id="LN278">278</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="279"><td class="num" id="LN279">279</td><td class="line"> <span class='comment'>*  So we right shift of 0 bits (no shift in practice) and</span></td></tr>
<tr class="codeline" data-linenumber="280"><td class="num" id="LN280">280</td><td class="line"> <span class='comment'>*  left shift the next byte of 8 bits, even if we don't use it,</span></td></tr>
<tr class="codeline" data-linenumber="281"><td class="num" id="LN281">281</td><td class="line"> <span class='comment'>*  but this has the effect of clearing the bits so the result</span></td></tr>
<tr class="codeline" data-linenumber="282"><td class="num" id="LN282">282</td><td class="line"> <span class='comment'>*  will not be affected after the OR.</span></td></tr>
<tr class="codeline" data-linenumber="283"><td class="num" id="LN283">283</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="284"><td class="num" id="LN284">284</td><td class="line"> <span class='comment'>* -------------------------------------------------------------------------</span></td></tr>
<tr class="codeline" data-linenumber="285"><td class="num" id="LN285">285</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="286"><td class="num" id="LN286">286</td><td class="line"> <span class='comment'>* Setting the register is a bit more complex, let's assume that 'val'</span></td></tr>
<tr class="codeline" data-linenumber="287"><td class="num" id="LN287">287</td><td class="line"> <span class='comment'>* is the value we want to set, already in the right range.</span></td></tr>
<tr class="codeline" data-linenumber="288"><td class="num" id="LN288">288</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="289"><td class="num" id="LN289">289</td><td class="line"> <span class='comment'>* We need two steps, in one we need to clear the bits, and in the other</span></td></tr>
<tr class="codeline" data-linenumber="290"><td class="num" id="LN290">290</td><td class="line"> <span class='comment'>* we need to bitwise-OR the new bits.</span></td></tr>
<tr class="codeline" data-linenumber="291"><td class="num" id="LN291">291</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="292"><td class="num" id="LN292">292</td><td class="line"> <span class='comment'>* Let's try with 'pos' = 1, so our first byte at 'b' is 0,</span></td></tr>
<tr class="codeline" data-linenumber="293"><td class="num" id="LN293">293</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="294"><td class="num" id="LN294">294</td><td class="line"> <span class='comment'>* "fb" is 6 in this case.</span></td></tr>
<tr class="codeline" data-linenumber="295"><td class="num" id="LN295">295</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="296"><td class="num" id="LN296">296</td><td class="line"> <span class='comment'>*   +--------+</span></td></tr>
<tr class="codeline" data-linenumber="297"><td class="num" id="LN297">297</td><td class="line"> <span class='comment'>*   |11000000|  &lt;- Our byte at b0</span></td></tr>
<tr class="codeline" data-linenumber="298"><td class="num" id="LN298">298</td><td class="line"> <span class='comment'>*   +--------+</span></td></tr>
<tr class="codeline" data-linenumber="299"><td class="num" id="LN299">299</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="300"><td class="num" id="LN300">300</td><td class="line"> <span class='comment'>* To create an AND-mask to clear the bits about this position, we just</span></td></tr>
<tr class="codeline" data-linenumber="301"><td class="num" id="LN301">301</td><td class="line"> <span class='comment'>* initialize the mask with the value 63, left shift it of "fs" bits,</span></td></tr>
<tr class="codeline" data-linenumber="302"><td class="num" id="LN302">302</td><td class="line"> <span class='comment'>* and finally invert the result.</span></td></tr>
<tr class="codeline" data-linenumber="303"><td class="num" id="LN303">303</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="304"><td class="num" id="LN304">304</td><td class="line"> <span class='comment'>*   +--------+</span></td></tr>
<tr class="codeline" data-linenumber="305"><td class="num" id="LN305">305</td><td class="line"> <span class='comment'>*   |00111111|  &lt;- "mask" starts at 63</span></td></tr>
<tr class="codeline" data-linenumber="306"><td class="num" id="LN306">306</td><td class="line"> <span class='comment'>*   |11000000|  &lt;- "mask" after left shift of "ls" bits.</span></td></tr>
<tr class="codeline" data-linenumber="307"><td class="num" id="LN307">307</td><td class="line"> <span class='comment'>*   |00111111|  &lt;- "mask" after invert.</span></td></tr>
<tr class="codeline" data-linenumber="308"><td class="num" id="LN308">308</td><td class="line"> <span class='comment'>*   +--------+</span></td></tr>
<tr class="codeline" data-linenumber="309"><td class="num" id="LN309">309</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="310"><td class="num" id="LN310">310</td><td class="line"> <span class='comment'>* Now we can bitwise-AND the byte at "b" with the mask, and bitwise-OR</span></td></tr>
<tr class="codeline" data-linenumber="311"><td class="num" id="LN311">311</td><td class="line"> <span class='comment'>* it with "val" left-shifted of "ls" bits to set the new bits.</span></td></tr>
<tr class="codeline" data-linenumber="312"><td class="num" id="LN312">312</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="313"><td class="num" id="LN313">313</td><td class="line"> <span class='comment'>* Now let's focus on the next byte b1:</span></td></tr>
<tr class="codeline" data-linenumber="314"><td class="num" id="LN314">314</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="315"><td class="num" id="LN315">315</td><td class="line"> <span class='comment'>*   +--------+</span></td></tr>
<tr class="codeline" data-linenumber="316"><td class="num" id="LN316">316</td><td class="line"> <span class='comment'>*   |22221111|  &lt;- Initial value of b1</span></td></tr>
<tr class="codeline" data-linenumber="317"><td class="num" id="LN317">317</td><td class="line"> <span class='comment'>*   +--------+</span></td></tr>
<tr class="codeline" data-linenumber="318"><td class="num" id="LN318">318</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="319"><td class="num" id="LN319">319</td><td class="line"> <span class='comment'>* To build the AND mask we start again with the 63 value, right shift</span></td></tr>
<tr class="codeline" data-linenumber="320"><td class="num" id="LN320">320</td><td class="line"> <span class='comment'>* it by 8-fb bits, and invert it.</span></td></tr>
<tr class="codeline" data-linenumber="321"><td class="num" id="LN321">321</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="322"><td class="num" id="LN322">322</td><td class="line"> <span class='comment'>*   +--------+</span></td></tr>
<tr class="codeline" data-linenumber="323"><td class="num" id="LN323">323</td><td class="line"> <span class='comment'>*   |00111111|  &lt;- "mask" set at 2&amp;6-1</span></td></tr>
<tr class="codeline" data-linenumber="324"><td class="num" id="LN324">324</td><td class="line"> <span class='comment'>*   |00001111|  &lt;- "mask" after the right shift by 8-fb = 2 bits</span></td></tr>
<tr class="codeline" data-linenumber="325"><td class="num" id="LN325">325</td><td class="line"> <span class='comment'>*   |11110000|  &lt;- "mask" after bitwise not.</span></td></tr>
<tr class="codeline" data-linenumber="326"><td class="num" id="LN326">326</td><td class="line"> <span class='comment'>*   +--------+</span></td></tr>
<tr class="codeline" data-linenumber="327"><td class="num" id="LN327">327</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="328"><td class="num" id="LN328">328</td><td class="line"> <span class='comment'>* Now we can mask it with b+1 to clear the old bits, and bitwise-OR</span></td></tr>
<tr class="codeline" data-linenumber="329"><td class="num" id="LN329">329</td><td class="line"> <span class='comment'>* with "val" left-shifted by "rs" bits to set the new value.</span></td></tr>
<tr class="codeline" data-linenumber="330"><td class="num" id="LN330">330</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="331"><td class="num" id="LN331">331</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="332"><td class="num" id="LN332">332</td><td class="line"><span class='comment'>/* Note: if we access the last counter, we will also access the b+1 byte</span></td></tr>
<tr class="codeline" data-linenumber="333"><td class="num" id="LN333">333</td><td class="line"> <span class='comment'>* that is out of the array, but sds strings always have an implicit null</span></td></tr>
<tr class="codeline" data-linenumber="334"><td class="num" id="LN334">334</td><td class="line"> <span class='comment'>* term, so the byte exists, and we can skip the conditional (or the need</span></td></tr>
<tr class="codeline" data-linenumber="335"><td class="num" id="LN335">335</td><td class="line"> <span class='comment'>* to allocate 1 byte more explicitly). */</span></td></tr>
<tr class="codeline" data-linenumber="336"><td class="num" id="LN336">336</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="337"><td class="num" id="LN337">337</td><td class="line"><span class='comment'>/* Store the value of the register at position 'regnum' into variable 'target'.</span></td></tr>
<tr class="codeline" data-linenumber="338"><td class="num" id="LN338">338</td><td class="line"> <span class='comment'>* 'p' is an array of unsigned bytes. */</span></td></tr>
<tr class="codeline" data-linenumber="339"><td class="num" id="LN339">339</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_DENSE_GET_REGISTER(target,p,regnum)<span class='macro_popup'>do { uint8_t *_p = (uint8_t*) p; unsigned long _byte = regnum<br>*6/8; unsigned long _fb = regnum*6&amp;7; unsigned long _fb8 =<br> 8 - _fb; unsigned long b0 = _p[_byte]; unsigned long b1 = _p<br>[_byte+1]; target = ((b0 &gt;&gt; _fb) | (b1 &lt;&lt; _fb8)) &amp;<br> ((1&lt;&lt;6)-1); } while(0)</span></span> do { \</span></td></tr>
<tr class="codeline" data-linenumber="340"><td class="num" id="LN340">340</td><td class="line">    <span class='directive'>uint8_t *_p = (uint8_t*) p; \</span></td></tr>
<tr class="codeline" data-linenumber="341"><td class="num" id="LN341">341</td><td class="line">    <span class='directive'>unsigned long _byte = regnum*<span class='macro'>HLL_BITS<span class='macro_popup'>6</span></span>/8; \</span></td></tr>
<tr class="codeline" data-linenumber="342"><td class="num" id="LN342">342</td><td class="line">    <span class='directive'>unsigned long _fb = regnum*<span class='macro'>HLL_BITS<span class='macro_popup'>6</span></span>&amp;7; \</span></td></tr>
<tr class="codeline" data-linenumber="343"><td class="num" id="LN343">343</td><td class="line">    <span class='directive'>unsigned long _fb8 = 8 - _fb; \</span></td></tr>
<tr class="codeline" data-linenumber="344"><td class="num" id="LN344">344</td><td class="line">    <span class='directive'>unsigned long b0 = _p[_byte]; \</span></td></tr>
<tr class="codeline" data-linenumber="345"><td class="num" id="LN345">345</td><td class="line">    <span class='directive'>unsigned long b1 = _p[_byte+1]; \</span></td></tr>
<tr class="codeline" data-linenumber="346"><td class="num" id="LN346">346</td><td class="line">    <span class='directive'>target = ((b0 &gt;&gt; _fb) | (b1 &lt;&lt; _fb8)) &amp; <span class='macro'>HLL_REGISTER_MAX<span class='macro_popup'>((1&lt;&lt;6)-1)</span></span>; \</span></td></tr>
<tr class="codeline" data-linenumber="347"><td class="num" id="LN347">347</td><td class="line"><span class='directive'>} while(0)</span></td></tr>
<tr class="codeline" data-linenumber="348"><td class="num" id="LN348">348</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="349"><td class="num" id="LN349">349</td><td class="line"><span class='comment'>/* Set the value of the register at position 'regnum' to 'val'.</span></td></tr>
<tr class="codeline" data-linenumber="350"><td class="num" id="LN350">350</td><td class="line"> <span class='comment'>* 'p' is an array of unsigned bytes. */</span></td></tr>
<tr class="codeline" data-linenumber="351"><td class="num" id="LN351">351</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_DENSE_SET_REGISTER(p,regnum,val)<span class='macro_popup'>do { uint8_t *_p = (uint8_t*) p; unsigned long _byte = regnum<br>*6/8; unsigned long _fb = regnum*6&amp;7; unsigned long _fb8 =<br> 8 - _fb; unsigned long _v = val; _p[_byte] &amp;= ~(((1&lt;&lt;<br>6)-1) &lt;&lt; _fb); _p[_byte] |= _v &lt;&lt; _fb; _p[_byte+1<br>] &amp;= ~(((1&lt;&lt;6)-1) &gt;&gt; _fb8); _p[_byte+1] |= _v<br> &gt;&gt; _fb8; } while(0)</span></span> do { \</span></td></tr>
<tr class="codeline" data-linenumber="352"><td class="num" id="LN352">352</td><td class="line">    <span class='directive'>uint8_t *_p = (uint8_t*) p; \</span></td></tr>
<tr class="codeline" data-linenumber="353"><td class="num" id="LN353">353</td><td class="line">    <span class='directive'>unsigned long _byte = regnum*<span class='macro'>HLL_BITS<span class='macro_popup'>6</span></span>/8; \</span></td></tr>
<tr class="codeline" data-linenumber="354"><td class="num" id="LN354">354</td><td class="line">    <span class='directive'>unsigned long _fb = regnum*<span class='macro'>HLL_BITS<span class='macro_popup'>6</span></span>&amp;7; \</span></td></tr>
<tr class="codeline" data-linenumber="355"><td class="num" id="LN355">355</td><td class="line">    <span class='directive'>unsigned long _fb8 = 8 - _fb; \</span></td></tr>
<tr class="codeline" data-linenumber="356"><td class="num" id="LN356">356</td><td class="line">    <span class='directive'>unsigned long _v = val; \</span></td></tr>
<tr class="codeline" data-linenumber="357"><td class="num" id="LN357">357</td><td class="line">    <span class='directive'>_p[_byte] &amp;= ~(<span class='macro'>HLL_REGISTER_MAX<span class='macro_popup'>((1&lt;&lt;6)-1)</span></span> &lt;&lt; _fb); \</span></td></tr>
<tr class="codeline" data-linenumber="358"><td class="num" id="LN358">358</td><td class="line">    <span class='directive'>_p[_byte] |= _v &lt;&lt; _fb; \</span></td></tr>
<tr class="codeline" data-linenumber="359"><td class="num" id="LN359">359</td><td class="line">    <span class='directive'>_p[_byte+1] &amp;= ~(<span class='macro'>HLL_REGISTER_MAX<span class='macro_popup'>((1&lt;&lt;6)-1)</span></span> &gt;&gt; _fb8); \</span></td></tr>
<tr class="codeline" data-linenumber="360"><td class="num" id="LN360">360</td><td class="line">    <span class='directive'>_p[_byte+1] |= _v &gt;&gt; _fb8; \</span></td></tr>
<tr class="codeline" data-linenumber="361"><td class="num" id="LN361">361</td><td class="line"><span class='directive'>} while(0)</span></td></tr>
<tr class="codeline" data-linenumber="362"><td class="num" id="LN362">362</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="363"><td class="num" id="LN363">363</td><td class="line"><span class='comment'>/* Macros to access the sparse representation.</span></td></tr>
<tr class="codeline" data-linenumber="364"><td class="num" id="LN364">364</td><td class="line"> <span class='comment'>* The macros parameter is expected to be an uint8_t pointer. */</span></td></tr>
<tr class="codeline" data-linenumber="365"><td class="num" id="LN365">365</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_SPARSE_XZERO_BIT<span class='macro_popup'>0x40</span></span> 0x40 /* 01xxxxxx */</span></td></tr>
<tr class="codeline" data-linenumber="366"><td class="num" id="LN366">366</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_SPARSE_VAL_BIT<span class='macro_popup'>0x80</span></span> 0x80 /* 1vvvvvxx */</span></td></tr>
<tr class="codeline" data-linenumber="367"><td class="num" id="LN367">367</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_SPARSE_IS_ZERO(p)<span class='macro_popup'>(((*(p)) &amp; 0xc0) == 0)</span></span> (((*(p)) &amp; 0xc0) == 0) /* 00xxxxxx */</span></td></tr>
<tr class="codeline" data-linenumber="368"><td class="num" id="LN368">368</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_SPARSE_IS_XZERO(p)<span class='macro_popup'>(((*(p)) &amp; 0xc0) == 0x40)</span></span> (((*(p)) &amp; 0xc0) == <span class='macro'>HLL_SPARSE_XZERO_BIT<span class='macro_popup'>0x40</span></span>)</span></td></tr>
<tr class="codeline" data-linenumber="369"><td class="num" id="LN369">369</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_SPARSE_IS_VAL(p)<span class='macro_popup'>((*(p)) &amp; 0x80)</span></span> ((*(p)) &amp; <span class='macro'>HLL_SPARSE_VAL_BIT<span class='macro_popup'>0x80</span></span>)</span></td></tr>
<tr class="codeline" data-linenumber="370"><td class="num" id="LN370">370</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_SPARSE_ZERO_LEN(p)<span class='macro_popup'>(((*(p)) &amp; 0x3f)+1)</span></span> (((*(p)) &amp; 0x3f)+1)</span></td></tr>
<tr class="codeline" data-linenumber="371"><td class="num" id="LN371">371</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_SPARSE_XZERO_LEN(p)<span class='macro_popup'>(((((*(p)) &amp; 0x3f) &lt;&lt; 8) | (*((p)+1)))+1)</span></span> (((((*(p)) &amp; 0x3f) &lt;&lt; 8) | (*((p)+1)))+1)</span></td></tr>
<tr class="codeline" data-linenumber="372"><td class="num" id="LN372">372</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_SPARSE_VAL_VALUE(p)<span class='macro_popup'>((((*(p)) &gt;&gt; 2) &amp; 0x1f)+1)</span></span> ((((*(p)) &gt;&gt; 2) &amp; 0x1f)+1)</span></td></tr>
<tr class="codeline" data-linenumber="373"><td class="num" id="LN373">373</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_SPARSE_VAL_LEN(p)<span class='macro_popup'>(((*(p)) &amp; 0x3)+1)</span></span> (((*(p)) &amp; 0x3)+1)</span></td></tr>
<tr class="codeline" data-linenumber="374"><td class="num" id="LN374">374</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_SPARSE_VAL_MAX_VALUE<span class='macro_popup'>32</span></span> 32</span></td></tr>
<tr class="codeline" data-linenumber="375"><td class="num" id="LN375">375</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_SPARSE_VAL_MAX_LEN<span class='macro_popup'>4</span></span> 4</span></td></tr>
<tr class="codeline" data-linenumber="376"><td class="num" id="LN376">376</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_SPARSE_ZERO_MAX_LEN<span class='macro_popup'>64</span></span> 64</span></td></tr>
<tr class="codeline" data-linenumber="377"><td class="num" id="LN377">377</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_SPARSE_XZERO_MAX_LEN<span class='macro_popup'>16384</span></span> 16384</span></td></tr>
<tr class="codeline" data-linenumber="378"><td class="num" id="LN378">378</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_SPARSE_VAL_SET(p,val,len)<span class='macro_popup'>do { *(p) = (((val)-1)&lt;&lt;2|((len)-1))|0x80; } while(0)</span></span> do { \</span></td></tr>
<tr class="codeline" data-linenumber="379"><td class="num" id="LN379">379</td><td class="line">    <span class='directive'>*(p) = (((val)-1)&lt;&lt;2|((len)-1))|<span class='macro'>HLL_SPARSE_VAL_BIT<span class='macro_popup'>0x80</span></span>; \</span></td></tr>
<tr class="codeline" data-linenumber="380"><td class="num" id="LN380">380</td><td class="line"><span class='directive'>} while(0)</span></td></tr>
<tr class="codeline" data-linenumber="381"><td class="num" id="LN381">381</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_SPARSE_ZERO_SET(p,len)<span class='macro_popup'>do { *(p) = (len)-1; } while(0)</span></span> do { \</span></td></tr>
<tr class="codeline" data-linenumber="382"><td class="num" id="LN382">382</td><td class="line">    <span class='directive'>*(p) = (len)-1; \</span></td></tr>
<tr class="codeline" data-linenumber="383"><td class="num" id="LN383">383</td><td class="line"><span class='directive'>} while(0)</span></td></tr>
<tr class="codeline" data-linenumber="384"><td class="num" id="LN384">384</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_SPARSE_XZERO_SET(p,len)<span class='macro_popup'>do { int _l = (len)-1; *(p) = (_l&gt;&gt;8) | 0x40; *((p)+1) =<br> (_l&amp;0xff); } while(0)</span></span> do { \</span></td></tr>
<tr class="codeline" data-linenumber="385"><td class="num" id="LN385">385</td><td class="line">    <span class='directive'>int _l = (len)-1; \</span></td></tr>
<tr class="codeline" data-linenumber="386"><td class="num" id="LN386">386</td><td class="line">    <span class='directive'>*(p) = (_l&gt;&gt;8) | <span class='macro'>HLL_SPARSE_XZERO_BIT<span class='macro_popup'>0x40</span></span>; \</span></td></tr>
<tr class="codeline" data-linenumber="387"><td class="num" id="LN387">387</td><td class="line">    <span class='directive'>*((p)+1) = (_l&amp;0xff); \</span></td></tr>
<tr class="codeline" data-linenumber="388"><td class="num" id="LN388">388</td><td class="line"><span class='directive'>} while(0)</span></td></tr>
<tr class="codeline" data-linenumber="389"><td class="num" id="LN389">389</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_ALPHA_INF<span class='macro_popup'>0.721347520444481703680</span></span> 0.721347520444481703680 /* constant for 0.5/ln(2) */</span></td></tr>
<tr class="codeline" data-linenumber="390"><td class="num" id="LN390">390</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="391"><td class="num" id="LN391">391</td><td class="line"><span class='comment'>/* ========================= HyperLogLog algorithm  ========================= */</span></td></tr>
<tr class="codeline" data-linenumber="392"><td class="num" id="LN392">392</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="393"><td class="num" id="LN393">393</td><td class="line"><span class='comment'>/* Our hash function is MurmurHash2, 64 bit version.</span></td></tr>
<tr class="codeline" data-linenumber="394"><td class="num" id="LN394">394</td><td class="line"> <span class='comment'>* It was modified for Redis in order to provide the same result in</span></td></tr>
<tr class="codeline" data-linenumber="395"><td class="num" id="LN395">395</td><td class="line"> <span class='comment'>* big and little endian archs (endian neutral). */</span></td></tr>
<tr class="codeline" data-linenumber="396"><td class="num" id="LN396">396</td><td class="line">uint64_t MurmurHash64A (<span class='keyword'>const</span> <span class='keyword'>void</span> * key, <span class='keyword'>int</span> len, <span class='keyword'>unsigned</span> <span class='keyword'>int</span> seed) {</td></tr>
<tr class="codeline" data-linenumber="397"><td class="num" id="LN397">397</td><td class="line">    <span class='keyword'>const</span> uint64_t m = 0xc6a4a7935bd1e995;</td></tr>
<tr class="codeline" data-linenumber="398"><td class="num" id="LN398">398</td><td class="line">    <span class='keyword'>const</span> <span class='keyword'>int</span> r = 47;</td></tr>
<tr class="codeline" data-linenumber="399"><td class="num" id="LN399">399</td><td class="line">    uint64_t h = seed ^ (len * m);</td></tr>
<tr class="codeline" data-linenumber="400"><td class="num" id="LN400">400</td><td class="line">    <span class='keyword'>const</span> uint8_t *data = (<span class='keyword'>const</span> uint8_t *)key;</td></tr>
<tr class="codeline" data-linenumber="401"><td class="num" id="LN401">401</td><td class="line">    <span class='keyword'>const</span> uint8_t *end = data + (len-(len&amp;7));</td></tr>
<tr class="codeline" data-linenumber="402"><td class="num" id="LN402">402</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="403"><td class="num" id="LN403">403</td><td class="line">    <span class='keyword'>while</span>(data != end) {</td></tr>
<tr class="codeline" data-linenumber="404"><td class="num" id="LN404">404</td><td class="line">        uint64_t k;</td></tr>
<tr class="codeline" data-linenumber="405"><td class="num" id="LN405">405</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="406"><td class="num" id="LN406">406</td><td class="line"><span class='directive'>#if (<span class='macro'>BYTE_ORDER<span class='macro_popup'>1234</span></span> == <span class='macro'>LITTLE_ENDIAN<span class='macro_popup'>1234</span></span>)</span></td></tr>
<tr class="codeline" data-linenumber="407"><td class="num" id="LN407">407</td><td class="line">    <span class='directive'>#ifdef USE_ALIGNED_ACCESS</span></td></tr>
<tr class="codeline" data-linenumber="408"><td class="num" id="LN408">408</td><td class="line">        memcpy(&amp;k,data,<span class='keyword'>sizeof</span>(uint64_t));</td></tr>
<tr class="codeline" data-linenumber="409"><td class="num" id="LN409">409</td><td class="line">    <span class='directive'>#else</span></td></tr>
<tr class="codeline" data-linenumber="410"><td class="num" id="LN410">410</td><td class="line">        k = *((uint64_t*)data);</td></tr>
<tr class="codeline" data-linenumber="411"><td class="num" id="LN411">411</td><td class="line">    <span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="412"><td class="num" id="LN412">412</td><td class="line"><span class='directive'>#else</span></td></tr>
<tr class="codeline" data-linenumber="413"><td class="num" id="LN413">413</td><td class="line">        k = (uint64_t) data[0];</td></tr>
<tr class="codeline" data-linenumber="414"><td class="num" id="LN414">414</td><td class="line">        k |= (uint64_t) data[1] &lt;&lt; 8;</td></tr>
<tr class="codeline" data-linenumber="415"><td class="num" id="LN415">415</td><td class="line">        k |= (uint64_t) data[2] &lt;&lt; 16;</td></tr>
<tr class="codeline" data-linenumber="416"><td class="num" id="LN416">416</td><td class="line">        k |= (uint64_t) data[3] &lt;&lt; 24;</td></tr>
<tr class="codeline" data-linenumber="417"><td class="num" id="LN417">417</td><td class="line">        k |= (uint64_t) data[4] &lt;&lt; 32;</td></tr>
<tr class="codeline" data-linenumber="418"><td class="num" id="LN418">418</td><td class="line">        k |= (uint64_t) data[5] &lt;&lt; 40;</td></tr>
<tr class="codeline" data-linenumber="419"><td class="num" id="LN419">419</td><td class="line">        k |= (uint64_t) data[6] &lt;&lt; 48;</td></tr>
<tr class="codeline" data-linenumber="420"><td class="num" id="LN420">420</td><td class="line">        k |= (uint64_t) data[7] &lt;&lt; 56;</td></tr>
<tr class="codeline" data-linenumber="421"><td class="num" id="LN421">421</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="422"><td class="num" id="LN422">422</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="423"><td class="num" id="LN423">423</td><td class="line">        k *= m;</td></tr>
<tr class="codeline" data-linenumber="424"><td class="num" id="LN424">424</td><td class="line">        k ^= k &gt;&gt; r;</td></tr>
<tr class="codeline" data-linenumber="425"><td class="num" id="LN425">425</td><td class="line">        k *= m;</td></tr>
<tr class="codeline" data-linenumber="426"><td class="num" id="LN426">426</td><td class="line">        h ^= k;</td></tr>
<tr class="codeline" data-linenumber="427"><td class="num" id="LN427">427</td><td class="line">        h *= m;</td></tr>
<tr class="codeline" data-linenumber="428"><td class="num" id="LN428">428</td><td class="line">        data += 8;</td></tr>
<tr class="codeline" data-linenumber="429"><td class="num" id="LN429">429</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="430"><td class="num" id="LN430">430</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="431"><td class="num" id="LN431">431</td><td class="line">    <span class='keyword'>switch</span>(len &amp; 7) {</td></tr>
<tr class="codeline" data-linenumber="432"><td class="num" id="LN432">432</td><td class="line">    <span class='keyword'>case</span> 7: h ^= (uint64_t)data[6] &lt;&lt; 48; <span class='comment'>/* fall-thru */</span></td></tr>
<tr class="codeline" data-linenumber="433"><td class="num" id="LN433">433</td><td class="line">    <span class='keyword'>case</span> 6: h ^= (uint64_t)data[5] &lt;&lt; 40; <span class='comment'>/* fall-thru */</span></td></tr>
<tr class="codeline" data-linenumber="434"><td class="num" id="LN434">434</td><td class="line">    <span class='keyword'>case</span> 5: h ^= (uint64_t)data[4] &lt;&lt; 32; <span class='comment'>/* fall-thru */</span></td></tr>
<tr class="codeline" data-linenumber="435"><td class="num" id="LN435">435</td><td class="line">    <span class='keyword'>case</span> 4: h ^= (uint64_t)data[3] &lt;&lt; 24; <span class='comment'>/* fall-thru */</span></td></tr>
<tr class="codeline" data-linenumber="436"><td class="num" id="LN436">436</td><td class="line">    <span class='keyword'>case</span> 3: h ^= (uint64_t)data[2] &lt;&lt; 16; <span class='comment'>/* fall-thru */</span></td></tr>
<tr class="codeline" data-linenumber="437"><td class="num" id="LN437">437</td><td class="line">    <span class='keyword'>case</span> 2: h ^= (uint64_t)data[1] &lt;&lt; 8; <span class='comment'>/* fall-thru */</span></td></tr>
<tr class="codeline" data-linenumber="438"><td class="num" id="LN438">438</td><td class="line">    <span class='keyword'>case</span> 1: h ^= (uint64_t)data[0];</td></tr>
<tr class="codeline" data-linenumber="439"><td class="num" id="LN439">439</td><td class="line">            h *= m; <span class='comment'>/* fall-thru */</span></td></tr>
<tr class="codeline" data-linenumber="440"><td class="num" id="LN440">440</td><td class="line">    };</td></tr>
<tr class="codeline" data-linenumber="441"><td class="num" id="LN441">441</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="442"><td class="num" id="LN442">442</td><td class="line">    h ^= h &gt;&gt; r;</td></tr>
<tr class="codeline" data-linenumber="443"><td class="num" id="LN443">443</td><td class="line">    h *= m;</td></tr>
<tr class="codeline" data-linenumber="444"><td class="num" id="LN444">444</td><td class="line">    h ^= h &gt;&gt; r;</td></tr>
<tr class="codeline" data-linenumber="445"><td class="num" id="LN445">445</td><td class="line">    <span class='keyword'>return</span> h;</td></tr>
<tr class="codeline" data-linenumber="446"><td class="num" id="LN446">446</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="447"><td class="num" id="LN447">447</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="448"><td class="num" id="LN448">448</td><td class="line"><span class='comment'>/* Given a string element to add to the HyperLogLog, returns the length</span></td></tr>
<tr class="codeline" data-linenumber="449"><td class="num" id="LN449">449</td><td class="line"> <span class='comment'>* of the pattern 000..1 of the element hash. As a side effect 'regp' is</span></td></tr>
<tr class="codeline" data-linenumber="450"><td class="num" id="LN450">450</td><td class="line"> <span class='comment'>* set to the register index this element hashes to. */</span></td></tr>
<tr class="codeline" data-linenumber="451"><td class="num" id="LN451">451</td><td class="line"><span class='keyword'>int</span> hllPatLen(<span class='keyword'>unsigned</span> <span class='keyword'>char</span> *ele, size_t elesize, <span class='keyword'>long</span> *regp) {</td></tr>
<tr class="codeline" data-linenumber="452"><td class="num" id="LN452">452</td><td class="line">    uint64_t hash, bit, index;</td></tr>
<tr class="codeline" data-linenumber="453"><td class="num" id="LN453">453</td><td class="line">    <span class='keyword'>int</span> count;</td></tr>
<tr class="codeline" data-linenumber="454"><td class="num" id="LN454">454</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="455"><td class="num" id="LN455">455</td><td class="line">    <span class='comment'>/* Count the number of zeroes starting from bit HLL_REGISTERS</span></td></tr>
<tr class="codeline" data-linenumber="456"><td class="num" id="LN456">456</td><td class="line">     <span class='comment'>* (that is a power of two corresponding to the first bit we don't use</span></td></tr>
<tr class="codeline" data-linenumber="457"><td class="num" id="LN457">457</td><td class="line">     <span class='comment'>* as index). The max run can be 64-P+1 = Q+1 bits.</span></td></tr>
<tr class="codeline" data-linenumber="458"><td class="num" id="LN458">458</td><td class="line">     <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="459"><td class="num" id="LN459">459</td><td class="line">     <span class='comment'>* Note that the final "1" ending the sequence of zeroes must be</span></td></tr>
<tr class="codeline" data-linenumber="460"><td class="num" id="LN460">460</td><td class="line">     <span class='comment'>* included in the count, so if we find "001" the count is 3, and</span></td></tr>
<tr class="codeline" data-linenumber="461"><td class="num" id="LN461">461</td><td class="line">     <span class='comment'>* the smallest count possible is no zeroes at all, just a 1 bit</span></td></tr>
<tr class="codeline" data-linenumber="462"><td class="num" id="LN462">462</td><td class="line">     <span class='comment'>* at the first position, that is a count of 1.</span></td></tr>
<tr class="codeline" data-linenumber="463"><td class="num" id="LN463">463</td><td class="line">     <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="464"><td class="num" id="LN464">464</td><td class="line">     <span class='comment'>* This may sound like inefficient, but actually in the average case</span></td></tr>
<tr class="codeline" data-linenumber="465"><td class="num" id="LN465">465</td><td class="line">     <span class='comment'>* there are high probabilities to find a 1 after a few iterations. */</span></td></tr>
<tr class="codeline" data-linenumber="466"><td class="num" id="LN466">466</td><td class="line">    hash = MurmurHash64A(ele,elesize,0xadc83b19ULL);</td></tr>
<tr class="codeline" data-linenumber="467"><td class="num" id="LN467">467</td><td class="line">    index = hash &amp; <span class='macro'>HLL_P_MASK<span class='macro_popup'>((1&lt;&lt;14)-1)</span></span>; <span class='comment'>/* Register index. */</span></td></tr>
<tr class="codeline" data-linenumber="468"><td class="num" id="LN468">468</td><td class="line">    hash &gt;&gt;= <span class='macro'>HLL_P<span class='macro_popup'>14</span></span>; <span class='comment'>/* Remove bits used to address the register. */</span></td></tr>
<tr class="codeline" data-linenumber="469"><td class="num" id="LN469">469</td><td class="line">    hash |= ((uint64_t)1&lt;&lt;<span class='macro'>HLL_Q<span class='macro_popup'>(64-14)</span></span>); <span class='comment'>/* Make sure the loop terminates</span></td></tr>
<tr class="codeline" data-linenumber="470"><td class="num" id="LN470">470</td><td class="line">                                     <span class='comment'>and count will be &lt;= Q+1. */</span></td></tr>
<tr class="codeline" data-linenumber="471"><td class="num" id="LN471">471</td><td class="line">    bit = 1;</td></tr>
<tr class="codeline" data-linenumber="472"><td class="num" id="LN472">472</td><td class="line">    count = 1; <span class='comment'>/* Initialized to 1 since we count the "00000...1" pattern. */</span></td></tr>
<tr class="codeline" data-linenumber="473"><td class="num" id="LN473">473</td><td class="line">    <span class='keyword'>while</span>((hash &amp; bit) == 0) {</td></tr>
<tr class="codeline" data-linenumber="474"><td class="num" id="LN474">474</td><td class="line">        count++;</td></tr>
<tr class="codeline" data-linenumber="475"><td class="num" id="LN475">475</td><td class="line">        bit &lt;&lt;= 1;</td></tr>
<tr class="codeline" data-linenumber="476"><td class="num" id="LN476">476</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="477"><td class="num" id="LN477">477</td><td class="line">    *regp = (<span class='keyword'>int</span>) index;</td></tr>
<tr class="codeline" data-linenumber="478"><td class="num" id="LN478">478</td><td class="line">    <span class='keyword'>return</span> count;</td></tr>
<tr class="codeline" data-linenumber="479"><td class="num" id="LN479">479</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="480"><td class="num" id="LN480">480</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="481"><td class="num" id="LN481">481</td><td class="line"><span class='comment'>/* ================== Dense representation implementation  ================== */</span></td></tr>
<tr class="codeline" data-linenumber="482"><td class="num" id="LN482">482</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="483"><td class="num" id="LN483">483</td><td class="line"><span class='comment'>/* Low level function to set the dense HLL register at 'index' to the</span></td></tr>
<tr class="codeline" data-linenumber="484"><td class="num" id="LN484">484</td><td class="line"> <span class='comment'>* specified value if the current value is smaller than 'count'.</span></td></tr>
<tr class="codeline" data-linenumber="485"><td class="num" id="LN485">485</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="486"><td class="num" id="LN486">486</td><td class="line"> <span class='comment'>* 'registers' is expected to have room for HLL_REGISTERS plus an</span></td></tr>
<tr class="codeline" data-linenumber="487"><td class="num" id="LN487">487</td><td class="line"> <span class='comment'>* additional byte on the right. This requirement is met by sds strings</span></td></tr>
<tr class="codeline" data-linenumber="488"><td class="num" id="LN488">488</td><td class="line"> <span class='comment'>* automatically since they are implicitly null terminated.</span></td></tr>
<tr class="codeline" data-linenumber="489"><td class="num" id="LN489">489</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="490"><td class="num" id="LN490">490</td><td class="line"> <span class='comment'>* The function always succeed, however if as a result of the operation</span></td></tr>
<tr class="codeline" data-linenumber="491"><td class="num" id="LN491">491</td><td class="line"> <span class='comment'>* the approximated cardinality changed, 1 is returned. Otherwise 0</span></td></tr>
<tr class="codeline" data-linenumber="492"><td class="num" id="LN492">492</td><td class="line"> <span class='comment'>* is returned. */</span></td></tr>
<tr class="codeline" data-linenumber="493"><td class="num" id="LN493">493</td><td class="line"><span class='keyword'>int</span> hllDenseSet(uint8_t *registers, <span class='keyword'>long</span> index, uint8_t count) {</td></tr>
<tr class="codeline" data-linenumber="494"><td class="num" id="LN494">494</td><td class="line">    uint8_t oldcount;</td></tr>
<tr class="codeline" data-linenumber="495"><td class="num" id="LN495">495</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="496"><td class="num" id="LN496">496</td><td class="line">    <span class='macro'>HLL_DENSE_GET_REGISTER(oldcount,registers,index)<span class='macro_popup'>do { uint8_t *_p = (uint8_t*) registers; unsigned long _byte =<br> index*6/8; unsigned long _fb = index*6&amp;7; unsigned long _fb8<br> = 8 - _fb; unsigned long b0 = _p[_byte]; unsigned long b1 = _p<br>[_byte+1]; oldcount = ((b0 &gt;&gt; _fb) | (b1 &lt;&lt; _fb8)<br>) &amp; ((1&lt;&lt;6)-1); } while(0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="497"><td class="num" id="LN497">497</td><td class="line">    <span class='keyword'>if</span> (count &gt; oldcount) {</td></tr>
<tr class="codeline" data-linenumber="498"><td class="num" id="LN498">498</td><td class="line">        <span class='macro'>HLL_DENSE_SET_REGISTER(registers,index,count)<span class='macro_popup'>do { uint8_t *_p = (uint8_t*) registers; unsigned long _byte =<br> index*6/8; unsigned long _fb = index*6&amp;7; unsigned long _fb8<br> = 8 - _fb; unsigned long _v = count; _p[_byte] &amp;= ~(((1&lt;&lt;<br>6)-1) &lt;&lt; _fb); _p[_byte] |= _v &lt;&lt; _fb; _p[_byte+1<br>] &amp;= ~(((1&lt;&lt;6)-1) &gt;&gt; _fb8); _p[_byte+1] |= _v<br> &gt;&gt; _fb8; } while(0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="499"><td class="num" id="LN499">499</td><td class="line">        <span class='keyword'>return</span> 1;</td></tr>
<tr class="codeline" data-linenumber="500"><td class="num" id="LN500">500</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="501"><td class="num" id="LN501">501</td><td class="line">        <span class='keyword'>return</span> 0;</td></tr>
<tr class="codeline" data-linenumber="502"><td class="num" id="LN502">502</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="503"><td class="num" id="LN503">503</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="504"><td class="num" id="LN504">504</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="505"><td class="num" id="LN505">505</td><td class="line"><span class='comment'>/* "Add" the element in the dense hyperloglog data structure.</span></td></tr>
<tr class="codeline" data-linenumber="506"><td class="num" id="LN506">506</td><td class="line"> <span class='comment'>* Actually nothing is added, but the max 0 pattern counter of the subset</span></td></tr>
<tr class="codeline" data-linenumber="507"><td class="num" id="LN507">507</td><td class="line"> <span class='comment'>* the element belongs to is incremented if needed.</span></td></tr>
<tr class="codeline" data-linenumber="508"><td class="num" id="LN508">508</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="509"><td class="num" id="LN509">509</td><td class="line"> <span class='comment'>* This is just a wrapper to hllDenseSet(), performing the hashing of the</span></td></tr>
<tr class="codeline" data-linenumber="510"><td class="num" id="LN510">510</td><td class="line"> <span class='comment'>* element in order to retrieve the index and zero-run count. */</span></td></tr>
<tr class="codeline" data-linenumber="511"><td class="num" id="LN511">511</td><td class="line"><span class='keyword'>int</span> hllDenseAdd(uint8_t *registers, <span class='keyword'>unsigned</span> <span class='keyword'>char</span> *ele, size_t elesize) {</td></tr>
<tr class="codeline" data-linenumber="512"><td class="num" id="LN512">512</td><td class="line">    <span class='keyword'>long</span> index;</td></tr>
<tr class="codeline" data-linenumber="513"><td class="num" id="LN513">513</td><td class="line">    uint8_t count = hllPatLen(ele,elesize,&amp;index);</td></tr>
<tr class="codeline" data-linenumber="514"><td class="num" id="LN514">514</td><td class="line">    <span class='comment'>/* Update the register if this element produced a longer run of zeroes. */</span></td></tr>
<tr class="codeline" data-linenumber="515"><td class="num" id="LN515">515</td><td class="line">    <span class='keyword'>return</span> hllDenseSet(registers,index,count);</td></tr>
<tr class="codeline" data-linenumber="516"><td class="num" id="LN516">516</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="517"><td class="num" id="LN517">517</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="518"><td class="num" id="LN518">518</td><td class="line"><span class='comment'>/* Compute the register histogram in the dense representation. */</span></td></tr>
<tr class="codeline" data-linenumber="519"><td class="num" id="LN519">519</td><td class="line"><span class='keyword'>void</span> hllDenseRegHisto(uint8_t *registers, <span class='keyword'>int</span>* reghisto) {</td></tr>
<tr class="codeline" data-linenumber="520"><td class="num" id="LN520">520</td><td class="line">    <span class='keyword'>int</span> j;</td></tr>
<tr class="codeline" data-linenumber="521"><td class="num" id="LN521">521</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="522"><td class="num" id="LN522">522</td><td class="line">    <span class='comment'>/* Redis default is to use 16384 registers 6 bits each. The code works</span></td></tr>
<tr class="codeline" data-linenumber="523"><td class="num" id="LN523">523</td><td class="line">     <span class='comment'>* with other values by modifying the defines, but for our target value</span></td></tr>
<tr class="codeline" data-linenumber="524"><td class="num" id="LN524">524</td><td class="line">     <span class='comment'>* we take a faster path with unrolled loops. */</span></td></tr>
<tr class="codeline" data-linenumber="525"><td class="num" id="LN525">525</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>HLL_REGISTERS<span class='macro_popup'>(1&lt;&lt;14)</span></span> == 16384 &amp;&amp; <span class='macro'>HLL_BITS<span class='macro_popup'>6</span></span> == 6) {</td></tr>
<tr class="codeline" data-linenumber="526"><td class="num" id="LN526">526</td><td class="line">        uint8_t *r = registers;</td></tr>
<tr class="codeline" data-linenumber="527"><td class="num" id="LN527">527</td><td class="line">        <span class='keyword'>unsigned</span> <span class='keyword'>long</span> r0, r1, r2, r3, r4, r5, r6, r7, r8, r9,</td></tr>
<tr class="codeline" data-linenumber="528"><td class="num" id="LN528">528</td><td class="line">                      r10, r11, r12, r13, r14, r15;</td></tr>
<tr class="codeline" data-linenumber="529"><td class="num" id="LN529">529</td><td class="line">        <span class='keyword'>for</span> (j = 0; j &lt; 1024; j++) {</td></tr>
<tr class="codeline" data-linenumber="530"><td class="num" id="LN530">530</td><td class="line">            <span class='comment'>/* Handle 16 registers per iteration. */</span></td></tr>
<tr class="codeline" data-linenumber="531"><td class="num" id="LN531">531</td><td class="line">            r0 = r[0] &amp; 63;</td></tr>
<tr class="codeline" data-linenumber="532"><td class="num" id="LN532">532</td><td class="line">            r1 = (r[0] &gt;&gt; 6 | r[1] &lt;&lt; 2) &amp; 63;</td></tr>
<tr class="codeline" data-linenumber="533"><td class="num" id="LN533">533</td><td class="line">            r2 = (r[1] &gt;&gt; 4 | r[2] &lt;&lt; 4) &amp; 63;</td></tr>
<tr class="codeline" data-linenumber="534"><td class="num" id="LN534">534</td><td class="line">            r3 = (r[2] &gt;&gt; 2) &amp; 63;</td></tr>
<tr class="codeline" data-linenumber="535"><td class="num" id="LN535">535</td><td class="line">            r4 = r[3] &amp; 63;</td></tr>
<tr class="codeline" data-linenumber="536"><td class="num" id="LN536">536</td><td class="line">            r5 = (r[3] &gt;&gt; 6 | r[4] &lt;&lt; 2) &amp; 63;</td></tr>
<tr class="codeline" data-linenumber="537"><td class="num" id="LN537">537</td><td class="line">            r6 = (r[4] &gt;&gt; 4 | r[5] &lt;&lt; 4) &amp; 63;</td></tr>
<tr class="codeline" data-linenumber="538"><td class="num" id="LN538">538</td><td class="line">            r7 = (r[5] &gt;&gt; 2) &amp; 63;</td></tr>
<tr class="codeline" data-linenumber="539"><td class="num" id="LN539">539</td><td class="line">            r8 = r[6] &amp; 63;</td></tr>
<tr class="codeline" data-linenumber="540"><td class="num" id="LN540">540</td><td class="line">            r9 = (r[6] &gt;&gt; 6 | r[7] &lt;&lt; 2) &amp; 63;</td></tr>
<tr class="codeline" data-linenumber="541"><td class="num" id="LN541">541</td><td class="line">            r10 = (r[7] &gt;&gt; 4 | r[8] &lt;&lt; 4) &amp; 63;</td></tr>
<tr class="codeline" data-linenumber="542"><td class="num" id="LN542">542</td><td class="line">            r11 = (r[8] &gt;&gt; 2) &amp; 63;</td></tr>
<tr class="codeline" data-linenumber="543"><td class="num" id="LN543">543</td><td class="line">            r12 = r[9] &amp; 63;</td></tr>
<tr class="codeline" data-linenumber="544"><td class="num" id="LN544">544</td><td class="line">            r13 = (r[9] &gt;&gt; 6 | r[10] &lt;&lt; 2) &amp; 63;</td></tr>
<tr class="codeline" data-linenumber="545"><td class="num" id="LN545">545</td><td class="line">            r14 = (r[10] &gt;&gt; 4 | r[11] &lt;&lt; 4) &amp; 63;</td></tr>
<tr class="codeline" data-linenumber="546"><td class="num" id="LN546">546</td><td class="line">            r15 = (r[11] &gt;&gt; 2) &amp; 63;</td></tr>
<tr class="codeline" data-linenumber="547"><td class="num" id="LN547">547</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="548"><td class="num" id="LN548">548</td><td class="line">            reghisto[r0]++;</td></tr>
<tr class="codeline" data-linenumber="549"><td class="num" id="LN549">549</td><td class="line">            reghisto[r1]++;</td></tr>
<tr class="codeline" data-linenumber="550"><td class="num" id="LN550">550</td><td class="line">            reghisto[r2]++;</td></tr>
<tr class="codeline" data-linenumber="551"><td class="num" id="LN551">551</td><td class="line">            reghisto[r3]++;</td></tr>
<tr class="codeline" data-linenumber="552"><td class="num" id="LN552">552</td><td class="line">            reghisto[r4]++;</td></tr>
<tr class="codeline" data-linenumber="553"><td class="num" id="LN553">553</td><td class="line">            reghisto[r5]++;</td></tr>
<tr class="codeline" data-linenumber="554"><td class="num" id="LN554">554</td><td class="line">            reghisto[r6]++;</td></tr>
<tr class="codeline" data-linenumber="555"><td class="num" id="LN555">555</td><td class="line">            reghisto[r7]++;</td></tr>
<tr class="codeline" data-linenumber="556"><td class="num" id="LN556">556</td><td class="line">            reghisto[r8]++;</td></tr>
<tr class="codeline" data-linenumber="557"><td class="num" id="LN557">557</td><td class="line">            reghisto[r9]++;</td></tr>
<tr class="codeline" data-linenumber="558"><td class="num" id="LN558">558</td><td class="line">            reghisto[r10]++;</td></tr>
<tr class="codeline" data-linenumber="559"><td class="num" id="LN559">559</td><td class="line">            reghisto[r11]++;</td></tr>
<tr class="codeline" data-linenumber="560"><td class="num" id="LN560">560</td><td class="line">            reghisto[r12]++;</td></tr>
<tr class="codeline" data-linenumber="561"><td class="num" id="LN561">561</td><td class="line">            reghisto[r13]++;</td></tr>
<tr class="codeline" data-linenumber="562"><td class="num" id="LN562">562</td><td class="line">            reghisto[r14]++;</td></tr>
<tr class="codeline" data-linenumber="563"><td class="num" id="LN563">563</td><td class="line">            reghisto[r15]++;</td></tr>
<tr class="codeline" data-linenumber="564"><td class="num" id="LN564">564</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="565"><td class="num" id="LN565">565</td><td class="line">            r += 12;</td></tr>
<tr class="codeline" data-linenumber="566"><td class="num" id="LN566">566</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="567"><td class="num" id="LN567">567</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="568"><td class="num" id="LN568">568</td><td class="line">        <span class='keyword'>for</span>(j = 0; j &lt; <span class='macro'>HLL_REGISTERS<span class='macro_popup'>(1&lt;&lt;14)</span></span>; j++) {</td></tr>
<tr class="codeline" data-linenumber="569"><td class="num" id="LN569">569</td><td class="line">            <span class='keyword'>unsigned</span> <span class='keyword'>long</span> reg;</td></tr>
<tr class="codeline" data-linenumber="570"><td class="num" id="LN570">570</td><td class="line">            <span class='macro'>HLL_DENSE_GET_REGISTER(reg,registers,j)<span class='macro_popup'>do { uint8_t *_p = (uint8_t*) registers; unsigned long _byte =<br> j*6/8; unsigned long _fb = j*6&amp;7; unsigned long _fb8 = 8<br> - _fb; unsigned long b0 = _p[_byte]; unsigned long b1 = _p[_byte<br>+1]; reg = ((b0 &gt;&gt; _fb) | (b1 &lt;&lt; _fb8)) &amp; ((1<br>&lt;&lt;6)-1); } while(0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="571"><td class="num" id="LN571">571</td><td class="line">            reghisto[reg]++;</td></tr>
<tr class="codeline" data-linenumber="572"><td class="num" id="LN572">572</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="573"><td class="num" id="LN573">573</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="574"><td class="num" id="LN574">574</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="575"><td class="num" id="LN575">575</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="576"><td class="num" id="LN576">576</td><td class="line"><span class='comment'>/* ================== Sparse representation implementation  ================= */</span></td></tr>
<tr class="codeline" data-linenumber="577"><td class="num" id="LN577">577</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="578"><td class="num" id="LN578">578</td><td class="line"><span class='comment'>/* Convert the HLL with sparse representation given as input in its dense</span></td></tr>
<tr class="codeline" data-linenumber="579"><td class="num" id="LN579">579</td><td class="line"> <span class='comment'>* representation. Both representations are represented by SDS strings, and</span></td></tr>
<tr class="codeline" data-linenumber="580"><td class="num" id="LN580">580</td><td class="line"> <span class='comment'>* the input representation is freed as a side effect.</span></td></tr>
<tr class="codeline" data-linenumber="581"><td class="num" id="LN581">581</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="582"><td class="num" id="LN582">582</td><td class="line"> <span class='comment'>* The function returns C_OK if the sparse representation was valid,</span></td></tr>
<tr class="codeline" data-linenumber="583"><td class="num" id="LN583">583</td><td class="line"> <span class='comment'>* otherwise C_ERR is returned if the representation was corrupted. */</span></td></tr>
<tr class="codeline" data-linenumber="584"><td class="num" id="LN584">584</td><td class="line"><span class='keyword'>int</span> hllSparseToDense(robj *o) {</td></tr>
<tr class="codeline" data-linenumber="585"><td class="num" id="LN585">585</td><td class="line">    sds sparse = o-&gt;ptr, dense;</td></tr>
<tr class="codeline" data-linenumber="586"><td class="num" id="LN586">586</td><td class="line">    <span class='keyword'>struct</span> hllhdr *hdr, *oldhdr = (<span class='keyword'>struct</span> hllhdr*)sparse;</td></tr>
<tr class="codeline" data-linenumber="587"><td class="num" id="LN587">587</td><td class="line">    <span class='keyword'>int</span> idx = 0, runlen, regval;</td></tr>
<tr class="codeline" data-linenumber="588"><td class="num" id="LN588">588</td><td class="line">    uint8_t *p = (uint8_t*)sparse, *end = p+sdslen(sparse);</td></tr>
<tr class="codeline" data-linenumber="589"><td class="num" id="LN589">589</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="590"><td class="num" id="LN590">590</td><td class="line">    <span class='comment'>/* If the representation is already the right one return ASAP. */</span></td></tr>
<tr class="codeline" data-linenumber="591"><td class="num" id="LN591">591</td><td class="line">    hdr = (<span class='keyword'>struct</span> hllhdr*) sparse;</td></tr>
<tr class="codeline" data-linenumber="592"><td class="num" id="LN592">592</td><td class="line">    <span class='keyword'>if</span> (hdr-&gt;encoding == <span class='macro'>HLL_DENSE<span class='macro_popup'>0</span></span>) <span class='keyword'>return</span> <span class='macro'>C_OK<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="593"><td class="num" id="LN593">593</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="594"><td class="num" id="LN594">594</td><td class="line">    <span class='comment'>/* Create a string of the right size filled with zero bytes.</span></td></tr>
<tr class="codeline" data-linenumber="595"><td class="num" id="LN595">595</td><td class="line">     <span class='comment'>* Note that the cached cardinality is set to 0 as a side effect</span></td></tr>
<tr class="codeline" data-linenumber="596"><td class="num" id="LN596">596</td><td class="line">     <span class='comment'>* that is exactly the cardinality of an empty HLL. */</span></td></tr>
<tr class="codeline" data-linenumber="597"><td class="num" id="LN597">597</td><td class="line">    dense = sdsnewlen(<span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>,<span class='macro'>HLL_DENSE_SIZE<span class='macro_popup'>(sizeof(struct hllhdr)+(((1&lt;&lt;14)*6 +7)/8))</span></span>);</td></tr>
<tr class="codeline" data-linenumber="598"><td class="num" id="LN598">598</td><td class="line">    hdr = (<span class='keyword'>struct</span> hllhdr*) dense;</td></tr>
<tr class="codeline" data-linenumber="599"><td class="num" id="LN599">599</td><td class="line">    *hdr = *oldhdr; <span class='comment'>/* This will copy the magic and cached cardinality. */</span></td></tr>
<tr class="codeline" data-linenumber="600"><td class="num" id="LN600">600</td><td class="line">    hdr-&gt;encoding = <span class='macro'>HLL_DENSE<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="601"><td class="num" id="LN601">601</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="602"><td class="num" id="LN602">602</td><td class="line">    <span class='comment'>/* Now read the sparse representation and set non-zero registers</span></td></tr>
<tr class="codeline" data-linenumber="603"><td class="num" id="LN603">603</td><td class="line">     <span class='comment'>* accordingly. */</span></td></tr>
<tr class="codeline" data-linenumber="604"><td class="num" id="LN604">604</td><td class="line">    p += <span class='macro'>HLL_HDR_SIZE<span class='macro_popup'>sizeof(struct hllhdr)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="605"><td class="num" id="LN605">605</td><td class="line">    <span class='keyword'>while</span>(p &lt; end) {</td></tr>
<tr class="codeline" data-linenumber="606"><td class="num" id="LN606">606</td><td class="line">        <span class='keyword'>if</span> (<span class='macro'>HLL_SPARSE_IS_ZERO(p)<span class='macro_popup'>(((*(p)) &amp; 0xc0) == 0)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="607"><td class="num" id="LN607">607</td><td class="line">            runlen = <span class='macro'>HLL_SPARSE_ZERO_LEN(p)<span class='macro_popup'>(((*(p)) &amp; 0x3f)+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="608"><td class="num" id="LN608">608</td><td class="line">            idx += runlen;</td></tr>
<tr class="codeline" data-linenumber="609"><td class="num" id="LN609">609</td><td class="line">            p++;</td></tr>
<tr class="codeline" data-linenumber="610"><td class="num" id="LN610">610</td><td class="line">        } <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>HLL_SPARSE_IS_XZERO(p)<span class='macro_popup'>(((*(p)) &amp; 0xc0) == 0x40)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="611"><td class="num" id="LN611">611</td><td class="line">            runlen = <span class='macro'>HLL_SPARSE_XZERO_LEN(p)<span class='macro_popup'>(((((*(p)) &amp; 0x3f) &lt;&lt; 8) | (*((p)+1)))+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="612"><td class="num" id="LN612">612</td><td class="line">            idx += runlen;</td></tr>
<tr class="codeline" data-linenumber="613"><td class="num" id="LN613">613</td><td class="line">            p += 2;</td></tr>
<tr class="codeline" data-linenumber="614"><td class="num" id="LN614">614</td><td class="line">        } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="615"><td class="num" id="LN615">615</td><td class="line">            runlen = <span class='macro'>HLL_SPARSE_VAL_LEN(p)<span class='macro_popup'>(((*(p)) &amp; 0x3)+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="616"><td class="num" id="LN616">616</td><td class="line">            regval = <span class='macro'>HLL_SPARSE_VAL_VALUE(p)<span class='macro_popup'>((((*(p)) &gt;&gt; 2) &amp; 0x1f)+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="617"><td class="num" id="LN617">617</td><td class="line">            <span class='keyword'>if</span> ((runlen + idx) &gt; <span class='macro'>HLL_REGISTERS<span class='macro_popup'>(1&lt;&lt;14)</span></span>) <span class='keyword'>break</span>; <span class='comment'>/* Overflow. */</span></td></tr>
<tr class="codeline" data-linenumber="618"><td class="num" id="LN618">618</td><td class="line">            <span class='keyword'>while</span>(runlen--) {</td></tr>
<tr class="codeline" data-linenumber="619"><td class="num" id="LN619">619</td><td class="line">                <span class='macro'>HLL_DENSE_SET_REGISTER(hdr-&gt;registers,idx,regval)<span class='macro_popup'>do { uint8_t *_p = (uint8_t*) hdr-&gt;registers; unsigned long<br> _byte = idx*6/8; unsigned long _fb = idx*6&amp;7; unsigned long<br> _fb8 = 8 - _fb; unsigned long _v = regval; _p[_byte] &amp;= ~<br>(((1&lt;&lt;6)-1) &lt;&lt; _fb); _p[_byte] |= _v &lt;&lt; _fb<br>; _p[_byte+1] &amp;= ~(((1&lt;&lt;6)-1) &gt;&gt; _fb8); _p[_byte<br>+1] |= _v &gt;&gt; _fb8; } while(0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="620"><td class="num" id="LN620">620</td><td class="line">                idx++;</td></tr>
<tr class="codeline" data-linenumber="621"><td class="num" id="LN621">621</td><td class="line">            }</td></tr>
<tr class="codeline" data-linenumber="622"><td class="num" id="LN622">622</td><td class="line">            p++;</td></tr>
<tr class="codeline" data-linenumber="623"><td class="num" id="LN623">623</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="624"><td class="num" id="LN624">624</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="625"><td class="num" id="LN625">625</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="626"><td class="num" id="LN626">626</td><td class="line">    <span class='comment'>/* If the sparse representation was valid, we expect to find idx</span></td></tr>
<tr class="codeline" data-linenumber="627"><td class="num" id="LN627">627</td><td class="line">     <span class='comment'>* set to HLL_REGISTERS. */</span></td></tr>
<tr class="codeline" data-linenumber="628"><td class="num" id="LN628">628</td><td class="line">    <span class='keyword'>if</span> (idx != <span class='macro'>HLL_REGISTERS<span class='macro_popup'>(1&lt;&lt;14)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="629"><td class="num" id="LN629">629</td><td class="line">        sdsfree(dense);</td></tr>
<tr class="codeline" data-linenumber="630"><td class="num" id="LN630">630</td><td class="line">        <span class='keyword'>return</span> <span class='macro'>C_ERR<span class='macro_popup'>-1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="631"><td class="num" id="LN631">631</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="632"><td class="num" id="LN632">632</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="633"><td class="num" id="LN633">633</td><td class="line">    <span class='comment'>/* Free the old representation and set the new one. */</span></td></tr>
<tr class="codeline" data-linenumber="634"><td class="num" id="LN634">634</td><td class="line">    sdsfree(o-&gt;ptr);</td></tr>
<tr class="codeline" data-linenumber="635"><td class="num" id="LN635">635</td><td class="line">    o-&gt;ptr = dense;</td></tr>
<tr class="codeline" data-linenumber="636"><td class="num" id="LN636">636</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>C_OK<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="637"><td class="num" id="LN637">637</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="638"><td class="num" id="LN638">638</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="639"><td class="num" id="LN639">639</td><td class="line"><span class='comment'>/* Low level function to set the sparse HLL register at 'index' to the</span></td></tr>
<tr class="codeline" data-linenumber="640"><td class="num" id="LN640">640</td><td class="line"> <span class='comment'>* specified value if the current value is smaller than 'count'.</span></td></tr>
<tr class="codeline" data-linenumber="641"><td class="num" id="LN641">641</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="642"><td class="num" id="LN642">642</td><td class="line"> <span class='comment'>* The object 'o' is the String object holding the HLL. The function requires</span></td></tr>
<tr class="codeline" data-linenumber="643"><td class="num" id="LN643">643</td><td class="line"> <span class='comment'>* a reference to the object in order to be able to enlarge the string if</span></td></tr>
<tr class="codeline" data-linenumber="644"><td class="num" id="LN644">644</td><td class="line"> <span class='comment'>* needed.</span></td></tr>
<tr class="codeline" data-linenumber="645"><td class="num" id="LN645">645</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="646"><td class="num" id="LN646">646</td><td class="line"> <span class='comment'>* On success, the function returns 1 if the cardinality changed, or 0</span></td></tr>
<tr class="codeline" data-linenumber="647"><td class="num" id="LN647">647</td><td class="line"> <span class='comment'>* if the register for this element was not updated.</span></td></tr>
<tr class="codeline" data-linenumber="648"><td class="num" id="LN648">648</td><td class="line"> <span class='comment'>* On error (if the representation is invalid) -1 is returned.</span></td></tr>
<tr class="codeline" data-linenumber="649"><td class="num" id="LN649">649</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="650"><td class="num" id="LN650">650</td><td class="line"> <span class='comment'>* As a side effect the function may promote the HLL representation from</span></td></tr>
<tr class="codeline" data-linenumber="651"><td class="num" id="LN651">651</td><td class="line"> <span class='comment'>* sparse to dense: this happens when a register requires to be set to a value</span></td></tr>
<tr class="codeline" data-linenumber="652"><td class="num" id="LN652">652</td><td class="line"> <span class='comment'>* not representable with the sparse representation, or when the resulting</span></td></tr>
<tr class="codeline" data-linenumber="653"><td class="num" id="LN653">653</td><td class="line"> <span class='comment'>* size would be greater than server.hll_sparse_max_bytes. */</span></td></tr>
<tr class="codeline" data-linenumber="654"><td class="num" id="LN654">654</td><td class="line"><span class='keyword'>int</span> hllSparseSet(robj *o, <span class='keyword'>long</span> index, uint8_t count) {</td></tr>
<tr class="codeline" data-linenumber="655"><td class="num" id="LN655">655</td><td class="line">    <span class='keyword'>struct</span> hllhdr *hdr;</td></tr>
<tr class="codeline" data-linenumber="656"><td class="num" id="LN656">656</td><td class="line">    uint8_t oldcount, *sparse, *end, *p, *prev, *next;</td></tr>
<tr class="codeline" data-linenumber="657"><td class="num" id="LN657">657</td><td class="line">    <span class='keyword'>long</span> first, span;</td></tr>
<tr class="codeline" data-linenumber="658"><td class="num" id="LN658">658</td><td class="line">    <span class='keyword'>long</span> is_zero = 0, is_xzero = 0, is_val = 0, runlen = 0;</td></tr>
<tr class="codeline" data-linenumber="659"><td class="num" id="LN659">659</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="660"><td class="num" id="LN660">660</td><td class="line">    <span class='comment'>/* If the count is too big to be representable by the sparse representation</span></td></tr>
<tr class="codeline" data-linenumber="661"><td class="num" id="LN661">661</td><td class="line">     <span class='comment'>* switch to dense representation. */</span></td></tr>
<tr class="codeline" data-linenumber="662"><td class="num" id="LN662">662</td><td class="line">    <span class='keyword'>if</span> (count &gt; <span class='macro'>HLL_SPARSE_VAL_MAX_VALUE<span class='macro_popup'>32</span></span>) <span class='keyword'>goto</span> promote;</td></tr>
<tr class="codeline" data-linenumber="663"><td class="num" id="LN663">663</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="664"><td class="num" id="LN664">664</td><td class="line">    <span class='comment'>/* When updating a sparse representation, sometimes we may need to</span></td></tr>
<tr class="codeline" data-linenumber="665"><td class="num" id="LN665">665</td><td class="line">     <span class='comment'>* enlarge the buffer for up to 3 bytes in the worst case (XZERO split</span></td></tr>
<tr class="codeline" data-linenumber="666"><td class="num" id="LN666">666</td><td class="line">     <span class='comment'>* into XZERO-VAL-XZERO). Make sure there is enough space right now</span></td></tr>
<tr class="codeline" data-linenumber="667"><td class="num" id="LN667">667</td><td class="line">     <span class='comment'>* so that the pointers we take during the execution of the function</span></td></tr>
<tr class="codeline" data-linenumber="668"><td class="num" id="LN668">668</td><td class="line">     <span class='comment'>* will be valid all the time. */</span></td></tr>
<tr class="codeline" data-linenumber="669"><td class="num" id="LN669">669</td><td class="line">    o-&gt;ptr = sdsMakeRoomFor(o-&gt;ptr,3);</td></tr>
<tr class="codeline" data-linenumber="670"><td class="num" id="LN670">670</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="671"><td class="num" id="LN671">671</td><td class="line">    <span class='comment'>/* Step 1: we need to locate the opcode we need to modify to check</span></td></tr>
<tr class="codeline" data-linenumber="672"><td class="num" id="LN672">672</td><td class="line">     <span class='comment'>* if a value update is actually needed. */</span></td></tr>
<tr class="codeline" data-linenumber="673"><td class="num" id="LN673">673</td><td class="line">    sparse = p = ((uint8_t*)o-&gt;ptr) + <span class='macro'>HLL_HDR_SIZE<span class='macro_popup'>sizeof(struct hllhdr)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="674"><td class="num" id="LN674">674</td><td class="line">    end = p + sdslen(o-&gt;ptr) - <span class='macro'>HLL_HDR_SIZE<span class='macro_popup'>sizeof(struct hllhdr)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="675"><td class="num" id="LN675">675</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="676"><td class="num" id="LN676">676</td><td class="line">    first = 0;</td></tr>
<tr class="codeline" data-linenumber="677"><td class="num" id="LN677">677</td><td class="line">    prev = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>; <span class='comment'>/* Points to previous opcode at the end of the loop. */</span></td></tr>
<tr class="codeline" data-linenumber="678"><td class="num" id="LN678">678</td><td class="line">    next = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>; <span class='comment'>/* Points to the next opcode at the end of the loop. */</span></td></tr>
<tr class="codeline" data-linenumber="679"><td class="num" id="LN679">679</td><td class="line">    span = 0;</td></tr>
<tr class="codeline" data-linenumber="680"><td class="num" id="LN680">680</td><td class="line">    <span class='keyword'>while</span>(p &lt; end) {</td></tr>
<tr class="codeline" data-linenumber="681"><td class="num" id="LN681">681</td><td class="line">        <span class='keyword'>long</span> oplen;</td></tr>
<tr class="codeline" data-linenumber="682"><td class="num" id="LN682">682</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="683"><td class="num" id="LN683">683</td><td class="line">        <span class='comment'>/* Set span to the number of registers covered by this opcode.</span></td></tr>
<tr class="codeline" data-linenumber="684"><td class="num" id="LN684">684</td><td class="line">         <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="685"><td class="num" id="LN685">685</td><td class="line">         <span class='comment'>* This is the most performance critical loop of the sparse</span></td></tr>
<tr class="codeline" data-linenumber="686"><td class="num" id="LN686">686</td><td class="line">         <span class='comment'>* representation. Sorting the conditionals from the most to the</span></td></tr>
<tr class="codeline" data-linenumber="687"><td class="num" id="LN687">687</td><td class="line">         <span class='comment'>* least frequent opcode in many-bytes sparse HLLs is faster. */</span></td></tr>
<tr class="codeline" data-linenumber="688"><td class="num" id="LN688">688</td><td class="line">        oplen = 1;</td></tr>
<tr class="codeline" data-linenumber="689"><td class="num" id="LN689">689</td><td class="line">        <span class='keyword'>if</span> (<span class='macro'>HLL_SPARSE_IS_ZERO(p)<span class='macro_popup'>(((*(p)) &amp; 0xc0) == 0)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="690"><td class="num" id="LN690">690</td><td class="line">            span = <span class='macro'>HLL_SPARSE_ZERO_LEN(p)<span class='macro_popup'>(((*(p)) &amp; 0x3f)+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="691"><td class="num" id="LN691">691</td><td class="line">        } <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>HLL_SPARSE_IS_VAL(p)<span class='macro_popup'>((*(p)) &amp; 0x80)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="692"><td class="num" id="LN692">692</td><td class="line">            span = <span class='macro'>HLL_SPARSE_VAL_LEN(p)<span class='macro_popup'>(((*(p)) &amp; 0x3)+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="693"><td class="num" id="LN693">693</td><td class="line">        } <span class='keyword'>else</span> { <span class='comment'>/* XZERO. */</span></td></tr>
<tr class="codeline" data-linenumber="694"><td class="num" id="LN694">694</td><td class="line">            span = <span class='macro'>HLL_SPARSE_XZERO_LEN(p)<span class='macro_popup'>(((((*(p)) &amp; 0x3f) &lt;&lt; 8) | (*((p)+1)))+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="695"><td class="num" id="LN695">695</td><td class="line">            oplen = 2;</td></tr>
<tr class="codeline" data-linenumber="696"><td class="num" id="LN696">696</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="697"><td class="num" id="LN697">697</td><td class="line">        <span class='comment'>/* Break if this opcode covers the register as 'index'. */</span></td></tr>
<tr class="codeline" data-linenumber="698"><td class="num" id="LN698">698</td><td class="line">        <span class='keyword'>if</span> (index &lt;= first+span-1) <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="699"><td class="num" id="LN699">699</td><td class="line">        prev = p;</td></tr>
<tr class="codeline" data-linenumber="700"><td class="num" id="LN700">700</td><td class="line">        p += oplen;</td></tr>
<tr class="codeline" data-linenumber="701"><td class="num" id="LN701">701</td><td class="line">        first += span;</td></tr>
<tr class="codeline" data-linenumber="702"><td class="num" id="LN702">702</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="703"><td class="num" id="LN703">703</td><td class="line">    <span class='keyword'>if</span> (span == 0 || p &gt;= end) <span class='keyword'>return</span> -1; <span class='comment'>/* Invalid format. */</span></td></tr>
<tr class="codeline" data-linenumber="704"><td class="num" id="LN704">704</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="705"><td class="num" id="LN705">705</td><td class="line">    next = <span class='macro'>HLL_SPARSE_IS_XZERO(p)<span class='macro_popup'>(((*(p)) &amp; 0xc0) == 0x40)</span></span> ? p+2 : p+1;</td></tr>
<tr class="codeline" data-linenumber="706"><td class="num" id="LN706">706</td><td class="line">    <span class='keyword'>if</span> (next &gt;= end) next = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="707"><td class="num" id="LN707">707</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="708"><td class="num" id="LN708">708</td><td class="line">    <span class='comment'>/* Cache current opcode type to avoid using the macro again and</span></td></tr>
<tr class="codeline" data-linenumber="709"><td class="num" id="LN709">709</td><td class="line">     <span class='comment'>* again for something that will not change.</span></td></tr>
<tr class="codeline" data-linenumber="710"><td class="num" id="LN710">710</td><td class="line">     <span class='comment'>* Also cache the run-length of the opcode. */</span></td></tr>
<tr class="codeline" data-linenumber="711"><td class="num" id="LN711">711</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>HLL_SPARSE_IS_ZERO(p)<span class='macro_popup'>(((*(p)) &amp; 0xc0) == 0)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="712"><td class="num" id="LN712">712</td><td class="line">        is_zero = 1;</td></tr>
<tr class="codeline" data-linenumber="713"><td class="num" id="LN713">713</td><td class="line">        runlen = <span class='macro'>HLL_SPARSE_ZERO_LEN(p)<span class='macro_popup'>(((*(p)) &amp; 0x3f)+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="714"><td class="num" id="LN714">714</td><td class="line">    } <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>HLL_SPARSE_IS_XZERO(p)<span class='macro_popup'>(((*(p)) &amp; 0xc0) == 0x40)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="715"><td class="num" id="LN715">715</td><td class="line">        is_xzero = 1;</td></tr>
<tr class="codeline" data-linenumber="716"><td class="num" id="LN716">716</td><td class="line">        runlen = <span class='macro'>HLL_SPARSE_XZERO_LEN(p)<span class='macro_popup'>(((((*(p)) &amp; 0x3f) &lt;&lt; 8) | (*((p)+1)))+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="717"><td class="num" id="LN717">717</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="718"><td class="num" id="LN718">718</td><td class="line">        is_val = 1;</td></tr>
<tr class="codeline" data-linenumber="719"><td class="num" id="LN719">719</td><td class="line">        runlen = <span class='macro'>HLL_SPARSE_VAL_LEN(p)<span class='macro_popup'>(((*(p)) &amp; 0x3)+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="720"><td class="num" id="LN720">720</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="721"><td class="num" id="LN721">721</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="722"><td class="num" id="LN722">722</td><td class="line">    <span class='comment'>/* Step 2: After the loop:</span></td></tr>
<tr class="codeline" data-linenumber="723"><td class="num" id="LN723">723</td><td class="line">     <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="724"><td class="num" id="LN724">724</td><td class="line">     <span class='comment'>* 'first' stores to the index of the first register covered</span></td></tr>
<tr class="codeline" data-linenumber="725"><td class="num" id="LN725">725</td><td class="line">     <span class='comment'>*  by the current opcode, which is pointed by 'p'.</span></td></tr>
<tr class="codeline" data-linenumber="726"><td class="num" id="LN726">726</td><td class="line">     <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="727"><td class="num" id="LN727">727</td><td class="line">     <span class='comment'>* 'next' ad 'prev' store respectively the next and previous opcode,</span></td></tr>
<tr class="codeline" data-linenumber="728"><td class="num" id="LN728">728</td><td class="line">     <span class='comment'>*  or NULL if the opcode at 'p' is respectively the last or first.</span></td></tr>
<tr class="codeline" data-linenumber="729"><td class="num" id="LN729">729</td><td class="line">     <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="730"><td class="num" id="LN730">730</td><td class="line">     <span class='comment'>* 'span' is set to the number of registers covered by the current</span></td></tr>
<tr class="codeline" data-linenumber="731"><td class="num" id="LN731">731</td><td class="line">     <span class='comment'>*  opcode.</span></td></tr>
<tr class="codeline" data-linenumber="732"><td class="num" id="LN732">732</td><td class="line">     <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="733"><td class="num" id="LN733">733</td><td class="line">     <span class='comment'>* There are different cases in order to update the data structure</span></td></tr>
<tr class="codeline" data-linenumber="734"><td class="num" id="LN734">734</td><td class="line">     <span class='comment'>* in place without generating it from scratch:</span></td></tr>
<tr class="codeline" data-linenumber="735"><td class="num" id="LN735">735</td><td class="line">     <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="736"><td class="num" id="LN736">736</td><td class="line">     <span class='comment'>* A) If it is a VAL opcode already set to a value &gt;= our 'count'</span></td></tr>
<tr class="codeline" data-linenumber="737"><td class="num" id="LN737">737</td><td class="line">     <span class='comment'>*    no update is needed, regardless of the VAL run-length field.</span></td></tr>
<tr class="codeline" data-linenumber="738"><td class="num" id="LN738">738</td><td class="line">     <span class='comment'>*    In this case PFADD returns 0 since no changes are performed.</span></td></tr>
<tr class="codeline" data-linenumber="739"><td class="num" id="LN739">739</td><td class="line">     <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="740"><td class="num" id="LN740">740</td><td class="line">     <span class='comment'>* B) If it is a VAL opcode with len = 1 (representing only our</span></td></tr>
<tr class="codeline" data-linenumber="741"><td class="num" id="LN741">741</td><td class="line">     <span class='comment'>*    register) and the value is less than 'count', we just update it</span></td></tr>
<tr class="codeline" data-linenumber="742"><td class="num" id="LN742">742</td><td class="line">     <span class='comment'>*    since this is a trivial case. */</span></td></tr>
<tr class="codeline" data-linenumber="743"><td class="num" id="LN743">743</td><td class="line">    <span class='keyword'>if</span> (is_val) {</td></tr>
<tr class="codeline" data-linenumber="744"><td class="num" id="LN744">744</td><td class="line">        oldcount = <span class='macro'>HLL_SPARSE_VAL_VALUE(p)<span class='macro_popup'>((((*(p)) &gt;&gt; 2) &amp; 0x1f)+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="745"><td class="num" id="LN745">745</td><td class="line">        <span class='comment'>/* Case A. */</span></td></tr>
<tr class="codeline" data-linenumber="746"><td class="num" id="LN746">746</td><td class="line">        <span class='keyword'>if</span> (oldcount &gt;= count) <span class='keyword'>return</span> 0;</td></tr>
<tr class="codeline" data-linenumber="747"><td class="num" id="LN747">747</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="748"><td class="num" id="LN748">748</td><td class="line">        <span class='comment'>/* Case B. */</span></td></tr>
<tr class="codeline" data-linenumber="749"><td class="num" id="LN749">749</td><td class="line">        <span class='keyword'>if</span> (runlen == 1) {</td></tr>
<tr class="codeline" data-linenumber="750"><td class="num" id="LN750">750</td><td class="line">            <span class='macro'>HLL_SPARSE_VAL_SET(p,count,1)<span class='macro_popup'>do { *(p) = (((count)-1)&lt;&lt;2|((1)-1))|0x80; } while(0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="751"><td class="num" id="LN751">751</td><td class="line">            <span class='keyword'>goto</span> updated;</td></tr>
<tr class="codeline" data-linenumber="752"><td class="num" id="LN752">752</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="753"><td class="num" id="LN753">753</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="754"><td class="num" id="LN754">754</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="755"><td class="num" id="LN755">755</td><td class="line">    <span class='comment'>/* C) Another trivial to handle case is a ZERO opcode with a len of 1.</span></td></tr>
<tr class="codeline" data-linenumber="756"><td class="num" id="LN756">756</td><td class="line">     <span class='comment'>* We can just replace it with a VAL opcode with our value and len of 1. */</span></td></tr>
<tr class="codeline" data-linenumber="757"><td class="num" id="LN757">757</td><td class="line">    <span class='keyword'>if</span> (is_zero &amp;&amp; runlen == 1) {</td></tr>
<tr class="codeline" data-linenumber="758"><td class="num" id="LN758">758</td><td class="line">        <span class='macro'>HLL_SPARSE_VAL_SET(p,count,1)<span class='macro_popup'>do { *(p) = (((count)-1)&lt;&lt;2|((1)-1))|0x80; } while(0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="759"><td class="num" id="LN759">759</td><td class="line">        <span class='keyword'>goto</span> updated;</td></tr>
<tr class="codeline" data-linenumber="760"><td class="num" id="LN760">760</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="761"><td class="num" id="LN761">761</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="762"><td class="num" id="LN762">762</td><td class="line">    <span class='comment'>/* D) General case.</span></td></tr>
<tr class="codeline" data-linenumber="763"><td class="num" id="LN763">763</td><td class="line">     <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="764"><td class="num" id="LN764">764</td><td class="line">     <span class='comment'>* The other cases are more complex: our register requires to be updated</span></td></tr>
<tr class="codeline" data-linenumber="765"><td class="num" id="LN765">765</td><td class="line">     <span class='comment'>* and is either currently represented by a VAL opcode with len &gt; 1,</span></td></tr>
<tr class="codeline" data-linenumber="766"><td class="num" id="LN766">766</td><td class="line">     <span class='comment'>* by a ZERO opcode with len &gt; 1, or by an XZERO opcode.</span></td></tr>
<tr class="codeline" data-linenumber="767"><td class="num" id="LN767">767</td><td class="line">     <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="768"><td class="num" id="LN768">768</td><td class="line">     <span class='comment'>* In those cases the original opcode must be split into multiple</span></td></tr>
<tr class="codeline" data-linenumber="769"><td class="num" id="LN769">769</td><td class="line">     <span class='comment'>* opcodes. The worst case is an XZERO split in the middle resulting into</span></td></tr>
<tr class="codeline" data-linenumber="770"><td class="num" id="LN770">770</td><td class="line">     <span class='comment'>* XZERO - VAL - XZERO, so the resulting sequence max length is</span></td></tr>
<tr class="codeline" data-linenumber="771"><td class="num" id="LN771">771</td><td class="line">     <span class='comment'>* 5 bytes.</span></td></tr>
<tr class="codeline" data-linenumber="772"><td class="num" id="LN772">772</td><td class="line">     <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="773"><td class="num" id="LN773">773</td><td class="line">     <span class='comment'>* We perform the split writing the new sequence into the 'new' buffer</span></td></tr>
<tr class="codeline" data-linenumber="774"><td class="num" id="LN774">774</td><td class="line">     <span class='comment'>* with 'newlen' as length. Later the new sequence is inserted in place</span></td></tr>
<tr class="codeline" data-linenumber="775"><td class="num" id="LN775">775</td><td class="line">     <span class='comment'>* of the old one, possibly moving what is on the right a few bytes</span></td></tr>
<tr class="codeline" data-linenumber="776"><td class="num" id="LN776">776</td><td class="line">     <span class='comment'>* if the new sequence is longer than the older one. */</span></td></tr>
<tr class="codeline" data-linenumber="777"><td class="num" id="LN777">777</td><td class="line">    uint8_t seq[5], *n = seq;</td></tr>
<tr class="codeline" data-linenumber="778"><td class="num" id="LN778">778</td><td class="line">    <span class='keyword'>int</span> last = first+span-1; <span class='comment'>/* Last register covered by the sequence. */</span></td></tr>
<tr class="codeline" data-linenumber="779"><td class="num" id="LN779">779</td><td class="line">    <span class='keyword'>int</span> len;</td></tr>
<tr class="codeline" data-linenumber="780"><td class="num" id="LN780">780</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="781"><td class="num" id="LN781">781</td><td class="line">    <span class='keyword'>if</span> (is_zero || is_xzero) {</td></tr>
<tr class="codeline" data-linenumber="782"><td class="num" id="LN782">782</td><td class="line">        <span class='comment'>/* Handle splitting of ZERO / XZERO. */</span></td></tr>
<tr class="codeline" data-linenumber="783"><td class="num" id="LN783">783</td><td class="line">        <span class='keyword'>if</span> (index != first) {</td></tr>
<tr class="codeline" data-linenumber="784"><td class="num" id="LN784">784</td><td class="line">            len = index-first;</td></tr>
<tr class="codeline" data-linenumber="785"><td class="num" id="LN785">785</td><td class="line">            <span class='keyword'>if</span> (len &gt; <span class='macro'>HLL_SPARSE_ZERO_MAX_LEN<span class='macro_popup'>64</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="786"><td class="num" id="LN786">786</td><td class="line">                <span class='macro'>HLL_SPARSE_XZERO_SET(n,len)<span class='macro_popup'>do { int _l = (len)-1; *(n) = (_l&gt;&gt;8) | 0x40; *((n)+1) =<br> (_l&amp;0xff); } while(0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="787"><td class="num" id="LN787">787</td><td class="line">                n += 2;</td></tr>
<tr class="codeline" data-linenumber="788"><td class="num" id="LN788">788</td><td class="line">            } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="789"><td class="num" id="LN789">789</td><td class="line">                <span class='macro'>HLL_SPARSE_ZERO_SET(n,len)<span class='macro_popup'>do { *(n) = (len)-1; } while(0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="790"><td class="num" id="LN790">790</td><td class="line">                n++;</td></tr>
<tr class="codeline" data-linenumber="791"><td class="num" id="LN791">791</td><td class="line">            }</td></tr>
<tr class="codeline" data-linenumber="792"><td class="num" id="LN792">792</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="793"><td class="num" id="LN793">793</td><td class="line">        <span class='macro'>HLL_SPARSE_VAL_SET(n,count,1)<span class='macro_popup'>do { *(n) = (((count)-1)&lt;&lt;2|((1)-1))|0x80; } while(0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="794"><td class="num" id="LN794">794</td><td class="line">        n++;</td></tr>
<tr class="codeline" data-linenumber="795"><td class="num" id="LN795">795</td><td class="line">        <span class='keyword'>if</span> (index != last) {</td></tr>
<tr class="codeline" data-linenumber="796"><td class="num" id="LN796">796</td><td class="line">            len = last-index;</td></tr>
<tr class="codeline" data-linenumber="797"><td class="num" id="LN797">797</td><td class="line">            <span class='keyword'>if</span> (len &gt; <span class='macro'>HLL_SPARSE_ZERO_MAX_LEN<span class='macro_popup'>64</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="798"><td class="num" id="LN798">798</td><td class="line">                <span class='macro'>HLL_SPARSE_XZERO_SET(n,len)<span class='macro_popup'>do { int _l = (len)-1; *(n) = (_l&gt;&gt;8) | 0x40; *((n)+1) =<br> (_l&amp;0xff); } while(0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="799"><td class="num" id="LN799">799</td><td class="line">                n += 2;</td></tr>
<tr class="codeline" data-linenumber="800"><td class="num" id="LN800">800</td><td class="line">            } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="801"><td class="num" id="LN801">801</td><td class="line">                <span class='macro'>HLL_SPARSE_ZERO_SET(n,len)<span class='macro_popup'>do { *(n) = (len)-1; } while(0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="802"><td class="num" id="LN802">802</td><td class="line">                n++;</td></tr>
<tr class="codeline" data-linenumber="803"><td class="num" id="LN803">803</td><td class="line">            }</td></tr>
<tr class="codeline" data-linenumber="804"><td class="num" id="LN804">804</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="805"><td class="num" id="LN805">805</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="806"><td class="num" id="LN806">806</td><td class="line">        <span class='comment'>/* Handle splitting of VAL. */</span></td></tr>
<tr class="codeline" data-linenumber="807"><td class="num" id="LN807">807</td><td class="line">        <span class='keyword'>int</span> curval = <span class='macro'>HLL_SPARSE_VAL_VALUE(p)<span class='macro_popup'>((((*(p)) &gt;&gt; 2) &amp; 0x1f)+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="808"><td class="num" id="LN808">808</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="809"><td class="num" id="LN809">809</td><td class="line">        <span class='keyword'>if</span> (index != first) {</td></tr>
<tr class="codeline" data-linenumber="810"><td class="num" id="LN810">810</td><td class="line">            len = index-first;</td></tr>
<tr class="codeline" data-linenumber="811"><td class="num" id="LN811">811</td><td class="line">            <span class='macro'>HLL_SPARSE_VAL_SET(n,curval,len)<span class='macro_popup'>do { *(n) = (((curval)-1)&lt;&lt;2|((len)-1))|0x80; } while(0<br>)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="812"><td class="num" id="LN812">812</td><td class="line">            n++;</td></tr>
<tr class="codeline" data-linenumber="813"><td class="num" id="LN813">813</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="814"><td class="num" id="LN814">814</td><td class="line">        <span class='macro'>HLL_SPARSE_VAL_SET(n,count,1)<span class='macro_popup'>do { *(n) = (((count)-1)&lt;&lt;2|((1)-1))|0x80; } while(0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="815"><td class="num" id="LN815">815</td><td class="line">        n++;</td></tr>
<tr class="codeline" data-linenumber="816"><td class="num" id="LN816">816</td><td class="line">        <span class='keyword'>if</span> (index != last) {</td></tr>
<tr class="codeline" data-linenumber="817"><td class="num" id="LN817">817</td><td class="line">            len = last-index;</td></tr>
<tr class="codeline" data-linenumber="818"><td class="num" id="LN818">818</td><td class="line">            <span class='macro'>HLL_SPARSE_VAL_SET(n,curval,len)<span class='macro_popup'>do { *(n) = (((curval)-1)&lt;&lt;2|((len)-1))|0x80; } while(0<br>)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="819"><td class="num" id="LN819">819</td><td class="line">            n++;</td></tr>
<tr class="codeline" data-linenumber="820"><td class="num" id="LN820">820</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="821"><td class="num" id="LN821">821</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="822"><td class="num" id="LN822">822</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="823"><td class="num" id="LN823">823</td><td class="line">    <span class='comment'>/* Step 3: substitute the new sequence with the old one.</span></td></tr>
<tr class="codeline" data-linenumber="824"><td class="num" id="LN824">824</td><td class="line">     <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="825"><td class="num" id="LN825">825</td><td class="line">     <span class='comment'>* Note that we already allocated space on the sds string</span></td></tr>
<tr class="codeline" data-linenumber="826"><td class="num" id="LN826">826</td><td class="line">     <span class='comment'>* calling sdsMakeRoomFor(). */</span></td></tr>
<tr class="codeline" data-linenumber="827"><td class="num" id="LN827">827</td><td class="line">     <span class='keyword'>int</span> seqlen = n-seq;</td></tr>
<tr class="codeline" data-linenumber="828"><td class="num" id="LN828">828</td><td class="line">     <span class='keyword'>int</span> oldlen = is_xzero ? 2 : 1;</td></tr>
<tr class="codeline" data-linenumber="829"><td class="num" id="LN829">829</td><td class="line">     <span class='keyword'>int</span> deltalen = seqlen-oldlen;</td></tr>
<tr class="codeline" data-linenumber="830"><td class="num" id="LN830">830</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="831"><td class="num" id="LN831">831</td><td class="line">     <span class='keyword'>if</span> (deltalen &gt; 0 &amp;&amp;</td></tr>
<tr class="codeline" data-linenumber="832"><td class="num" id="LN832">832</td><td class="line">         sdslen(o-&gt;ptr)+deltalen &gt; server.hll_sparse_max_bytes) <span class='keyword'>goto</span> promote;</td></tr>
<tr class="codeline" data-linenumber="833"><td class="num" id="LN833">833</td><td class="line">     <span class='keyword'>if</span> (deltalen &amp;&amp; next) memmove(next+deltalen,next,end-next);</td></tr>
<tr class="codeline" data-linenumber="834"><td class="num" id="LN834">834</td><td class="line">     sdsIncrLen(o-&gt;ptr,deltalen);</td></tr>
<tr class="codeline" data-linenumber="835"><td class="num" id="LN835">835</td><td class="line">     memcpy(p,seq,seqlen);</td></tr>
<tr class="codeline" data-linenumber="836"><td class="num" id="LN836">836</td><td class="line">     end += deltalen;</td></tr>
<tr class="codeline" data-linenumber="837"><td class="num" id="LN837">837</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="838"><td class="num" id="LN838">838</td><td class="line">updated:</td></tr>
<tr class="codeline" data-linenumber="839"><td class="num" id="LN839">839</td><td class="line">    <span class='comment'>/* Step 4: Merge adjacent values if possible.</span></td></tr>
<tr class="codeline" data-linenumber="840"><td class="num" id="LN840">840</td><td class="line">     <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="841"><td class="num" id="LN841">841</td><td class="line">     <span class='comment'>* The representation was updated, however the resulting representation</span></td></tr>
<tr class="codeline" data-linenumber="842"><td class="num" id="LN842">842</td><td class="line">     <span class='comment'>* may not be optimal: adjacent VAL opcodes can sometimes be merged into</span></td></tr>
<tr class="codeline" data-linenumber="843"><td class="num" id="LN843">843</td><td class="line">     <span class='comment'>* a single one. */</span></td></tr>
<tr class="codeline" data-linenumber="844"><td class="num" id="LN844">844</td><td class="line">    p = prev ? prev : sparse;</td></tr>
<tr class="codeline" data-linenumber="845"><td class="num" id="LN845">845</td><td class="line">    <span class='keyword'>int</span> scanlen = 5; <span class='comment'>/* Scan up to 5 upcodes starting from prev. */</span></td></tr>
<tr class="codeline" data-linenumber="846"><td class="num" id="LN846">846</td><td class="line">    <span class='keyword'>while</span> (p &lt; end &amp;&amp; scanlen--) {</td></tr>
<tr class="codeline" data-linenumber="847"><td class="num" id="LN847">847</td><td class="line">        <span class='keyword'>if</span> (<span class='macro'>HLL_SPARSE_IS_XZERO(p)<span class='macro_popup'>(((*(p)) &amp; 0xc0) == 0x40)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="848"><td class="num" id="LN848">848</td><td class="line">            p += 2;</td></tr>
<tr class="codeline" data-linenumber="849"><td class="num" id="LN849">849</td><td class="line">            <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="850"><td class="num" id="LN850">850</td><td class="line">        } <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>HLL_SPARSE_IS_ZERO(p)<span class='macro_popup'>(((*(p)) &amp; 0xc0) == 0)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="851"><td class="num" id="LN851">851</td><td class="line">            p++;</td></tr>
<tr class="codeline" data-linenumber="852"><td class="num" id="LN852">852</td><td class="line">            <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="853"><td class="num" id="LN853">853</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="854"><td class="num" id="LN854">854</td><td class="line">        <span class='comment'>/* We need two adjacent VAL opcodes to try a merge, having</span></td></tr>
<tr class="codeline" data-linenumber="855"><td class="num" id="LN855">855</td><td class="line">         <span class='comment'>* the same value, and a len that fits the VAL opcode max len. */</span></td></tr>
<tr class="codeline" data-linenumber="856"><td class="num" id="LN856">856</td><td class="line">        <span class='keyword'>if</span> (p+1 &lt; end &amp;&amp; <span class='macro'>HLL_SPARSE_IS_VAL(p+1)<span class='macro_popup'>((*(p+1)) &amp; 0x80)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="857"><td class="num" id="LN857">857</td><td class="line">            <span class='keyword'>int</span> v1 = <span class='macro'>HLL_SPARSE_VAL_VALUE(p)<span class='macro_popup'>((((*(p)) &gt;&gt; 2) &amp; 0x1f)+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="858"><td class="num" id="LN858">858</td><td class="line">            <span class='keyword'>int</span> v2 = <span class='macro'>HLL_SPARSE_VAL_VALUE(p+1)<span class='macro_popup'>((((*(p+1)) &gt;&gt; 2) &amp; 0x1f)+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="859"><td class="num" id="LN859">859</td><td class="line">            <span class='keyword'>if</span> (v1 == v2) {</td></tr>
<tr class="codeline" data-linenumber="860"><td class="num" id="LN860">860</td><td class="line">                <span class='keyword'>int</span> len = <span class='macro'>HLL_SPARSE_VAL_LEN(p)<span class='macro_popup'>(((*(p)) &amp; 0x3)+1)</span></span>+<span class='macro'>HLL_SPARSE_VAL_LEN(p+1)<span class='macro_popup'>(((*(p+1)) &amp; 0x3)+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="861"><td class="num" id="LN861">861</td><td class="line">                <span class='keyword'>if</span> (len &lt;= <span class='macro'>HLL_SPARSE_VAL_MAX_LEN<span class='macro_popup'>4</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="862"><td class="num" id="LN862">862</td><td class="line">                    <span class='macro'>HLL_SPARSE_VAL_SET(p+1,v1,len)<span class='macro_popup'>do { *(p+1) = (((v1)-1)&lt;&lt;2|((len)-1))|0x80; } while(0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="863"><td class="num" id="LN863">863</td><td class="line">                    memmove(p,p+1,end-p);</td></tr>
<tr class="codeline" data-linenumber="864"><td class="num" id="LN864">864</td><td class="line">                    sdsIncrLen(o-&gt;ptr,-1);</td></tr>
<tr class="codeline" data-linenumber="865"><td class="num" id="LN865">865</td><td class="line">                    end--;</td></tr>
<tr class="codeline" data-linenumber="866"><td class="num" id="LN866">866</td><td class="line">                    <span class='comment'>/* After a merge we reiterate without incrementing 'p'</span></td></tr>
<tr class="codeline" data-linenumber="867"><td class="num" id="LN867">867</td><td class="line">                     <span class='comment'>* in order to try to merge the just merged value with</span></td></tr>
<tr class="codeline" data-linenumber="868"><td class="num" id="LN868">868</td><td class="line">                     <span class='comment'>* a value on its right. */</span></td></tr>
<tr class="codeline" data-linenumber="869"><td class="num" id="LN869">869</td><td class="line">                    <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="870"><td class="num" id="LN870">870</td><td class="line">                }</td></tr>
<tr class="codeline" data-linenumber="871"><td class="num" id="LN871">871</td><td class="line">            }</td></tr>
<tr class="codeline" data-linenumber="872"><td class="num" id="LN872">872</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="873"><td class="num" id="LN873">873</td><td class="line">        p++;</td></tr>
<tr class="codeline" data-linenumber="874"><td class="num" id="LN874">874</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="875"><td class="num" id="LN875">875</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="876"><td class="num" id="LN876">876</td><td class="line">    <span class='comment'>/* Invalidate the cached cardinality. */</span></td></tr>
<tr class="codeline" data-linenumber="877"><td class="num" id="LN877">877</td><td class="line">    hdr = o-&gt;ptr;</td></tr>
<tr class="codeline" data-linenumber="878"><td class="num" id="LN878">878</td><td class="line">    <span class='macro'>HLL_INVALIDATE_CACHE(hdr)<span class='macro_popup'>(hdr)-&gt;card[7] |= (1&lt;&lt;7)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="879"><td class="num" id="LN879">879</td><td class="line">    <span class='keyword'>return</span> 1;</td></tr>
<tr class="codeline" data-linenumber="880"><td class="num" id="LN880">880</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="881"><td class="num" id="LN881">881</td><td class="line">promote: <span class='comment'>/* Promote to dense representation. */</span></td></tr>
<tr class="codeline" data-linenumber="882"><td class="num" id="LN882">882</td><td class="line">    <span class='keyword'>if</span> (hllSparseToDense(o) == <span class='macro'>C_ERR<span class='macro_popup'>-1</span></span>) <span class='keyword'>return</span> -1; <span class='comment'>/* Corrupted HLL. */</span></td></tr>
<tr class="codeline" data-linenumber="883"><td class="num" id="LN883">883</td><td class="line">    hdr = o-&gt;ptr;</td></tr>
<tr class="codeline" data-linenumber="884"><td class="num" id="LN884">884</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="885"><td class="num" id="LN885">885</td><td class="line">    <span class='comment'>/* We need to call hllDenseAdd() to perform the operation after the</span></td></tr>
<tr class="codeline" data-linenumber="886"><td class="num" id="LN886">886</td><td class="line">     <span class='comment'>* conversion. However the result must be 1, since if we need to</span></td></tr>
<tr class="codeline" data-linenumber="887"><td class="num" id="LN887">887</td><td class="line">     <span class='comment'>* convert from sparse to dense a register requires to be updated.</span></td></tr>
<tr class="codeline" data-linenumber="888"><td class="num" id="LN888">888</td><td class="line">     <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="889"><td class="num" id="LN889">889</td><td class="line">     <span class='comment'>* Note that this in turn means that PFADD will make sure the command</span></td></tr>
<tr class="codeline" data-linenumber="890"><td class="num" id="LN890">890</td><td class="line">     <span class='comment'>* is propagated to slaves / AOF, so if there is a sparse -&gt; dense</span></td></tr>
<tr class="codeline" data-linenumber="891"><td class="num" id="LN891">891</td><td class="line">     <span class='comment'>* conversion, it will be performed in all the slaves as well. */</span></td></tr>
<tr class="codeline" data-linenumber="892"><td class="num" id="LN892">892</td><td class="line">    <span class='keyword'>int</span> dense_retval = hllDenseSet(hdr-&gt;registers,index,count);</td></tr>
<tr class="codeline" data-linenumber="893"><td class="num" id="LN893">893</td><td class="line">    <span class='macro'>serverAssert(dense_retval == 1)<span class='macro_popup'>((dense_retval == 1)?(void)0 : (_serverAssert("dense_retval == 1"<br>,"hyperloglog.c",893),_exit(1)))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="894"><td class="num" id="LN894">894</td><td class="line">    <span class='keyword'>return</span> dense_retval;</td></tr>
<tr class="codeline" data-linenumber="895"><td class="num" id="LN895">895</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="896"><td class="num" id="LN896">896</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="897"><td class="num" id="LN897">897</td><td class="line"><span class='comment'>/* "Add" the element in the sparse hyperloglog data structure.</span></td></tr>
<tr class="codeline" data-linenumber="898"><td class="num" id="LN898">898</td><td class="line"> <span class='comment'>* Actually nothing is added, but the max 0 pattern counter of the subset</span></td></tr>
<tr class="codeline" data-linenumber="899"><td class="num" id="LN899">899</td><td class="line"> <span class='comment'>* the element belongs to is incremented if needed.</span></td></tr>
<tr class="codeline" data-linenumber="900"><td class="num" id="LN900">900</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="901"><td class="num" id="LN901">901</td><td class="line"> <span class='comment'>* This function is actually a wrapper for hllSparseSet(), it only performs</span></td></tr>
<tr class="codeline" data-linenumber="902"><td class="num" id="LN902">902</td><td class="line"> <span class='comment'>* the hashshing of the element to obtain the index and zeros run length. */</span></td></tr>
<tr class="codeline" data-linenumber="903"><td class="num" id="LN903">903</td><td class="line"><span class='keyword'>int</span> hllSparseAdd(robj *o, <span class='keyword'>unsigned</span> <span class='keyword'>char</span> *ele, size_t elesize) {</td></tr>
<tr class="codeline" data-linenumber="904"><td class="num" id="LN904">904</td><td class="line">    <span class='keyword'>long</span> index;</td></tr>
<tr class="codeline" data-linenumber="905"><td class="num" id="LN905">905</td><td class="line">    uint8_t count = hllPatLen(ele,elesize,&amp;index);</td></tr>
<tr class="codeline" data-linenumber="906"><td class="num" id="LN906">906</td><td class="line">    <span class='comment'>/* Update the register if this element produced a longer run of zeroes. */</span></td></tr>
<tr class="codeline" data-linenumber="907"><td class="num" id="LN907">907</td><td class="line">    <span class='keyword'>return</span> hllSparseSet(o,index,count);</td></tr>
<tr class="codeline" data-linenumber="908"><td class="num" id="LN908">908</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="909"><td class="num" id="LN909">909</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="910"><td class="num" id="LN910">910</td><td class="line"><span class='comment'>/* Compute the register histogram in the sparse representation. */</span></td></tr>
<tr class="codeline" data-linenumber="911"><td class="num" id="LN911">911</td><td class="line"><span class='keyword'>void</span> hllSparseRegHisto(uint8_t *sparse, <span class='keyword'>int</span> sparselen, <span class='keyword'>int</span> *invalid, <span class='keyword'>int</span>* reghisto) {</td></tr>
<tr class="codeline" data-linenumber="912"><td class="num" id="LN912">912</td><td class="line">    <span class='keyword'>int</span> idx = 0, runlen, regval;</td></tr>
<tr class="codeline" data-linenumber="913"><td class="num" id="LN913">913</td><td class="line">    uint8_t *end = sparse+sparselen, *p = sparse;</td></tr>
<tr class="codeline" data-linenumber="914"><td class="num" id="LN914">914</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="915"><td class="num" id="LN915">915</td><td class="line">    <span class='keyword'>while</span>(p &lt; end) {</td></tr>
<tr class="codeline" data-linenumber="916"><td class="num" id="LN916">916</td><td class="line">        <span class='keyword'>if</span> (<span class='macro'>HLL_SPARSE_IS_ZERO(p)<span class='macro_popup'>(((*(p)) &amp; 0xc0) == 0)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="917"><td class="num" id="LN917">917</td><td class="line">            runlen = <span class='macro'>HLL_SPARSE_ZERO_LEN(p)<span class='macro_popup'>(((*(p)) &amp; 0x3f)+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="918"><td class="num" id="LN918">918</td><td class="line">            idx += runlen;</td></tr>
<tr class="codeline" data-linenumber="919"><td class="num" id="LN919">919</td><td class="line">            reghisto[0] += runlen;</td></tr>
<tr class="codeline" data-linenumber="920"><td class="num" id="LN920">920</td><td class="line">            p++;</td></tr>
<tr class="codeline" data-linenumber="921"><td class="num" id="LN921">921</td><td class="line">        } <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>HLL_SPARSE_IS_XZERO(p)<span class='macro_popup'>(((*(p)) &amp; 0xc0) == 0x40)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="922"><td class="num" id="LN922">922</td><td class="line">            runlen = <span class='macro'>HLL_SPARSE_XZERO_LEN(p)<span class='macro_popup'>(((((*(p)) &amp; 0x3f) &lt;&lt; 8) | (*((p)+1)))+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="923"><td class="num" id="LN923">923</td><td class="line">            idx += runlen;</td></tr>
<tr class="codeline" data-linenumber="924"><td class="num" id="LN924">924</td><td class="line">            reghisto[0] += runlen;</td></tr>
<tr class="codeline" data-linenumber="925"><td class="num" id="LN925">925</td><td class="line">            p += 2;</td></tr>
<tr class="codeline" data-linenumber="926"><td class="num" id="LN926">926</td><td class="line">        } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="927"><td class="num" id="LN927">927</td><td class="line">            runlen = <span class='macro'>HLL_SPARSE_VAL_LEN(p)<span class='macro_popup'>(((*(p)) &amp; 0x3)+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="928"><td class="num" id="LN928">928</td><td class="line">            regval = <span class='macro'>HLL_SPARSE_VAL_VALUE(p)<span class='macro_popup'>((((*(p)) &gt;&gt; 2) &amp; 0x1f)+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="929"><td class="num" id="LN929">929</td><td class="line">            idx += runlen;</td></tr>
<tr class="codeline" data-linenumber="930"><td class="num" id="LN930">930</td><td class="line">            reghisto[regval] += runlen;</td></tr>
<tr class="codeline" data-linenumber="931"><td class="num" id="LN931">931</td><td class="line">            p++;</td></tr>
<tr class="codeline" data-linenumber="932"><td class="num" id="LN932">932</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="933"><td class="num" id="LN933">933</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="934"><td class="num" id="LN934">934</td><td class="line">    <span class='keyword'>if</span> (idx != <span class='macro'>HLL_REGISTERS<span class='macro_popup'>(1&lt;&lt;14)</span></span> &amp;&amp; invalid) *invalid = 1;</td></tr>
<tr class="codeline" data-linenumber="935"><td class="num" id="LN935">935</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="936"><td class="num" id="LN936">936</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="937"><td class="num" id="LN937">937</td><td class="line"><span class='comment'>/* ========================= HyperLogLog Count ==============================</span></td></tr>
<tr class="codeline" data-linenumber="938"><td class="num" id="LN938">938</td><td class="line"> <span class='comment'>* This is the core of the algorithm where the approximated count is computed.</span></td></tr>
<tr class="codeline" data-linenumber="939"><td class="num" id="LN939">939</td><td class="line"> <span class='comment'>* The function uses the lower level hllDenseRegHisto() and hllSparseRegHisto()</span></td></tr>
<tr class="codeline" data-linenumber="940"><td class="num" id="LN940">940</td><td class="line"> <span class='comment'>* functions as helpers to compute histogram of register values part of the</span></td></tr>
<tr class="codeline" data-linenumber="941"><td class="num" id="LN941">941</td><td class="line"> <span class='comment'>* computation, which is representation-specific, while all the rest is common. */</span></td></tr>
<tr class="codeline" data-linenumber="942"><td class="num" id="LN942">942</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="943"><td class="num" id="LN943">943</td><td class="line"><span class='comment'>/* Implements the register histogram calculation for uint8_t data type</span></td></tr>
<tr class="codeline" data-linenumber="944"><td class="num" id="LN944">944</td><td class="line"> <span class='comment'>* which is only used internally as speedup for PFCOUNT with multiple keys. */</span></td></tr>
<tr class="codeline" data-linenumber="945"><td class="num" id="LN945">945</td><td class="line"><span class='keyword'>void</span> hllRawRegHisto(uint8_t *registers, <span class='keyword'>int</span>* reghisto) {</td></tr>
<tr class="codeline" data-linenumber="946"><td class="num" id="LN946">946</td><td class="line">    uint64_t *word = (uint64_t*) registers;</td></tr>
<tr class="codeline" data-linenumber="947"><td class="num" id="LN947">947</td><td class="line">    uint8_t *bytes;</td></tr>
<tr class="codeline" data-linenumber="948"><td class="num" id="LN948">948</td><td class="line">    <span class='keyword'>int</span> j;</td></tr>
<tr class="codeline" data-linenumber="949"><td class="num" id="LN949">949</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="950"><td class="num" id="LN950">950</td><td class="line">    <span class='keyword'>for</span> (j = 0; j &lt; <span class='macro'>HLL_REGISTERS<span class='macro_popup'>(1&lt;&lt;14)</span></span>/8; j++) {</td></tr>
<tr class="codeline" data-linenumber="951"><td class="num" id="LN951">951</td><td class="line">        <span class='keyword'>if</span> (*word == 0) {</td></tr>
<tr class="codeline" data-linenumber="952"><td class="num" id="LN952">952</td><td class="line">            reghisto[0] += 8;</td></tr>
<tr class="codeline" data-linenumber="953"><td class="num" id="LN953">953</td><td class="line">        } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="954"><td class="num" id="LN954">954</td><td class="line">            bytes = (uint8_t*) word;</td></tr>
<tr class="codeline" data-linenumber="955"><td class="num" id="LN955">955</td><td class="line">            reghisto[bytes[0]]++;</td></tr>
<tr class="codeline" data-linenumber="956"><td class="num" id="LN956">956</td><td class="line">            reghisto[bytes[1]]++;</td></tr>
<tr class="codeline" data-linenumber="957"><td class="num" id="LN957">957</td><td class="line">            reghisto[bytes[2]]++;</td></tr>
<tr class="codeline" data-linenumber="958"><td class="num" id="LN958">958</td><td class="line">            reghisto[bytes[3]]++;</td></tr>
<tr class="codeline" data-linenumber="959"><td class="num" id="LN959">959</td><td class="line">            reghisto[bytes[4]]++;</td></tr>
<tr class="codeline" data-linenumber="960"><td class="num" id="LN960">960</td><td class="line">            reghisto[bytes[5]]++;</td></tr>
<tr class="codeline" data-linenumber="961"><td class="num" id="LN961">961</td><td class="line">            reghisto[bytes[6]]++;</td></tr>
<tr class="codeline" data-linenumber="962"><td class="num" id="LN962">962</td><td class="line">            reghisto[bytes[7]]++;</td></tr>
<tr class="codeline" data-linenumber="963"><td class="num" id="LN963">963</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="964"><td class="num" id="LN964">964</td><td class="line">        word++;</td></tr>
<tr class="codeline" data-linenumber="965"><td class="num" id="LN965">965</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="966"><td class="num" id="LN966">966</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="967"><td class="num" id="LN967">967</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="968"><td class="num" id="LN968">968</td><td class="line"><span class='comment'>/* Helper function sigma as defined in</span></td></tr>
<tr class="codeline" data-linenumber="969"><td class="num" id="LN969">969</td><td class="line"> <span class='comment'>* "New cardinality estimation algorithms for HyperLogLog sketches"</span></td></tr>
<tr class="codeline" data-linenumber="970"><td class="num" id="LN970">970</td><td class="line"> <span class='comment'>* Otmar Ertl, arXiv:1702.01284 */</span></td></tr>
<tr class="codeline" data-linenumber="971"><td class="num" id="LN971">971</td><td class="line"><span class='keyword'>double</span> hllSigma(<span class='keyword'>double</span> x) {</td></tr>
<tr class="codeline" data-linenumber="972"><td class="num" id="LN972">972</td><td class="line">    <span class='keyword'>if</span> (x == 1.) <span class='keyword'>return</span> <span class='macro'>INFINITY<span class='macro_popup'>(__builtin_inff ())</span></span>;</td></tr>
<tr class="codeline" data-linenumber="973"><td class="num" id="LN973">973</td><td class="line">    <span class='keyword'>double</span> zPrime;</td></tr>
<tr class="codeline" data-linenumber="974"><td class="num" id="LN974">974</td><td class="line">    <span class='keyword'>double</span> y = 1;</td></tr>
<tr class="codeline" data-linenumber="975"><td class="num" id="LN975">975</td><td class="line">    <span class='keyword'>double</span> z = x;</td></tr>
<tr class="codeline" data-linenumber="976"><td class="num" id="LN976">976</td><td class="line">    <span class='keyword'>do</span> {</td></tr>
<tr class="codeline" data-linenumber="977"><td class="num" id="LN977">977</td><td class="line">        x *= x;</td></tr>
<tr class="codeline" data-linenumber="978"><td class="num" id="LN978">978</td><td class="line">        zPrime = z;</td></tr>
<tr class="codeline" data-linenumber="979"><td class="num" id="LN979">979</td><td class="line">        z += x * y;</td></tr>
<tr class="codeline" data-linenumber="980"><td class="num" id="LN980">980</td><td class="line">        y += y;</td></tr>
<tr class="codeline" data-linenumber="981"><td class="num" id="LN981">981</td><td class="line">    } <span class='keyword'>while</span>(zPrime != z);</td></tr>
<tr class="codeline" data-linenumber="982"><td class="num" id="LN982">982</td><td class="line">    <span class='keyword'>return</span> z;</td></tr>
<tr class="codeline" data-linenumber="983"><td class="num" id="LN983">983</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="984"><td class="num" id="LN984">984</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="985"><td class="num" id="LN985">985</td><td class="line"><span class='comment'>/* Helper function tau as defined in</span></td></tr>
<tr class="codeline" data-linenumber="986"><td class="num" id="LN986">986</td><td class="line"> <span class='comment'>* "New cardinality estimation algorithms for HyperLogLog sketches"</span></td></tr>
<tr class="codeline" data-linenumber="987"><td class="num" id="LN987">987</td><td class="line"> <span class='comment'>* Otmar Ertl, arXiv:1702.01284 */</span></td></tr>
<tr class="codeline" data-linenumber="988"><td class="num" id="LN988">988</td><td class="line"><span class='keyword'>double</span> hllTau(<span class='keyword'>double</span> x) {</td></tr>
<tr class="codeline" data-linenumber="989"><td class="num" id="LN989">989</td><td class="line">    <span class='keyword'>if</span> (x == 0. || x == 1.) <span class='keyword'>return</span> 0.;</td></tr>
<tr class="codeline" data-linenumber="990"><td class="num" id="LN990">990</td><td class="line">    <span class='keyword'>double</span> zPrime;</td></tr>
<tr class="codeline" data-linenumber="991"><td class="num" id="LN991">991</td><td class="line">    <span class='keyword'>double</span> y = 1.0;</td></tr>
<tr class="codeline" data-linenumber="992"><td class="num" id="LN992">992</td><td class="line">    <span class='keyword'>double</span> z = 1 - x;</td></tr>
<tr class="codeline" data-linenumber="993"><td class="num" id="LN993">993</td><td class="line">    <span class='keyword'>do</span> {</td></tr>
<tr class="codeline" data-linenumber="994"><td class="num" id="LN994">994</td><td class="line">        x = sqrt(x);</td></tr>
<tr class="codeline" data-linenumber="995"><td class="num" id="LN995">995</td><td class="line">        zPrime = z;</td></tr>
<tr class="codeline" data-linenumber="996"><td class="num" id="LN996">996</td><td class="line">        y *= 0.5;</td></tr>
<tr class="codeline" data-linenumber="997"><td class="num" id="LN997">997</td><td class="line">        z -= pow(1 - x, 2)*y;</td></tr>
<tr class="codeline" data-linenumber="998"><td class="num" id="LN998">998</td><td class="line">    } <span class='keyword'>while</span>(zPrime != z);</td></tr>
<tr class="codeline" data-linenumber="999"><td class="num" id="LN999">999</td><td class="line">    <span class='keyword'>return</span> z / 3;</td></tr>
<tr class="codeline" data-linenumber="1000"><td class="num" id="LN1000">1000</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1001"><td class="num" id="LN1001">1001</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1002"><td class="num" id="LN1002">1002</td><td class="line"><span class='comment'>/* Return the approximated cardinality of the set based on the harmonic</span></td></tr>
<tr class="codeline" data-linenumber="1003"><td class="num" id="LN1003">1003</td><td class="line"> <span class='comment'>* mean of the registers values. 'hdr' points to the start of the SDS</span></td></tr>
<tr class="codeline" data-linenumber="1004"><td class="num" id="LN1004">1004</td><td class="line"> <span class='comment'>* representing the String object holding the HLL representation.</span></td></tr>
<tr class="codeline" data-linenumber="1005"><td class="num" id="LN1005">1005</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="1006"><td class="num" id="LN1006">1006</td><td class="line"> <span class='comment'>* If the sparse representation of the HLL object is not valid, the integer</span></td></tr>
<tr class="codeline" data-linenumber="1007"><td class="num" id="LN1007">1007</td><td class="line"> <span class='comment'>* pointed by 'invalid' is set to non-zero, otherwise it is left untouched.</span></td></tr>
<tr class="codeline" data-linenumber="1008"><td class="num" id="LN1008">1008</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="1009"><td class="num" id="LN1009">1009</td><td class="line"> <span class='comment'>* hllCount() supports a special internal-only encoding of HLL_RAW, that</span></td></tr>
<tr class="codeline" data-linenumber="1010"><td class="num" id="LN1010">1010</td><td class="line"> <span class='comment'>* is, hdr-&gt;registers will point to an uint8_t array of HLL_REGISTERS element.</span></td></tr>
<tr class="codeline" data-linenumber="1011"><td class="num" id="LN1011">1011</td><td class="line"> <span class='comment'>* This is useful in order to speedup PFCOUNT when called against multiple</span></td></tr>
<tr class="codeline" data-linenumber="1012"><td class="num" id="LN1012">1012</td><td class="line"> <span class='comment'>* keys (no need to work with 6-bit integers encoding). */</span></td></tr>
<tr class="codeline" data-linenumber="1013"><td class="num" id="LN1013">1013</td><td class="line">uint64_t hllCount(<span class='keyword'>struct</span> hllhdr *hdr, <span class='keyword'>int</span> *invalid) {</td></tr>
<tr class="codeline" data-linenumber="1014"><td class="num" id="LN1014">1014</td><td class="line">    <span class='keyword'>double</span> m = <span class='macro'>HLL_REGISTERS<span class='macro_popup'>(1&lt;&lt;14)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1015"><td class="num" id="LN1015">1015</td><td class="line">    <span class='keyword'>double</span> E;</td></tr>
<tr class="codeline" data-linenumber="1016"><td class="num" id="LN1016">1016</td><td class="line">    <span class='keyword'>int</span> j;</td></tr>
<tr class="codeline" data-linenumber="1017"><td class="num" id="LN1017">1017</td><td class="line">    <span class='comment'>/* Note that reghisto size could be just HLL_Q+2, because HLL_Q+1 is</span></td></tr>
<tr class="codeline" data-linenumber="1018"><td class="num" id="LN1018">1018</td><td class="line">     <span class='comment'>* the maximum frequency of the "000...1" sequence the hash function is</span></td></tr>
<tr class="codeline" data-linenumber="1019"><td class="num" id="LN1019">1019</td><td class="line">     <span class='comment'>* able to return. However it is slow to check for sanity of the</span></td></tr>
<tr class="codeline" data-linenumber="1020"><td class="num" id="LN1020">1020</td><td class="line">     <span class='comment'>* input: instead we history array at a safe size: overflows will</span></td></tr>
<tr class="codeline" data-linenumber="1021"><td class="num" id="LN1021">1021</td><td class="line">     <span class='comment'>* just write data to wrong, but correctly allocated, places. */</span></td></tr>
<tr class="codeline" data-linenumber="1022"><td class="num" id="LN1022">1022</td><td class="line">    <span class='keyword'>int</span> reghisto[64] = {0};</td></tr>
<tr class="codeline" data-linenumber="1023"><td class="num" id="LN1023">1023</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1024"><td class="num" id="LN1024">1024</td><td class="line">    <span class='comment'>/* Compute register histogram */</span></td></tr>
<tr class="codeline" data-linenumber="1025"><td class="num" id="LN1025">1025</td><td class="line">    <span class='keyword'>if</span> (hdr-&gt;encoding == <span class='macro'>HLL_DENSE<span class='macro_popup'>0</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="1026"><td class="num" id="LN1026">1026</td><td class="line">        hllDenseRegHisto(hdr-&gt;registers,reghisto);</td></tr>
<tr class="codeline" data-linenumber="1027"><td class="num" id="LN1027">1027</td><td class="line">    } <span class='keyword'>else</span> <span class='keyword'>if</span> (hdr-&gt;encoding == <span class='macro'>HLL_SPARSE<span class='macro_popup'>1</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="1028"><td class="num" id="LN1028">1028</td><td class="line">        hllSparseRegHisto(hdr-&gt;registers,</td></tr>
<tr class="codeline" data-linenumber="1029"><td class="num" id="LN1029">1029</td><td class="line">                         sdslen((sds)hdr)-<span class='macro'>HLL_HDR_SIZE<span class='macro_popup'>sizeof(struct hllhdr)</span></span>,invalid,reghisto);</td></tr>
<tr class="codeline" data-linenumber="1030"><td class="num" id="LN1030">1030</td><td class="line">    } <span class='keyword'>else</span> <span class='keyword'>if</span> (hdr-&gt;encoding == <span class='macro'>HLL_RAW<span class='macro_popup'>255</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="1031"><td class="num" id="LN1031">1031</td><td class="line">        hllRawRegHisto(hdr-&gt;registers,reghisto);</td></tr>
<tr class="codeline" data-linenumber="1032"><td class="num" id="LN1032">1032</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="1033"><td class="num" id="LN1033">1033</td><td class="line">        <span class='macro'>serverPanic(<span class='string_literal'>"Unknown HyperLogLog encoding in hllCount()"</span>)<span class='macro_popup'>_serverPanic("hyperloglog.c",1033,"Unknown HyperLogLog encoding in hllCount()"<br>),_exit(1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1034"><td class="num" id="LN1034">1034</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1035"><td class="num" id="LN1035">1035</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1036"><td class="num" id="LN1036">1036</td><td class="line">    <span class='comment'>/* Estimate cardinality form register histogram. See:</span></td></tr>
<tr class="codeline" data-linenumber="1037"><td class="num" id="LN1037">1037</td><td class="line">     <span class='comment'>* "New cardinality estimation algorithms for HyperLogLog sketches"</span></td></tr>
<tr class="codeline" data-linenumber="1038"><td class="num" id="LN1038">1038</td><td class="line">     <span class='comment'>* Otmar Ertl, arXiv:1702.01284 */</span></td></tr>
<tr class="codeline" data-linenumber="1039"><td class="num" id="LN1039">1039</td><td class="line">    <span class='keyword'>double</span> z = m * hllTau((m-reghisto[<span class='macro'>HLL_Q<span class='macro_popup'>(64-14)</span></span>+1])/(<span class='keyword'>double</span>)m);</td></tr>
<tr class="codeline" data-linenumber="1040"><td class="num" id="LN1040">1040</td><td class="line">    <span class='keyword'>for</span> (j = <span class='macro'>HLL_Q<span class='macro_popup'>(64-14)</span></span>; j &gt;= 1; --j) {</td></tr>
<tr class="codeline" data-linenumber="1041"><td class="num" id="LN1041">1041</td><td class="line">        z += reghisto[j];</td></tr>
<tr class="codeline" data-linenumber="1042"><td class="num" id="LN1042">1042</td><td class="line">        z *= 0.5;</td></tr>
<tr class="codeline" data-linenumber="1043"><td class="num" id="LN1043">1043</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1044"><td class="num" id="LN1044">1044</td><td class="line">    z += m * hllSigma(reghisto[0]/(<span class='keyword'>double</span>)m);</td></tr>
<tr class="codeline" data-linenumber="1045"><td class="num" id="LN1045">1045</td><td class="line">    E = llroundl(<span class='macro'>HLL_ALPHA_INF<span class='macro_popup'>0.721347520444481703680</span></span>*m*m/z);</td></tr>
<tr class="codeline" data-linenumber="1046"><td class="num" id="LN1046">1046</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1047"><td class="num" id="LN1047">1047</td><td class="line">    <span class='keyword'>return</span> (uint64_t) E;</td></tr>
<tr class="codeline" data-linenumber="1048"><td class="num" id="LN1048">1048</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1049"><td class="num" id="LN1049">1049</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1050"><td class="num" id="LN1050">1050</td><td class="line"><span class='comment'>/* Call hllDenseAdd() or hllSparseAdd() according to the HLL encoding. */</span></td></tr>
<tr class="codeline" data-linenumber="1051"><td class="num" id="LN1051">1051</td><td class="line"><span class='keyword'>int</span> hllAdd(robj *o, <span class='keyword'>unsigned</span> <span class='keyword'>char</span> *ele, size_t elesize) {</td></tr>
<tr class="codeline" data-linenumber="1052"><td class="num" id="LN1052">1052</td><td class="line">    <span class='keyword'>struct</span> hllhdr *hdr = o-&gt;ptr;</td></tr>
<tr class="codeline" data-linenumber="1053"><td class="num" id="LN1053">1053</td><td class="line">    <span class='keyword'>switch</span>(hdr-&gt;encoding) {</td></tr>
<tr class="codeline" data-linenumber="1054"><td class="num" id="LN1054">1054</td><td class="line">    <span class='keyword'>case</span> <span class='macro'>HLL_DENSE<span class='macro_popup'>0</span></span>: <span class='keyword'>return</span> hllDenseAdd(hdr-&gt;registers,ele,elesize);</td></tr>
<tr class="codeline" data-linenumber="1055"><td class="num" id="LN1055">1055</td><td class="line">    <span class='keyword'>case</span> <span class='macro'>HLL_SPARSE<span class='macro_popup'>1</span></span>: <span class='keyword'>return</span> hllSparseAdd(o,ele,elesize);</td></tr>
<tr class="codeline" data-linenumber="1056"><td class="num" id="LN1056">1056</td><td class="line">    <span class='keyword'>default</span>: <span class='keyword'>return</span> -1; <span class='comment'>/* Invalid representation. */</span></td></tr>
<tr class="codeline" data-linenumber="1057"><td class="num" id="LN1057">1057</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1058"><td class="num" id="LN1058">1058</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1059"><td class="num" id="LN1059">1059</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1060"><td class="num" id="LN1060">1060</td><td class="line"><span class='comment'>/* Merge by computing MAX(registers[i],hll[i]) the HyperLogLog 'hll'</span></td></tr>
<tr class="codeline" data-linenumber="1061"><td class="num" id="LN1061">1061</td><td class="line"> <span class='comment'>* with an array of uint8_t HLL_REGISTERS registers pointed by 'max'.</span></td></tr>
<tr class="codeline" data-linenumber="1062"><td class="num" id="LN1062">1062</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="1063"><td class="num" id="LN1063">1063</td><td class="line"> <span class='comment'>* The hll object must be already validated via isHLLObjectOrReply()</span></td></tr>
<tr class="codeline" data-linenumber="1064"><td class="num" id="LN1064">1064</td><td class="line"> <span class='comment'>* or in some other way.</span></td></tr>
<tr class="codeline" data-linenumber="1065"><td class="num" id="LN1065">1065</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="1066"><td class="num" id="LN1066">1066</td><td class="line"> <span class='comment'>* If the HyperLogLog is sparse and is found to be invalid, C_ERR</span></td></tr>
<tr class="codeline" data-linenumber="1067"><td class="num" id="LN1067">1067</td><td class="line"> <span class='comment'>* is returned, otherwise the function always succeeds. */</span></td></tr>
<tr class="codeline" data-linenumber="1068"><td class="num" id="LN1068">1068</td><td class="line"><span class='keyword'>int</span> hllMerge(uint8_t *max, robj *hll) {</td></tr>
<tr class="codeline" data-linenumber="1069"><td class="num" id="LN1069">1069</td><td class="line">    <span class='keyword'>struct</span> hllhdr *hdr = hll-&gt;ptr;</td></tr>
<tr class="codeline" data-linenumber="1070"><td class="num" id="LN1070">1070</td><td class="line">    <span class='keyword'>int</span> i;</td></tr>
<tr class="codeline" data-linenumber="1071"><td class="num" id="LN1071">1071</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1072"><td class="num" id="LN1072">1072</td><td class="line">    <span class='keyword'>if</span> (hdr-&gt;encoding == <span class='macro'>HLL_DENSE<span class='macro_popup'>0</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="1073"><td class="num" id="LN1073">1073</td><td class="line">        uint8_t val;</td></tr>
<tr class="codeline" data-linenumber="1074"><td class="num" id="LN1074">1074</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1075"><td class="num" id="LN1075">1075</td><td class="line">        <span class='keyword'>for</span> (i = 0; i &lt; <span class='macro'>HLL_REGISTERS<span class='macro_popup'>(1&lt;&lt;14)</span></span>; i++) {</td></tr>
<tr class="codeline" data-linenumber="1076"><td class="num" id="LN1076">1076</td><td class="line">            <span class='macro'>HLL_DENSE_GET_REGISTER(val,hdr-&gt;registers,i)<span class='macro_popup'>do { uint8_t *_p = (uint8_t*) hdr-&gt;registers; unsigned long<br> _byte = i*6/8; unsigned long _fb = i*6&amp;7; unsigned long _fb8<br> = 8 - _fb; unsigned long b0 = _p[_byte]; unsigned long b1 = _p<br>[_byte+1]; val = ((b0 &gt;&gt; _fb) | (b1 &lt;&lt; _fb8)) &amp;<br> ((1&lt;&lt;6)-1); } while(0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1077"><td class="num" id="LN1077">1077</td><td class="line">            <span class='keyword'>if</span> (val &gt; max[i]) max[i] = val;</td></tr>
<tr class="codeline" data-linenumber="1078"><td class="num" id="LN1078">1078</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="1079"><td class="num" id="LN1079">1079</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="1080"><td class="num" id="LN1080">1080</td><td class="line">        uint8_t *p = hll-&gt;ptr, *end = p + sdslen(hll-&gt;ptr);</td></tr>
<tr class="codeline" data-linenumber="1081"><td class="num" id="LN1081">1081</td><td class="line">        <span class='keyword'>long</span> runlen, regval;</td></tr>
<tr class="codeline" data-linenumber="1082"><td class="num" id="LN1082">1082</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1083"><td class="num" id="LN1083">1083</td><td class="line">        p += <span class='macro'>HLL_HDR_SIZE<span class='macro_popup'>sizeof(struct hllhdr)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1084"><td class="num" id="LN1084">1084</td><td class="line">        i = 0;</td></tr>
<tr class="codeline" data-linenumber="1085"><td class="num" id="LN1085">1085</td><td class="line">        <span class='keyword'>while</span>(p &lt; end) {</td></tr>
<tr class="codeline" data-linenumber="1086"><td class="num" id="LN1086">1086</td><td class="line">            <span class='keyword'>if</span> (<span class='macro'>HLL_SPARSE_IS_ZERO(p)<span class='macro_popup'>(((*(p)) &amp; 0xc0) == 0)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="1087"><td class="num" id="LN1087">1087</td><td class="line">                runlen = <span class='macro'>HLL_SPARSE_ZERO_LEN(p)<span class='macro_popup'>(((*(p)) &amp; 0x3f)+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1088"><td class="num" id="LN1088">1088</td><td class="line">                i += runlen;</td></tr>
<tr class="codeline" data-linenumber="1089"><td class="num" id="LN1089">1089</td><td class="line">                p++;</td></tr>
<tr class="codeline" data-linenumber="1090"><td class="num" id="LN1090">1090</td><td class="line">            } <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>HLL_SPARSE_IS_XZERO(p)<span class='macro_popup'>(((*(p)) &amp; 0xc0) == 0x40)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="1091"><td class="num" id="LN1091">1091</td><td class="line">                runlen = <span class='macro'>HLL_SPARSE_XZERO_LEN(p)<span class='macro_popup'>(((((*(p)) &amp; 0x3f) &lt;&lt; 8) | (*((p)+1)))+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1092"><td class="num" id="LN1092">1092</td><td class="line">                i += runlen;</td></tr>
<tr class="codeline" data-linenumber="1093"><td class="num" id="LN1093">1093</td><td class="line">                p += 2;</td></tr>
<tr class="codeline" data-linenumber="1094"><td class="num" id="LN1094">1094</td><td class="line">            } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="1095"><td class="num" id="LN1095">1095</td><td class="line">                runlen = <span class='macro'>HLL_SPARSE_VAL_LEN(p)<span class='macro_popup'>(((*(p)) &amp; 0x3)+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1096"><td class="num" id="LN1096">1096</td><td class="line">                regval = <span class='macro'>HLL_SPARSE_VAL_VALUE(p)<span class='macro_popup'>((((*(p)) &gt;&gt; 2) &amp; 0x1f)+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1097"><td class="num" id="LN1097">1097</td><td class="line">                <span class='keyword'>if</span> ((runlen + i) &gt; <span class='macro'>HLL_REGISTERS<span class='macro_popup'>(1&lt;&lt;14)</span></span>) <span class='keyword'>break</span>; <span class='comment'>/* Overflow. */</span></td></tr>
<tr class="codeline" data-linenumber="1098"><td class="num" id="LN1098">1098</td><td class="line">                <span class='keyword'>while</span>(runlen--) {</td></tr>
<tr class="codeline" data-linenumber="1099"><td class="num" id="LN1099">1099</td><td class="line">                    <span class='keyword'>if</span> (regval &gt; max[i]) max[i] = regval;</td></tr>
<tr class="codeline" data-linenumber="1100"><td class="num" id="LN1100">1100</td><td class="line">                    i++;</td></tr>
<tr class="codeline" data-linenumber="1101"><td class="num" id="LN1101">1101</td><td class="line">                }</td></tr>
<tr class="codeline" data-linenumber="1102"><td class="num" id="LN1102">1102</td><td class="line">                p++;</td></tr>
<tr class="codeline" data-linenumber="1103"><td class="num" id="LN1103">1103</td><td class="line">            }</td></tr>
<tr class="codeline" data-linenumber="1104"><td class="num" id="LN1104">1104</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="1105"><td class="num" id="LN1105">1105</td><td class="line">        <span class='keyword'>if</span> (i != <span class='macro'>HLL_REGISTERS<span class='macro_popup'>(1&lt;&lt;14)</span></span>) <span class='keyword'>return</span> <span class='macro'>C_ERR<span class='macro_popup'>-1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1106"><td class="num" id="LN1106">1106</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1107"><td class="num" id="LN1107">1107</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>C_OK<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1108"><td class="num" id="LN1108">1108</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1109"><td class="num" id="LN1109">1109</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1110"><td class="num" id="LN1110">1110</td><td class="line"><span class='comment'>/* ========================== HyperLogLog commands ========================== */</span></td></tr>
<tr class="codeline" data-linenumber="1111"><td class="num" id="LN1111">1111</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1112"><td class="num" id="LN1112">1112</td><td class="line"><span class='comment'>/* Create an HLL object. We always create the HLL using sparse encoding.</span></td></tr>
<tr class="codeline" data-linenumber="1113"><td class="num" id="LN1113">1113</td><td class="line"> <span class='comment'>* This will be upgraded to the dense representation as needed. */</span></td></tr>
<tr class="codeline" data-linenumber="1114"><td class="num" id="LN1114">1114</td><td class="line">robj *createHLLObject(<span class='keyword'>void</span>) {</td></tr>
<tr class="codeline" data-linenumber="1115"><td class="num" id="LN1115">1115</td><td class="line">    robj *o;</td></tr>
<tr class="codeline" data-linenumber="1116"><td class="num" id="LN1116">1116</td><td class="line">    <span class='keyword'>struct</span> hllhdr *hdr;</td></tr>
<tr class="codeline" data-linenumber="1117"><td class="num" id="LN1117">1117</td><td class="line">    sds s;</td></tr>
<tr class="codeline" data-linenumber="1118"><td class="num" id="LN1118">1118</td><td class="line">    uint8_t *p;</td></tr>
<tr class="codeline" data-linenumber="1119"><td class="num" id="LN1119">1119</td><td class="line">    <span class='keyword'>int</span> sparselen = <span class='macro'>HLL_HDR_SIZE<span class='macro_popup'>sizeof(struct hllhdr)</span></span> +</td></tr>
<tr class="codeline" data-linenumber="1120"><td class="num" id="LN1120">1120</td><td class="line">                    (((<span class='macro'>HLL_REGISTERS<span class='macro_popup'>(1&lt;&lt;14)</span></span>+(<span class='macro'>HLL_SPARSE_XZERO_MAX_LEN<span class='macro_popup'>16384</span></span>-1)) /</td></tr>
<tr class="codeline" data-linenumber="1121"><td class="num" id="LN1121">1121</td><td class="line">                     <span class='macro'>HLL_SPARSE_XZERO_MAX_LEN<span class='macro_popup'>16384</span></span>)*2);</td></tr>
<tr class="codeline" data-linenumber="1122"><td class="num" id="LN1122">1122</td><td class="line">    <span class='keyword'>int</span> aux;</td></tr>
<tr class="codeline" data-linenumber="1123"><td class="num" id="LN1123">1123</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1124"><td class="num" id="LN1124">1124</td><td class="line">    <span class='comment'>/* Populate the sparse representation with as many XZERO opcodes as</span></td></tr>
<tr class="codeline" data-linenumber="1125"><td class="num" id="LN1125">1125</td><td class="line">     <span class='comment'>* needed to represent all the registers. */</span></td></tr>
<tr class="codeline" data-linenumber="1126"><td class="num" id="LN1126">1126</td><td class="line">    aux = <span class='macro'>HLL_REGISTERS<span class='macro_popup'>(1&lt;&lt;14)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1127"><td class="num" id="LN1127">1127</td><td class="line">    s = sdsnewlen(<span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>,sparselen);</td></tr>
<tr class="codeline" data-linenumber="1128"><td class="num" id="LN1128">1128</td><td class="line">    p = (uint8_t*)s + <span class='macro'>HLL_HDR_SIZE<span class='macro_popup'>sizeof(struct hllhdr)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1129"><td class="num" id="LN1129">1129</td><td class="line">    <span class='keyword'>while</span>(aux) {</td></tr>
<tr class="codeline" data-linenumber="1130"><td class="num" id="LN1130">1130</td><td class="line">        <span class='keyword'>int</span> xzero = <span class='macro'>HLL_SPARSE_XZERO_MAX_LEN<span class='macro_popup'>16384</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1131"><td class="num" id="LN1131">1131</td><td class="line">        <span class='keyword'>if</span> (xzero &gt; aux) xzero = aux;</td></tr>
<tr class="codeline" data-linenumber="1132"><td class="num" id="LN1132">1132</td><td class="line">        <span class='macro'>HLL_SPARSE_XZERO_SET(p,xzero)<span class='macro_popup'>do { int _l = (xzero)-1; *(p) = (_l&gt;&gt;8) | 0x40; *((p)+1<br>) = (_l&amp;0xff); } while(0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1133"><td class="num" id="LN1133">1133</td><td class="line">        p += 2;</td></tr>
<tr class="codeline" data-linenumber="1134"><td class="num" id="LN1134">1134</td><td class="line">        aux -= xzero;</td></tr>
<tr class="codeline" data-linenumber="1135"><td class="num" id="LN1135">1135</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1136"><td class="num" id="LN1136">1136</td><td class="line">    <span class='macro'>serverAssert((p-(uint8_t*)s) == sparselen)<span class='macro_popup'>(((p-(uint8_t*)s) == sparselen)?(void)0 : (_serverAssert("(p-(uint8_t*)s) == sparselen"<br>,"hyperloglog.c",1136),_exit(1)))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1137"><td class="num" id="LN1137">1137</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1138"><td class="num" id="LN1138">1138</td><td class="line">    <span class='comment'>/* Create the actual object. */</span></td></tr>
<tr class="codeline" data-linenumber="1139"><td class="num" id="LN1139">1139</td><td class="line">    o = createObject(<span class='macro'>OBJ_STRING<span class='macro_popup'>0</span></span>,s);</td></tr>
<tr class="codeline" data-linenumber="1140"><td class="num" id="LN1140">1140</td><td class="line">    hdr = o-&gt;ptr;</td></tr>
<tr class="codeline" data-linenumber="1141"><td class="num" id="LN1141">1141</td><td class="line">    memcpy(hdr-&gt;magic,<span class='string_literal'>"HYLL"</span>,4);</td></tr>
<tr class="codeline" data-linenumber="1142"><td class="num" id="LN1142">1142</td><td class="line">    hdr-&gt;encoding = <span class='macro'>HLL_SPARSE<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1143"><td class="num" id="LN1143">1143</td><td class="line">    <span class='keyword'>return</span> o;</td></tr>
<tr class="codeline" data-linenumber="1144"><td class="num" id="LN1144">1144</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1145"><td class="num" id="LN1145">1145</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1146"><td class="num" id="LN1146">1146</td><td class="line"><span class='comment'>/* Check if the object is a String with a valid HLL representation.</span></td></tr>
<tr class="codeline" data-linenumber="1147"><td class="num" id="LN1147">1147</td><td class="line"> <span class='comment'>* Return C_OK if this is true, otherwise reply to the client</span></td></tr>
<tr class="codeline" data-linenumber="1148"><td class="num" id="LN1148">1148</td><td class="line"> <span class='comment'>* with an error and return C_ERR. */</span></td></tr>
<tr class="codeline" data-linenumber="1149"><td class="num" id="LN1149">1149</td><td class="line"><span class='keyword'>int</span> isHLLObjectOrReply(client *c, robj *o) {</td></tr>
<tr class="codeline" data-linenumber="1150"><td class="num" id="LN1150">1150</td><td class="line">    <span class='keyword'>struct</span> hllhdr *hdr;</td></tr>
<tr class="codeline" data-linenumber="1151"><td class="num" id="LN1151">1151</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1152"><td class="num" id="LN1152">1152</td><td class="line">    <span class='comment'>/* Key exists, check type */</span></td></tr>
<tr class="codeline" data-linenumber="1153"><td class="num" id="LN1153">1153</td><td class="line">    <span class='keyword'>if</span> (checkType(c,o,<span class='macro'>OBJ_STRING<span class='macro_popup'>0</span></span>))</td></tr>
<tr class="codeline" data-linenumber="1154"><td class="num" id="LN1154">1154</td><td class="line">        <span class='keyword'>return</span> <span class='macro'>C_ERR<span class='macro_popup'>-1</span></span>; <span class='comment'>/* Error already sent. */</span></td></tr>
<tr class="codeline" data-linenumber="1155"><td class="num" id="LN1155">1155</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1156"><td class="num" id="LN1156">1156</td><td class="line">    <span class='keyword'>if</span> (!<span class='macro'>sdsEncodedObject(o)<span class='macro_popup'>(o-&gt;encoding == 0 || o-&gt;encoding == 8)</span></span>) <span class='keyword'>goto</span> invalid;</td></tr>
<tr class="codeline" data-linenumber="1157"><td class="num" id="LN1157">1157</td><td class="line">    <span class='keyword'>if</span> (stringObjectLen(o) &lt; <span class='keyword'>sizeof</span>(*hdr)) <span class='keyword'>goto</span> invalid;</td></tr>
<tr class="codeline" data-linenumber="1158"><td class="num" id="LN1158">1158</td><td class="line">    hdr = o-&gt;ptr;</td></tr>
<tr class="codeline" data-linenumber="1159"><td class="num" id="LN1159">1159</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1160"><td class="num" id="LN1160">1160</td><td class="line">    <span class='comment'>/* Magic should be "HYLL". */</span></td></tr>
<tr class="codeline" data-linenumber="1161"><td class="num" id="LN1161">1161</td><td class="line">    <span class='keyword'>if</span> (hdr-&gt;magic[0] != 'H' || hdr-&gt;magic[1] != 'Y' ||</td></tr>
<tr class="codeline" data-linenumber="1162"><td class="num" id="LN1162">1162</td><td class="line">        hdr-&gt;magic[2] != 'L' || hdr-&gt;magic[3] != 'L') <span class='keyword'>goto</span> invalid;</td></tr>
<tr class="codeline" data-linenumber="1163"><td class="num" id="LN1163">1163</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1164"><td class="num" id="LN1164">1164</td><td class="line">    <span class='keyword'>if</span> (hdr-&gt;encoding &gt; <span class='macro'>HLL_MAX_ENCODING<span class='macro_popup'>1</span></span>) <span class='keyword'>goto</span> invalid;</td></tr>
<tr class="codeline" data-linenumber="1165"><td class="num" id="LN1165">1165</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1166"><td class="num" id="LN1166">1166</td><td class="line">    <span class='comment'>/* Dense representation string length should match exactly. */</span></td></tr>
<tr class="codeline" data-linenumber="1167"><td class="num" id="LN1167">1167</td><td class="line">    <span class='keyword'>if</span> (hdr-&gt;encoding == <span class='macro'>HLL_DENSE<span class='macro_popup'>0</span></span> &amp;&amp;</td></tr>
<tr class="codeline" data-linenumber="1168"><td class="num" id="LN1168">1168</td><td class="line">        stringObjectLen(o) != <span class='macro'>HLL_DENSE_SIZE<span class='macro_popup'>(sizeof(struct hllhdr)+(((1&lt;&lt;14)*6 +7)/8))</span></span>) <span class='keyword'>goto</span> invalid;</td></tr>
<tr class="codeline" data-linenumber="1169"><td class="num" id="LN1169">1169</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1170"><td class="num" id="LN1170">1170</td><td class="line">    <span class='comment'>/* All tests passed. */</span></td></tr>
<tr class="codeline" data-linenumber="1171"><td class="num" id="LN1171">1171</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>C_OK<span class='macro_popup'>0</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1172"><td class="num" id="LN1172">1172</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1173"><td class="num" id="LN1173">1173</td><td class="line">invalid:</td></tr>
<tr class="codeline" data-linenumber="1174"><td class="num" id="LN1174">1174</td><td class="line">    addReplySds(c,</td></tr>
<tr class="codeline" data-linenumber="1175"><td class="num" id="LN1175">1175</td><td class="line">        sdsnew(<span class='string_literal'>"-WRONGTYPE Key is not a valid "</span></td></tr>
<tr class="codeline" data-linenumber="1176"><td class="num" id="LN1176">1176</td><td class="line">               <span class='string_literal'>"HyperLogLog string value.\r\n"</span>));</td></tr>
<tr class="codeline" data-linenumber="1177"><td class="num" id="LN1177">1177</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>C_ERR<span class='macro_popup'>-1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1178"><td class="num" id="LN1178">1178</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1179"><td class="num" id="LN1179">1179</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1180"><td class="num" id="LN1180">1180</td><td class="line"><span class='comment'>/* PFADD var ele ele ele ... ele =&gt; :0 or :1 */</span></td></tr>
<tr class="codeline" data-linenumber="1181"><td class="num" id="LN1181">1181</td><td class="line"><span class='keyword'>void</span> pfaddCommand(client *c) {</td></tr>
<tr class="codeline" data-linenumber="1182"><td class="num" id="LN1182">1182</td><td class="line">    robj *o = lookupKeyWrite(c-&gt;db,c-&gt;argv[1]);</td></tr>
<tr class="codeline" data-linenumber="1183"><td class="num" id="LN1183">1183</td><td class="line">    <span class='keyword'>struct</span> hllhdr *hdr;</td></tr>
<tr class="codeline" data-linenumber="1184"><td class="num" id="LN1184">1184</td><td class="line">    <span class='keyword'>int</span> updated = 0, j;</td></tr>
<tr class="codeline" data-linenumber="1185"><td class="num" id="LN1185">1185</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1186"><td class="num" id="LN1186">1186</td><td class="line">    <span class='keyword'>if</span> (o == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="1187"><td class="num" id="LN1187">1187</td><td class="line">        <span class='comment'>/* Create the key with a string value of the exact length to</span></td></tr>
<tr class="codeline" data-linenumber="1188"><td class="num" id="LN1188">1188</td><td class="line">         <span class='comment'>* hold our HLL data structure. sdsnewlen() when NULL is passed</span></td></tr>
<tr class="codeline" data-linenumber="1189"><td class="num" id="LN1189">1189</td><td class="line">         <span class='comment'>* is guaranteed to return bytes initialized to zero. */</span></td></tr>
<tr class="codeline" data-linenumber="1190"><td class="num" id="LN1190">1190</td><td class="line">        o = createHLLObject();</td></tr>
<tr class="codeline" data-linenumber="1191"><td class="num" id="LN1191">1191</td><td class="line">        dbAdd(c-&gt;db,c-&gt;argv[1],o);</td></tr>
<tr class="codeline" data-linenumber="1192"><td class="num" id="LN1192">1192</td><td class="line">        updated++;</td></tr>
<tr class="codeline" data-linenumber="1193"><td class="num" id="LN1193">1193</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="1194"><td class="num" id="LN1194">1194</td><td class="line">        <span class='keyword'>if</span> (isHLLObjectOrReply(c,o) != <span class='macro'>C_OK<span class='macro_popup'>0</span></span>) <span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="1195"><td class="num" id="LN1195">1195</td><td class="line">        o = dbUnshareStringValue(c-&gt;db,c-&gt;argv[1],o);</td></tr>
<tr class="codeline" data-linenumber="1196"><td class="num" id="LN1196">1196</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1197"><td class="num" id="LN1197">1197</td><td class="line">    <span class='comment'>/* Perform the low level ADD operation for every element. */</span></td></tr>
<tr class="codeline" data-linenumber="1198"><td class="num" id="LN1198">1198</td><td class="line">    <span class='keyword'>for</span> (j = 2; j &lt; c-&gt;argc; j++) {</td></tr>
<tr class="codeline" data-linenumber="1199"><td class="num" id="LN1199">1199</td><td class="line">        <span class='keyword'>int</span> retval = hllAdd(o, (<span class='keyword'>unsigned</span> <span class='keyword'>char</span>*)c-&gt;argv[j]-&gt;ptr,</td></tr>
<tr class="codeline" data-linenumber="1200"><td class="num" id="LN1200">1200</td><td class="line">                               sdslen(c-&gt;argv[j]-&gt;ptr));</td></tr>
<tr class="codeline" data-linenumber="1201"><td class="num" id="LN1201">1201</td><td class="line">        <span class='keyword'>switch</span>(retval) {</td></tr>
<tr class="codeline" data-linenumber="1202"><td class="num" id="LN1202">1202</td><td class="line">        <span class='keyword'>case</span> 1:</td></tr>
<tr class="codeline" data-linenumber="1203"><td class="num" id="LN1203">1203</td><td class="line">            updated++;</td></tr>
<tr class="codeline" data-linenumber="1204"><td class="num" id="LN1204">1204</td><td class="line">            <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="1205"><td class="num" id="LN1205">1205</td><td class="line">        <span class='keyword'>case</span> -1:</td></tr>
<tr class="codeline" data-linenumber="1206"><td class="num" id="LN1206">1206</td><td class="line">            addReplySds(c,sdsnew(invalid_hll_err));</td></tr>
<tr class="codeline" data-linenumber="1207"><td class="num" id="LN1207">1207</td><td class="line">            <span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="1208"><td class="num" id="LN1208">1208</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="1209"><td class="num" id="LN1209">1209</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1210"><td class="num" id="LN1210">1210</td><td class="line">    hdr = o-&gt;ptr;</td></tr>
<tr class="codeline" data-linenumber="1211"><td class="num" id="LN1211">1211</td><td class="line">    <span class='keyword'>if</span> (updated) {</td></tr>
<tr class="codeline" data-linenumber="1212"><td class="num" id="LN1212">1212</td><td class="line">        signalModifiedKey(c,c-&gt;db,c-&gt;argv[1]);</td></tr>
<tr class="codeline" data-linenumber="1213"><td class="num" id="LN1213">1213</td><td class="line">        notifyKeyspaceEvent(<span class='macro'>NOTIFY_STRING<span class='macro_popup'>(1&lt;&lt;3)</span></span>,<span class='string_literal'>"pfadd"</span>,c-&gt;argv[1],c-&gt;db-&gt;id);</td></tr>
<tr class="codeline" data-linenumber="1214"><td class="num" id="LN1214">1214</td><td class="line">        server.dirty++;</td></tr>
<tr class="codeline" data-linenumber="1215"><td class="num" id="LN1215">1215</td><td class="line">        <span class='macro'>HLL_INVALIDATE_CACHE(hdr)<span class='macro_popup'>(hdr)-&gt;card[7] |= (1&lt;&lt;7)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1216"><td class="num" id="LN1216">1216</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1217"><td class="num" id="LN1217">1217</td><td class="line">    addReply(c, updated ? shared.cone : shared.czero);</td></tr>
<tr class="codeline" data-linenumber="1218"><td class="num" id="LN1218">1218</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1219"><td class="num" id="LN1219">1219</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1220"><td class="num" id="LN1220">1220</td><td class="line"><span class='comment'>/* PFCOUNT var -&gt; approximated cardinality of set. */</span></td></tr>
<tr class="codeline" data-linenumber="1221"><td class="num" id="LN1221">1221</td><td class="line"><span class='keyword'>void</span> pfcountCommand(client *c) {</td></tr>
<tr class="codeline" data-linenumber="1222"><td class="num" id="LN1222">1222</td><td class="line">    robj *o;</td></tr>
<tr class="codeline" data-linenumber="1223"><td class="num" id="LN1223">1223</td><td class="line">    <span class='keyword'>struct</span> hllhdr *hdr;</td></tr>
<tr class="codeline" data-linenumber="1224"><td class="num" id="LN1224">1224</td><td class="line">    uint64_t card;</td></tr>
<tr class="codeline" data-linenumber="1225"><td class="num" id="LN1225">1225</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1226"><td class="num" id="LN1226">1226</td><td class="line">    <span class='comment'>/* Case 1: multi-key keys, cardinality of the union.</span></td></tr>
<tr class="codeline" data-linenumber="1227"><td class="num" id="LN1227">1227</td><td class="line">     <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="1228"><td class="num" id="LN1228">1228</td><td class="line">     <span class='comment'>* When multiple keys are specified, PFCOUNT actually computes</span></td></tr>
<tr class="codeline" data-linenumber="1229"><td class="num" id="LN1229">1229</td><td class="line">     <span class='comment'>* the cardinality of the merge of the N HLLs specified. */</span></td></tr>
<tr class="codeline" data-linenumber="1230"><td class="num" id="LN1230">1230</td><td class="line">    <span class='keyword'>if</span> (c-&gt;argc &gt; 2) {</td></tr>
<tr class="codeline" data-linenumber="1231"><td class="num" id="LN1231">1231</td><td class="line">        uint8_t max[<span class='macro'>HLL_HDR_SIZE<span class='macro_popup'>sizeof(struct hllhdr)</span></span>+<span class='macro'>HLL_REGISTERS<span class='macro_popup'>(1&lt;&lt;14)</span></span>], *registers;</td></tr>
<tr class="codeline" data-linenumber="1232"><td class="num" id="LN1232">1232</td><td class="line">        <span class='keyword'>int</span> j;</td></tr>
<tr class="codeline" data-linenumber="1233"><td class="num" id="LN1233">1233</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1234"><td class="num" id="LN1234">1234</td><td class="line">        <span class='comment'>/* Compute an HLL with M[i] = MAX(M[i]_j). */</span></td></tr>
<tr class="codeline" data-linenumber="1235"><td class="num" id="LN1235">1235</td><td class="line">        <span class="mrange">memset</span>(max,0,<span class='keyword'>sizeof</span>(max));</td></tr>
<tr><td class="num"></td><td class="line"><div id="EndPath" class="msg msgEvent" style="margin-left:9ex; max-width:58em">Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11</div></td></tr>
<tr class="codeline" data-linenumber="1236"><td class="num" id="LN1236">1236</td><td class="line">        hdr = (<span class='keyword'>struct</span> hllhdr*) max;</td></tr>
<tr class="codeline" data-linenumber="1237"><td class="num" id="LN1237">1237</td><td class="line">        hdr-&gt;encoding = <span class='macro'>HLL_RAW<span class='macro_popup'>255</span></span>; <span class='comment'>/* Special internal-only encoding. */</span></td></tr>
<tr class="codeline" data-linenumber="1238"><td class="num" id="LN1238">1238</td><td class="line">        registers = max + <span class='macro'>HLL_HDR_SIZE<span class='macro_popup'>sizeof(struct hllhdr)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1239"><td class="num" id="LN1239">1239</td><td class="line">        <span class='keyword'>for</span> (j = 1; j &lt; c-&gt;argc; j++) {</td></tr>
<tr class="codeline" data-linenumber="1240"><td class="num" id="LN1240">1240</td><td class="line">            <span class='comment'>/* Check type and size. */</span></td></tr>
<tr class="codeline" data-linenumber="1241"><td class="num" id="LN1241">1241</td><td class="line">            robj *o = lookupKeyRead(c-&gt;db,c-&gt;argv[j]);</td></tr>
<tr class="codeline" data-linenumber="1242"><td class="num" id="LN1242">1242</td><td class="line">            <span class='keyword'>if</span> (o == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>) <span class='keyword'>continue</span>; <span class='comment'>/* Assume empty HLL for non existing var.*/</span></td></tr>
<tr class="codeline" data-linenumber="1243"><td class="num" id="LN1243">1243</td><td class="line">            <span class='keyword'>if</span> (isHLLObjectOrReply(c,o) != <span class='macro'>C_OK<span class='macro_popup'>0</span></span>) <span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="1244"><td class="num" id="LN1244">1244</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1245"><td class="num" id="LN1245">1245</td><td class="line">            <span class='comment'>/* Merge with this HLL with our 'max' HLL by setting max[i]</span></td></tr>
<tr class="codeline" data-linenumber="1246"><td class="num" id="LN1246">1246</td><td class="line">             <span class='comment'>* to MAX(max[i],hll[i]). */</span></td></tr>
<tr class="codeline" data-linenumber="1247"><td class="num" id="LN1247">1247</td><td class="line">            <span class='keyword'>if</span> (hllMerge(registers,o) == <span class='macro'>C_ERR<span class='macro_popup'>-1</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="1248"><td class="num" id="LN1248">1248</td><td class="line">                addReplySds(c,sdsnew(invalid_hll_err));</td></tr>
<tr class="codeline" data-linenumber="1249"><td class="num" id="LN1249">1249</td><td class="line">                <span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="1250"><td class="num" id="LN1250">1250</td><td class="line">            }</td></tr>
<tr class="codeline" data-linenumber="1251"><td class="num" id="LN1251">1251</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="1252"><td class="num" id="LN1252">1252</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1253"><td class="num" id="LN1253">1253</td><td class="line">        <span class='comment'>/* Compute cardinality of the resulting set. */</span></td></tr>
<tr class="codeline" data-linenumber="1254"><td class="num" id="LN1254">1254</td><td class="line">        addReplyLongLong(c,hllCount(hdr,<span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>));</td></tr>
<tr class="codeline" data-linenumber="1255"><td class="num" id="LN1255">1255</td><td class="line">        <span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="1256"><td class="num" id="LN1256">1256</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1257"><td class="num" id="LN1257">1257</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1258"><td class="num" id="LN1258">1258</td><td class="line">    <span class='comment'>/* Case 2: cardinality of the single HLL.</span></td></tr>
<tr class="codeline" data-linenumber="1259"><td class="num" id="LN1259">1259</td><td class="line">     <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="1260"><td class="num" id="LN1260">1260</td><td class="line">     <span class='comment'>* The user specified a single key. Either return the cached value</span></td></tr>
<tr class="codeline" data-linenumber="1261"><td class="num" id="LN1261">1261</td><td class="line">     <span class='comment'>* or compute one and update the cache. */</span></td></tr>
<tr class="codeline" data-linenumber="1262"><td class="num" id="LN1262">1262</td><td class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[1]);</td></tr>
<tr class="codeline" data-linenumber="1263"><td class="num" id="LN1263">1263</td><td class="line">    <span class='keyword'>if</span> (o == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="1264"><td class="num" id="LN1264">1264</td><td class="line">        <span class='comment'>/* No key? Cardinality is zero since no element was added, otherwise</span></td></tr>
<tr class="codeline" data-linenumber="1265"><td class="num" id="LN1265">1265</td><td class="line">         <span class='comment'>* we would have a key as HLLADD creates it as a side effect. */</span></td></tr>
<tr class="codeline" data-linenumber="1266"><td class="num" id="LN1266">1266</td><td class="line">        addReply(c,shared.czero);</td></tr>
<tr class="codeline" data-linenumber="1267"><td class="num" id="LN1267">1267</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="1268"><td class="num" id="LN1268">1268</td><td class="line">        <span class='keyword'>if</span> (isHLLObjectOrReply(c,o) != <span class='macro'>C_OK<span class='macro_popup'>0</span></span>) <span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="1269"><td class="num" id="LN1269">1269</td><td class="line">        o = dbUnshareStringValue(c-&gt;db,c-&gt;argv[1],o);</td></tr>
<tr class="codeline" data-linenumber="1270"><td class="num" id="LN1270">1270</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1271"><td class="num" id="LN1271">1271</td><td class="line">        <span class='comment'>/* Check if the cached cardinality is valid. */</span></td></tr>
<tr class="codeline" data-linenumber="1272"><td class="num" id="LN1272">1272</td><td class="line">        hdr = o-&gt;ptr;</td></tr>
<tr class="codeline" data-linenumber="1273"><td class="num" id="LN1273">1273</td><td class="line">        <span class='keyword'>if</span> (<span class='macro'>HLL_VALID_CACHE(hdr)<span class='macro_popup'>(((hdr)-&gt;card[7] &amp; (1&lt;&lt;7)) == 0)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="1274"><td class="num" id="LN1274">1274</td><td class="line">            <span class='comment'>/* Just return the cached value. */</span></td></tr>
<tr class="codeline" data-linenumber="1275"><td class="num" id="LN1275">1275</td><td class="line">            card = (uint64_t)hdr-&gt;card[0];</td></tr>
<tr class="codeline" data-linenumber="1276"><td class="num" id="LN1276">1276</td><td class="line">            card |= (uint64_t)hdr-&gt;card[1] &lt;&lt; 8;</td></tr>
<tr class="codeline" data-linenumber="1277"><td class="num" id="LN1277">1277</td><td class="line">            card |= (uint64_t)hdr-&gt;card[2] &lt;&lt; 16;</td></tr>
<tr class="codeline" data-linenumber="1278"><td class="num" id="LN1278">1278</td><td class="line">            card |= (uint64_t)hdr-&gt;card[3] &lt;&lt; 24;</td></tr>
<tr class="codeline" data-linenumber="1279"><td class="num" id="LN1279">1279</td><td class="line">            card |= (uint64_t)hdr-&gt;card[4] &lt;&lt; 32;</td></tr>
<tr class="codeline" data-linenumber="1280"><td class="num" id="LN1280">1280</td><td class="line">            card |= (uint64_t)hdr-&gt;card[5] &lt;&lt; 40;</td></tr>
<tr class="codeline" data-linenumber="1281"><td class="num" id="LN1281">1281</td><td class="line">            card |= (uint64_t)hdr-&gt;card[6] &lt;&lt; 48;</td></tr>
<tr class="codeline" data-linenumber="1282"><td class="num" id="LN1282">1282</td><td class="line">            card |= (uint64_t)hdr-&gt;card[7] &lt;&lt; 56;</td></tr>
<tr class="codeline" data-linenumber="1283"><td class="num" id="LN1283">1283</td><td class="line">        } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="1284"><td class="num" id="LN1284">1284</td><td class="line">            <span class='keyword'>int</span> invalid = 0;</td></tr>
<tr class="codeline" data-linenumber="1285"><td class="num" id="LN1285">1285</td><td class="line">            <span class='comment'>/* Recompute it and update the cached value. */</span></td></tr>
<tr class="codeline" data-linenumber="1286"><td class="num" id="LN1286">1286</td><td class="line">            card = hllCount(hdr,&amp;invalid);</td></tr>
<tr class="codeline" data-linenumber="1287"><td class="num" id="LN1287">1287</td><td class="line">            <span class='keyword'>if</span> (invalid) {</td></tr>
<tr class="codeline" data-linenumber="1288"><td class="num" id="LN1288">1288</td><td class="line">                addReplySds(c,sdsnew(invalid_hll_err));</td></tr>
<tr class="codeline" data-linenumber="1289"><td class="num" id="LN1289">1289</td><td class="line">                <span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="1290"><td class="num" id="LN1290">1290</td><td class="line">            }</td></tr>
<tr class="codeline" data-linenumber="1291"><td class="num" id="LN1291">1291</td><td class="line">            hdr-&gt;card[0] = card &amp; 0xff;</td></tr>
<tr class="codeline" data-linenumber="1292"><td class="num" id="LN1292">1292</td><td class="line">            hdr-&gt;card[1] = (card &gt;&gt; 8) &amp; 0xff;</td></tr>
<tr class="codeline" data-linenumber="1293"><td class="num" id="LN1293">1293</td><td class="line">            hdr-&gt;card[2] = (card &gt;&gt; 16) &amp; 0xff;</td></tr>
<tr class="codeline" data-linenumber="1294"><td class="num" id="LN1294">1294</td><td class="line">            hdr-&gt;card[3] = (card &gt;&gt; 24) &amp; 0xff;</td></tr>
<tr class="codeline" data-linenumber="1295"><td class="num" id="LN1295">1295</td><td class="line">            hdr-&gt;card[4] = (card &gt;&gt; 32) &amp; 0xff;</td></tr>
<tr class="codeline" data-linenumber="1296"><td class="num" id="LN1296">1296</td><td class="line">            hdr-&gt;card[5] = (card &gt;&gt; 40) &amp; 0xff;</td></tr>
<tr class="codeline" data-linenumber="1297"><td class="num" id="LN1297">1297</td><td class="line">            hdr-&gt;card[6] = (card &gt;&gt; 48) &amp; 0xff;</td></tr>
<tr class="codeline" data-linenumber="1298"><td class="num" id="LN1298">1298</td><td class="line">            hdr-&gt;card[7] = (card &gt;&gt; 56) &amp; 0xff;</td></tr>
<tr class="codeline" data-linenumber="1299"><td class="num" id="LN1299">1299</td><td class="line">            <span class='comment'>/* This is not considered a read-only command even if the</span></td></tr>
<tr class="codeline" data-linenumber="1300"><td class="num" id="LN1300">1300</td><td class="line">             <span class='comment'>* data structure is not modified, since the cached value</span></td></tr>
<tr class="codeline" data-linenumber="1301"><td class="num" id="LN1301">1301</td><td class="line">             <span class='comment'>* may be modified and given that the HLL is a Redis string</span></td></tr>
<tr class="codeline" data-linenumber="1302"><td class="num" id="LN1302">1302</td><td class="line">             <span class='comment'>* we need to propagate the change. */</span></td></tr>
<tr class="codeline" data-linenumber="1303"><td class="num" id="LN1303">1303</td><td class="line">            signalModifiedKey(c,c-&gt;db,c-&gt;argv[1]);</td></tr>
<tr class="codeline" data-linenumber="1304"><td class="num" id="LN1304">1304</td><td class="line">            server.dirty++;</td></tr>
<tr class="codeline" data-linenumber="1305"><td class="num" id="LN1305">1305</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="1306"><td class="num" id="LN1306">1306</td><td class="line">        addReplyLongLong(c,card);</td></tr>
<tr class="codeline" data-linenumber="1307"><td class="num" id="LN1307">1307</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1308"><td class="num" id="LN1308">1308</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1309"><td class="num" id="LN1309">1309</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1310"><td class="num" id="LN1310">1310</td><td class="line"><span class='comment'>/* PFMERGE dest src1 src2 src3 ... srcN =&gt; OK */</span></td></tr>
<tr class="codeline" data-linenumber="1311"><td class="num" id="LN1311">1311</td><td class="line"><span class='keyword'>void</span> pfmergeCommand(client *c) {</td></tr>
<tr class="codeline" data-linenumber="1312"><td class="num" id="LN1312">1312</td><td class="line">    uint8_t max[<span class='macro'>HLL_REGISTERS<span class='macro_popup'>(1&lt;&lt;14)</span></span>];</td></tr>
<tr class="codeline" data-linenumber="1313"><td class="num" id="LN1313">1313</td><td class="line">    <span class='keyword'>struct</span> hllhdr *hdr;</td></tr>
<tr class="codeline" data-linenumber="1314"><td class="num" id="LN1314">1314</td><td class="line">    <span class='keyword'>int</span> j;</td></tr>
<tr class="codeline" data-linenumber="1315"><td class="num" id="LN1315">1315</td><td class="line">    <span class='keyword'>int</span> use_dense = 0; <span class='comment'>/* Use dense representation as target? */</span></td></tr>
<tr class="codeline" data-linenumber="1316"><td class="num" id="LN1316">1316</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1317"><td class="num" id="LN1317">1317</td><td class="line">    <span class='comment'>/* Compute an HLL with M[i] = MAX(M[i]_j).</span></td></tr>
<tr class="codeline" data-linenumber="1318"><td class="num" id="LN1318">1318</td><td class="line">     <span class='comment'>* We store the maximum into the max array of registers. We'll write</span></td></tr>
<tr class="codeline" data-linenumber="1319"><td class="num" id="LN1319">1319</td><td class="line">     <span class='comment'>* it to the target variable later. */</span></td></tr>
<tr class="codeline" data-linenumber="1320"><td class="num" id="LN1320">1320</td><td class="line">    memset(max,0,<span class='keyword'>sizeof</span>(max));</td></tr>
<tr class="codeline" data-linenumber="1321"><td class="num" id="LN1321">1321</td><td class="line">    <span class='keyword'>for</span> (j = 1; j &lt; c-&gt;argc; j++) {</td></tr>
<tr class="codeline" data-linenumber="1322"><td class="num" id="LN1322">1322</td><td class="line">        <span class='comment'>/* Check type and size. */</span></td></tr>
<tr class="codeline" data-linenumber="1323"><td class="num" id="LN1323">1323</td><td class="line">        robj *o = lookupKeyRead(c-&gt;db,c-&gt;argv[j]);</td></tr>
<tr class="codeline" data-linenumber="1324"><td class="num" id="LN1324">1324</td><td class="line">        <span class='keyword'>if</span> (o == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>) <span class='keyword'>continue</span>; <span class='comment'>/* Assume empty HLL for non existing var. */</span></td></tr>
<tr class="codeline" data-linenumber="1325"><td class="num" id="LN1325">1325</td><td class="line">        <span class='keyword'>if</span> (isHLLObjectOrReply(c,o) != <span class='macro'>C_OK<span class='macro_popup'>0</span></span>) <span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="1326"><td class="num" id="LN1326">1326</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1327"><td class="num" id="LN1327">1327</td><td class="line">        <span class='comment'>/* If at least one involved HLL is dense, use the dense representation</span></td></tr>
<tr class="codeline" data-linenumber="1328"><td class="num" id="LN1328">1328</td><td class="line">         <span class='comment'>* as target ASAP to save time and avoid the conversion step. */</span></td></tr>
<tr class="codeline" data-linenumber="1329"><td class="num" id="LN1329">1329</td><td class="line">        hdr = o-&gt;ptr;</td></tr>
<tr class="codeline" data-linenumber="1330"><td class="num" id="LN1330">1330</td><td class="line">        <span class='keyword'>if</span> (hdr-&gt;encoding == <span class='macro'>HLL_DENSE<span class='macro_popup'>0</span></span>) use_dense = 1;</td></tr>
<tr class="codeline" data-linenumber="1331"><td class="num" id="LN1331">1331</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1332"><td class="num" id="LN1332">1332</td><td class="line">        <span class='comment'>/* Merge with this HLL with our 'max' HLL by setting max[i]</span></td></tr>
<tr class="codeline" data-linenumber="1333"><td class="num" id="LN1333">1333</td><td class="line">         <span class='comment'>* to MAX(max[i],hll[i]). */</span></td></tr>
<tr class="codeline" data-linenumber="1334"><td class="num" id="LN1334">1334</td><td class="line">        <span class='keyword'>if</span> (hllMerge(max,o) == <span class='macro'>C_ERR<span class='macro_popup'>-1</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="1335"><td class="num" id="LN1335">1335</td><td class="line">            addReplySds(c,sdsnew(invalid_hll_err));</td></tr>
<tr class="codeline" data-linenumber="1336"><td class="num" id="LN1336">1336</td><td class="line">            <span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="1337"><td class="num" id="LN1337">1337</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="1338"><td class="num" id="LN1338">1338</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1339"><td class="num" id="LN1339">1339</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1340"><td class="num" id="LN1340">1340</td><td class="line">    <span class='comment'>/* Create / unshare the destination key's value if needed. */</span></td></tr>
<tr class="codeline" data-linenumber="1341"><td class="num" id="LN1341">1341</td><td class="line">    robj *o = lookupKeyWrite(c-&gt;db,c-&gt;argv[1]);</td></tr>
<tr class="codeline" data-linenumber="1342"><td class="num" id="LN1342">1342</td><td class="line">    <span class='keyword'>if</span> (o == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="1343"><td class="num" id="LN1343">1343</td><td class="line">        <span class='comment'>/* Create the key with a string value of the exact length to</span></td></tr>
<tr class="codeline" data-linenumber="1344"><td class="num" id="LN1344">1344</td><td class="line">         <span class='comment'>* hold our HLL data structure. sdsnewlen() when NULL is passed</span></td></tr>
<tr class="codeline" data-linenumber="1345"><td class="num" id="LN1345">1345</td><td class="line">         <span class='comment'>* is guaranteed to return bytes initialized to zero. */</span></td></tr>
<tr class="codeline" data-linenumber="1346"><td class="num" id="LN1346">1346</td><td class="line">        o = createHLLObject();</td></tr>
<tr class="codeline" data-linenumber="1347"><td class="num" id="LN1347">1347</td><td class="line">        dbAdd(c-&gt;db,c-&gt;argv[1],o);</td></tr>
<tr class="codeline" data-linenumber="1348"><td class="num" id="LN1348">1348</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="1349"><td class="num" id="LN1349">1349</td><td class="line">        <span class='comment'>/* If key exists we are sure it's of the right type/size</span></td></tr>
<tr class="codeline" data-linenumber="1350"><td class="num" id="LN1350">1350</td><td class="line">         <span class='comment'>* since we checked when merging the different HLLs, so we</span></td></tr>
<tr class="codeline" data-linenumber="1351"><td class="num" id="LN1351">1351</td><td class="line">         <span class='comment'>* don't check again. */</span></td></tr>
<tr class="codeline" data-linenumber="1352"><td class="num" id="LN1352">1352</td><td class="line">        o = dbUnshareStringValue(c-&gt;db,c-&gt;argv[1],o);</td></tr>
<tr class="codeline" data-linenumber="1353"><td class="num" id="LN1353">1353</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1354"><td class="num" id="LN1354">1354</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1355"><td class="num" id="LN1355">1355</td><td class="line">    <span class='comment'>/* Convert the destination object to dense representation if at least</span></td></tr>
<tr class="codeline" data-linenumber="1356"><td class="num" id="LN1356">1356</td><td class="line">     <span class='comment'>* one of the inputs was dense. */</span></td></tr>
<tr class="codeline" data-linenumber="1357"><td class="num" id="LN1357">1357</td><td class="line">    <span class='keyword'>if</span> (use_dense &amp;&amp; hllSparseToDense(o) == <span class='macro'>C_ERR<span class='macro_popup'>-1</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="1358"><td class="num" id="LN1358">1358</td><td class="line">        addReplySds(c,sdsnew(invalid_hll_err));</td></tr>
<tr class="codeline" data-linenumber="1359"><td class="num" id="LN1359">1359</td><td class="line">        <span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="1360"><td class="num" id="LN1360">1360</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1361"><td class="num" id="LN1361">1361</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1362"><td class="num" id="LN1362">1362</td><td class="line">    <span class='comment'>/* Write the resulting HLL to the destination HLL registers and</span></td></tr>
<tr class="codeline" data-linenumber="1363"><td class="num" id="LN1363">1363</td><td class="line">     <span class='comment'>* invalidate the cached value. */</span></td></tr>
<tr class="codeline" data-linenumber="1364"><td class="num" id="LN1364">1364</td><td class="line">    <span class='keyword'>for</span> (j = 0; j &lt; <span class='macro'>HLL_REGISTERS<span class='macro_popup'>(1&lt;&lt;14)</span></span>; j++) {</td></tr>
<tr class="codeline" data-linenumber="1365"><td class="num" id="LN1365">1365</td><td class="line">        <span class='keyword'>if</span> (max[j] == 0) <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="1366"><td class="num" id="LN1366">1366</td><td class="line">        hdr = o-&gt;ptr;</td></tr>
<tr class="codeline" data-linenumber="1367"><td class="num" id="LN1367">1367</td><td class="line">        <span class='keyword'>switch</span>(hdr-&gt;encoding) {</td></tr>
<tr class="codeline" data-linenumber="1368"><td class="num" id="LN1368">1368</td><td class="line">        <span class='keyword'>case</span> <span class='macro'>HLL_DENSE<span class='macro_popup'>0</span></span>: hllDenseSet(hdr-&gt;registers,j,max[j]); <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="1369"><td class="num" id="LN1369">1369</td><td class="line">        <span class='keyword'>case</span> <span class='macro'>HLL_SPARSE<span class='macro_popup'>1</span></span>: hllSparseSet(o,j,max[j]); <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="1370"><td class="num" id="LN1370">1370</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="1371"><td class="num" id="LN1371">1371</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1372"><td class="num" id="LN1372">1372</td><td class="line">    hdr = o-&gt;ptr; <span class='comment'>/* o-&gt;ptr may be different now, as a side effect of</span></td></tr>
<tr class="codeline" data-linenumber="1373"><td class="num" id="LN1373">1373</td><td class="line">                     <span class='comment'>last hllSparseSet() call. */</span></td></tr>
<tr class="codeline" data-linenumber="1374"><td class="num" id="LN1374">1374</td><td class="line">    <span class='macro'>HLL_INVALIDATE_CACHE(hdr)<span class='macro_popup'>(hdr)-&gt;card[7] |= (1&lt;&lt;7)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1375"><td class="num" id="LN1375">1375</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1376"><td class="num" id="LN1376">1376</td><td class="line">    signalModifiedKey(c,c-&gt;db,c-&gt;argv[1]);</td></tr>
<tr class="codeline" data-linenumber="1377"><td class="num" id="LN1377">1377</td><td class="line">    <span class='comment'>/* We generate a PFADD event for PFMERGE for semantical simplicity</span></td></tr>
<tr class="codeline" data-linenumber="1378"><td class="num" id="LN1378">1378</td><td class="line">     <span class='comment'>* since in theory this is a mass-add of elements. */</span></td></tr>
<tr class="codeline" data-linenumber="1379"><td class="num" id="LN1379">1379</td><td class="line">    notifyKeyspaceEvent(<span class='macro'>NOTIFY_STRING<span class='macro_popup'>(1&lt;&lt;3)</span></span>,<span class='string_literal'>"pfadd"</span>,c-&gt;argv[1],c-&gt;db-&gt;id);</td></tr>
<tr class="codeline" data-linenumber="1380"><td class="num" id="LN1380">1380</td><td class="line">    server.dirty++;</td></tr>
<tr class="codeline" data-linenumber="1381"><td class="num" id="LN1381">1381</td><td class="line">    addReply(c,shared.ok);</td></tr>
<tr class="codeline" data-linenumber="1382"><td class="num" id="LN1382">1382</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1383"><td class="num" id="LN1383">1383</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1384"><td class="num" id="LN1384">1384</td><td class="line"><span class='comment'>/* ========================== Testing / Debugging  ========================== */</span></td></tr>
<tr class="codeline" data-linenumber="1385"><td class="num" id="LN1385">1385</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1386"><td class="num" id="LN1386">1386</td><td class="line"><span class='comment'>/* PFSELFTEST</span></td></tr>
<tr class="codeline" data-linenumber="1387"><td class="num" id="LN1387">1387</td><td class="line"> <span class='comment'>* This command performs a self-test of the HLL registers implementation.</span></td></tr>
<tr class="codeline" data-linenumber="1388"><td class="num" id="LN1388">1388</td><td class="line"> <span class='comment'>* Something that is not easy to test from within the outside. */</span></td></tr>
<tr class="codeline" data-linenumber="1389"><td class="num" id="LN1389">1389</td><td class="line"><span class='directive'>#define <span class='macro'>HLL_TEST_CYCLES<span class='macro_popup'>1000</span></span> 1000</span></td></tr>
<tr class="codeline" data-linenumber="1390"><td class="num" id="LN1390">1390</td><td class="line"><span class='keyword'>void</span> pfselftestCommand(client *c) {</td></tr>
<tr class="codeline" data-linenumber="1391"><td class="num" id="LN1391">1391</td><td class="line">    <span class='keyword'>unsigned</span> <span class='keyword'>int</span> j, i;</td></tr>
<tr class="codeline" data-linenumber="1392"><td class="num" id="LN1392">1392</td><td class="line">    sds bitcounters = sdsnewlen(<span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>,<span class='macro'>HLL_DENSE_SIZE<span class='macro_popup'>(sizeof(struct hllhdr)+(((1&lt;&lt;14)*6 +7)/8))</span></span>);</td></tr>
<tr class="codeline" data-linenumber="1393"><td class="num" id="LN1393">1393</td><td class="line">    <span class='keyword'>struct</span> hllhdr *hdr = (<span class='keyword'>struct</span> hllhdr*) bitcounters, *hdr2;</td></tr>
<tr class="codeline" data-linenumber="1394"><td class="num" id="LN1394">1394</td><td class="line">    robj *o = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1395"><td class="num" id="LN1395">1395</td><td class="line">    uint8_t bytecounters[<span class='macro'>HLL_REGISTERS<span class='macro_popup'>(1&lt;&lt;14)</span></span>];</td></tr>
<tr class="codeline" data-linenumber="1396"><td class="num" id="LN1396">1396</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1397"><td class="num" id="LN1397">1397</td><td class="line">    <span class='comment'>/* Test 1: access registers.</span></td></tr>
<tr class="codeline" data-linenumber="1398"><td class="num" id="LN1398">1398</td><td class="line">     <span class='comment'>* The test is conceived to test that the different counters of our data</span></td></tr>
<tr class="codeline" data-linenumber="1399"><td class="num" id="LN1399">1399</td><td class="line">     <span class='comment'>* structure are accessible and that setting their values both result in</span></td></tr>
<tr class="codeline" data-linenumber="1400"><td class="num" id="LN1400">1400</td><td class="line">     <span class='comment'>* the correct value to be retained and not affect adjacent values. */</span></td></tr>
<tr class="codeline" data-linenumber="1401"><td class="num" id="LN1401">1401</td><td class="line">    <span class='keyword'>for</span> (j = 0; j &lt; <span class='macro'>HLL_TEST_CYCLES<span class='macro_popup'>1000</span></span>; j++) {</td></tr>
<tr class="codeline" data-linenumber="1402"><td class="num" id="LN1402">1402</td><td class="line">        <span class='comment'>/* Set the HLL counters and an array of unsigned byes of the</span></td></tr>
<tr class="codeline" data-linenumber="1403"><td class="num" id="LN1403">1403</td><td class="line">         <span class='comment'>* same size to the same set of random values. */</span></td></tr>
<tr class="codeline" data-linenumber="1404"><td class="num" id="LN1404">1404</td><td class="line">        <span class='keyword'>for</span> (i = 0; i &lt; <span class='macro'>HLL_REGISTERS<span class='macro_popup'>(1&lt;&lt;14)</span></span>; i++) {</td></tr>
<tr class="codeline" data-linenumber="1405"><td class="num" id="LN1405">1405</td><td class="line">            <span class='keyword'>unsigned</span> <span class='keyword'>int</span> r = rand() &amp; <span class='macro'>HLL_REGISTER_MAX<span class='macro_popup'>((1&lt;&lt;6)-1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1406"><td class="num" id="LN1406">1406</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1407"><td class="num" id="LN1407">1407</td><td class="line">            bytecounters[i] = r;</td></tr>
<tr class="codeline" data-linenumber="1408"><td class="num" id="LN1408">1408</td><td class="line">            <span class='macro'>HLL_DENSE_SET_REGISTER(hdr-&gt;registers,i,r)<span class='macro_popup'>do { uint8_t *_p = (uint8_t*) hdr-&gt;registers; unsigned long<br> _byte = i*6/8; unsigned long _fb = i*6&amp;7; unsigned long _fb8<br> = 8 - _fb; unsigned long _v = r; _p[_byte] &amp;= ~(((1&lt;&lt;<br>6)-1) &lt;&lt; _fb); _p[_byte] |= _v &lt;&lt; _fb; _p[_byte+1<br>] &amp;= ~(((1&lt;&lt;6)-1) &gt;&gt; _fb8); _p[_byte+1] |= _v<br> &gt;&gt; _fb8; } while(0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1409"><td class="num" id="LN1409">1409</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="1410"><td class="num" id="LN1410">1410</td><td class="line">        <span class='comment'>/* Check that we are able to retrieve the same values. */</span></td></tr>
<tr class="codeline" data-linenumber="1411"><td class="num" id="LN1411">1411</td><td class="line">        <span class='keyword'>for</span> (i = 0; i &lt; <span class='macro'>HLL_REGISTERS<span class='macro_popup'>(1&lt;&lt;14)</span></span>; i++) {</td></tr>
<tr class="codeline" data-linenumber="1412"><td class="num" id="LN1412">1412</td><td class="line">            <span class='keyword'>unsigned</span> <span class='keyword'>int</span> val;</td></tr>
<tr class="codeline" data-linenumber="1413"><td class="num" id="LN1413">1413</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1414"><td class="num" id="LN1414">1414</td><td class="line">            <span class='macro'>HLL_DENSE_GET_REGISTER(val,hdr-&gt;registers,i)<span class='macro_popup'>do { uint8_t *_p = (uint8_t*) hdr-&gt;registers; unsigned long<br> _byte = i*6/8; unsigned long _fb = i*6&amp;7; unsigned long _fb8<br> = 8 - _fb; unsigned long b0 = _p[_byte]; unsigned long b1 = _p<br>[_byte+1]; val = ((b0 &gt;&gt; _fb) | (b1 &lt;&lt; _fb8)) &amp;<br> ((1&lt;&lt;6)-1); } while(0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1415"><td class="num" id="LN1415">1415</td><td class="line">            <span class='keyword'>if</span> (val != bytecounters[i]) {</td></tr>
<tr class="codeline" data-linenumber="1416"><td class="num" id="LN1416">1416</td><td class="line">                addReplyErrorFormat(c,</td></tr>
<tr class="codeline" data-linenumber="1417"><td class="num" id="LN1417">1417</td><td class="line">                    <span class='string_literal'>"TESTFAILED Register %d should be %d but is %d"</span>,</td></tr>
<tr class="codeline" data-linenumber="1418"><td class="num" id="LN1418">1418</td><td class="line">                    i, (<span class='keyword'>int</span>) bytecounters[i], (<span class='keyword'>int</span>) val);</td></tr>
<tr class="codeline" data-linenumber="1419"><td class="num" id="LN1419">1419</td><td class="line">                <span class='keyword'>goto</span> cleanup;</td></tr>
<tr class="codeline" data-linenumber="1420"><td class="num" id="LN1420">1420</td><td class="line">            }</td></tr>
<tr class="codeline" data-linenumber="1421"><td class="num" id="LN1421">1421</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="1422"><td class="num" id="LN1422">1422</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1423"><td class="num" id="LN1423">1423</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1424"><td class="num" id="LN1424">1424</td><td class="line">    <span class='comment'>/* Test 2: approximation error.</span></td></tr>
<tr class="codeline" data-linenumber="1425"><td class="num" id="LN1425">1425</td><td class="line">     <span class='comment'>* The test adds unique elements and check that the estimated value</span></td></tr>
<tr class="codeline" data-linenumber="1426"><td class="num" id="LN1426">1426</td><td class="line">     <span class='comment'>* is always reasonable bounds.</span></td></tr>
<tr class="codeline" data-linenumber="1427"><td class="num" id="LN1427">1427</td><td class="line">     <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="1428"><td class="num" id="LN1428">1428</td><td class="line">     <span class='comment'>* We check that the error is smaller than a few times than the expected</span></td></tr>
<tr class="codeline" data-linenumber="1429"><td class="num" id="LN1429">1429</td><td class="line">     <span class='comment'>* standard error, to make it very unlikely for the test to fail because</span></td></tr>
<tr class="codeline" data-linenumber="1430"><td class="num" id="LN1430">1430</td><td class="line">     <span class='comment'>* of a "bad" run.</span></td></tr>
<tr class="codeline" data-linenumber="1431"><td class="num" id="LN1431">1431</td><td class="line">     <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="1432"><td class="num" id="LN1432">1432</td><td class="line">     <span class='comment'>* The test is performed with both dense and sparse HLLs at the same</span></td></tr>
<tr class="codeline" data-linenumber="1433"><td class="num" id="LN1433">1433</td><td class="line">     <span class='comment'>* time also verifying that the computed cardinality is the same. */</span></td></tr>
<tr class="codeline" data-linenumber="1434"><td class="num" id="LN1434">1434</td><td class="line">    memset(hdr-&gt;registers,0,<span class='macro'>HLL_DENSE_SIZE<span class='macro_popup'>(sizeof(struct hllhdr)+(((1&lt;&lt;14)*6 +7)/8))</span></span>-<span class='macro'>HLL_HDR_SIZE<span class='macro_popup'>sizeof(struct hllhdr)</span></span>);</td></tr>
<tr class="codeline" data-linenumber="1435"><td class="num" id="LN1435">1435</td><td class="line">    o = createHLLObject();</td></tr>
<tr class="codeline" data-linenumber="1436"><td class="num" id="LN1436">1436</td><td class="line">    <span class='keyword'>double</span> relerr = 1.04/sqrt(<span class='macro'>HLL_REGISTERS<span class='macro_popup'>(1&lt;&lt;14)</span></span>);</td></tr>
<tr class="codeline" data-linenumber="1437"><td class="num" id="LN1437">1437</td><td class="line">    int64_t checkpoint = 1;</td></tr>
<tr class="codeline" data-linenumber="1438"><td class="num" id="LN1438">1438</td><td class="line">    uint64_t seed = (uint64_t)rand() | (uint64_t)rand() &lt;&lt; 32;</td></tr>
<tr class="codeline" data-linenumber="1439"><td class="num" id="LN1439">1439</td><td class="line">    uint64_t ele;</td></tr>
<tr class="codeline" data-linenumber="1440"><td class="num" id="LN1440">1440</td><td class="line">    <span class='keyword'>for</span> (j = 1; j &lt;= 10000000; j++) {</td></tr>
<tr class="codeline" data-linenumber="1441"><td class="num" id="LN1441">1441</td><td class="line">        ele = j ^ seed;</td></tr>
<tr class="codeline" data-linenumber="1442"><td class="num" id="LN1442">1442</td><td class="line">        hllDenseAdd(hdr-&gt;registers,(<span class='keyword'>unsigned</span> <span class='keyword'>char</span>*)&amp;ele,<span class='keyword'>sizeof</span>(ele));</td></tr>
<tr class="codeline" data-linenumber="1443"><td class="num" id="LN1443">1443</td><td class="line">        hllAdd(o,(<span class='keyword'>unsigned</span> <span class='keyword'>char</span>*)&amp;ele,<span class='keyword'>sizeof</span>(ele));</td></tr>
<tr class="codeline" data-linenumber="1444"><td class="num" id="LN1444">1444</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1445"><td class="num" id="LN1445">1445</td><td class="line">        <span class='comment'>/* Make sure that for small cardinalities we use sparse</span></td></tr>
<tr class="codeline" data-linenumber="1446"><td class="num" id="LN1446">1446</td><td class="line">         <span class='comment'>* encoding. */</span></td></tr>
<tr class="codeline" data-linenumber="1447"><td class="num" id="LN1447">1447</td><td class="line">        <span class='keyword'>if</span> (j == checkpoint &amp;&amp; j &lt; server.hll_sparse_max_bytes/2) {</td></tr>
<tr class="codeline" data-linenumber="1448"><td class="num" id="LN1448">1448</td><td class="line">            hdr2 = o-&gt;ptr;</td></tr>
<tr class="codeline" data-linenumber="1449"><td class="num" id="LN1449">1449</td><td class="line">            <span class='keyword'>if</span> (hdr2-&gt;encoding != <span class='macro'>HLL_SPARSE<span class='macro_popup'>1</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="1450"><td class="num" id="LN1450">1450</td><td class="line">                addReplyError(c, <span class='string_literal'>"TESTFAILED sparse encoding not used"</span>);</td></tr>
<tr class="codeline" data-linenumber="1451"><td class="num" id="LN1451">1451</td><td class="line">                <span class='keyword'>goto</span> cleanup;</td></tr>
<tr class="codeline" data-linenumber="1452"><td class="num" id="LN1452">1452</td><td class="line">            }</td></tr>
<tr class="codeline" data-linenumber="1453"><td class="num" id="LN1453">1453</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="1454"><td class="num" id="LN1454">1454</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1455"><td class="num" id="LN1455">1455</td><td class="line">        <span class='comment'>/* Check that dense and sparse representations agree. */</span></td></tr>
<tr class="codeline" data-linenumber="1456"><td class="num" id="LN1456">1456</td><td class="line">        <span class='keyword'>if</span> (j == checkpoint &amp;&amp; hllCount(hdr,<span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>) != hllCount(o-&gt;ptr,<span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>)) {</td></tr>
<tr class="codeline" data-linenumber="1457"><td class="num" id="LN1457">1457</td><td class="line">                addReplyError(c, <span class='string_literal'>"TESTFAILED dense/sparse disagree"</span>);</td></tr>
<tr class="codeline" data-linenumber="1458"><td class="num" id="LN1458">1458</td><td class="line">                <span class='keyword'>goto</span> cleanup;</td></tr>
<tr class="codeline" data-linenumber="1459"><td class="num" id="LN1459">1459</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="1460"><td class="num" id="LN1460">1460</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1461"><td class="num" id="LN1461">1461</td><td class="line">        <span class='comment'>/* Check error. */</span></td></tr>
<tr class="codeline" data-linenumber="1462"><td class="num" id="LN1462">1462</td><td class="line">        <span class='keyword'>if</span> (j == checkpoint) {</td></tr>
<tr class="codeline" data-linenumber="1463"><td class="num" id="LN1463">1463</td><td class="line">            int64_t abserr = checkpoint - (int64_t)hllCount(hdr,<span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>);</td></tr>
<tr class="codeline" data-linenumber="1464"><td class="num" id="LN1464">1464</td><td class="line">            uint64_t maxerr = ceil(relerr*6*checkpoint);</td></tr>
<tr class="codeline" data-linenumber="1465"><td class="num" id="LN1465">1465</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1466"><td class="num" id="LN1466">1466</td><td class="line">            <span class='comment'>/* Adjust the max error we expect for cardinality 10</span></td></tr>
<tr class="codeline" data-linenumber="1467"><td class="num" id="LN1467">1467</td><td class="line">             <span class='comment'>* since from time to time it is statistically likely to get</span></td></tr>
<tr class="codeline" data-linenumber="1468"><td class="num" id="LN1468">1468</td><td class="line">             <span class='comment'>* much higher error due to collision, resulting into a false</span></td></tr>
<tr class="codeline" data-linenumber="1469"><td class="num" id="LN1469">1469</td><td class="line">             <span class='comment'>* positive. */</span></td></tr>
<tr class="codeline" data-linenumber="1470"><td class="num" id="LN1470">1470</td><td class="line">            <span class='keyword'>if</span> (j == 10) maxerr = 1;</td></tr>
<tr class="codeline" data-linenumber="1471"><td class="num" id="LN1471">1471</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1472"><td class="num" id="LN1472">1472</td><td class="line">            <span class='keyword'>if</span> (abserr &lt; 0) abserr = -abserr;</td></tr>
<tr class="codeline" data-linenumber="1473"><td class="num" id="LN1473">1473</td><td class="line">            <span class='keyword'>if</span> (abserr &gt; (int64_t)maxerr) {</td></tr>
<tr class="codeline" data-linenumber="1474"><td class="num" id="LN1474">1474</td><td class="line">                addReplyErrorFormat(c,</td></tr>
<tr class="codeline" data-linenumber="1475"><td class="num" id="LN1475">1475</td><td class="line">                    <span class='string_literal'>"TESTFAILED Too big error. card:%llu abserr:%llu"</span>,</td></tr>
<tr class="codeline" data-linenumber="1476"><td class="num" id="LN1476">1476</td><td class="line">                    (<span class='keyword'>unsigned</span> <span class='keyword'>long</span> <span class='keyword'>long</span>) checkpoint,</td></tr>
<tr class="codeline" data-linenumber="1477"><td class="num" id="LN1477">1477</td><td class="line">                    (<span class='keyword'>unsigned</span> <span class='keyword'>long</span> <span class='keyword'>long</span>) abserr);</td></tr>
<tr class="codeline" data-linenumber="1478"><td class="num" id="LN1478">1478</td><td class="line">                <span class='keyword'>goto</span> cleanup;</td></tr>
<tr class="codeline" data-linenumber="1479"><td class="num" id="LN1479">1479</td><td class="line">            }</td></tr>
<tr class="codeline" data-linenumber="1480"><td class="num" id="LN1480">1480</td><td class="line">            checkpoint *= 10;</td></tr>
<tr class="codeline" data-linenumber="1481"><td class="num" id="LN1481">1481</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="1482"><td class="num" id="LN1482">1482</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1483"><td class="num" id="LN1483">1483</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1484"><td class="num" id="LN1484">1484</td><td class="line">    <span class='comment'>/* Success! */</span></td></tr>
<tr class="codeline" data-linenumber="1485"><td class="num" id="LN1485">1485</td><td class="line">    addReply(c,shared.ok);</td></tr>
<tr class="codeline" data-linenumber="1486"><td class="num" id="LN1486">1486</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1487"><td class="num" id="LN1487">1487</td><td class="line">cleanup:</td></tr>
<tr class="codeline" data-linenumber="1488"><td class="num" id="LN1488">1488</td><td class="line">    sdsfree(bitcounters);</td></tr>
<tr class="codeline" data-linenumber="1489"><td class="num" id="LN1489">1489</td><td class="line">    <span class='keyword'>if</span> (o) decrRefCount(o);</td></tr>
<tr class="codeline" data-linenumber="1490"><td class="num" id="LN1490">1490</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1491"><td class="num" id="LN1491">1491</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1492"><td class="num" id="LN1492">1492</td><td class="line"><span class='comment'>/* PFDEBUG &lt;subcommand&gt; &lt;key&gt; ... args ...</span></td></tr>
<tr class="codeline" data-linenumber="1493"><td class="num" id="LN1493">1493</td><td class="line"> <span class='comment'>* Different debugging related operations about the HLL implementation. */</span></td></tr>
<tr class="codeline" data-linenumber="1494"><td class="num" id="LN1494">1494</td><td class="line"><span class='keyword'>void</span> pfdebugCommand(client *c) {</td></tr>
<tr class="codeline" data-linenumber="1495"><td class="num" id="LN1495">1495</td><td class="line">    <span class='keyword'>char</span> *cmd = c-&gt;argv[1]-&gt;ptr;</td></tr>
<tr class="codeline" data-linenumber="1496"><td class="num" id="LN1496">1496</td><td class="line">    <span class='keyword'>struct</span> hllhdr *hdr;</td></tr>
<tr class="codeline" data-linenumber="1497"><td class="num" id="LN1497">1497</td><td class="line">    robj *o;</td></tr>
<tr class="codeline" data-linenumber="1498"><td class="num" id="LN1498">1498</td><td class="line">    <span class='keyword'>int</span> j;</td></tr>
<tr class="codeline" data-linenumber="1499"><td class="num" id="LN1499">1499</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1500"><td class="num" id="LN1500">1500</td><td class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[2]);</td></tr>
<tr class="codeline" data-linenumber="1501"><td class="num" id="LN1501">1501</td><td class="line">    <span class='keyword'>if</span> (o == <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="1502"><td class="num" id="LN1502">1502</td><td class="line">        addReplyError(c,<span class='string_literal'>"The specified key does not exist"</span>);</td></tr>
<tr class="codeline" data-linenumber="1503"><td class="num" id="LN1503">1503</td><td class="line">        <span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="1504"><td class="num" id="LN1504">1504</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1505"><td class="num" id="LN1505">1505</td><td class="line">    <span class='keyword'>if</span> (isHLLObjectOrReply(c,o) != <span class='macro'>C_OK<span class='macro_popup'>0</span></span>) <span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="1506"><td class="num" id="LN1506">1506</td><td class="line">    o = dbUnshareStringValue(c-&gt;db,c-&gt;argv[2],o);</td></tr>
<tr class="codeline" data-linenumber="1507"><td class="num" id="LN1507">1507</td><td class="line">    hdr = o-&gt;ptr;</td></tr>
<tr class="codeline" data-linenumber="1508"><td class="num" id="LN1508">1508</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1509"><td class="num" id="LN1509">1509</td><td class="line">    <span class='comment'>/* PFDEBUG GETREG &lt;key&gt; */</span></td></tr>
<tr class="codeline" data-linenumber="1510"><td class="num" id="LN1510">1510</td><td class="line">    <span class='keyword'>if</span> (!strcasecmp(cmd,<span class='string_literal'>"getreg"</span>)) {</td></tr>
<tr class="codeline" data-linenumber="1511"><td class="num" id="LN1511">1511</td><td class="line">        <span class='keyword'>if</span> (c-&gt;argc != 3) <span class='keyword'>goto</span> arityerr;</td></tr>
<tr class="codeline" data-linenumber="1512"><td class="num" id="LN1512">1512</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1513"><td class="num" id="LN1513">1513</td><td class="line">        <span class='keyword'>if</span> (hdr-&gt;encoding == <span class='macro'>HLL_SPARSE<span class='macro_popup'>1</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="1514"><td class="num" id="LN1514">1514</td><td class="line">            <span class='keyword'>if</span> (hllSparseToDense(o) == <span class='macro'>C_ERR<span class='macro_popup'>-1</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="1515"><td class="num" id="LN1515">1515</td><td class="line">                addReplySds(c,sdsnew(invalid_hll_err));</td></tr>
<tr class="codeline" data-linenumber="1516"><td class="num" id="LN1516">1516</td><td class="line">                <span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="1517"><td class="num" id="LN1517">1517</td><td class="line">            }</td></tr>
<tr class="codeline" data-linenumber="1518"><td class="num" id="LN1518">1518</td><td class="line">            server.dirty++; <span class='comment'>/* Force propagation on encoding change. */</span></td></tr>
<tr class="codeline" data-linenumber="1519"><td class="num" id="LN1519">1519</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="1520"><td class="num" id="LN1520">1520</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1521"><td class="num" id="LN1521">1521</td><td class="line">        hdr = o-&gt;ptr;</td></tr>
<tr class="codeline" data-linenumber="1522"><td class="num" id="LN1522">1522</td><td class="line">        addReplyArrayLen(c,<span class='macro'>HLL_REGISTERS<span class='macro_popup'>(1&lt;&lt;14)</span></span>);</td></tr>
<tr class="codeline" data-linenumber="1523"><td class="num" id="LN1523">1523</td><td class="line">        <span class='keyword'>for</span> (j = 0; j &lt; <span class='macro'>HLL_REGISTERS<span class='macro_popup'>(1&lt;&lt;14)</span></span>; j++) {</td></tr>
<tr class="codeline" data-linenumber="1524"><td class="num" id="LN1524">1524</td><td class="line">            uint8_t val;</td></tr>
<tr class="codeline" data-linenumber="1525"><td class="num" id="LN1525">1525</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1526"><td class="num" id="LN1526">1526</td><td class="line">            <span class='macro'>HLL_DENSE_GET_REGISTER(val,hdr-&gt;registers,j)<span class='macro_popup'>do { uint8_t *_p = (uint8_t*) hdr-&gt;registers; unsigned long<br> _byte = j*6/8; unsigned long _fb = j*6&amp;7; unsigned long _fb8<br> = 8 - _fb; unsigned long b0 = _p[_byte]; unsigned long b1 = _p<br>[_byte+1]; val = ((b0 &gt;&gt; _fb) | (b1 &lt;&lt; _fb8)) &amp;<br> ((1&lt;&lt;6)-1); } while(0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1527"><td class="num" id="LN1527">1527</td><td class="line">            addReplyLongLong(c,val);</td></tr>
<tr class="codeline" data-linenumber="1528"><td class="num" id="LN1528">1528</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="1529"><td class="num" id="LN1529">1529</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1530"><td class="num" id="LN1530">1530</td><td class="line">    <span class='comment'>/* PFDEBUG DECODE &lt;key&gt; */</span></td></tr>
<tr class="codeline" data-linenumber="1531"><td class="num" id="LN1531">1531</td><td class="line">    <span class='keyword'>else</span> <span class='keyword'>if</span> (!strcasecmp(cmd,<span class='string_literal'>"decode"</span>)) {</td></tr>
<tr class="codeline" data-linenumber="1532"><td class="num" id="LN1532">1532</td><td class="line">        <span class='keyword'>if</span> (c-&gt;argc != 3) <span class='keyword'>goto</span> arityerr;</td></tr>
<tr class="codeline" data-linenumber="1533"><td class="num" id="LN1533">1533</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1534"><td class="num" id="LN1534">1534</td><td class="line">        uint8_t *p = o-&gt;ptr, *end = p+sdslen(o-&gt;ptr);</td></tr>
<tr class="codeline" data-linenumber="1535"><td class="num" id="LN1535">1535</td><td class="line">        sds decoded = sdsempty();</td></tr>
<tr class="codeline" data-linenumber="1536"><td class="num" id="LN1536">1536</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1537"><td class="num" id="LN1537">1537</td><td class="line">        <span class='keyword'>if</span> (hdr-&gt;encoding != <span class='macro'>HLL_SPARSE<span class='macro_popup'>1</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="1538"><td class="num" id="LN1538">1538</td><td class="line">            sdsfree(decoded);</td></tr>
<tr class="codeline" data-linenumber="1539"><td class="num" id="LN1539">1539</td><td class="line">            addReplyError(c,<span class='string_literal'>"HLL encoding is not sparse"</span>);</td></tr>
<tr class="codeline" data-linenumber="1540"><td class="num" id="LN1540">1540</td><td class="line">            <span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="1541"><td class="num" id="LN1541">1541</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="1542"><td class="num" id="LN1542">1542</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1543"><td class="num" id="LN1543">1543</td><td class="line">        p += <span class='macro'>HLL_HDR_SIZE<span class='macro_popup'>sizeof(struct hllhdr)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1544"><td class="num" id="LN1544">1544</td><td class="line">        <span class='keyword'>while</span>(p &lt; end) {</td></tr>
<tr class="codeline" data-linenumber="1545"><td class="num" id="LN1545">1545</td><td class="line">            <span class='keyword'>int</span> runlen, regval;</td></tr>
<tr class="codeline" data-linenumber="1546"><td class="num" id="LN1546">1546</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1547"><td class="num" id="LN1547">1547</td><td class="line">            <span class='keyword'>if</span> (<span class='macro'>HLL_SPARSE_IS_ZERO(p)<span class='macro_popup'>(((*(p)) &amp; 0xc0) == 0)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="1548"><td class="num" id="LN1548">1548</td><td class="line">                runlen = <span class='macro'>HLL_SPARSE_ZERO_LEN(p)<span class='macro_popup'>(((*(p)) &amp; 0x3f)+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1549"><td class="num" id="LN1549">1549</td><td class="line">                p++;</td></tr>
<tr class="codeline" data-linenumber="1550"><td class="num" id="LN1550">1550</td><td class="line">                decoded = sdscatprintf(decoded,<span class='string_literal'>"z:%d "</span>,runlen);</td></tr>
<tr class="codeline" data-linenumber="1551"><td class="num" id="LN1551">1551</td><td class="line">            } <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>HLL_SPARSE_IS_XZERO(p)<span class='macro_popup'>(((*(p)) &amp; 0xc0) == 0x40)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="1552"><td class="num" id="LN1552">1552</td><td class="line">                runlen = <span class='macro'>HLL_SPARSE_XZERO_LEN(p)<span class='macro_popup'>(((((*(p)) &amp; 0x3f) &lt;&lt; 8) | (*((p)+1)))+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1553"><td class="num" id="LN1553">1553</td><td class="line">                p += 2;</td></tr>
<tr class="codeline" data-linenumber="1554"><td class="num" id="LN1554">1554</td><td class="line">                decoded = sdscatprintf(decoded,<span class='string_literal'>"Z:%d "</span>,runlen);</td></tr>
<tr class="codeline" data-linenumber="1555"><td class="num" id="LN1555">1555</td><td class="line">            } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="1556"><td class="num" id="LN1556">1556</td><td class="line">                runlen = <span class='macro'>HLL_SPARSE_VAL_LEN(p)<span class='macro_popup'>(((*(p)) &amp; 0x3)+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1557"><td class="num" id="LN1557">1557</td><td class="line">                regval = <span class='macro'>HLL_SPARSE_VAL_VALUE(p)<span class='macro_popup'>((((*(p)) &gt;&gt; 2) &amp; 0x1f)+1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1558"><td class="num" id="LN1558">1558</td><td class="line">                p++;</td></tr>
<tr class="codeline" data-linenumber="1559"><td class="num" id="LN1559">1559</td><td class="line">                decoded = sdscatprintf(decoded,<span class='string_literal'>"v:%d,%d "</span>,regval,runlen);</td></tr>
<tr class="codeline" data-linenumber="1560"><td class="num" id="LN1560">1560</td><td class="line">            }</td></tr>
<tr class="codeline" data-linenumber="1561"><td class="num" id="LN1561">1561</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="1562"><td class="num" id="LN1562">1562</td><td class="line">        decoded = sdstrim(decoded,<span class='string_literal'>" "</span>);</td></tr>
<tr class="codeline" data-linenumber="1563"><td class="num" id="LN1563">1563</td><td class="line">        addReplyBulkCBuffer(c,decoded,sdslen(decoded));</td></tr>
<tr class="codeline" data-linenumber="1564"><td class="num" id="LN1564">1564</td><td class="line">        sdsfree(decoded);</td></tr>
<tr class="codeline" data-linenumber="1565"><td class="num" id="LN1565">1565</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1566"><td class="num" id="LN1566">1566</td><td class="line">    <span class='comment'>/* PFDEBUG ENCODING &lt;key&gt; */</span></td></tr>
<tr class="codeline" data-linenumber="1567"><td class="num" id="LN1567">1567</td><td class="line">    <span class='keyword'>else</span> <span class='keyword'>if</span> (!strcasecmp(cmd,<span class='string_literal'>"encoding"</span>)) {</td></tr>
<tr class="codeline" data-linenumber="1568"><td class="num" id="LN1568">1568</td><td class="line">        <span class='keyword'>char</span> *encodingstr[2] = {<span class='string_literal'>"dense"</span>,<span class='string_literal'>"sparse"</span>};</td></tr>
<tr class="codeline" data-linenumber="1569"><td class="num" id="LN1569">1569</td><td class="line">        <span class='keyword'>if</span> (c-&gt;argc != 3) <span class='keyword'>goto</span> arityerr;</td></tr>
<tr class="codeline" data-linenumber="1570"><td class="num" id="LN1570">1570</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1571"><td class="num" id="LN1571">1571</td><td class="line">        addReplyStatus(c,encodingstr[hdr-&gt;encoding]);</td></tr>
<tr class="codeline" data-linenumber="1572"><td class="num" id="LN1572">1572</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1573"><td class="num" id="LN1573">1573</td><td class="line">    <span class='comment'>/* PFDEBUG TODENSE &lt;key&gt; */</span></td></tr>
<tr class="codeline" data-linenumber="1574"><td class="num" id="LN1574">1574</td><td class="line">    <span class='keyword'>else</span> <span class='keyword'>if</span> (!strcasecmp(cmd,<span class='string_literal'>"todense"</span>)) {</td></tr>
<tr class="codeline" data-linenumber="1575"><td class="num" id="LN1575">1575</td><td class="line">        <span class='keyword'>int</span> conv = 0;</td></tr>
<tr class="codeline" data-linenumber="1576"><td class="num" id="LN1576">1576</td><td class="line">        <span class='keyword'>if</span> (c-&gt;argc != 3) <span class='keyword'>goto</span> arityerr;</td></tr>
<tr class="codeline" data-linenumber="1577"><td class="num" id="LN1577">1577</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1578"><td class="num" id="LN1578">1578</td><td class="line">        <span class='keyword'>if</span> (hdr-&gt;encoding == <span class='macro'>HLL_SPARSE<span class='macro_popup'>1</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="1579"><td class="num" id="LN1579">1579</td><td class="line">            <span class='keyword'>if</span> (hllSparseToDense(o) == <span class='macro'>C_ERR<span class='macro_popup'>-1</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="1580"><td class="num" id="LN1580">1580</td><td class="line">                addReplySds(c,sdsnew(invalid_hll_err));</td></tr>
<tr class="codeline" data-linenumber="1581"><td class="num" id="LN1581">1581</td><td class="line">                <span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="1582"><td class="num" id="LN1582">1582</td><td class="line">            }</td></tr>
<tr class="codeline" data-linenumber="1583"><td class="num" id="LN1583">1583</td><td class="line">            conv = 1;</td></tr>
<tr class="codeline" data-linenumber="1584"><td class="num" id="LN1584">1584</td><td class="line">            server.dirty++; <span class='comment'>/* Force propagation on encoding change. */</span></td></tr>
<tr class="codeline" data-linenumber="1585"><td class="num" id="LN1585">1585</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="1586"><td class="num" id="LN1586">1586</td><td class="line">        addReply(c,conv ? shared.cone : shared.czero);</td></tr>
<tr class="codeline" data-linenumber="1587"><td class="num" id="LN1587">1587</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="1588"><td class="num" id="LN1588">1588</td><td class="line">        addReplyErrorFormat(c,<span class='string_literal'>"Unknown PFDEBUG subcommand '%s'"</span>, cmd);</td></tr>
<tr class="codeline" data-linenumber="1589"><td class="num" id="LN1589">1589</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1590"><td class="num" id="LN1590">1590</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="1591"><td class="num" id="LN1591">1591</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1592"><td class="num" id="LN1592">1592</td><td class="line">arityerr:</td></tr>
<tr class="codeline" data-linenumber="1593"><td class="num" id="LN1593">1593</td><td class="line">    addReplyErrorFormat(c,</td></tr>
<tr class="codeline" data-linenumber="1594"><td class="num" id="LN1594">1594</td><td class="line">        <span class='string_literal'>"Wrong number of arguments for the '%s' subcommand"</span>,cmd);</td></tr>
<tr class="codeline" data-linenumber="1595"><td class="num" id="LN1595">1595</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1596"><td class="num" id="LN1596">1596</td><td class="line"> </td></tr>
</table></body></html>
