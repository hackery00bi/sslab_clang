<!doctype html>
<html>
<head>
<title>lj_str.c</title>

<style type="text/css">
body { color:#000000; background-color:#ffffff }
body { font-family:Helvetica, sans-serif; font-size:10pt }
h1 { font-size:14pt }
.FileName { margin-top: 5px; margin-bottom: 5px; display: inline; }
.FileNav { margin-left: 5px; margin-right: 5px; display: inline; }
.FileNav a { text-decoration:none; font-size: larger; }
.divider { margin-top: 30px; margin-bottom: 30px; height: 15px; }
.divider { background-color: gray; }
.code { border-collapse:collapse; width:100%; }
.code { font-family: "Monospace", monospace; font-size:10pt }
.code { line-height: 1.2em }
.comment { color: green; font-style: oblique }
.keyword { color: blue }
.string_literal { color: red }
.directive { color: darkmagenta }

/* Macros and variables could have pop-up notes hidden by default.
  - Macro pop-up:    expansion of the macro
  - Variable pop-up: value (table) of the variable */
.macro_popup, .variable_popup { display: none; }

/* Pop-up appears on mouse-hover event. */
.macro:hover .macro_popup, .variable:hover .variable_popup {
  display: block;
  padding: 2px;
  -webkit-border-radius:5px;
  -webkit-box-shadow:1px 1px 7px #000;
  border-radius:5px;
  box-shadow:1px 1px 7px #000;
  position: absolute;
  top: -1em;
  left:10em;
  z-index: 1
}

.macro_popup {
  border: 2px solid red;
  background-color:#FFF0F0;
  font-weight: normal;
}

.variable_popup {
  border: 2px solid blue;
  background-color:#F0F0FF;
  font-weight: bold;
  font-family: Helvetica, sans-serif;
  font-size: 9pt;
}

/* Pop-up notes needs a relative position as a base where they pops up. */
.macro, .variable {
  background-color: PaleGoldenRod;
  position: relative;
}
.macro { color: DarkMagenta; }

#tooltiphint {
  position: fixed;
  width: 50em;
  margin-left: -25em;
  left: 50%;
  padding: 10px;
  border: 1px solid #b0b0b0;
  border-radius: 2px;
  box-shadow: 1px 1px 7px black;
  background-color: #c0c0c0;
  z-index: 2;
}

.num { width:2.5em; padding-right:2ex; background-color:#eeeeee }
.num { text-align:right; font-size:8pt }
.num { color:#444444 }
.line { padding-left: 1ex; border-left: 3px solid #ccc }
.line { white-space: pre }
.msg { -webkit-box-shadow:1px 1px 7px #000 }
.msg { box-shadow:1px 1px 7px #000 }
.msg { -webkit-border-radius:5px }
.msg { border-radius:5px }
.msg { font-family:Helvetica, sans-serif; font-size:8pt }
.msg { float:left }
.msg { padding:0.25em 1ex 0.25em 1ex }
.msg { margin-top:10px; margin-bottom:10px }
.msg { font-weight:bold }
.msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }
.msgT { padding:0x; spacing:0x }
.msgEvent { background-color:#fff8b4; color:#000000 }
.msgControl { background-color:#bbbbbb; color:#000000 }
.msgNote { background-color:#ddeeff; color:#000000 }
.mrange { background-color:#dfddf3 }
.mrange { border-bottom:1px solid #6F9DBE }
.PathIndex { font-weight: bold; padding:0px 5px; margin-right:5px; }
.PathIndex { -webkit-border-radius:8px }
.PathIndex { border-radius:8px }
.PathIndexEvent { background-color:#bfba87 }
.PathIndexControl { background-color:#8c8c8c }
.PathIndexPopUp { background-color: #879abc; }
.PathNav a { text-decoration:none; font-size: larger }
.CodeInsertionHint { font-weight: bold; background-color: #10dd10 }
.CodeRemovalHint { background-color:#de1010 }
.CodeRemovalHint { border-bottom:1px solid #6F9DBE }
.selected{ background-color:orange !important; }

table.simpletable {
  padding: 5px;
  font-size:12pt;
  margin:20px;
  border-collapse: collapse; border-spacing: 0px;
}
td.rowname {
  text-align: right;
  vertical-align: top;
  font-weight: bold;
  color:#444444;
  padding-right:2ex;
}

/* Hidden text. */
input.spoilerhider + label {
  cursor: pointer;
  text-decoration: underline;
  display: block;
}
input.spoilerhider {
 display: none;
}
input.spoilerhider ~ .spoiler {
  overflow: hidden;
  margin: 10px auto 0;
  height: 0;
  opacity: 0;
}
input.spoilerhider:checked + label + .spoiler{
  height: auto;
  opacity: 1;
}
</style>
</head>
<body>
<!-- BUGDESC Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 -->

<!-- BUGTYPE Potential insecure memory buffer bounds restriction in call 'memcpy' -->

<!-- BUGCATEGORY Security -->

<!-- BUGFILE /tmp/real/c_wrk/wrk0/obj/LuaJIT-2.1.0-beta3/src/lj_str.c -->

<!-- FILENAME lj_str.c -->

<!-- FUNCTIONNAME lj_str_new -->

<!-- ISSUEHASHCONTENTOFLINEINCONTEXT bfa26ab1636a6920bcfcf47c3f0b4ebb -->

<!-- BUGLINE 180 -->

<!-- BUGCOLUMN 3 -->

<!-- BUGPATHLENGTH 1 -->

<!-- BUGMETAEND -->
<!-- REPORTHEADER -->
<h3>Bug Summary</h3>
<table class="simpletable">
<tr><td class="rowname">File:</td><td>lj_str.c</td></tr>
<tr><td class="rowname">Warning:</td><td><a href="#EndPath">line 180, column 3</a><br />Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11</td></tr>

</table>
<!-- REPORTSUMMARYEXTRA -->
<h3>Annotated Source Code</h3>
<p>Press <a href="#" onclick="toggleHelp(); return false;">'?'</a>
   to see keyboard shortcuts</p>
<input type="checkbox" class="spoilerhider" id="showinvocation" />
<label for="showinvocation" >Show analyzer invocation</label>
<div class="spoiler">clang -cc1 -cc1 -triple x86_64-unknown-linux-gnu -analyze -disable-free -main-file-name lj_str.c -analyzer-store=region -analyzer-opt-analyze-nested-blocks -analyzer-checker=core -analyzer-checker=apiModeling -analyzer-checker=unix -analyzer-checker=deadcode -analyzer-checker=security.insecureAPI.UncheckedReturn -analyzer-checker=security.insecureAPI.getpw -analyzer-checker=security.insecureAPI.gets -analyzer-checker=security.insecureAPI.mktemp -analyzer-checker=security.insecureAPI.mkstemp -analyzer-checker=security.insecureAPI.vfork -analyzer-checker=nullability.NullPassedToNonnull -analyzer-checker=nullability.NullReturnedFromNonnull -analyzer-output plist -w -setup-static-analyzer -mrelocation-model static -mframe-pointer=none -fmath-errno -fno-rounding-math -mconstructor-aliases -munwind-tables -target-cpu x86-64 -fno-split-dwarf-inlining -debugger-tuning=gdb -resource-dir /llvm-project/build/lib/clang/12.0.0 -D _FILE_OFFSET_BITS=64 -D _LARGEFILE_SOURCE -U _FORTIFY_SOURCE -D LUA_ROOT="/tmp/real/c_wrk/wrk0/obj" -D LUA_MULTILIB="lib" -internal-isystem /usr/local/include -internal-isystem /llvm-project/build/lib/clang/12.0.0/include -internal-externc-isystem /usr/include/x86_64-linux-gnu -internal-externc-isystem /include -internal-externc-isystem /usr/include -O2 -fdebug-compilation-dir /tmp/real/c_wrk/wrk0/obj/LuaJIT-2.1.0-beta3/src -ferror-limit 19 -fgnuc-version=4.2.1 -vectorize-loops -vectorize-slp -analyzer-checker core -analyzer-checker cplusplus -analyzer-checker nullability -analyzer-checker optin -analyzer-checker security -analyzer-checker unix -analyzer-checker osx -analyzer-checker fuchsia -analyzer-checker webkit -analyzer-output=html -faddrsig -o /tmp/scan-build-2020-11-20-010034-2981-1 -x c lj_str.c
</div>
<div id='tooltiphint' hidden="true">
  <p>Keyboard shortcuts: </p>
  <ul>
    <li>Use 'j/k' keys for keyboard navigation</li>
    <li>Use 'Shift+S' to show/hide relevant lines</li>
    <li>Use '?' to toggle this window</li>
  </ul>
  <a href="#" onclick="toggleHelp(); return false;">Close</a>
</div>
<script type='text/javascript'>
var relevant_lines = {"1": {"180": 1}};

var filterCounterexample = function (hide) {
  var tables = document.getElementsByClassName("code");
  for (var t=0; t<tables.length; t++) {
    var table = tables[t];
    var file_id = table.getAttribute("data-fileid");
    var lines_in_fid = relevant_lines[file_id];
    if (!lines_in_fid) {
      lines_in_fid = {};
    }
    var lines = table.getElementsByClassName("codeline");
    for (var i=0; i<lines.length; i++) {
        var el = lines[i];
        var lineNo = el.getAttribute("data-linenumber");
        if (!lines_in_fid[lineNo]) {
          if (hide) {
            el.setAttribute("hidden", "");
          } else {
            el.removeAttribute("hidden");
          }
        }
    }
  }
}

window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.key == "S") {
    var checked = document.getElementsByName("showCounterexample")[0].checked;
    filterCounterexample(!checked);
    document.getElementsByName("showCounterexample")[0].checked = !checked;
  } else {
    return;
  }
  event.preventDefault();
}, true);

document.addEventListener("DOMContentLoaded", function() {
    document.querySelector('input[name="showCounterexample"]').onchange=
        function (event) {
      filterCounterexample(this.checked);
    };
});
</script>

<form>
    <input type="checkbox" name="showCounterexample" id="showCounterexample" />
    <label for="showCounterexample">
       Show only relevant lines
    </label>
</form>

<script type='text/javascript'>
var digitMatcher = new RegExp("[0-9]+");

var querySelectorAllArray = function(selector) {
  return Array.prototype.slice.call(
    document.querySelectorAll(selector));
}

document.addEventListener("DOMContentLoaded", function() {
    querySelectorAllArray(".PathNav > a").forEach(
        function(currentValue, currentIndex) {
            var hrefValue = currentValue.getAttribute("href");
            currentValue.onclick = function() {
                scrollTo(document.querySelector(hrefValue));
                return false;
            };
        });
});

var findNum = function() {
    var s = document.querySelector(".selected");
    if (!s || s.id == "EndPath") {
        return 0;
    }
    var out = parseInt(digitMatcher.exec(s.id)[0]);
    return out;
};

var scrollTo = function(el) {
    querySelectorAllArray(".selected").forEach(function(s) {
        s.classList.remove("selected");
    });
    el.classList.add("selected");
    window.scrollBy(0, el.getBoundingClientRect().top -
        (window.innerHeight / 2));
}

var move = function(num, up, numItems) {
  if (num == 1 && up || num == numItems - 1 && !up) {
    return 0;
  } else if (num == 0 && up) {
    return numItems - 1;
  } else if (num == 0 && !up) {
    return 1 % numItems;
  }
  return up ? num - 1 : num + 1;
}

var numToId = function(num) {
  if (num == 0) {
    return document.getElementById("EndPath")
  }
  return document.getElementById("Path" + num);
};

var navigateTo = function(up) {
  var numItems = document.querySelectorAll(
      ".line > .msgEvent, .line > .msgControl").length;
  var currentSelected = findNum();
  var newSelected = move(currentSelected, up, numItems);
  var newEl = numToId(newSelected, numItems);

  // Scroll element into center.
  scrollTo(newEl);
};

window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.key == "j") {
    navigateTo(/*up=*/false);
  } else if (event.key == "k") {
    navigateTo(/*up=*/true);
  } else {
    return;
  }
  event.preventDefault();
}, true);
</script>
  
<script type='text/javascript'>

var toggleHelp = function() {
    var hint = document.querySelector("#tooltiphint");
    var attributeName = "hidden";
    if (hint.hasAttribute(attributeName)) {
      hint.removeAttribute(attributeName);
    } else {
      hint.setAttribute("hidden", "true");
    }
};
window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.key == "?") {
    toggleHelp();
  } else {
    return;
  }
  event.preventDefault();
});
</script>
<table class="code" data-fileid="1">
<tr class="codeline" data-linenumber="1"><td class="num" id="LN1">1</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="2"><td class="num" id="LN2">2</td><td class="line"><span class='comment'>** String handling.</span></td></tr>
<tr class="codeline" data-linenumber="3"><td class="num" id="LN3">3</td><td class="line"><span class='comment'>** Copyright (C) 2005-2017 Mike Pall. See Copyright Notice in luajit.h</span></td></tr>
<tr class="codeline" data-linenumber="4"><td class="num" id="LN4">4</td><td class="line"><span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="5"><td class="num" id="LN5">5</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="6"><td class="num" id="LN6">6</td><td class="line"><span class='directive'>#define lj_str_c</span></td></tr>
<tr class="codeline" data-linenumber="7"><td class="num" id="LN7">7</td><td class="line"><span class='directive'>#define LUA_CORE</span></td></tr>
<tr class="codeline" data-linenumber="8"><td class="num" id="LN8">8</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="9"><td class="num" id="LN9">9</td><td class="line"><span class='directive'>#include "lj_obj.h"</span></td></tr>
<tr class="codeline" data-linenumber="10"><td class="num" id="LN10">10</td><td class="line"><span class='directive'>#include "lj_gc.h"</span></td></tr>
<tr class="codeline" data-linenumber="11"><td class="num" id="LN11">11</td><td class="line"><span class='directive'>#include "lj_err.h"</span></td></tr>
<tr class="codeline" data-linenumber="12"><td class="num" id="LN12">12</td><td class="line"><span class='directive'>#include "lj_str.h"</span></td></tr>
<tr class="codeline" data-linenumber="13"><td class="num" id="LN13">13</td><td class="line"><span class='directive'>#include "lj_char.h"</span></td></tr>
<tr class="codeline" data-linenumber="14"><td class="num" id="LN14">14</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="15"><td class="num" id="LN15">15</td><td class="line"><span class='comment'>/* -- String helpers ------------------------------------------------------ */</span></td></tr>
<tr class="codeline" data-linenumber="16"><td class="num" id="LN16">16</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="17"><td class="num" id="LN17">17</td><td class="line"><span class='comment'>/* Ordered compare of strings. Assumes string data is 4-byte aligned. */</span></td></tr>
<tr class="codeline" data-linenumber="18"><td class="num" id="LN18">18</td><td class="line">int32_t LJ_FASTCALL lj_str_cmp(GCstr *a, GCstr *b)</td></tr>
<tr class="codeline" data-linenumber="19"><td class="num" id="LN19">19</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="20"><td class="num" id="LN20">20</td><td class="line">  MSize i, n = a-&gt;len &gt; b-&gt;len ? b-&gt;len : a-&gt;len;</td></tr>
<tr class="codeline" data-linenumber="21"><td class="num" id="LN21">21</td><td class="line">  <span class='keyword'>for</span> (i = 0; i &lt; n; i += 4) {</td></tr>
<tr class="codeline" data-linenumber="22"><td class="num" id="LN22">22</td><td class="line">    <span class='comment'>/* Note: innocuous access up to end of string + 3. */</span></td></tr>
<tr class="codeline" data-linenumber="23"><td class="num" id="LN23">23</td><td class="line">    uint32_t va = *(<span class='keyword'>const</span> uint32_t *)(<span class='macro'>strdata(a)<span class='macro_popup'>((const char *)((a)+1))</span></span>+i);</td></tr>
<tr class="codeline" data-linenumber="24"><td class="num" id="LN24">24</td><td class="line">    uint32_t vb = *(<span class='keyword'>const</span> uint32_t *)(<span class='macro'>strdata(b)<span class='macro_popup'>((const char *)((b)+1))</span></span>+i);</td></tr>
<tr class="codeline" data-linenumber="25"><td class="num" id="LN25">25</td><td class="line">    <span class='keyword'>if</span> (va != vb) {</td></tr>
<tr class="codeline" data-linenumber="26"><td class="num" id="LN26">26</td><td class="line"><span class='directive'>#if <span class='macro'>LJ_LE<span class='macro_popup'>1</span></span></span></td></tr>
<tr class="codeline" data-linenumber="27"><td class="num" id="LN27">27</td><td class="line">      va = lj_bswap(va); vb = lj_bswap(vb);</td></tr>
<tr class="codeline" data-linenumber="28"><td class="num" id="LN28">28</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="29"><td class="num" id="LN29">29</td><td class="line">      i -= n;</td></tr>
<tr class="codeline" data-linenumber="30"><td class="num" id="LN30">30</td><td class="line">      <span class='keyword'>if</span> ((int32_t)i &gt;= -3) {</td></tr>
<tr class="codeline" data-linenumber="31"><td class="num" id="LN31">31</td><td class="line">	va &gt;&gt;= 32+(i&lt;&lt;3); vb &gt;&gt;= 32+(i&lt;&lt;3);</td></tr>
<tr class="codeline" data-linenumber="32"><td class="num" id="LN32">32</td><td class="line">	<span class='keyword'>if</span> (va == vb) <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="33"><td class="num" id="LN33">33</td><td class="line">      }</td></tr>
<tr class="codeline" data-linenumber="34"><td class="num" id="LN34">34</td><td class="line">      <span class='keyword'>return</span> va &lt; vb ? -1 : 1;</td></tr>
<tr class="codeline" data-linenumber="35"><td class="num" id="LN35">35</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="36"><td class="num" id="LN36">36</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="37"><td class="num" id="LN37">37</td><td class="line">  <span class='keyword'>return</span> (int32_t)(a-&gt;len - b-&gt;len);</td></tr>
<tr class="codeline" data-linenumber="38"><td class="num" id="LN38">38</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="39"><td class="num" id="LN39">39</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="40"><td class="num" id="LN40">40</td><td class="line"><span class='comment'>/* Fast string data comparison. Caveat: unaligned access to 1st string! */</span></td></tr>
<tr class="codeline" data-linenumber="41"><td class="num" id="LN41">41</td><td class="line"><span class='keyword'>static</span> <span class='macro'>LJ_AINLINE<span class='macro_popup'>inline __attribute__((always_inline))</span></span> <span class='keyword'>int</span> str_fastcmp(<span class='keyword'>const</span> <span class='keyword'>char</span> *a, <span class='keyword'>const</span> <span class='keyword'>char</span> *b, MSize len)</td></tr>
<tr class="codeline" data-linenumber="42"><td class="num" id="LN42">42</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="43"><td class="num" id="LN43">43</td><td class="line">  MSize i = 0;</td></tr>
<tr class="codeline" data-linenumber="44"><td class="num" id="LN44">44</td><td class="line">  <span class='macro'>lua_assert(len &gt; 0)<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="45"><td class="num" id="LN45">45</td><td class="line">  <span class='macro'>lua_assert((((uintptr_t)a+len-1) &amp; (LJ_PAGESIZE-1)) &lt;= LJ_PAGESIZE-4)<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="46"><td class="num" id="LN46">46</td><td class="line">  <span class='keyword'>do</span> {  <span class='comment'>/* Note: innocuous access up to end of string + 3. */</span></td></tr>
<tr class="codeline" data-linenumber="47"><td class="num" id="LN47">47</td><td class="line">    uint32_t v = lj_getu32(a+i) ^ *(<span class='keyword'>const</span> uint32_t *)(b+i);</td></tr>
<tr class="codeline" data-linenumber="48"><td class="num" id="LN48">48</td><td class="line">    <span class='keyword'>if</span> (v) {</td></tr>
<tr class="codeline" data-linenumber="49"><td class="num" id="LN49">49</td><td class="line">      i -= len;</td></tr>
<tr class="codeline" data-linenumber="50"><td class="num" id="LN50">50</td><td class="line"><span class='directive'>#if <span class='macro'>LJ_LE<span class='macro_popup'>1</span></span></span></td></tr>
<tr class="codeline" data-linenumber="51"><td class="num" id="LN51">51</td><td class="line">      <span class='keyword'>return</span> (int32_t)i &gt;= -3 ? (v &lt;&lt; (32+(i&lt;&lt;3))) : 1;</td></tr>
<tr class="codeline" data-linenumber="52"><td class="num" id="LN52">52</td><td class="line"><span class='directive'>#else</span></td></tr>
<tr class="codeline" data-linenumber="53"><td class="num" id="LN53">53</td><td class="line">      <span class='keyword'>return</span> (int32_t)i &gt;= -3 ? (v &gt;&gt; (32+(i&lt;&lt;3))) : 1;</td></tr>
<tr class="codeline" data-linenumber="54"><td class="num" id="LN54">54</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="55"><td class="num" id="LN55">55</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="56"><td class="num" id="LN56">56</td><td class="line">    i += 4;</td></tr>
<tr class="codeline" data-linenumber="57"><td class="num" id="LN57">57</td><td class="line">  } <span class='keyword'>while</span> (i &lt; len);</td></tr>
<tr class="codeline" data-linenumber="58"><td class="num" id="LN58">58</td><td class="line">  <span class='keyword'>return</span> 0;</td></tr>
<tr class="codeline" data-linenumber="59"><td class="num" id="LN59">59</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="60"><td class="num" id="LN60">60</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="61"><td class="num" id="LN61">61</td><td class="line"><span class='comment'>/* Find fixed string p inside string s. */</span></td></tr>
<tr class="codeline" data-linenumber="62"><td class="num" id="LN62">62</td><td class="line"><span class='keyword'>const</span> <span class='keyword'>char</span> *lj_str_find(<span class='keyword'>const</span> <span class='keyword'>char</span> *s, <span class='keyword'>const</span> <span class='keyword'>char</span> *p, MSize slen, MSize plen)</td></tr>
<tr class="codeline" data-linenumber="63"><td class="num" id="LN63">63</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="64"><td class="num" id="LN64">64</td><td class="line">  <span class='keyword'>if</span> (plen &lt;= slen) {</td></tr>
<tr class="codeline" data-linenumber="65"><td class="num" id="LN65">65</td><td class="line">    <span class='keyword'>if</span> (plen == 0) {</td></tr>
<tr class="codeline" data-linenumber="66"><td class="num" id="LN66">66</td><td class="line">      <span class='keyword'>return</span> s;</td></tr>
<tr class="codeline" data-linenumber="67"><td class="num" id="LN67">67</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="68"><td class="num" id="LN68">68</td><td class="line">      <span class='keyword'>int</span> c = *(<span class='keyword'>const</span> uint8_t *)p++;</td></tr>
<tr class="codeline" data-linenumber="69"><td class="num" id="LN69">69</td><td class="line">      plen--; slen -= plen;</td></tr>
<tr class="codeline" data-linenumber="70"><td class="num" id="LN70">70</td><td class="line">      <span class='keyword'>while</span> (slen) {</td></tr>
<tr class="codeline" data-linenumber="71"><td class="num" id="LN71">71</td><td class="line">	<span class='keyword'>const</span> <span class='keyword'>char</span> *q = (<span class='keyword'>const</span> <span class='keyword'>char</span> *)memchr(s, c, slen);</td></tr>
<tr class="codeline" data-linenumber="72"><td class="num" id="LN72">72</td><td class="line">	<span class='keyword'>if</span> (!q) <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="73"><td class="num" id="LN73">73</td><td class="line">	<span class='keyword'>if</span> (memcmp(q+1, p, plen) == 0) <span class='keyword'>return</span> q;</td></tr>
<tr class="codeline" data-linenumber="74"><td class="num" id="LN74">74</td><td class="line">	q++; slen -= (MSize)(q-s); s = q;</td></tr>
<tr class="codeline" data-linenumber="75"><td class="num" id="LN75">75</td><td class="line">      }</td></tr>
<tr class="codeline" data-linenumber="76"><td class="num" id="LN76">76</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="77"><td class="num" id="LN77">77</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="78"><td class="num" id="LN78">78</td><td class="line">  <span class='keyword'>return</span> <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="79"><td class="num" id="LN79">79</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="80"><td class="num" id="LN80">80</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="81"><td class="num" id="LN81">81</td><td class="line"><span class='comment'>/* Check whether a string has a pattern matching character. */</span></td></tr>
<tr class="codeline" data-linenumber="82"><td class="num" id="LN82">82</td><td class="line"><span class='keyword'>int</span> lj_str_haspattern(GCstr *s)</td></tr>
<tr class="codeline" data-linenumber="83"><td class="num" id="LN83">83</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="84"><td class="num" id="LN84">84</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>char</span> *p = <span class='macro'>strdata(s)<span class='macro_popup'>((const char *)((s)+1))</span></span>, *q = p + s-&gt;len;</td></tr>
<tr class="codeline" data-linenumber="85"><td class="num" id="LN85">85</td><td class="line">  <span class='keyword'>while</span> (p &lt; q) {</td></tr>
<tr class="codeline" data-linenumber="86"><td class="num" id="LN86">86</td><td class="line">    <span class='keyword'>int</span> c = *(<span class='keyword'>const</span> uint8_t *)p++;</td></tr>
<tr class="codeline" data-linenumber="87"><td class="num" id="LN87">87</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>lj_char_ispunct(c)<span class='macro_popup'>((lj_char_bits+1)[((c))] &amp; 0x04)</span></span> &amp;&amp; strchr(<span class='string_literal'>"^$*+?.([%-"</span>, c))</td></tr>
<tr class="codeline" data-linenumber="88"><td class="num" id="LN88">88</td><td class="line">      <span class='keyword'>return</span> 1;  <span class='comment'>/* Found a pattern matching char. */</span></td></tr>
<tr class="codeline" data-linenumber="89"><td class="num" id="LN89">89</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="90"><td class="num" id="LN90">90</td><td class="line">  <span class='keyword'>return</span> 0;  <span class='comment'>/* No pattern matching chars found. */</span></td></tr>
<tr class="codeline" data-linenumber="91"><td class="num" id="LN91">91</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="92"><td class="num" id="LN92">92</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="93"><td class="num" id="LN93">93</td><td class="line"><span class='comment'>/* -- String interning ---------------------------------------------------- */</span></td></tr>
<tr class="codeline" data-linenumber="94"><td class="num" id="LN94">94</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="95"><td class="num" id="LN95">95</td><td class="line"><span class='comment'>/* Resize the string hash table (grow and shrink). */</span></td></tr>
<tr class="codeline" data-linenumber="96"><td class="num" id="LN96">96</td><td class="line"><span class='keyword'>void</span> lj_str_resize(lua_State *L, MSize newmask)</td></tr>
<tr class="codeline" data-linenumber="97"><td class="num" id="LN97">97</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="98"><td class="num" id="LN98">98</td><td class="line">  global_State *g = <span class='macro'>G(L)<span class='macro_popup'>(((global_State *)(void *)(uintptr_t)(L-&gt;glref).ptr32))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="99"><td class="num" id="LN99">99</td><td class="line">  GCRef *newhash;</td></tr>
<tr class="codeline" data-linenumber="100"><td class="num" id="LN100">100</td><td class="line">  MSize i;</td></tr>
<tr class="codeline" data-linenumber="101"><td class="num" id="LN101">101</td><td class="line">  <span class='keyword'>if</span> (g-&gt;gc.state == GCSsweepstring || newmask &gt;= <span class='macro'>LJ_MAX_STRTAB<span class='macro_popup'>(1&lt;&lt;26)</span></span>-1)</td></tr>
<tr class="codeline" data-linenumber="102"><td class="num" id="LN102">102</td><td class="line">    <span class='keyword'>return</span>;  <span class='comment'>/* No resizing during GC traversal or if already too big. */</span></td></tr>
<tr class="codeline" data-linenumber="103"><td class="num" id="LN103">103</td><td class="line">  newhash = <span class='macro'>lj_mem_newvec(L, newmask+1, GCRef)<span class='macro_popup'>((GCRef *)lj_mem_realloc(L, ((void*)0), 0, ((GCSize)((newmask<br>+1)*sizeof(GCRef)))))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="104"><td class="num" id="LN104">104</td><td class="line">  memset(newhash, 0, (newmask+1)*<span class='keyword'>sizeof</span>(GCRef));</td></tr>
<tr class="codeline" data-linenumber="105"><td class="num" id="LN105">105</td><td class="line">  <span class='keyword'>for</span> (i = g-&gt;strmask; i != ~(MSize)0; i--) {  <span class='comment'>/* Rehash old table. */</span></td></tr>
<tr class="codeline" data-linenumber="106"><td class="num" id="LN106">106</td><td class="line">    GCobj *p = <span class='macro'>gcref(g-&gt;strhash[i])<span class='macro_popup'>((GCobj *)(uintptr_t)(g-&gt;strhash[i]).gcptr32)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="107"><td class="num" id="LN107">107</td><td class="line">    <span class='keyword'>while</span> (p) {  <span class='comment'>/* Follow each hash chain and reinsert all strings. */</span></td></tr>
<tr class="codeline" data-linenumber="108"><td class="num" id="LN108">108</td><td class="line">      MSize h = <span class='macro'>gco2str(p)<span class='macro_popup'>(&amp;(p)-&gt;str)</span></span>-&gt;hash &amp; newmask;</td></tr>
<tr class="codeline" data-linenumber="109"><td class="num" id="LN109">109</td><td class="line">      GCobj *next = <span class='macro'>gcnext(p)<span class='macro_popup'>(((GCobj *)(uintptr_t)((p)-&gt;gch.nextgc).gcptr32))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="110"><td class="num" id="LN110">110</td><td class="line">      <span class='comment'>/* NOBARRIER: The string table is a GC root. */</span></td></tr>
<tr class="codeline" data-linenumber="111"><td class="num" id="LN111">111</td><td class="line">      <span class='macro'>setgcrefr(p-&gt;gch.nextgc, newhash[h])<span class='macro_popup'>((p-&gt;gch.nextgc).gcptr32 = (newhash[h]).gcptr32)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="112"><td class="num" id="LN112">112</td><td class="line">      <span class='macro'>setgcref(newhash[h], p)<span class='macro_popup'>((newhash[h]).gcptr32 = (uint32_t)(uintptr_t)&amp;(p)-&gt;gch<br>)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="113"><td class="num" id="LN113">113</td><td class="line">      p = next;</td></tr>
<tr class="codeline" data-linenumber="114"><td class="num" id="LN114">114</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="115"><td class="num" id="LN115">115</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="116"><td class="num" id="LN116">116</td><td class="line">  <span class='macro'>lj_mem_freevec(g, g-&gt;strhash, g-&gt;strmask+1, GCRef)<span class='macro_popup'>lj_mem_free(g, (g-&gt;strhash), (g-&gt;strmask+1)*sizeof(GCRef<br>))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="117"><td class="num" id="LN117">117</td><td class="line">  g-&gt;strmask = newmask;</td></tr>
<tr class="codeline" data-linenumber="118"><td class="num" id="LN118">118</td><td class="line">  g-&gt;strhash = newhash;</td></tr>
<tr class="codeline" data-linenumber="119"><td class="num" id="LN119">119</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="120"><td class="num" id="LN120">120</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="121"><td class="num" id="LN121">121</td><td class="line"><span class='comment'>/* Intern a string and return string object. */</span></td></tr>
<tr class="codeline" data-linenumber="122"><td class="num" id="LN122">122</td><td class="line">GCstr *lj_str_new(lua_State *L, <span class='keyword'>const</span> <span class='keyword'>char</span> *str, size_t lenx)</td></tr>
<tr class="codeline" data-linenumber="123"><td class="num" id="LN123">123</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="124"><td class="num" id="LN124">124</td><td class="line">  global_State *g;</td></tr>
<tr class="codeline" data-linenumber="125"><td class="num" id="LN125">125</td><td class="line">  GCstr *s;</td></tr>
<tr class="codeline" data-linenumber="126"><td class="num" id="LN126">126</td><td class="line">  GCobj *o;</td></tr>
<tr class="codeline" data-linenumber="127"><td class="num" id="LN127">127</td><td class="line">  MSize len = (MSize)lenx;</td></tr>
<tr class="codeline" data-linenumber="128"><td class="num" id="LN128">128</td><td class="line">  MSize a, b, h = len;</td></tr>
<tr class="codeline" data-linenumber="129"><td class="num" id="LN129">129</td><td class="line">  <span class='keyword'>if</span> (lenx &gt;= <span class='macro'>LJ_MAX_STR<span class='macro_popup'>0x7fffff00</span></span>)</td></tr>
<tr class="codeline" data-linenumber="130"><td class="num" id="LN130">130</td><td class="line">    lj_err_msg(L, LJ_ERR_STROV);</td></tr>
<tr class="codeline" data-linenumber="131"><td class="num" id="LN131">131</td><td class="line">  g = <span class='macro'>G(L)<span class='macro_popup'>(((global_State *)(void *)(uintptr_t)(L-&gt;glref).ptr32))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="132"><td class="num" id="LN132">132</td><td class="line">  <span class='comment'>/* Compute string hash. Constants taken from lookup3 hash by Bob Jenkins. */</span></td></tr>
<tr class="codeline" data-linenumber="133"><td class="num" id="LN133">133</td><td class="line">  <span class='keyword'>if</span> (len &gt;= 4) {  <span class='comment'>/* Caveat: unaligned access! */</span></td></tr>
<tr class="codeline" data-linenumber="134"><td class="num" id="LN134">134</td><td class="line">    a = lj_getu32(str);</td></tr>
<tr class="codeline" data-linenumber="135"><td class="num" id="LN135">135</td><td class="line">    h ^= lj_getu32(str+len-4);</td></tr>
<tr class="codeline" data-linenumber="136"><td class="num" id="LN136">136</td><td class="line">    b = lj_getu32(str+(len&gt;&gt;1)-2);</td></tr>
<tr class="codeline" data-linenumber="137"><td class="num" id="LN137">137</td><td class="line">    h ^= b; h -= <span class='macro'>lj_rol(b, 14)<span class='macro_popup'>(((b)&lt;&lt;(14)) | ((b)&gt;&gt;(-(int)(14)&amp;(8*sizeof(b)<br>-1))))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="138"><td class="num" id="LN138">138</td><td class="line">    b += lj_getu32(str+(len&gt;&gt;2)-1);</td></tr>
<tr class="codeline" data-linenumber="139"><td class="num" id="LN139">139</td><td class="line">  } <span class='keyword'>else</span> <span class='keyword'>if</span> (len &gt; 0) {</td></tr>
<tr class="codeline" data-linenumber="140"><td class="num" id="LN140">140</td><td class="line">    a = *(<span class='keyword'>const</span> uint8_t *)str;</td></tr>
<tr class="codeline" data-linenumber="141"><td class="num" id="LN141">141</td><td class="line">    h ^= *(<span class='keyword'>const</span> uint8_t *)(str+len-1);</td></tr>
<tr class="codeline" data-linenumber="142"><td class="num" id="LN142">142</td><td class="line">    b = *(<span class='keyword'>const</span> uint8_t *)(str+(len&gt;&gt;1));</td></tr>
<tr class="codeline" data-linenumber="143"><td class="num" id="LN143">143</td><td class="line">    h ^= b; h -= <span class='macro'>lj_rol(b, 14)<span class='macro_popup'>(((b)&lt;&lt;(14)) | ((b)&gt;&gt;(-(int)(14)&amp;(8*sizeof(b)<br>-1))))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="144"><td class="num" id="LN144">144</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="145"><td class="num" id="LN145">145</td><td class="line">    <span class='keyword'>return</span> &amp;g-&gt;strempty;</td></tr>
<tr class="codeline" data-linenumber="146"><td class="num" id="LN146">146</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="147"><td class="num" id="LN147">147</td><td class="line">  a ^= h; a -= <span class='macro'>lj_rol(h, 11)<span class='macro_popup'>(((h)&lt;&lt;(11)) | ((h)&gt;&gt;(-(int)(11)&amp;(8*sizeof(h)<br>-1))))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="148"><td class="num" id="LN148">148</td><td class="line">  b ^= a; b -= <span class='macro'>lj_rol(a, 25)<span class='macro_popup'>(((a)&lt;&lt;(25)) | ((a)&gt;&gt;(-(int)(25)&amp;(8*sizeof(a)<br>-1))))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="149"><td class="num" id="LN149">149</td><td class="line">  h ^= b; h -= <span class='macro'>lj_rol(b, 16)<span class='macro_popup'>(((b)&lt;&lt;(16)) | ((b)&gt;&gt;(-(int)(16)&amp;(8*sizeof(b)<br>-1))))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="150"><td class="num" id="LN150">150</td><td class="line">  <span class='comment'>/* Check if the string has already been interned. */</span></td></tr>
<tr class="codeline" data-linenumber="151"><td class="num" id="LN151">151</td><td class="line">  o = <span class='macro'>gcref(g-&gt;strhash[h &amp; g-&gt;strmask])<span class='macro_popup'>((GCobj *)(uintptr_t)(g-&gt;strhash[h &amp; g-&gt;strmask]).gcptr32<br>)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="152"><td class="num" id="LN152">152</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>LJ_LIKELY((((uintptr_t)str+len-1) &amp; (LJ_PAGESIZE-1)) &lt;= LJ_PAGESIZE-4)<span class='macro_popup'>__builtin_expect(!!((((uintptr_t)str+len-1) &amp; (4096 -1)) &lt;=<br> 4096 -4), 1)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="153"><td class="num" id="LN153">153</td><td class="line">    <span class='keyword'>while</span> (o != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="154"><td class="num" id="LN154">154</td><td class="line">      GCstr *sx = <span class='macro'>gco2str(o)<span class='macro_popup'>(&amp;(o)-&gt;str)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="155"><td class="num" id="LN155">155</td><td class="line">      <span class='keyword'>if</span> (sx-&gt;len == len &amp;&amp; str_fastcmp(str, <span class='macro'>strdata(sx)<span class='macro_popup'>((const char *)((sx)+1))</span></span>, len) == 0) {</td></tr>
<tr class="codeline" data-linenumber="156"><td class="num" id="LN156">156</td><td class="line">	<span class='comment'>/* Resurrect if dead. Can only happen with fixstring() (keywords). */</span></td></tr>
<tr class="codeline" data-linenumber="157"><td class="num" id="LN157">157</td><td class="line">	<span class='keyword'>if</span> (<span class='macro'>isdead(g, o)<span class='macro_popup'>((o)-&gt;gch.marked &amp; (g-&gt;gc.currentwhite ^ (0x01 | 0x02<br>)) &amp; (0x01 | 0x02))</span></span>) <span class='macro'>flipwhite(o)<span class='macro_popup'>((o)-&gt;gch.marked ^= (0x01 | 0x02))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="158"><td class="num" id="LN158">158</td><td class="line">	<span class='keyword'>return</span> sx;  <span class='comment'>/* Return existing string. */</span></td></tr>
<tr class="codeline" data-linenumber="159"><td class="num" id="LN159">159</td><td class="line">      }</td></tr>
<tr class="codeline" data-linenumber="160"><td class="num" id="LN160">160</td><td class="line">      o = <span class='macro'>gcnext(o)<span class='macro_popup'>(((GCobj *)(uintptr_t)((o)-&gt;gch.nextgc).gcptr32))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="161"><td class="num" id="LN161">161</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="162"><td class="num" id="LN162">162</td><td class="line">  } <span class='keyword'>else</span> {  <span class='comment'>/* Slow path: end of string is too close to a page boundary. */</span></td></tr>
<tr class="codeline" data-linenumber="163"><td class="num" id="LN163">163</td><td class="line">    <span class='keyword'>while</span> (o != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="164"><td class="num" id="LN164">164</td><td class="line">      GCstr *sx = <span class='macro'>gco2str(o)<span class='macro_popup'>(&amp;(o)-&gt;str)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="165"><td class="num" id="LN165">165</td><td class="line">      <span class='keyword'>if</span> (sx-&gt;len == len &amp;&amp; memcmp(str, <span class='macro'>strdata(sx)<span class='macro_popup'>((const char *)((sx)+1))</span></span>, len) == 0) {</td></tr>
<tr class="codeline" data-linenumber="166"><td class="num" id="LN166">166</td><td class="line">	<span class='comment'>/* Resurrect if dead. Can only happen with fixstring() (keywords). */</span></td></tr>
<tr class="codeline" data-linenumber="167"><td class="num" id="LN167">167</td><td class="line">	<span class='keyword'>if</span> (<span class='macro'>isdead(g, o)<span class='macro_popup'>((o)-&gt;gch.marked &amp; (g-&gt;gc.currentwhite ^ (0x01 | 0x02<br>)) &amp; (0x01 | 0x02))</span></span>) <span class='macro'>flipwhite(o)<span class='macro_popup'>((o)-&gt;gch.marked ^= (0x01 | 0x02))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="168"><td class="num" id="LN168">168</td><td class="line">	<span class='keyword'>return</span> sx;  <span class='comment'>/* Return existing string. */</span></td></tr>
<tr class="codeline" data-linenumber="169"><td class="num" id="LN169">169</td><td class="line">      }</td></tr>
<tr class="codeline" data-linenumber="170"><td class="num" id="LN170">170</td><td class="line">      o = <span class='macro'>gcnext(o)<span class='macro_popup'>(((GCobj *)(uintptr_t)((o)-&gt;gch.nextgc).gcptr32))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="171"><td class="num" id="LN171">171</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="172"><td class="num" id="LN172">172</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="173"><td class="num" id="LN173">173</td><td class="line">  <span class='comment'>/* Nope, create a new string. */</span></td></tr>
<tr class="codeline" data-linenumber="174"><td class="num" id="LN174">174</td><td class="line">  s = <span class='macro'>lj_mem_newt(L, <span class='keyword'>sizeof</span>(GCstr)+len+1, GCstr)<span class='macro_popup'>((GCstr *)lj_mem_realloc(L, ((void*)0), 0, ((sizeof(GCstr)+len<br>+1))))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="175"><td class="num" id="LN175">175</td><td class="line">  <span class='macro'>newwhite(g, s)<span class='macro_popup'>(((GCobj *)(s))-&gt;gch.marked = (uint8_t)((g)-&gt;gc.currentwhite<br> &amp; (0x01 | 0x02)))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="176"><td class="num" id="LN176">176</td><td class="line">  s-&gt;gct = ~<span class='macro'>LJ_TSTR<span class='macro_popup'>(~4u)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="177"><td class="num" id="LN177">177</td><td class="line">  s-&gt;len = len;</td></tr>
<tr class="codeline" data-linenumber="178"><td class="num" id="LN178">178</td><td class="line">  s-&gt;hash = h;</td></tr>
<tr class="codeline" data-linenumber="179"><td class="num" id="LN179">179</td><td class="line">  s-&gt;reserved = 0;</td></tr>
<tr class="codeline" data-linenumber="180"><td class="num" id="LN180">180</td><td class="line">  <span class="mrange">memcpy</span>(<span class='macro'>strdatawr(s)<span class='macro_popup'>((char *)((s)+1))</span></span>, str, len);</td></tr>
<tr><td class="num"></td><td class="line"><div id="EndPath" class="msg msgEvent" style="margin-left:3ex; max-width:58em">Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11</div></td></tr>
<tr class="codeline" data-linenumber="181"><td class="num" id="LN181">181</td><td class="line">  <span class='macro'>strdatawr(s)<span class='macro_popup'>((char *)((s)+1))</span></span>[len] = '\0';  <span class='comment'>/* Zero-terminate string. */</span></td></tr>
<tr class="codeline" data-linenumber="182"><td class="num" id="LN182">182</td><td class="line">  <span class='comment'>/* Add it to string hash table. */</span></td></tr>
<tr class="codeline" data-linenumber="183"><td class="num" id="LN183">183</td><td class="line">  h &amp;= g-&gt;strmask;</td></tr>
<tr class="codeline" data-linenumber="184"><td class="num" id="LN184">184</td><td class="line">  s-&gt;nextgc = g-&gt;strhash[h];</td></tr>
<tr class="codeline" data-linenumber="185"><td class="num" id="LN185">185</td><td class="line">  <span class='comment'>/* NOBARRIER: The string table is a GC root. */</span></td></tr>
<tr class="codeline" data-linenumber="186"><td class="num" id="LN186">186</td><td class="line">  <span class='macro'>setgcref(g-&gt;strhash[h], obj2gco(s))<span class='macro_popup'>((g-&gt;strhash[h]).gcptr32 = (uint32_t)(uintptr_t)&amp;(((GCobj<br> *)(s)))-&gt;gch)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="187"><td class="num" id="LN187">187</td><td class="line">  <span class='keyword'>if</span> (g-&gt;strnum++ &gt; g-&gt;strmask)  <span class='comment'>/* Allow a 100% load factor. */</span></td></tr>
<tr class="codeline" data-linenumber="188"><td class="num" id="LN188">188</td><td class="line">    lj_str_resize(L, (g-&gt;strmask&lt;&lt;1)+1);  <span class='comment'>/* Grow string table. */</span></td></tr>
<tr class="codeline" data-linenumber="189"><td class="num" id="LN189">189</td><td class="line">  <span class='keyword'>return</span> s;  <span class='comment'>/* Return newly interned string. */</span></td></tr>
<tr class="codeline" data-linenumber="190"><td class="num" id="LN190">190</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="191"><td class="num" id="LN191">191</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="192"><td class="num" id="LN192">192</td><td class="line"><span class='keyword'>void</span> LJ_FASTCALL lj_str_free(global_State *g, GCstr *s)</td></tr>
<tr class="codeline" data-linenumber="193"><td class="num" id="LN193">193</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="194"><td class="num" id="LN194">194</td><td class="line">  g-&gt;strnum--;</td></tr>
<tr class="codeline" data-linenumber="195"><td class="num" id="LN195">195</td><td class="line">  lj_mem_free(g, s, <span class='macro'>sizestring(s)<span class='macro_popup'>(sizeof(struct GCstr)+(s)-&gt;len+1)</span></span>);</td></tr>
<tr class="codeline" data-linenumber="196"><td class="num" id="LN196">196</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="197"><td class="num" id="LN197">197</td><td class="line"> </td></tr>
</table></body></html>
