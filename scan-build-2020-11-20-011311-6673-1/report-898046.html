<!doctype html>
<html>
<head>
<title>lj_ccall.c</title>

<style type="text/css">
body { color:#000000; background-color:#ffffff }
body { font-family:Helvetica, sans-serif; font-size:10pt }
h1 { font-size:14pt }
.FileName { margin-top: 5px; margin-bottom: 5px; display: inline; }
.FileNav { margin-left: 5px; margin-right: 5px; display: inline; }
.FileNav a { text-decoration:none; font-size: larger; }
.divider { margin-top: 30px; margin-bottom: 30px; height: 15px; }
.divider { background-color: gray; }
.code { border-collapse:collapse; width:100%; }
.code { font-family: "Monospace", monospace; font-size:10pt }
.code { line-height: 1.2em }
.comment { color: green; font-style: oblique }
.keyword { color: blue }
.string_literal { color: red }
.directive { color: darkmagenta }

/* Macros and variables could have pop-up notes hidden by default.
  - Macro pop-up:    expansion of the macro
  - Variable pop-up: value (table) of the variable */
.macro_popup, .variable_popup { display: none; }

/* Pop-up appears on mouse-hover event. */
.macro:hover .macro_popup, .variable:hover .variable_popup {
  display: block;
  padding: 2px;
  -webkit-border-radius:5px;
  -webkit-box-shadow:1px 1px 7px #000;
  border-radius:5px;
  box-shadow:1px 1px 7px #000;
  position: absolute;
  top: -1em;
  left:10em;
  z-index: 1
}

.macro_popup {
  border: 2px solid red;
  background-color:#FFF0F0;
  font-weight: normal;
}

.variable_popup {
  border: 2px solid blue;
  background-color:#F0F0FF;
  font-weight: bold;
  font-family: Helvetica, sans-serif;
  font-size: 9pt;
}

/* Pop-up notes needs a relative position as a base where they pops up. */
.macro, .variable {
  background-color: PaleGoldenRod;
  position: relative;
}
.macro { color: DarkMagenta; }

#tooltiphint {
  position: fixed;
  width: 50em;
  margin-left: -25em;
  left: 50%;
  padding: 10px;
  border: 1px solid #b0b0b0;
  border-radius: 2px;
  box-shadow: 1px 1px 7px black;
  background-color: #c0c0c0;
  z-index: 2;
}

.num { width:2.5em; padding-right:2ex; background-color:#eeeeee }
.num { text-align:right; font-size:8pt }
.num { color:#444444 }
.line { padding-left: 1ex; border-left: 3px solid #ccc }
.line { white-space: pre }
.msg { -webkit-box-shadow:1px 1px 7px #000 }
.msg { box-shadow:1px 1px 7px #000 }
.msg { -webkit-border-radius:5px }
.msg { border-radius:5px }
.msg { font-family:Helvetica, sans-serif; font-size:8pt }
.msg { float:left }
.msg { padding:0.25em 1ex 0.25em 1ex }
.msg { margin-top:10px; margin-bottom:10px }
.msg { font-weight:bold }
.msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }
.msgT { padding:0x; spacing:0x }
.msgEvent { background-color:#fff8b4; color:#000000 }
.msgControl { background-color:#bbbbbb; color:#000000 }
.msgNote { background-color:#ddeeff; color:#000000 }
.mrange { background-color:#dfddf3 }
.mrange { border-bottom:1px solid #6F9DBE }
.PathIndex { font-weight: bold; padding:0px 5px; margin-right:5px; }
.PathIndex { -webkit-border-radius:8px }
.PathIndex { border-radius:8px }
.PathIndexEvent { background-color:#bfba87 }
.PathIndexControl { background-color:#8c8c8c }
.PathIndexPopUp { background-color: #879abc; }
.PathNav a { text-decoration:none; font-size: larger }
.CodeInsertionHint { font-weight: bold; background-color: #10dd10 }
.CodeRemovalHint { background-color:#de1010 }
.CodeRemovalHint { border-bottom:1px solid #6F9DBE }
.selected{ background-color:orange !important; }

table.simpletable {
  padding: 5px;
  font-size:12pt;
  margin:20px;
  border-collapse: collapse; border-spacing: 0px;
}
td.rowname {
  text-align: right;
  vertical-align: top;
  font-weight: bold;
  color:#444444;
  padding-right:2ex;
}

/* Hidden text. */
input.spoilerhider + label {
  cursor: pointer;
  text-decoration: underline;
  display: block;
}
input.spoilerhider {
 display: none;
}
input.spoilerhider ~ .spoiler {
  overflow: hidden;
  margin: 10px auto 0;
  height: 0;
  opacity: 0;
}
input.spoilerhider:checked + label + .spoiler{
  height: auto;
  opacity: 1;
}
</style>
</head>
<body>
<!-- BUGDESC Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 -->

<!-- BUGTYPE Potential insecure memory buffer bounds restriction in call 'memcpy' -->

<!-- BUGCATEGORY Security -->

<!-- BUGFILE /tmp/real/c_wrk/wrk2/deps/luajit/src/lj_ccall.c -->

<!-- FILENAME lj_ccall.c -->

<!-- FUNCTIONNAME ccall_struct_ret -->

<!-- ISSUEHASHCONTENTOFLINEINCONTEXT 38637c4e817fd35ed27abcbb86738d4c -->

<!-- BUGLINE 573 -->

<!-- BUGCOLUMN 3 -->

<!-- BUGPATHLENGTH 1 -->

<!-- BUGMETAEND -->
<!-- REPORTHEADER -->
<h3>Bug Summary</h3>
<table class="simpletable">
<tr><td class="rowname">File:</td><td>src/lj_ccall.c</td></tr>
<tr><td class="rowname">Warning:</td><td><a href="#EndPath">line 573, column 3</a><br />Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11</td></tr>

</table>
<!-- REPORTSUMMARYEXTRA -->
<h3>Annotated Source Code</h3>
<p>Press <a href="#" onclick="toggleHelp(); return false;">'?'</a>
   to see keyboard shortcuts</p>
<input type="checkbox" class="spoilerhider" id="showinvocation" />
<label for="showinvocation" >Show analyzer invocation</label>
<div class="spoiler">clang -cc1 -cc1 -triple x86_64-unknown-linux-gnu -analyze -disable-free -main-file-name lj_ccall.c -analyzer-store=region -analyzer-opt-analyze-nested-blocks -analyzer-checker=core -analyzer-checker=apiModeling -analyzer-checker=unix -analyzer-checker=deadcode -analyzer-checker=security.insecureAPI.UncheckedReturn -analyzer-checker=security.insecureAPI.getpw -analyzer-checker=security.insecureAPI.gets -analyzer-checker=security.insecureAPI.mktemp -analyzer-checker=security.insecureAPI.mkstemp -analyzer-checker=security.insecureAPI.vfork -analyzer-checker=nullability.NullPassedToNonnull -analyzer-checker=nullability.NullReturnedFromNonnull -analyzer-output plist -w -setup-static-analyzer -mrelocation-model static -mframe-pointer=none -fmath-errno -fno-rounding-math -mconstructor-aliases -munwind-tables -target-cpu x86-64 -fno-split-dwarf-inlining -debugger-tuning=gdb -resource-dir /llvm-project/build/lib/clang/12.0.0 -D _FILE_OFFSET_BITS=64 -D _LARGEFILE_SOURCE -U _FORTIFY_SOURCE -internal-isystem /usr/local/include -internal-isystem /llvm-project/build/lib/clang/12.0.0/include -internal-externc-isystem /usr/include/x86_64-linux-gnu -internal-externc-isystem /include -internal-externc-isystem /usr/include -O2 -fdebug-compilation-dir /tmp/real/c_wrk/wrk2/deps/luajit/src -ferror-limit 19 -fgnuc-version=4.2.1 -vectorize-loops -vectorize-slp -analyzer-checker core -analyzer-checker cplusplus -analyzer-checker nullability -analyzer-checker optin -analyzer-checker security -analyzer-checker unix -analyzer-checker osx -analyzer-checker fuchsia -analyzer-checker webkit -analyzer-output=html -faddrsig -o /tmp/scan-build-2020-11-20-011311-6673-1 -x c lj_ccall.c
</div>
<div id='tooltiphint' hidden="true">
  <p>Keyboard shortcuts: </p>
  <ul>
    <li>Use 'j/k' keys for keyboard navigation</li>
    <li>Use 'Shift+S' to show/hide relevant lines</li>
    <li>Use '?' to toggle this window</li>
  </ul>
  <a href="#" onclick="toggleHelp(); return false;">Close</a>
</div>
<script type='text/javascript'>
var relevant_lines = {"1": {"573": 1}};

var filterCounterexample = function (hide) {
  var tables = document.getElementsByClassName("code");
  for (var t=0; t<tables.length; t++) {
    var table = tables[t];
    var file_id = table.getAttribute("data-fileid");
    var lines_in_fid = relevant_lines[file_id];
    if (!lines_in_fid) {
      lines_in_fid = {};
    }
    var lines = table.getElementsByClassName("codeline");
    for (var i=0; i<lines.length; i++) {
        var el = lines[i];
        var lineNo = el.getAttribute("data-linenumber");
        if (!lines_in_fid[lineNo]) {
          if (hide) {
            el.setAttribute("hidden", "");
          } else {
            el.removeAttribute("hidden");
          }
        }
    }
  }
}

window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.key == "S") {
    var checked = document.getElementsByName("showCounterexample")[0].checked;
    filterCounterexample(!checked);
    document.getElementsByName("showCounterexample")[0].checked = !checked;
  } else {
    return;
  }
  event.preventDefault();
}, true);

document.addEventListener("DOMContentLoaded", function() {
    document.querySelector('input[name="showCounterexample"]').onchange=
        function (event) {
      filterCounterexample(this.checked);
    };
});
</script>

<form>
    <input type="checkbox" name="showCounterexample" id="showCounterexample" />
    <label for="showCounterexample">
       Show only relevant lines
    </label>
</form>

<script type='text/javascript'>
var digitMatcher = new RegExp("[0-9]+");

var querySelectorAllArray = function(selector) {
  return Array.prototype.slice.call(
    document.querySelectorAll(selector));
}

document.addEventListener("DOMContentLoaded", function() {
    querySelectorAllArray(".PathNav > a").forEach(
        function(currentValue, currentIndex) {
            var hrefValue = currentValue.getAttribute("href");
            currentValue.onclick = function() {
                scrollTo(document.querySelector(hrefValue));
                return false;
            };
        });
});

var findNum = function() {
    var s = document.querySelector(".selected");
    if (!s || s.id == "EndPath") {
        return 0;
    }
    var out = parseInt(digitMatcher.exec(s.id)[0]);
    return out;
};

var scrollTo = function(el) {
    querySelectorAllArray(".selected").forEach(function(s) {
        s.classList.remove("selected");
    });
    el.classList.add("selected");
    window.scrollBy(0, el.getBoundingClientRect().top -
        (window.innerHeight / 2));
}

var move = function(num, up, numItems) {
  if (num == 1 && up || num == numItems - 1 && !up) {
    return 0;
  } else if (num == 0 && up) {
    return numItems - 1;
  } else if (num == 0 && !up) {
    return 1 % numItems;
  }
  return up ? num - 1 : num + 1;
}

var numToId = function(num) {
  if (num == 0) {
    return document.getElementById("EndPath")
  }
  return document.getElementById("Path" + num);
};

var navigateTo = function(up) {
  var numItems = document.querySelectorAll(
      ".line > .msgEvent, .line > .msgControl").length;
  var currentSelected = findNum();
  var newSelected = move(currentSelected, up, numItems);
  var newEl = numToId(newSelected, numItems);

  // Scroll element into center.
  scrollTo(newEl);
};

window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.key == "j") {
    navigateTo(/*up=*/false);
  } else if (event.key == "k") {
    navigateTo(/*up=*/true);
  } else {
    return;
  }
  event.preventDefault();
}, true);
</script>
  
<script type='text/javascript'>

var toggleHelp = function() {
    var hint = document.querySelector("#tooltiphint");
    var attributeName = "hidden";
    if (hint.hasAttribute(attributeName)) {
      hint.removeAttribute(attributeName);
    } else {
      hint.setAttribute("hidden", "true");
    }
};
window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.key == "?") {
    toggleHelp();
  } else {
    return;
  }
  event.preventDefault();
});
</script>
<table class="code" data-fileid="1">
<tr class="codeline" data-linenumber="1"><td class="num" id="LN1">1</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="2"><td class="num" id="LN2">2</td><td class="line"><span class='comment'>** FFI C call handling.</span></td></tr>
<tr class="codeline" data-linenumber="3"><td class="num" id="LN3">3</td><td class="line"><span class='comment'>** Copyright (C) 2005-2014 Mike Pall. See Copyright Notice in luajit.h</span></td></tr>
<tr class="codeline" data-linenumber="4"><td class="num" id="LN4">4</td><td class="line"><span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="5"><td class="num" id="LN5">5</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="6"><td class="num" id="LN6">6</td><td class="line"><span class='directive'>#include "lj_obj.h"</span></td></tr>
<tr class="codeline" data-linenumber="7"><td class="num" id="LN7">7</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="8"><td class="num" id="LN8">8</td><td class="line"><span class='directive'>#if <span class='macro'>LJ_HASFFI<span class='macro_popup'>1</span></span></span></td></tr>
<tr class="codeline" data-linenumber="9"><td class="num" id="LN9">9</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="10"><td class="num" id="LN10">10</td><td class="line"><span class='directive'>#include "lj_gc.h"</span></td></tr>
<tr class="codeline" data-linenumber="11"><td class="num" id="LN11">11</td><td class="line"><span class='directive'>#include "lj_err.h"</span></td></tr>
<tr class="codeline" data-linenumber="12"><td class="num" id="LN12">12</td><td class="line"><span class='directive'>#include "lj_str.h"</span></td></tr>
<tr class="codeline" data-linenumber="13"><td class="num" id="LN13">13</td><td class="line"><span class='directive'>#include "lj_tab.h"</span></td></tr>
<tr class="codeline" data-linenumber="14"><td class="num" id="LN14">14</td><td class="line"><span class='directive'>#include "lj_ctype.h"</span></td></tr>
<tr class="codeline" data-linenumber="15"><td class="num" id="LN15">15</td><td class="line"><span class='directive'>#include "lj_cconv.h"</span></td></tr>
<tr class="codeline" data-linenumber="16"><td class="num" id="LN16">16</td><td class="line"><span class='directive'>#include "lj_cdata.h"</span></td></tr>
<tr class="codeline" data-linenumber="17"><td class="num" id="LN17">17</td><td class="line"><span class='directive'>#include "lj_ccall.h"</span></td></tr>
<tr class="codeline" data-linenumber="18"><td class="num" id="LN18">18</td><td class="line"><span class='directive'>#include "lj_trace.h"</span></td></tr>
<tr class="codeline" data-linenumber="19"><td class="num" id="LN19">19</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="20"><td class="num" id="LN20">20</td><td class="line"><span class='comment'>/* Target-specific handling of register arguments. */</span></td></tr>
<tr class="codeline" data-linenumber="21"><td class="num" id="LN21">21</td><td class="line"><span class='directive'>#if LJ_TARGET_X86</span></td></tr>
<tr class="codeline" data-linenumber="22"><td class="num" id="LN22">22</td><td class="line"><span class='comment'>/* -- x86 calling conventions --------------------------------------------- */</span></td></tr>
<tr class="codeline" data-linenumber="23"><td class="num" id="LN23">23</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="24"><td class="num" id="LN24">24</td><td class="line"><span class='directive'>#if <span class='macro'>LJ_ABI_WIN<span class='macro_popup'>(2 == 1)</span></span></span></td></tr>
<tr class="codeline" data-linenumber="25"><td class="num" id="LN25">25</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="26"><td class="num" id="LN26">26</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_STRUCTRET<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; if (ccall_classify_struct(cts<br>, ctr, rcl, 0)) { cc-&gt;retref = 1; cc-&gt;gpr[ngpr++] = (GPRArg<br>)dp; } else { cc-&gt;retref = 0; }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="27"><td class="num" id="LN27">27</td><td class="line">  <span class='directive'>/* Return structs bigger than 8 by reference (on stack only). */ \</span></td></tr>
<tr class="codeline" data-linenumber="28"><td class="num" id="LN28">28</td><td class="line">  <span class='directive'>cc-&gt;retref = (sz &gt; 8); \</span></td></tr>
<tr class="codeline" data-linenumber="29"><td class="num" id="LN29">29</td><td class="line">  <span class='directive'>if (cc-&gt;retref) cc-&gt;stack[nsp++] = (GPRArg)dp;</span></td></tr>
<tr class="codeline" data-linenumber="30"><td class="num" id="LN30">30</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="31"><td class="num" id="LN31">31</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_COMPLEXRET<span class='macro_popup'>cc-&gt;retref = 0;</span></span> <span class='macro'>CCALL_HANDLE_STRUCTRET<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; if (ccall_classify_struct(cts<br>, ctr, rcl, 0)) { cc-&gt;retref = 1; cc-&gt;gpr[ngpr++] = (GPRArg<br>)dp; } else { cc-&gt;retref = 0; }</span></span></span></td></tr>
<tr class="codeline" data-linenumber="32"><td class="num" id="LN32">32</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="33"><td class="num" id="LN33">33</td><td class="line"><span class='directive'>#else</span></td></tr>
<tr class="codeline" data-linenumber="34"><td class="num" id="LN34">34</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="35"><td class="num" id="LN35">35</td><td class="line"><span class='directive'>#if <span class='macro'>LJ_TARGET_OSX<span class='macro_popup'>(2 == 3)</span></span></span></td></tr>
<tr class="codeline" data-linenumber="36"><td class="num" id="LN36">36</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="37"><td class="num" id="LN37">37</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_STRUCTRET<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; if (ccall_classify_struct(cts<br>, ctr, rcl, 0)) { cc-&gt;retref = 1; cc-&gt;gpr[ngpr++] = (GPRArg<br>)dp; } else { cc-&gt;retref = 0; }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="38"><td class="num" id="LN38">38</td><td class="line">  <span class='directive'>/* Return structs of size 1, 2, 4 or 8 in registers. */ \</span></td></tr>
<tr class="codeline" data-linenumber="39"><td class="num" id="LN39">39</td><td class="line">  <span class='directive'>cc-&gt;retref = !(sz == 1 || sz == 2 || sz == 4 || sz == 8); \</span></td></tr>
<tr class="codeline" data-linenumber="40"><td class="num" id="LN40">40</td><td class="line">  <span class='directive'>if (cc-&gt;retref) { \</span></td></tr>
<tr class="codeline" data-linenumber="41"><td class="num" id="LN41">41</td><td class="line">    <span class='directive'>if (ngpr &lt; maxgpr) \</span></td></tr>
<tr class="codeline" data-linenumber="42"><td class="num" id="LN42">42</td><td class="line">      <span class='directive'>cc-&gt;gpr[ngpr++] = (GPRArg)dp; \</span></td></tr>
<tr class="codeline" data-linenumber="43"><td class="num" id="LN43">43</td><td class="line">    <span class='directive'>else \</span></td></tr>
<tr class="codeline" data-linenumber="44"><td class="num" id="LN44">44</td><td class="line">      <span class='directive'>cc-&gt;stack[nsp++] = (GPRArg)dp; \</span></td></tr>
<tr class="codeline" data-linenumber="45"><td class="num" id="LN45">45</td><td class="line">  <span class='directive'>} else {  /* Struct with single FP field ends up in FPR. */ \</span></td></tr>
<tr class="codeline" data-linenumber="46"><td class="num" id="LN46">46</td><td class="line">    <span class='directive'>cc-&gt;resx87 = ccall_classify_struct(cts, ctr); \</span></td></tr>
<tr class="codeline" data-linenumber="47"><td class="num" id="LN47">47</td><td class="line">  <span class='directive'>}</span></td></tr>
<tr class="codeline" data-linenumber="48"><td class="num" id="LN48">48</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="49"><td class="num" id="LN49">49</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_STRUCTRET2<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; ccall_classify_struct(cts, ctr<br>, rcl, 0); ccall_struct_ret(cc, rcl, dp, ctr-&gt;size);</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="50"><td class="num" id="LN50">50</td><td class="line">  <span class='directive'>if (cc-&gt;resx87) sp = (uint8_t *)&amp;cc-&gt;fpr[0]; \</span></td></tr>
<tr class="codeline" data-linenumber="51"><td class="num" id="LN51">51</td><td class="line">  <span class='directive'>memcpy(dp, sp, ctr-&gt;size);</span></td></tr>
<tr class="codeline" data-linenumber="52"><td class="num" id="LN52">52</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="53"><td class="num" id="LN53">53</td><td class="line"><span class='directive'>#else</span></td></tr>
<tr class="codeline" data-linenumber="54"><td class="num" id="LN54">54</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="55"><td class="num" id="LN55">55</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_STRUCTRET<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; if (ccall_classify_struct(cts<br>, ctr, rcl, 0)) { cc-&gt;retref = 1; cc-&gt;gpr[ngpr++] = (GPRArg<br>)dp; } else { cc-&gt;retref = 0; }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="56"><td class="num" id="LN56">56</td><td class="line">  <span class='directive'>cc-&gt;retref = 1;  /* Return all structs by reference (in reg or on stack). */ \</span></td></tr>
<tr class="codeline" data-linenumber="57"><td class="num" id="LN57">57</td><td class="line">  <span class='directive'>if (ngpr &lt; maxgpr) \</span></td></tr>
<tr class="codeline" data-linenumber="58"><td class="num" id="LN58">58</td><td class="line">    <span class='directive'>cc-&gt;gpr[ngpr++] = (GPRArg)dp; \</span></td></tr>
<tr class="codeline" data-linenumber="59"><td class="num" id="LN59">59</td><td class="line">  <span class='directive'>else \</span></td></tr>
<tr class="codeline" data-linenumber="60"><td class="num" id="LN60">60</td><td class="line">    <span class='directive'>cc-&gt;stack[nsp++] = (GPRArg)dp;</span></td></tr>
<tr class="codeline" data-linenumber="61"><td class="num" id="LN61">61</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="62"><td class="num" id="LN62">62</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="63"><td class="num" id="LN63">63</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="64"><td class="num" id="LN64">64</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_COMPLEXRET<span class='macro_popup'>cc-&gt;retref = 0;</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="65"><td class="num" id="LN65">65</td><td class="line">  <span class='directive'>/* Return complex float in GPRs and complex double by reference. */ \</span></td></tr>
<tr class="codeline" data-linenumber="66"><td class="num" id="LN66">66</td><td class="line">  <span class='directive'>cc-&gt;retref = (sz &gt; 8); \</span></td></tr>
<tr class="codeline" data-linenumber="67"><td class="num" id="LN67">67</td><td class="line">  <span class='directive'>if (cc-&gt;retref) { \</span></td></tr>
<tr class="codeline" data-linenumber="68"><td class="num" id="LN68">68</td><td class="line">    <span class='directive'>if (ngpr &lt; maxgpr) \</span></td></tr>
<tr class="codeline" data-linenumber="69"><td class="num" id="LN69">69</td><td class="line">      <span class='directive'>cc-&gt;gpr[ngpr++] = (GPRArg)dp; \</span></td></tr>
<tr class="codeline" data-linenumber="70"><td class="num" id="LN70">70</td><td class="line">    <span class='directive'>else \</span></td></tr>
<tr class="codeline" data-linenumber="71"><td class="num" id="LN71">71</td><td class="line">      <span class='directive'>cc-&gt;stack[nsp++] = (GPRArg)dp; \</span></td></tr>
<tr class="codeline" data-linenumber="72"><td class="num" id="LN72">72</td><td class="line">  <span class='directive'>}</span></td></tr>
<tr class="codeline" data-linenumber="73"><td class="num" id="LN73">73</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="74"><td class="num" id="LN74">74</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="75"><td class="num" id="LN75">75</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="76"><td class="num" id="LN76">76</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_COMPLEXRET2<span class='macro_popup'>if (ctr-&gt;size == 2*sizeof(float)) { *(int64_t *)dp = cc-&gt;<br>fpr[0].l[0]; } else { ((int64_t *)dp)[0] = cc-&gt;fpr[0].l[0]<br>; ((int64_t *)dp)[1] = cc-&gt;fpr[1].l[0]; }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="77"><td class="num" id="LN77">77</td><td class="line">  <span class='directive'>if (!cc-&gt;retref) \</span></td></tr>
<tr class="codeline" data-linenumber="78"><td class="num" id="LN78">78</td><td class="line">    <span class='directive'>*(int64_t *)dp = *(int64_t *)sp;  /* Copy complex float from GPRs. */</span></td></tr>
<tr class="codeline" data-linenumber="79"><td class="num" id="LN79">79</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="80"><td class="num" id="LN80">80</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_STRUCTARG<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; if (!ccall_classify_struct(cts<br>, d, rcl, 0)) { cc-&gt;nsp = nsp; cc-&gt;ngpr = ngpr; cc-&gt;<br>nfpr = nfpr; if (ccall_struct_arg(cc, cts, d, rcl, o, narg)) goto<br> err_nyi; nsp = cc-&gt;nsp; ngpr = cc-&gt;ngpr; nfpr = cc-&gt;<br>nfpr; continue; }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="81"><td class="num" id="LN81">81</td><td class="line">  <span class='directive'>ngpr = maxgpr;  /* Pass all structs by value on the stack. */</span></td></tr>
<tr class="codeline" data-linenumber="82"><td class="num" id="LN82">82</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="83"><td class="num" id="LN83">83</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_COMPLEXARG<span class='macro_popup'>isfp = 2;</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="84"><td class="num" id="LN84">84</td><td class="line">  <span class='directive'>isfp = 1;  /* Pass complex by value on stack. */</span></td></tr>
<tr class="codeline" data-linenumber="85"><td class="num" id="LN85">85</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="86"><td class="num" id="LN86">86</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_REGARG<span class='macro_popup'>if (isfp) { int n2 = (((d-&gt;info) &amp; (0xf0000000u|0x08000000u<br>)) == (((CTInfo)(CT_ARRAY) &lt;&lt; 28) + (0x08000000u))) ? 1<br> : n; if (nfpr + n2 &lt;= 8) { dp = &amp;cc-&gt;fpr[nfpr]; nfpr<br> += n2; goto done; } } else { if (n &lt;= 2 &amp;&amp; ngpr +<br> n &lt;= maxgpr) { dp = &amp;cc-&gt;gpr[ngpr]; ngpr += n; goto<br> done; } }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="87"><td class="num" id="LN87">87</td><td class="line">  <span class='directive'>if (!isfp) {  /* Only non-FP values may be passed in registers. */ \</span></td></tr>
<tr class="codeline" data-linenumber="88"><td class="num" id="LN88">88</td><td class="line">    <span class='directive'>if (n &gt; 1) {  /* Anything &gt; 32 bit is passed on the stack. */ \</span></td></tr>
<tr class="codeline" data-linenumber="89"><td class="num" id="LN89">89</td><td class="line">      <span class='directive'>if (!<span class='macro'>LJ_ABI_WIN<span class='macro_popup'>(2 == 1)</span></span>) ngpr = maxgpr;  /* Prevent reordering. */ \</span></td></tr>
<tr class="codeline" data-linenumber="90"><td class="num" id="LN90">90</td><td class="line">    <span class='directive'>} else if (ngpr + 1 &lt;= maxgpr) { \</span></td></tr>
<tr class="codeline" data-linenumber="91"><td class="num" id="LN91">91</td><td class="line">      <span class='directive'>dp = &amp;cc-&gt;gpr[ngpr]; \</span></td></tr>
<tr class="codeline" data-linenumber="92"><td class="num" id="LN92">92</td><td class="line">      <span class='directive'>ngpr += n; \</span></td></tr>
<tr class="codeline" data-linenumber="93"><td class="num" id="LN93">93</td><td class="line">      <span class='directive'>goto done; \</span></td></tr>
<tr class="codeline" data-linenumber="94"><td class="num" id="LN94">94</td><td class="line">    <span class='directive'>} \</span></td></tr>
<tr class="codeline" data-linenumber="95"><td class="num" id="LN95">95</td><td class="line">  <span class='directive'>}</span></td></tr>
<tr class="codeline" data-linenumber="96"><td class="num" id="LN96">96</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="97"><td class="num" id="LN97">97</td><td class="line"><span class='directive'>#elif <span class='macro'>LJ_TARGET_X64<span class='macro_popup'>1</span></span> &amp;&amp; <span class='macro'>LJ_ABI_WIN<span class='macro_popup'>(2 == 1)</span></span></span></td></tr>
<tr class="codeline" data-linenumber="98"><td class="num" id="LN98">98</td><td class="line"><span class='comment'>/* -- Windows/x64 calling conventions ------------------------------------- */</span></td></tr>
<tr class="codeline" data-linenumber="99"><td class="num" id="LN99">99</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="100"><td class="num" id="LN100">100</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_STRUCTRET<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; if (ccall_classify_struct(cts<br>, ctr, rcl, 0)) { cc-&gt;retref = 1; cc-&gt;gpr[ngpr++] = (GPRArg<br>)dp; } else { cc-&gt;retref = 0; }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="101"><td class="num" id="LN101">101</td><td class="line">  <span class='directive'>/* Return structs of size 1, 2, 4 or 8 in a GPR. */ \</span></td></tr>
<tr class="codeline" data-linenumber="102"><td class="num" id="LN102">102</td><td class="line">  <span class='directive'>cc-&gt;retref = !(sz == 1 || sz == 2 || sz == 4 || sz == 8); \</span></td></tr>
<tr class="codeline" data-linenumber="103"><td class="num" id="LN103">103</td><td class="line">  <span class='directive'>if (cc-&gt;retref) cc-&gt;gpr[ngpr++] = (GPRArg)dp;</span></td></tr>
<tr class="codeline" data-linenumber="104"><td class="num" id="LN104">104</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="105"><td class="num" id="LN105">105</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_COMPLEXRET<span class='macro_popup'>cc-&gt;retref = 0;</span></span> <span class='macro'>CCALL_HANDLE_STRUCTRET<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; if (ccall_classify_struct(cts<br>, ctr, rcl, 0)) { cc-&gt;retref = 1; cc-&gt;gpr[ngpr++] = (GPRArg<br>)dp; } else { cc-&gt;retref = 0; }</span></span></span></td></tr>
<tr class="codeline" data-linenumber="106"><td class="num" id="LN106">106</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="107"><td class="num" id="LN107">107</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_COMPLEXRET2<span class='macro_popup'>if (ctr-&gt;size == 2*sizeof(float)) { *(int64_t *)dp = cc-&gt;<br>fpr[0].l[0]; } else { ((int64_t *)dp)[0] = cc-&gt;fpr[0].l[0]<br>; ((int64_t *)dp)[1] = cc-&gt;fpr[1].l[0]; }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="108"><td class="num" id="LN108">108</td><td class="line">  <span class='directive'>if (!cc-&gt;retref) \</span></td></tr>
<tr class="codeline" data-linenumber="109"><td class="num" id="LN109">109</td><td class="line">    <span class='directive'>*(int64_t *)dp = *(int64_t *)sp;  /* Copy complex float from GPRs. */</span></td></tr>
<tr class="codeline" data-linenumber="110"><td class="num" id="LN110">110</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="111"><td class="num" id="LN111">111</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_STRUCTARG<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; if (!ccall_classify_struct(cts<br>, d, rcl, 0)) { cc-&gt;nsp = nsp; cc-&gt;ngpr = ngpr; cc-&gt;<br>nfpr = nfpr; if (ccall_struct_arg(cc, cts, d, rcl, o, narg)) goto<br> err_nyi; nsp = cc-&gt;nsp; ngpr = cc-&gt;ngpr; nfpr = cc-&gt;<br>nfpr; continue; }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="112"><td class="num" id="LN112">112</td><td class="line">  <span class='directive'>/* Pass structs of size 1, 2, 4 or 8 in a GPR by value. */ \</span></td></tr>
<tr class="codeline" data-linenumber="113"><td class="num" id="LN113">113</td><td class="line">  <span class='directive'>if (!(sz == 1 || sz == 2 || sz == 4 || sz == 8)) { \</span></td></tr>
<tr class="codeline" data-linenumber="114"><td class="num" id="LN114">114</td><td class="line">    <span class='directive'>rp = <span class='macro'>cdataptr(lj_cdata_new(cts, did, sz))<span class='macro_popup'>((void *)((lj_cdata_new(cts, did, sz))+1))</span></span>; \</span></td></tr>
<tr class="codeline" data-linenumber="115"><td class="num" id="LN115">115</td><td class="line">    <span class='directive'>sz = <span class='macro'>CTSIZE_PTR<span class='macro_popup'>8</span></span>;  /* Pass all other structs by reference. */ \</span></td></tr>
<tr class="codeline" data-linenumber="116"><td class="num" id="LN116">116</td><td class="line">  <span class='directive'>}</span></td></tr>
<tr class="codeline" data-linenumber="117"><td class="num" id="LN117">117</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="118"><td class="num" id="LN118">118</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_COMPLEXARG<span class='macro_popup'>isfp = 2;</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="119"><td class="num" id="LN119">119</td><td class="line">  <span class='directive'>/* Pass complex float in a GPR and complex double by reference. */ \</span></td></tr>
<tr class="codeline" data-linenumber="120"><td class="num" id="LN120">120</td><td class="line">  <span class='directive'>if (sz != 2*sizeof(float)) { \</span></td></tr>
<tr class="codeline" data-linenumber="121"><td class="num" id="LN121">121</td><td class="line">    <span class='directive'>rp = <span class='macro'>cdataptr(lj_cdata_new(cts, did, sz))<span class='macro_popup'>((void *)((lj_cdata_new(cts, did, sz))+1))</span></span>; \</span></td></tr>
<tr class="codeline" data-linenumber="122"><td class="num" id="LN122">122</td><td class="line">    <span class='directive'>sz = <span class='macro'>CTSIZE_PTR<span class='macro_popup'>8</span></span>; \</span></td></tr>
<tr class="codeline" data-linenumber="123"><td class="num" id="LN123">123</td><td class="line">  <span class='directive'>}</span></td></tr>
<tr class="codeline" data-linenumber="124"><td class="num" id="LN124">124</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="125"><td class="num" id="LN125">125</td><td class="line"><span class='comment'>/* Windows/x64 argument registers are strictly positional (use ngpr). */</span></td></tr>
<tr class="codeline" data-linenumber="126"><td class="num" id="LN126">126</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_REGARG<span class='macro_popup'>if (isfp) { int n2 = (((d-&gt;info) &amp; (0xf0000000u|0x08000000u<br>)) == (((CTInfo)(CT_ARRAY) &lt;&lt; 28) + (0x08000000u))) ? 1<br> : n; if (nfpr + n2 &lt;= 8) { dp = &amp;cc-&gt;fpr[nfpr]; nfpr<br> += n2; goto done; } } else { if (n &lt;= 2 &amp;&amp; ngpr +<br> n &lt;= maxgpr) { dp = &amp;cc-&gt;gpr[ngpr]; ngpr += n; goto<br> done; } }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="127"><td class="num" id="LN127">127</td><td class="line">  <span class='directive'>if (isfp) { \</span></td></tr>
<tr class="codeline" data-linenumber="128"><td class="num" id="LN128">128</td><td class="line">    <span class='directive'>if (ngpr &lt; maxgpr) { dp = &amp;cc-&gt;fpr[ngpr++]; nfpr = ngpr; goto done; } \</span></td></tr>
<tr class="codeline" data-linenumber="129"><td class="num" id="LN129">129</td><td class="line">  <span class='directive'>} else { \</span></td></tr>
<tr class="codeline" data-linenumber="130"><td class="num" id="LN130">130</td><td class="line">    <span class='directive'>if (ngpr &lt; maxgpr) { dp = &amp;cc-&gt;gpr[ngpr++]; goto done; } \</span></td></tr>
<tr class="codeline" data-linenumber="131"><td class="num" id="LN131">131</td><td class="line">  <span class='directive'>}</span></td></tr>
<tr class="codeline" data-linenumber="132"><td class="num" id="LN132">132</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="133"><td class="num" id="LN133">133</td><td class="line"><span class='directive'>#elif <span class='macro'>LJ_TARGET_X64<span class='macro_popup'>1</span></span></span></td></tr>
<tr class="codeline" data-linenumber="134"><td class="num" id="LN134">134</td><td class="line"><span class='comment'>/* -- POSIX/x64 calling conventions --------------------------------------- */</span></td></tr>
<tr class="codeline" data-linenumber="135"><td class="num" id="LN135">135</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="136"><td class="num" id="LN136">136</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_STRUCTRET<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; if (ccall_classify_struct(cts<br>, ctr, rcl, 0)) { cc-&gt;retref = 1; cc-&gt;gpr[ngpr++] = (GPRArg<br>)dp; } else { cc-&gt;retref = 0; }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="137"><td class="num" id="LN137">137</td><td class="line">  <span class='directive'>int rcl[2]; rcl[0] = rcl[1] = 0; \</span></td></tr>
<tr class="codeline" data-linenumber="138"><td class="num" id="LN138">138</td><td class="line">  <span class='directive'>if (ccall_classify_struct(cts, ctr, rcl, 0)) { \</span></td></tr>
<tr class="codeline" data-linenumber="139"><td class="num" id="LN139">139</td><td class="line">    <span class='directive'>cc-&gt;retref = 1;  /* Return struct by reference. */ \</span></td></tr>
<tr class="codeline" data-linenumber="140"><td class="num" id="LN140">140</td><td class="line">    <span class='directive'>cc-&gt;gpr[ngpr++] = (GPRArg)dp; \</span></td></tr>
<tr class="codeline" data-linenumber="141"><td class="num" id="LN141">141</td><td class="line">  <span class='directive'>} else { \</span></td></tr>
<tr class="codeline" data-linenumber="142"><td class="num" id="LN142">142</td><td class="line">    <span class='directive'>cc-&gt;retref = 0;  /* Return small structs in registers. */ \</span></td></tr>
<tr class="codeline" data-linenumber="143"><td class="num" id="LN143">143</td><td class="line">  <span class='directive'>}</span></td></tr>
<tr class="codeline" data-linenumber="144"><td class="num" id="LN144">144</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="145"><td class="num" id="LN145">145</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_STRUCTRET2<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; ccall_classify_struct(cts, ctr<br>, rcl, 0); ccall_struct_ret(cc, rcl, dp, ctr-&gt;size);</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="146"><td class="num" id="LN146">146</td><td class="line">  <span class='directive'>int rcl[2]; rcl[0] = rcl[1] = 0; \</span></td></tr>
<tr class="codeline" data-linenumber="147"><td class="num" id="LN147">147</td><td class="line">  <span class='directive'>ccall_classify_struct(cts, ctr, rcl, 0); \</span></td></tr>
<tr class="codeline" data-linenumber="148"><td class="num" id="LN148">148</td><td class="line">  <span class='directive'>ccall_struct_ret(cc, rcl, dp, ctr-&gt;size);</span></td></tr>
<tr class="codeline" data-linenumber="149"><td class="num" id="LN149">149</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="150"><td class="num" id="LN150">150</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_COMPLEXRET<span class='macro_popup'>cc-&gt;retref = 0;</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="151"><td class="num" id="LN151">151</td><td class="line">  <span class='directive'>/* Complex values are returned in one or two FPRs. */ \</span></td></tr>
<tr class="codeline" data-linenumber="152"><td class="num" id="LN152">152</td><td class="line">  <span class='directive'>cc-&gt;retref = 0;</span></td></tr>
<tr class="codeline" data-linenumber="153"><td class="num" id="LN153">153</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="154"><td class="num" id="LN154">154</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_COMPLEXRET2<span class='macro_popup'>if (ctr-&gt;size == 2*sizeof(float)) { *(int64_t *)dp = cc-&gt;<br>fpr[0].l[0]; } else { ((int64_t *)dp)[0] = cc-&gt;fpr[0].l[0]<br>; ((int64_t *)dp)[1] = cc-&gt;fpr[1].l[0]; }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="155"><td class="num" id="LN155">155</td><td class="line">  <span class='directive'>if (ctr-&gt;size == 2*sizeof(float)) {  /* Copy complex float from FPR. */ \</span></td></tr>
<tr class="codeline" data-linenumber="156"><td class="num" id="LN156">156</td><td class="line">    <span class='directive'>*(int64_t *)dp = cc-&gt;fpr[0].l[0]; \</span></td></tr>
<tr class="codeline" data-linenumber="157"><td class="num" id="LN157">157</td><td class="line">  <span class='directive'>} else {  /* Copy non-contiguous complex double from FPRs. */ \</span></td></tr>
<tr class="codeline" data-linenumber="158"><td class="num" id="LN158">158</td><td class="line">    <span class='directive'>((int64_t *)dp)[0] = cc-&gt;fpr[0].l[0]; \</span></td></tr>
<tr class="codeline" data-linenumber="159"><td class="num" id="LN159">159</td><td class="line">    <span class='directive'>((int64_t *)dp)[1] = cc-&gt;fpr[1].l[0]; \</span></td></tr>
<tr class="codeline" data-linenumber="160"><td class="num" id="LN160">160</td><td class="line">  <span class='directive'>}</span></td></tr>
<tr class="codeline" data-linenumber="161"><td class="num" id="LN161">161</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="162"><td class="num" id="LN162">162</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_STRUCTARG<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; if (!ccall_classify_struct(cts<br>, d, rcl, 0)) { cc-&gt;nsp = nsp; cc-&gt;ngpr = ngpr; cc-&gt;<br>nfpr = nfpr; if (ccall_struct_arg(cc, cts, d, rcl, o, narg)) goto<br> err_nyi; nsp = cc-&gt;nsp; ngpr = cc-&gt;ngpr; nfpr = cc-&gt;<br>nfpr; continue; }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="163"><td class="num" id="LN163">163</td><td class="line">  <span class='directive'>int rcl[2]; rcl[0] = rcl[1] = 0; \</span></td></tr>
<tr class="codeline" data-linenumber="164"><td class="num" id="LN164">164</td><td class="line">  <span class='directive'>if (!ccall_classify_struct(cts, d, rcl, 0)) { \</span></td></tr>
<tr class="codeline" data-linenumber="165"><td class="num" id="LN165">165</td><td class="line">    <span class='directive'>cc-&gt;nsp = nsp; cc-&gt;ngpr = ngpr; cc-&gt;nfpr = nfpr; \</span></td></tr>
<tr class="codeline" data-linenumber="166"><td class="num" id="LN166">166</td><td class="line">    <span class='directive'>if (ccall_struct_arg(cc, cts, d, rcl, o, narg)) goto err_nyi; \</span></td></tr>
<tr class="codeline" data-linenumber="167"><td class="num" id="LN167">167</td><td class="line">    <span class='directive'>nsp = cc-&gt;nsp; ngpr = cc-&gt;ngpr; nfpr = cc-&gt;nfpr; \</span></td></tr>
<tr class="codeline" data-linenumber="168"><td class="num" id="LN168">168</td><td class="line">    <span class='directive'>continue; \</span></td></tr>
<tr class="codeline" data-linenumber="169"><td class="num" id="LN169">169</td><td class="line">  <span class='directive'>}  /* Pass all other structs by value on stack. */</span></td></tr>
<tr class="codeline" data-linenumber="170"><td class="num" id="LN170">170</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="171"><td class="num" id="LN171">171</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_COMPLEXARG<span class='macro_popup'>isfp = 2;</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="172"><td class="num" id="LN172">172</td><td class="line">  <span class='directive'>isfp = 2;  /* Pass complex in FPRs or on stack. Needs postprocessing. */</span></td></tr>
<tr class="codeline" data-linenumber="173"><td class="num" id="LN173">173</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="174"><td class="num" id="LN174">174</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_REGARG<span class='macro_popup'>if (isfp) { int n2 = (((d-&gt;info) &amp; (0xf0000000u|0x08000000u<br>)) == (((CTInfo)(CT_ARRAY) &lt;&lt; 28) + (0x08000000u))) ? 1<br> : n; if (nfpr + n2 &lt;= 8) { dp = &amp;cc-&gt;fpr[nfpr]; nfpr<br> += n2; goto done; } } else { if (n &lt;= 2 &amp;&amp; ngpr +<br> n &lt;= maxgpr) { dp = &amp;cc-&gt;gpr[ngpr]; ngpr += n; goto<br> done; } }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="175"><td class="num" id="LN175">175</td><td class="line">  <span class='directive'>if (isfp) {  /* Try to pass argument in FPRs. */ \</span></td></tr>
<tr class="codeline" data-linenumber="176"><td class="num" id="LN176">176</td><td class="line">    <span class='directive'>int n2 = <span class='macro'>ctype_isvector(d-&gt;info)<span class='macro_popup'>(((d-&gt;info) &amp; (0xf0000000u|0x08000000u)) == (((CTInfo)<br>(CT_ARRAY) &lt;&lt; 28) + (0x08000000u)))</span></span> ? 1 : n; \</span></td></tr>
<tr class="codeline" data-linenumber="177"><td class="num" id="LN177">177</td><td class="line">    <span class='directive'>if (nfpr + n2 &lt;= <span class='macro'>CCALL_NARG_FPR<span class='macro_popup'>8</span></span>) { \</span></td></tr>
<tr class="codeline" data-linenumber="178"><td class="num" id="LN178">178</td><td class="line">      <span class='directive'>dp = &amp;cc-&gt;fpr[nfpr]; \</span></td></tr>
<tr class="codeline" data-linenumber="179"><td class="num" id="LN179">179</td><td class="line">      <span class='directive'>nfpr += n2; \</span></td></tr>
<tr class="codeline" data-linenumber="180"><td class="num" id="LN180">180</td><td class="line">      <span class='directive'>goto done; \</span></td></tr>
<tr class="codeline" data-linenumber="181"><td class="num" id="LN181">181</td><td class="line">    <span class='directive'>} \</span></td></tr>
<tr class="codeline" data-linenumber="182"><td class="num" id="LN182">182</td><td class="line">  <span class='directive'>} else {  /* Try to pass argument in GPRs. */ \</span></td></tr>
<tr class="codeline" data-linenumber="183"><td class="num" id="LN183">183</td><td class="line">    <span class='directive'>/* Note that reordering is explicitly allowed in the x64 ABI. */ \</span></td></tr>
<tr class="codeline" data-linenumber="184"><td class="num" id="LN184">184</td><td class="line">    <span class='directive'>if (n &lt;= 2 &amp;&amp; ngpr + n &lt;= maxgpr) { \</span></td></tr>
<tr class="codeline" data-linenumber="185"><td class="num" id="LN185">185</td><td class="line">      <span class='directive'>dp = &amp;cc-&gt;gpr[ngpr]; \</span></td></tr>
<tr class="codeline" data-linenumber="186"><td class="num" id="LN186">186</td><td class="line">      <span class='directive'>ngpr += n; \</span></td></tr>
<tr class="codeline" data-linenumber="187"><td class="num" id="LN187">187</td><td class="line">      <span class='directive'>goto done; \</span></td></tr>
<tr class="codeline" data-linenumber="188"><td class="num" id="LN188">188</td><td class="line">    <span class='directive'>} \</span></td></tr>
<tr class="codeline" data-linenumber="189"><td class="num" id="LN189">189</td><td class="line">  <span class='directive'>}</span></td></tr>
<tr class="codeline" data-linenumber="190"><td class="num" id="LN190">190</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="191"><td class="num" id="LN191">191</td><td class="line"><span class='directive'>#elif LJ_TARGET_ARM</span></td></tr>
<tr class="codeline" data-linenumber="192"><td class="num" id="LN192">192</td><td class="line"><span class='comment'>/* -- ARM calling conventions --------------------------------------------- */</span></td></tr>
<tr class="codeline" data-linenumber="193"><td class="num" id="LN193">193</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="194"><td class="num" id="LN194">194</td><td class="line"><span class='directive'>#if <span class='macro'>LJ_ABI_SOFTFP<span class='macro_popup'>0</span></span></span></td></tr>
<tr class="codeline" data-linenumber="195"><td class="num" id="LN195">195</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="196"><td class="num" id="LN196">196</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_STRUCTRET<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; if (ccall_classify_struct(cts<br>, ctr, rcl, 0)) { cc-&gt;retref = 1; cc-&gt;gpr[ngpr++] = (GPRArg<br>)dp; } else { cc-&gt;retref = 0; }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="197"><td class="num" id="LN197">197</td><td class="line">  <span class='directive'>/* Return structs of size &lt;= 4 in a GPR. */ \</span></td></tr>
<tr class="codeline" data-linenumber="198"><td class="num" id="LN198">198</td><td class="line">  <span class='directive'>cc-&gt;retref = !(sz &lt;= 4); \</span></td></tr>
<tr class="codeline" data-linenumber="199"><td class="num" id="LN199">199</td><td class="line">  <span class='directive'>if (cc-&gt;retref) cc-&gt;gpr[ngpr++] = (GPRArg)dp;</span></td></tr>
<tr class="codeline" data-linenumber="200"><td class="num" id="LN200">200</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="201"><td class="num" id="LN201">201</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_COMPLEXRET<span class='macro_popup'>cc-&gt;retref = 0;</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="202"><td class="num" id="LN202">202</td><td class="line">  <span class='directive'>cc-&gt;retref = 1;  /* Return all complex values by reference. */ \</span></td></tr>
<tr class="codeline" data-linenumber="203"><td class="num" id="LN203">203</td><td class="line">  <span class='directive'>cc-&gt;gpr[ngpr++] = (GPRArg)dp;</span></td></tr>
<tr class="codeline" data-linenumber="204"><td class="num" id="LN204">204</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="205"><td class="num" id="LN205">205</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_COMPLEXRET2<span class='macro_popup'>if (ctr-&gt;size == 2*sizeof(float)) { *(int64_t *)dp = cc-&gt;<br>fpr[0].l[0]; } else { ((int64_t *)dp)[0] = cc-&gt;fpr[0].l[0]<br>; ((int64_t *)dp)[1] = cc-&gt;fpr[1].l[0]; }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="206"><td class="num" id="LN206">206</td><td class="line">  <span class='directive'><span class='macro'>UNUSED(dp)<span class='macro_popup'>((void)(dp))</span></span>; /* Nothing to do. */</span></td></tr>
<tr class="codeline" data-linenumber="207"><td class="num" id="LN207">207</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="208"><td class="num" id="LN208">208</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_STRUCTARG<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; if (!ccall_classify_struct(cts<br>, d, rcl, 0)) { cc-&gt;nsp = nsp; cc-&gt;ngpr = ngpr; cc-&gt;<br>nfpr = nfpr; if (ccall_struct_arg(cc, cts, d, rcl, o, narg)) goto<br> err_nyi; nsp = cc-&gt;nsp; ngpr = cc-&gt;ngpr; nfpr = cc-&gt;<br>nfpr; continue; }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="209"><td class="num" id="LN209">209</td><td class="line">  <span class='directive'>/* Pass all structs by value in registers and/or on the stack. */</span></td></tr>
<tr class="codeline" data-linenumber="210"><td class="num" id="LN210">210</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="211"><td class="num" id="LN211">211</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_COMPLEXARG<span class='macro_popup'>isfp = 2;</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="212"><td class="num" id="LN212">212</td><td class="line">  <span class='directive'>/* Pass complex by value in 2 or 4 GPRs. */</span></td></tr>
<tr class="codeline" data-linenumber="213"><td class="num" id="LN213">213</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="214"><td class="num" id="LN214">214</td><td class="line"><span class='directive'>#define CCALL_HANDLE_REGARG_FP1</span></td></tr>
<tr class="codeline" data-linenumber="215"><td class="num" id="LN215">215</td><td class="line"><span class='directive'>#define CCALL_HANDLE_REGARG_FP2</span></td></tr>
<tr class="codeline" data-linenumber="216"><td class="num" id="LN216">216</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="217"><td class="num" id="LN217">217</td><td class="line"><span class='directive'>#else</span></td></tr>
<tr class="codeline" data-linenumber="218"><td class="num" id="LN218">218</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="219"><td class="num" id="LN219">219</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_STRUCTRET<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; if (ccall_classify_struct(cts<br>, ctr, rcl, 0)) { cc-&gt;retref = 1; cc-&gt;gpr[ngpr++] = (GPRArg<br>)dp; } else { cc-&gt;retref = 0; }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="220"><td class="num" id="LN220">220</td><td class="line">  <span class='directive'>cc-&gt;retref = !ccall_classify_struct(cts, ctr, ct); \</span></td></tr>
<tr class="codeline" data-linenumber="221"><td class="num" id="LN221">221</td><td class="line">  <span class='directive'>if (cc-&gt;retref) cc-&gt;gpr[ngpr++] = (GPRArg)dp;</span></td></tr>
<tr class="codeline" data-linenumber="222"><td class="num" id="LN222">222</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="223"><td class="num" id="LN223">223</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_STRUCTRET2<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; ccall_classify_struct(cts, ctr<br>, rcl, 0); ccall_struct_ret(cc, rcl, dp, ctr-&gt;size);</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="224"><td class="num" id="LN224">224</td><td class="line">  <span class='directive'>if (ccall_classify_struct(cts, ctr, ct) &gt; 1) sp = (uint8_t *)&amp;cc-&gt;fpr[0]; \</span></td></tr>
<tr class="codeline" data-linenumber="225"><td class="num" id="LN225">225</td><td class="line">  <span class='directive'>memcpy(dp, sp, ctr-&gt;size);</span></td></tr>
<tr class="codeline" data-linenumber="226"><td class="num" id="LN226">226</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="227"><td class="num" id="LN227">227</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_COMPLEXRET<span class='macro_popup'>cc-&gt;retref = 0;</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="228"><td class="num" id="LN228">228</td><td class="line">  <span class='directive'>if (!(ct-&gt;info &amp; <span class='macro'>CTF_VARARG<span class='macro_popup'>0x00800000u</span></span>)) cc-&gt;retref = 0;  /* Return complex in FPRs. */</span></td></tr>
<tr class="codeline" data-linenumber="229"><td class="num" id="LN229">229</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="230"><td class="num" id="LN230">230</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_COMPLEXRET2<span class='macro_popup'>if (ctr-&gt;size == 2*sizeof(float)) { *(int64_t *)dp = cc-&gt;<br>fpr[0].l[0]; } else { ((int64_t *)dp)[0] = cc-&gt;fpr[0].l[0]<br>; ((int64_t *)dp)[1] = cc-&gt;fpr[1].l[0]; }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="231"><td class="num" id="LN231">231</td><td class="line">  <span class='directive'>if (!(ct-&gt;info &amp; <span class='macro'>CTF_VARARG<span class='macro_popup'>0x00800000u</span></span>)) memcpy(dp, &amp;cc-&gt;fpr[0], ctr-&gt;size);</span></td></tr>
<tr class="codeline" data-linenumber="232"><td class="num" id="LN232">232</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="233"><td class="num" id="LN233">233</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_STRUCTARG<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; if (!ccall_classify_struct(cts<br>, d, rcl, 0)) { cc-&gt;nsp = nsp; cc-&gt;ngpr = ngpr; cc-&gt;<br>nfpr = nfpr; if (ccall_struct_arg(cc, cts, d, rcl, o, narg)) goto<br> err_nyi; nsp = cc-&gt;nsp; ngpr = cc-&gt;ngpr; nfpr = cc-&gt;<br>nfpr; continue; }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="234"><td class="num" id="LN234">234</td><td class="line">  <span class='directive'>isfp = (ccall_classify_struct(cts, d, ct) &gt; 1);</span></td></tr>
<tr class="codeline" data-linenumber="235"><td class="num" id="LN235">235</td><td class="line">  <span class='comment'>/* Pass all structs by value in registers and/or on the stack. */</span></td></tr>
<tr class="codeline" data-linenumber="236"><td class="num" id="LN236">236</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="237"><td class="num" id="LN237">237</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_COMPLEXARG<span class='macro_popup'>isfp = 2;</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="238"><td class="num" id="LN238">238</td><td class="line">  <span class='directive'>isfp = 1;  /* Pass complex by value in FPRs or on stack. */</span></td></tr>
<tr class="codeline" data-linenumber="239"><td class="num" id="LN239">239</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="240"><td class="num" id="LN240">240</td><td class="line"><span class='directive'>#define CCALL_HANDLE_REGARG_FP1 \</span></td></tr>
<tr class="codeline" data-linenumber="241"><td class="num" id="LN241">241</td><td class="line">  <span class='directive'>if (isfp &amp;&amp; !(ct-&gt;info &amp; <span class='macro'>CTF_VARARG<span class='macro_popup'>0x00800000u</span></span>)) { \</span></td></tr>
<tr class="codeline" data-linenumber="242"><td class="num" id="LN242">242</td><td class="line">    <span class='directive'>if ((d-&gt;info &amp; <span class='macro'>CTF_ALIGN<span class='macro_popup'>(15&lt;&lt;16)</span></span>) &gt; <span class='macro'>CTALIGN_PTR<span class='macro_popup'>((CTSize)(3) &lt;&lt; 16)</span></span>) { \</span></td></tr>
<tr class="codeline" data-linenumber="243"><td class="num" id="LN243">243</td><td class="line">      <span class='directive'>if (nfpr + (n &gt;&gt; 1) &lt;= <span class='macro'>CCALL_NARG_FPR<span class='macro_popup'>8</span></span>) { \</span></td></tr>
<tr class="codeline" data-linenumber="244"><td class="num" id="LN244">244</td><td class="line">	<span class='directive'>dp = &amp;cc-&gt;fpr[nfpr]; \</span></td></tr>
<tr class="codeline" data-linenumber="245"><td class="num" id="LN245">245</td><td class="line">	<span class='directive'>nfpr += (n &gt;&gt; 1); \</span></td></tr>
<tr class="codeline" data-linenumber="246"><td class="num" id="LN246">246</td><td class="line">	<span class='directive'>goto done; \</span></td></tr>
<tr class="codeline" data-linenumber="247"><td class="num" id="LN247">247</td><td class="line">      <span class='directive'>} \</span></td></tr>
<tr class="codeline" data-linenumber="248"><td class="num" id="LN248">248</td><td class="line">    <span class='directive'>} else { \</span></td></tr>
<tr class="codeline" data-linenumber="249"><td class="num" id="LN249">249</td><td class="line">      <span class='directive'>if (sz &gt; 1 &amp;&amp; fprodd != nfpr) fprodd = 0; \</span></td></tr>
<tr class="codeline" data-linenumber="250"><td class="num" id="LN250">250</td><td class="line">      <span class='directive'>if (fprodd) { \</span></td></tr>
<tr class="codeline" data-linenumber="251"><td class="num" id="LN251">251</td><td class="line">	<span class='directive'>if (2*nfpr+n &lt;= 2*<span class='macro'>CCALL_NARG_FPR<span class='macro_popup'>8</span></span>+1) { \</span></td></tr>
<tr class="codeline" data-linenumber="252"><td class="num" id="LN252">252</td><td class="line">	  <span class='directive'>dp = (void *)&amp;cc-&gt;fpr[fprodd-1].f[1]; \</span></td></tr>
<tr class="codeline" data-linenumber="253"><td class="num" id="LN253">253</td><td class="line">	  <span class='directive'>nfpr += (n &gt;&gt; 1); \</span></td></tr>
<tr class="codeline" data-linenumber="254"><td class="num" id="LN254">254</td><td class="line">	  <span class='directive'>if ((n &amp; 1)) fprodd = 0; else fprodd = nfpr-1; \</span></td></tr>
<tr class="codeline" data-linenumber="255"><td class="num" id="LN255">255</td><td class="line">	  <span class='directive'>goto done; \</span></td></tr>
<tr class="codeline" data-linenumber="256"><td class="num" id="LN256">256</td><td class="line">	<span class='directive'>} \</span></td></tr>
<tr class="codeline" data-linenumber="257"><td class="num" id="LN257">257</td><td class="line">      <span class='directive'>} else { \</span></td></tr>
<tr class="codeline" data-linenumber="258"><td class="num" id="LN258">258</td><td class="line">	<span class='directive'>if (2*nfpr+n &lt;= 2*<span class='macro'>CCALL_NARG_FPR<span class='macro_popup'>8</span></span>) { \</span></td></tr>
<tr class="codeline" data-linenumber="259"><td class="num" id="LN259">259</td><td class="line">	  <span class='directive'>dp = (void *)&amp;cc-&gt;fpr[nfpr]; \</span></td></tr>
<tr class="codeline" data-linenumber="260"><td class="num" id="LN260">260</td><td class="line">	  <span class='directive'>nfpr += (n &gt;&gt; 1); \</span></td></tr>
<tr class="codeline" data-linenumber="261"><td class="num" id="LN261">261</td><td class="line">	  <span class='directive'>if ((n &amp; 1)) fprodd = ++nfpr; else fprodd = 0; \</span></td></tr>
<tr class="codeline" data-linenumber="262"><td class="num" id="LN262">262</td><td class="line">	  <span class='directive'>goto done; \</span></td></tr>
<tr class="codeline" data-linenumber="263"><td class="num" id="LN263">263</td><td class="line">	<span class='directive'>} \</span></td></tr>
<tr class="codeline" data-linenumber="264"><td class="num" id="LN264">264</td><td class="line">      <span class='directive'>} \</span></td></tr>
<tr class="codeline" data-linenumber="265"><td class="num" id="LN265">265</td><td class="line">    <span class='directive'>} \</span></td></tr>
<tr class="codeline" data-linenumber="266"><td class="num" id="LN266">266</td><td class="line">    <span class='directive'>fprodd = 0;  /* No reordering after the first FP value is on stack. */ \</span></td></tr>
<tr class="codeline" data-linenumber="267"><td class="num" id="LN267">267</td><td class="line">  <span class='directive'>} else {</span></td></tr>
<tr class="codeline" data-linenumber="268"><td class="num" id="LN268">268</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="269"><td class="num" id="LN269">269</td><td class="line"><span class='directive'>#define CCALL_HANDLE_REGARG_FP2	}</span></td></tr>
<tr class="codeline" data-linenumber="270"><td class="num" id="LN270">270</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="271"><td class="num" id="LN271">271</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="272"><td class="num" id="LN272">272</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="273"><td class="num" id="LN273">273</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_REGARG<span class='macro_popup'>if (isfp) { int n2 = (((d-&gt;info) &amp; (0xf0000000u|0x08000000u<br>)) == (((CTInfo)(CT_ARRAY) &lt;&lt; 28) + (0x08000000u))) ? 1<br> : n; if (nfpr + n2 &lt;= 8) { dp = &amp;cc-&gt;fpr[nfpr]; nfpr<br> += n2; goto done; } } else { if (n &lt;= 2 &amp;&amp; ngpr +<br> n &lt;= maxgpr) { dp = &amp;cc-&gt;gpr[ngpr]; ngpr += n; goto<br> done; } }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="274"><td class="num" id="LN274">274</td><td class="line">  <span class='directive'>CCALL_HANDLE_REGARG_FP1 \</span></td></tr>
<tr class="codeline" data-linenumber="275"><td class="num" id="LN275">275</td><td class="line">  <span class='directive'>if ((d-&gt;info &amp; <span class='macro'>CTF_ALIGN<span class='macro_popup'>(15&lt;&lt;16)</span></span>) &gt; <span class='macro'>CTALIGN_PTR<span class='macro_popup'>((CTSize)(3) &lt;&lt; 16)</span></span>) { \</span></td></tr>
<tr class="codeline" data-linenumber="276"><td class="num" id="LN276">276</td><td class="line">    <span class='directive'>if (ngpr &lt; maxgpr) \</span></td></tr>
<tr class="codeline" data-linenumber="277"><td class="num" id="LN277">277</td><td class="line">      <span class='directive'>ngpr = (ngpr + 1u) &amp; ~1u;  /* Align to regpair. */ \</span></td></tr>
<tr class="codeline" data-linenumber="278"><td class="num" id="LN278">278</td><td class="line">  <span class='directive'>} \</span></td></tr>
<tr class="codeline" data-linenumber="279"><td class="num" id="LN279">279</td><td class="line">  <span class='directive'>if (ngpr &lt; maxgpr) { \</span></td></tr>
<tr class="codeline" data-linenumber="280"><td class="num" id="LN280">280</td><td class="line">    <span class='directive'>dp = &amp;cc-&gt;gpr[ngpr]; \</span></td></tr>
<tr class="codeline" data-linenumber="281"><td class="num" id="LN281">281</td><td class="line">    <span class='directive'>if (ngpr + n &gt; maxgpr) { \</span></td></tr>
<tr class="codeline" data-linenumber="282"><td class="num" id="LN282">282</td><td class="line">      <span class='directive'>nsp += ngpr + n - maxgpr;  /* Assumes contiguous gpr/stack fields. */ \</span></td></tr>
<tr class="codeline" data-linenumber="283"><td class="num" id="LN283">283</td><td class="line">      <span class='directive'>if (nsp &gt; <span class='macro'>CCALL_MAXSTACK<span class='macro_popup'>32</span></span>) goto err_nyi;  /* Too many arguments. */ \</span></td></tr>
<tr class="codeline" data-linenumber="284"><td class="num" id="LN284">284</td><td class="line">      <span class='directive'>ngpr = maxgpr; \</span></td></tr>
<tr class="codeline" data-linenumber="285"><td class="num" id="LN285">285</td><td class="line">    <span class='directive'>} else { \</span></td></tr>
<tr class="codeline" data-linenumber="286"><td class="num" id="LN286">286</td><td class="line">      <span class='directive'>ngpr += n; \</span></td></tr>
<tr class="codeline" data-linenumber="287"><td class="num" id="LN287">287</td><td class="line">    <span class='directive'>} \</span></td></tr>
<tr class="codeline" data-linenumber="288"><td class="num" id="LN288">288</td><td class="line">    <span class='directive'>goto done; \</span></td></tr>
<tr class="codeline" data-linenumber="289"><td class="num" id="LN289">289</td><td class="line">  <span class='directive'>} CCALL_HANDLE_REGARG_FP2</span></td></tr>
<tr class="codeline" data-linenumber="290"><td class="num" id="LN290">290</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="291"><td class="num" id="LN291">291</td><td class="line"><span class='directive'>#define CCALL_HANDLE_RET \</span></td></tr>
<tr class="codeline" data-linenumber="292"><td class="num" id="LN292">292</td><td class="line">  <span class='directive'>if ((ct-&gt;info &amp; <span class='macro'>CTF_VARARG<span class='macro_popup'>0x00800000u</span></span>)) sp = (uint8_t *)&amp;cc-&gt;gpr[0];</span></td></tr>
<tr class="codeline" data-linenumber="293"><td class="num" id="LN293">293</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="294"><td class="num" id="LN294">294</td><td class="line"><span class='directive'>#elif LJ_TARGET_PPC</span></td></tr>
<tr class="codeline" data-linenumber="295"><td class="num" id="LN295">295</td><td class="line"><span class='comment'>/* -- PPC calling conventions --------------------------------------------- */</span></td></tr>
<tr class="codeline" data-linenumber="296"><td class="num" id="LN296">296</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="297"><td class="num" id="LN297">297</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_STRUCTRET<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; if (ccall_classify_struct(cts<br>, ctr, rcl, 0)) { cc-&gt;retref = 1; cc-&gt;gpr[ngpr++] = (GPRArg<br>)dp; } else { cc-&gt;retref = 0; }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="298"><td class="num" id="LN298">298</td><td class="line">  <span class='directive'>cc-&gt;retref = 1;  /* Return all structs by reference. */ \</span></td></tr>
<tr class="codeline" data-linenumber="299"><td class="num" id="LN299">299</td><td class="line">  <span class='directive'>cc-&gt;gpr[ngpr++] = (GPRArg)dp;</span></td></tr>
<tr class="codeline" data-linenumber="300"><td class="num" id="LN300">300</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="301"><td class="num" id="LN301">301</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_COMPLEXRET<span class='macro_popup'>cc-&gt;retref = 0;</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="302"><td class="num" id="LN302">302</td><td class="line">  <span class='directive'>/* Complex values are returned in 2 or 4 GPRs. */ \</span></td></tr>
<tr class="codeline" data-linenumber="303"><td class="num" id="LN303">303</td><td class="line">  <span class='directive'>cc-&gt;retref = 0;</span></td></tr>
<tr class="codeline" data-linenumber="304"><td class="num" id="LN304">304</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="305"><td class="num" id="LN305">305</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_COMPLEXRET2<span class='macro_popup'>if (ctr-&gt;size == 2*sizeof(float)) { *(int64_t *)dp = cc-&gt;<br>fpr[0].l[0]; } else { ((int64_t *)dp)[0] = cc-&gt;fpr[0].l[0]<br>; ((int64_t *)dp)[1] = cc-&gt;fpr[1].l[0]; }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="306"><td class="num" id="LN306">306</td><td class="line">  <span class='directive'>memcpy(dp, sp, ctr-&gt;size);  /* Copy complex from GPRs. */</span></td></tr>
<tr class="codeline" data-linenumber="307"><td class="num" id="LN307">307</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="308"><td class="num" id="LN308">308</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_STRUCTARG<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; if (!ccall_classify_struct(cts<br>, d, rcl, 0)) { cc-&gt;nsp = nsp; cc-&gt;ngpr = ngpr; cc-&gt;<br>nfpr = nfpr; if (ccall_struct_arg(cc, cts, d, rcl, o, narg)) goto<br> err_nyi; nsp = cc-&gt;nsp; ngpr = cc-&gt;ngpr; nfpr = cc-&gt;<br>nfpr; continue; }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="309"><td class="num" id="LN309">309</td><td class="line">  <span class='directive'>rp = <span class='macro'>cdataptr(lj_cdata_new(cts, did, sz))<span class='macro_popup'>((void *)((lj_cdata_new(cts, did, sz))+1))</span></span>; \</span></td></tr>
<tr class="codeline" data-linenumber="310"><td class="num" id="LN310">310</td><td class="line">  <span class='directive'>sz = <span class='macro'>CTSIZE_PTR<span class='macro_popup'>8</span></span>;  /* Pass all structs by reference. */</span></td></tr>
<tr class="codeline" data-linenumber="311"><td class="num" id="LN311">311</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="312"><td class="num" id="LN312">312</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_COMPLEXARG<span class='macro_popup'>isfp = 2;</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="313"><td class="num" id="LN313">313</td><td class="line">  <span class='directive'>/* Pass complex by value in 2 or 4 GPRs. */</span></td></tr>
<tr class="codeline" data-linenumber="314"><td class="num" id="LN314">314</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="315"><td class="num" id="LN315">315</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_REGARG<span class='macro_popup'>if (isfp) { int n2 = (((d-&gt;info) &amp; (0xf0000000u|0x08000000u<br>)) == (((CTInfo)(CT_ARRAY) &lt;&lt; 28) + (0x08000000u))) ? 1<br> : n; if (nfpr + n2 &lt;= 8) { dp = &amp;cc-&gt;fpr[nfpr]; nfpr<br> += n2; goto done; } } else { if (n &lt;= 2 &amp;&amp; ngpr +<br> n &lt;= maxgpr) { dp = &amp;cc-&gt;gpr[ngpr]; ngpr += n; goto<br> done; } }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="316"><td class="num" id="LN316">316</td><td class="line">  <span class='directive'>if (isfp) {  /* Try to pass argument in FPRs. */ \</span></td></tr>
<tr class="codeline" data-linenumber="317"><td class="num" id="LN317">317</td><td class="line">    <span class='directive'>if (nfpr + 1 &lt;= <span class='macro'>CCALL_NARG_FPR<span class='macro_popup'>8</span></span>) { \</span></td></tr>
<tr class="codeline" data-linenumber="318"><td class="num" id="LN318">318</td><td class="line">      <span class='directive'>dp = &amp;cc-&gt;fpr[nfpr]; \</span></td></tr>
<tr class="codeline" data-linenumber="319"><td class="num" id="LN319">319</td><td class="line">      <span class='directive'>nfpr += 1; \</span></td></tr>
<tr class="codeline" data-linenumber="320"><td class="num" id="LN320">320</td><td class="line">      <span class='directive'>d = ctype_get(cts, CTID_DOUBLE);  /* FPRs always hold doubles. */ \</span></td></tr>
<tr class="codeline" data-linenumber="321"><td class="num" id="LN321">321</td><td class="line">      <span class='directive'>goto done; \</span></td></tr>
<tr class="codeline" data-linenumber="322"><td class="num" id="LN322">322</td><td class="line">    <span class='directive'>} \</span></td></tr>
<tr class="codeline" data-linenumber="323"><td class="num" id="LN323">323</td><td class="line">  <span class='directive'>} else {  /* Try to pass argument in GPRs. */ \</span></td></tr>
<tr class="codeline" data-linenumber="324"><td class="num" id="LN324">324</td><td class="line">    <span class='directive'>if (n &gt; 1) { \</span></td></tr>
<tr class="codeline" data-linenumber="325"><td class="num" id="LN325">325</td><td class="line">      <span class='directive'><span class='macro'>lua_assert(n == 2 || n == 4)<span class='macro_popup'>((void)0)</span></span>;  /* int64_t or complex (float). */ \</span></td></tr>
<tr class="codeline" data-linenumber="326"><td class="num" id="LN326">326</td><td class="line">      <span class='directive'>if (<span class='macro'>ctype_isinteger(d-&gt;info)<span class='macro_popup'>(((d-&gt;info) &amp; (0xf0000000u|0x08000000u|0x04000000u)) ==<br> (((CTInfo)(CT_NUM) &lt;&lt; 28) + (0)))</span></span>) \</span></td></tr>
<tr class="codeline" data-linenumber="327"><td class="num" id="LN327">327</td><td class="line">	<span class='directive'>ngpr = (ngpr + 1u) &amp; ~1u;  /* Align int64_t to regpair. */ \</span></td></tr>
<tr class="codeline" data-linenumber="328"><td class="num" id="LN328">328</td><td class="line">      <span class='directive'>else if (ngpr + n &gt; maxgpr) \</span></td></tr>
<tr class="codeline" data-linenumber="329"><td class="num" id="LN329">329</td><td class="line">	<span class='directive'>ngpr = maxgpr;  /* Prevent reordering. */ \</span></td></tr>
<tr class="codeline" data-linenumber="330"><td class="num" id="LN330">330</td><td class="line">    <span class='directive'>} \</span></td></tr>
<tr class="codeline" data-linenumber="331"><td class="num" id="LN331">331</td><td class="line">    <span class='directive'>if (ngpr + n &lt;= maxgpr) { \</span></td></tr>
<tr class="codeline" data-linenumber="332"><td class="num" id="LN332">332</td><td class="line">      <span class='directive'>dp = &amp;cc-&gt;gpr[ngpr]; \</span></td></tr>
<tr class="codeline" data-linenumber="333"><td class="num" id="LN333">333</td><td class="line">      <span class='directive'>ngpr += n; \</span></td></tr>
<tr class="codeline" data-linenumber="334"><td class="num" id="LN334">334</td><td class="line">      <span class='directive'>goto done; \</span></td></tr>
<tr class="codeline" data-linenumber="335"><td class="num" id="LN335">335</td><td class="line">    <span class='directive'>} \</span></td></tr>
<tr class="codeline" data-linenumber="336"><td class="num" id="LN336">336</td><td class="line">  <span class='directive'>}</span></td></tr>
<tr class="codeline" data-linenumber="337"><td class="num" id="LN337">337</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="338"><td class="num" id="LN338">338</td><td class="line"><span class='directive'>#define CCALL_HANDLE_RET \</span></td></tr>
<tr class="codeline" data-linenumber="339"><td class="num" id="LN339">339</td><td class="line">  <span class='directive'>if (<span class='macro'>ctype_isfp(ctr-&gt;info)<span class='macro_popup'>(((ctr-&gt;info) &amp; (0xf0000000u|0x04000000u)) == (((CTInfo<br>)(CT_NUM) &lt;&lt; 28) + (0x04000000u)))</span></span> &amp;&amp; ctr-&gt;size == sizeof(float)) \</span></td></tr>
<tr class="codeline" data-linenumber="340"><td class="num" id="LN340">340</td><td class="line">    <span class='directive'>ctr = ctype_get(cts, CTID_DOUBLE);  /* FPRs always hold doubles. */</span></td></tr>
<tr class="codeline" data-linenumber="341"><td class="num" id="LN341">341</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="342"><td class="num" id="LN342">342</td><td class="line"><span class='directive'>#elif LJ_TARGET_PPCSPE</span></td></tr>
<tr class="codeline" data-linenumber="343"><td class="num" id="LN343">343</td><td class="line"><span class='comment'>/* -- PPC/SPE calling conventions ----------------------------------------- */</span></td></tr>
<tr class="codeline" data-linenumber="344"><td class="num" id="LN344">344</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="345"><td class="num" id="LN345">345</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_STRUCTRET<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; if (ccall_classify_struct(cts<br>, ctr, rcl, 0)) { cc-&gt;retref = 1; cc-&gt;gpr[ngpr++] = (GPRArg<br>)dp; } else { cc-&gt;retref = 0; }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="346"><td class="num" id="LN346">346</td><td class="line">  <span class='directive'>cc-&gt;retref = 1;  /* Return all structs by reference. */ \</span></td></tr>
<tr class="codeline" data-linenumber="347"><td class="num" id="LN347">347</td><td class="line">  <span class='directive'>cc-&gt;gpr[ngpr++] = (GPRArg)dp;</span></td></tr>
<tr class="codeline" data-linenumber="348"><td class="num" id="LN348">348</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="349"><td class="num" id="LN349">349</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_COMPLEXRET<span class='macro_popup'>cc-&gt;retref = 0;</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="350"><td class="num" id="LN350">350</td><td class="line">  <span class='directive'>/* Complex values are returned in 2 or 4 GPRs. */ \</span></td></tr>
<tr class="codeline" data-linenumber="351"><td class="num" id="LN351">351</td><td class="line">  <span class='directive'>cc-&gt;retref = 0;</span></td></tr>
<tr class="codeline" data-linenumber="352"><td class="num" id="LN352">352</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="353"><td class="num" id="LN353">353</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_COMPLEXRET2<span class='macro_popup'>if (ctr-&gt;size == 2*sizeof(float)) { *(int64_t *)dp = cc-&gt;<br>fpr[0].l[0]; } else { ((int64_t *)dp)[0] = cc-&gt;fpr[0].l[0]<br>; ((int64_t *)dp)[1] = cc-&gt;fpr[1].l[0]; }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="354"><td class="num" id="LN354">354</td><td class="line">  <span class='directive'>memcpy(dp, sp, ctr-&gt;size);  /* Copy complex from GPRs. */</span></td></tr>
<tr class="codeline" data-linenumber="355"><td class="num" id="LN355">355</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="356"><td class="num" id="LN356">356</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_STRUCTARG<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; if (!ccall_classify_struct(cts<br>, d, rcl, 0)) { cc-&gt;nsp = nsp; cc-&gt;ngpr = ngpr; cc-&gt;<br>nfpr = nfpr; if (ccall_struct_arg(cc, cts, d, rcl, o, narg)) goto<br> err_nyi; nsp = cc-&gt;nsp; ngpr = cc-&gt;ngpr; nfpr = cc-&gt;<br>nfpr; continue; }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="357"><td class="num" id="LN357">357</td><td class="line">  <span class='directive'>rp = <span class='macro'>cdataptr(lj_cdata_new(cts, did, sz))<span class='macro_popup'>((void *)((lj_cdata_new(cts, did, sz))+1))</span></span>; \</span></td></tr>
<tr class="codeline" data-linenumber="358"><td class="num" id="LN358">358</td><td class="line">  <span class='directive'>sz = <span class='macro'>CTSIZE_PTR<span class='macro_popup'>8</span></span>;  /* Pass all structs by reference. */</span></td></tr>
<tr class="codeline" data-linenumber="359"><td class="num" id="LN359">359</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="360"><td class="num" id="LN360">360</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_COMPLEXARG<span class='macro_popup'>isfp = 2;</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="361"><td class="num" id="LN361">361</td><td class="line">  <span class='directive'>/* Pass complex by value in 2 or 4 GPRs. */</span></td></tr>
<tr class="codeline" data-linenumber="362"><td class="num" id="LN362">362</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="363"><td class="num" id="LN363">363</td><td class="line"><span class='comment'>/* PPC/SPE has a softfp ABI. */</span></td></tr>
<tr class="codeline" data-linenumber="364"><td class="num" id="LN364">364</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_REGARG<span class='macro_popup'>if (isfp) { int n2 = (((d-&gt;info) &amp; (0xf0000000u|0x08000000u<br>)) == (((CTInfo)(CT_ARRAY) &lt;&lt; 28) + (0x08000000u))) ? 1<br> : n; if (nfpr + n2 &lt;= 8) { dp = &amp;cc-&gt;fpr[nfpr]; nfpr<br> += n2; goto done; } } else { if (n &lt;= 2 &amp;&amp; ngpr +<br> n &lt;= maxgpr) { dp = &amp;cc-&gt;gpr[ngpr]; ngpr += n; goto<br> done; } }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="365"><td class="num" id="LN365">365</td><td class="line">  <span class='directive'>if (n &gt; 1) {  /* Doesn't fit in a single GPR? */ \</span></td></tr>
<tr class="codeline" data-linenumber="366"><td class="num" id="LN366">366</td><td class="line">    <span class='directive'><span class='macro'>lua_assert(n == 2 || n == 4)<span class='macro_popup'>((void)0)</span></span>;  /* int64_t, double or complex (float). */ \</span></td></tr>
<tr class="codeline" data-linenumber="367"><td class="num" id="LN367">367</td><td class="line">    <span class='directive'>if (n == 2) \</span></td></tr>
<tr class="codeline" data-linenumber="368"><td class="num" id="LN368">368</td><td class="line">      <span class='directive'>ngpr = (ngpr + 1u) &amp; ~1u;  /* Only align 64 bit value to regpair. */ \</span></td></tr>
<tr class="codeline" data-linenumber="369"><td class="num" id="LN369">369</td><td class="line">    <span class='directive'>else if (ngpr + n &gt; maxgpr) \</span></td></tr>
<tr class="codeline" data-linenumber="370"><td class="num" id="LN370">370</td><td class="line">      <span class='directive'>ngpr = maxgpr;  /* Prevent reordering. */ \</span></td></tr>
<tr class="codeline" data-linenumber="371"><td class="num" id="LN371">371</td><td class="line">  <span class='directive'>} \</span></td></tr>
<tr class="codeline" data-linenumber="372"><td class="num" id="LN372">372</td><td class="line">  <span class='directive'>if (ngpr + n &lt;= maxgpr) { \</span></td></tr>
<tr class="codeline" data-linenumber="373"><td class="num" id="LN373">373</td><td class="line">    <span class='directive'>dp = &amp;cc-&gt;gpr[ngpr]; \</span></td></tr>
<tr class="codeline" data-linenumber="374"><td class="num" id="LN374">374</td><td class="line">    <span class='directive'>ngpr += n; \</span></td></tr>
<tr class="codeline" data-linenumber="375"><td class="num" id="LN375">375</td><td class="line">    <span class='directive'>goto done; \</span></td></tr>
<tr class="codeline" data-linenumber="376"><td class="num" id="LN376">376</td><td class="line">  <span class='directive'>}</span></td></tr>
<tr class="codeline" data-linenumber="377"><td class="num" id="LN377">377</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="378"><td class="num" id="LN378">378</td><td class="line"><span class='directive'>#elif LJ_TARGET_MIPS</span></td></tr>
<tr class="codeline" data-linenumber="379"><td class="num" id="LN379">379</td><td class="line"><span class='comment'>/* -- MIPS calling conventions -------------------------------------------- */</span></td></tr>
<tr class="codeline" data-linenumber="380"><td class="num" id="LN380">380</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="381"><td class="num" id="LN381">381</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_STRUCTRET<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; if (ccall_classify_struct(cts<br>, ctr, rcl, 0)) { cc-&gt;retref = 1; cc-&gt;gpr[ngpr++] = (GPRArg<br>)dp; } else { cc-&gt;retref = 0; }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="382"><td class="num" id="LN382">382</td><td class="line">  <span class='directive'>cc-&gt;retref = 1;  /* Return all structs by reference. */ \</span></td></tr>
<tr class="codeline" data-linenumber="383"><td class="num" id="LN383">383</td><td class="line">  <span class='directive'>cc-&gt;gpr[ngpr++] = (GPRArg)dp;</span></td></tr>
<tr class="codeline" data-linenumber="384"><td class="num" id="LN384">384</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="385"><td class="num" id="LN385">385</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_COMPLEXRET<span class='macro_popup'>cc-&gt;retref = 0;</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="386"><td class="num" id="LN386">386</td><td class="line">  <span class='directive'>/* Complex values are returned in 1 or 2 FPRs. */ \</span></td></tr>
<tr class="codeline" data-linenumber="387"><td class="num" id="LN387">387</td><td class="line">  <span class='directive'>cc-&gt;retref = 0;</span></td></tr>
<tr class="codeline" data-linenumber="388"><td class="num" id="LN388">388</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="389"><td class="num" id="LN389">389</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_COMPLEXRET2<span class='macro_popup'>if (ctr-&gt;size == 2*sizeof(float)) { *(int64_t *)dp = cc-&gt;<br>fpr[0].l[0]; } else { ((int64_t *)dp)[0] = cc-&gt;fpr[0].l[0]<br>; ((int64_t *)dp)[1] = cc-&gt;fpr[1].l[0]; }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="390"><td class="num" id="LN390">390</td><td class="line">  <span class='directive'>if (ctr-&gt;size == 2*sizeof(float)) {  /* Copy complex float from FPRs. */ \</span></td></tr>
<tr class="codeline" data-linenumber="391"><td class="num" id="LN391">391</td><td class="line">    <span class='directive'>((float *)dp)[0] = cc-&gt;fpr[0].f; \</span></td></tr>
<tr class="codeline" data-linenumber="392"><td class="num" id="LN392">392</td><td class="line">    <span class='directive'>((float *)dp)[1] = cc-&gt;fpr[1].f; \</span></td></tr>
<tr class="codeline" data-linenumber="393"><td class="num" id="LN393">393</td><td class="line">  <span class='directive'>} else {  /* Copy complex double from FPRs. */ \</span></td></tr>
<tr class="codeline" data-linenumber="394"><td class="num" id="LN394">394</td><td class="line">    <span class='directive'>((double *)dp)[0] = cc-&gt;fpr[0].d; \</span></td></tr>
<tr class="codeline" data-linenumber="395"><td class="num" id="LN395">395</td><td class="line">    <span class='directive'>((double *)dp)[1] = cc-&gt;fpr[1].d; \</span></td></tr>
<tr class="codeline" data-linenumber="396"><td class="num" id="LN396">396</td><td class="line">  <span class='directive'>}</span></td></tr>
<tr class="codeline" data-linenumber="397"><td class="num" id="LN397">397</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="398"><td class="num" id="LN398">398</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_STRUCTARG<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; if (!ccall_classify_struct(cts<br>, d, rcl, 0)) { cc-&gt;nsp = nsp; cc-&gt;ngpr = ngpr; cc-&gt;<br>nfpr = nfpr; if (ccall_struct_arg(cc, cts, d, rcl, o, narg)) goto<br> err_nyi; nsp = cc-&gt;nsp; ngpr = cc-&gt;ngpr; nfpr = cc-&gt;<br>nfpr; continue; }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="399"><td class="num" id="LN399">399</td><td class="line">  <span class='directive'>/* Pass all structs by value in registers and/or on the stack. */</span></td></tr>
<tr class="codeline" data-linenumber="400"><td class="num" id="LN400">400</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="401"><td class="num" id="LN401">401</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_COMPLEXARG<span class='macro_popup'>isfp = 2;</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="402"><td class="num" id="LN402">402</td><td class="line">  <span class='directive'>/* Pass complex by value in 2 or 4 GPRs. */</span></td></tr>
<tr class="codeline" data-linenumber="403"><td class="num" id="LN403">403</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="404"><td class="num" id="LN404">404</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_REGARG<span class='macro_popup'>if (isfp) { int n2 = (((d-&gt;info) &amp; (0xf0000000u|0x08000000u<br>)) == (((CTInfo)(CT_ARRAY) &lt;&lt; 28) + (0x08000000u))) ? 1<br> : n; if (nfpr + n2 &lt;= 8) { dp = &amp;cc-&gt;fpr[nfpr]; nfpr<br> += n2; goto done; } } else { if (n &lt;= 2 &amp;&amp; ngpr +<br> n &lt;= maxgpr) { dp = &amp;cc-&gt;gpr[ngpr]; ngpr += n; goto<br> done; } }</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="405"><td class="num" id="LN405">405</td><td class="line">  <span class='directive'>if (isfp &amp;&amp; nfpr &lt; <span class='macro'>CCALL_NARG_FPR<span class='macro_popup'>8</span></span> &amp;&amp; !(ct-&gt;info &amp; <span class='macro'>CTF_VARARG<span class='macro_popup'>0x00800000u</span></span>)) { \</span></td></tr>
<tr class="codeline" data-linenumber="406"><td class="num" id="LN406">406</td><td class="line">    <span class='directive'>/* Try to pass argument in FPRs. */ \</span></td></tr>
<tr class="codeline" data-linenumber="407"><td class="num" id="LN407">407</td><td class="line">    <span class='directive'>dp = n == 1 ? (void *)&amp;cc-&gt;fpr[nfpr].f : (void *)&amp;cc-&gt;fpr[nfpr].d; \</span></td></tr>
<tr class="codeline" data-linenumber="408"><td class="num" id="LN408">408</td><td class="line">    <span class='directive'>nfpr++; ngpr += n; \</span></td></tr>
<tr class="codeline" data-linenumber="409"><td class="num" id="LN409">409</td><td class="line">    <span class='directive'>goto done; \</span></td></tr>
<tr class="codeline" data-linenumber="410"><td class="num" id="LN410">410</td><td class="line">  <span class='directive'>} else {  /* Try to pass argument in GPRs. */ \</span></td></tr>
<tr class="codeline" data-linenumber="411"><td class="num" id="LN411">411</td><td class="line">    <span class='directive'>nfpr = <span class='macro'>CCALL_NARG_FPR<span class='macro_popup'>8</span></span>; \</span></td></tr>
<tr class="codeline" data-linenumber="412"><td class="num" id="LN412">412</td><td class="line">    <span class='directive'>if ((d-&gt;info &amp; <span class='macro'>CTF_ALIGN<span class='macro_popup'>(15&lt;&lt;16)</span></span>) &gt; <span class='macro'>CTALIGN_PTR<span class='macro_popup'>((CTSize)(3) &lt;&lt; 16)</span></span>) \</span></td></tr>
<tr class="codeline" data-linenumber="413"><td class="num" id="LN413">413</td><td class="line">      <span class='directive'>ngpr = (ngpr + 1u) &amp; ~1u;  /* Align to regpair. */ \</span></td></tr>
<tr class="codeline" data-linenumber="414"><td class="num" id="LN414">414</td><td class="line">    <span class='directive'>if (ngpr &lt; maxgpr) { \</span></td></tr>
<tr class="codeline" data-linenumber="415"><td class="num" id="LN415">415</td><td class="line">      <span class='directive'>dp = &amp;cc-&gt;gpr[ngpr]; \</span></td></tr>
<tr class="codeline" data-linenumber="416"><td class="num" id="LN416">416</td><td class="line">      <span class='directive'>if (ngpr + n &gt; maxgpr) { \</span></td></tr>
<tr class="codeline" data-linenumber="417"><td class="num" id="LN417">417</td><td class="line">	<span class='directive'>nsp += ngpr + n - maxgpr;  /* Assumes contiguous gpr/stack fields. */ \</span></td></tr>
<tr class="codeline" data-linenumber="418"><td class="num" id="LN418">418</td><td class="line">	<span class='directive'>if (nsp &gt; <span class='macro'>CCALL_MAXSTACK<span class='macro_popup'>32</span></span>) goto err_nyi;  /* Too many arguments. */ \</span></td></tr>
<tr class="codeline" data-linenumber="419"><td class="num" id="LN419">419</td><td class="line">	<span class='directive'>ngpr = maxgpr; \</span></td></tr>
<tr class="codeline" data-linenumber="420"><td class="num" id="LN420">420</td><td class="line">      <span class='directive'>} else { \</span></td></tr>
<tr class="codeline" data-linenumber="421"><td class="num" id="LN421">421</td><td class="line">	<span class='directive'>ngpr += n; \</span></td></tr>
<tr class="codeline" data-linenumber="422"><td class="num" id="LN422">422</td><td class="line">      <span class='directive'>} \</span></td></tr>
<tr class="codeline" data-linenumber="423"><td class="num" id="LN423">423</td><td class="line">      <span class='directive'>goto done; \</span></td></tr>
<tr class="codeline" data-linenumber="424"><td class="num" id="LN424">424</td><td class="line">    <span class='directive'>} \</span></td></tr>
<tr class="codeline" data-linenumber="425"><td class="num" id="LN425">425</td><td class="line">  <span class='directive'>}</span></td></tr>
<tr class="codeline" data-linenumber="426"><td class="num" id="LN426">426</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="427"><td class="num" id="LN427">427</td><td class="line"><span class='directive'>#define CCALL_HANDLE_RET \</span></td></tr>
<tr class="codeline" data-linenumber="428"><td class="num" id="LN428">428</td><td class="line">  <span class='directive'>if (<span class='macro'>ctype_isfp(ctr-&gt;info)<span class='macro_popup'>(((ctr-&gt;info) &amp; (0xf0000000u|0x04000000u)) == (((CTInfo<br>)(CT_NUM) &lt;&lt; 28) + (0x04000000u)))</span></span> &amp;&amp; ctr-&gt;size == sizeof(float)) \</span></td></tr>
<tr class="codeline" data-linenumber="429"><td class="num" id="LN429">429</td><td class="line">    <span class='directive'>sp = (uint8_t *)&amp;cc-&gt;fpr[0].f;</span></td></tr>
<tr class="codeline" data-linenumber="430"><td class="num" id="LN430">430</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="431"><td class="num" id="LN431">431</td><td class="line"><span class='directive'>#else</span></td></tr>
<tr class="codeline" data-linenumber="432"><td class="num" id="LN432">432</td><td class="line"><span class='directive'>#error "Missing calling convention definitions for this architecture"</span></td></tr>
<tr class="codeline" data-linenumber="433"><td class="num" id="LN433">433</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="434"><td class="num" id="LN434">434</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="435"><td class="num" id="LN435">435</td><td class="line"><span class='directive'>#ifndef <span class='macro'>CCALL_HANDLE_STRUCTRET2<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; ccall_classify_struct(cts, ctr<br>, rcl, 0); ccall_struct_ret(cc, rcl, dp, ctr-&gt;size);</span></span></span></td></tr>
<tr class="codeline" data-linenumber="436"><td class="num" id="LN436">436</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_HANDLE_STRUCTRET2<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; ccall_classify_struct(cts, ctr<br>, rcl, 0); ccall_struct_ret(cc, rcl, dp, ctr-&gt;size);</span></span> \</span></td></tr>
<tr class="codeline" data-linenumber="437"><td class="num" id="LN437">437</td><td class="line">  <span class='directive'>memcpy(dp, sp, ctr-&gt;size);  /* Copy struct return value from GPRs. */</span></td></tr>
<tr class="codeline" data-linenumber="438"><td class="num" id="LN438">438</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="439"><td class="num" id="LN439">439</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="440"><td class="num" id="LN440">440</td><td class="line"><span class='comment'>/* -- x86 OSX ABI struct classification ----------------------------------- */</span></td></tr>
<tr class="codeline" data-linenumber="441"><td class="num" id="LN441">441</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="442"><td class="num" id="LN442">442</td><td class="line"><span class='directive'>#if LJ_TARGET_X86 &amp;&amp; <span class='macro'>LJ_TARGET_OSX<span class='macro_popup'>(2 == 3)</span></span></span></td></tr>
<tr class="codeline" data-linenumber="443"><td class="num" id="LN443">443</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="444"><td class="num" id="LN444">444</td><td class="line"><span class='comment'>/* Check for struct with single FP field. */</span></td></tr>
<tr class="codeline" data-linenumber="445"><td class="num" id="LN445">445</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> ccall_classify_struct(CTState *cts, CType *ct)</td></tr>
<tr class="codeline" data-linenumber="446"><td class="num" id="LN446">446</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="447"><td class="num" id="LN447">447</td><td class="line">  CTSize sz = ct-&gt;size;</td></tr>
<tr class="codeline" data-linenumber="448"><td class="num" id="LN448">448</td><td class="line">  <span class='keyword'>if</span> (!(sz == <span class='keyword'>sizeof</span>(<span class='keyword'>float</span>) || sz == <span class='keyword'>sizeof</span>(<span class='keyword'>double</span>))) <span class='keyword'>return</span> 0;</td></tr>
<tr class="codeline" data-linenumber="449"><td class="num" id="LN449">449</td><td class="line">  <span class='keyword'>if</span> ((ct-&gt;info &amp; <span class='macro'>CTF_UNION<span class='macro_popup'>0x00800000u</span></span>)) <span class='keyword'>return</span> 0;</td></tr>
<tr class="codeline" data-linenumber="450"><td class="num" id="LN450">450</td><td class="line">  <span class='keyword'>while</span> (ct-&gt;sib) {</td></tr>
<tr class="codeline" data-linenumber="451"><td class="num" id="LN451">451</td><td class="line">    ct = ctype_get(cts, ct-&gt;sib);</td></tr>
<tr class="codeline" data-linenumber="452"><td class="num" id="LN452">452</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>ctype_isfield(ct-&gt;info)<span class='macro_popup'>((((ct-&gt;info)) &gt;&gt; 28) == CT_FIELD)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="453"><td class="num" id="LN453">453</td><td class="line">      CType *sct = ctype_rawchild(cts, ct);</td></tr>
<tr class="codeline" data-linenumber="454"><td class="num" id="LN454">454</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>ctype_isfp(sct-&gt;info)<span class='macro_popup'>(((sct-&gt;info) &amp; (0xf0000000u|0x04000000u)) == (((CTInfo<br>)(CT_NUM) &lt;&lt; 28) + (0x04000000u)))</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="455"><td class="num" id="LN455">455</td><td class="line">	<span class='keyword'>if</span> (sct-&gt;size == sz)</td></tr>
<tr class="codeline" data-linenumber="456"><td class="num" id="LN456">456</td><td class="line">	  <span class='keyword'>return</span> (sz &gt;&gt; 2);  <span class='comment'>/* Return 1 for float or 2 for double. */</span></td></tr>
<tr class="codeline" data-linenumber="457"><td class="num" id="LN457">457</td><td class="line">      } <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>ctype_isstruct(sct-&gt;info)<span class='macro_popup'>((((sct-&gt;info)) &gt;&gt; 28) == CT_STRUCT)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="458"><td class="num" id="LN458">458</td><td class="line">	<span class='keyword'>if</span> (sct-&gt;size)</td></tr>
<tr class="codeline" data-linenumber="459"><td class="num" id="LN459">459</td><td class="line">	  <span class='keyword'>return</span> ccall_classify_struct(cts, sct);</td></tr>
<tr class="codeline" data-linenumber="460"><td class="num" id="LN460">460</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="461"><td class="num" id="LN461">461</td><td class="line">	<span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="462"><td class="num" id="LN462">462</td><td class="line">      }</td></tr>
<tr class="codeline" data-linenumber="463"><td class="num" id="LN463">463</td><td class="line">    } <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>ctype_isbitfield(ct-&gt;info)<span class='macro_popup'>((((ct-&gt;info)) &gt;&gt; 28) == CT_BITFIELD)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="464"><td class="num" id="LN464">464</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="465"><td class="num" id="LN465">465</td><td class="line">    } <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>ctype_isxattrib(ct-&gt;info, CTA_SUBTYPE)<span class='macro_popup'>(((ct-&gt;info) &amp; (0xf0000000u|((CTInfo)(255) &lt;&lt; 16<br>))) == (((CTInfo)(CT_ATTRIB) &lt;&lt; 28) + (((CTInfo)(CTA_SUBTYPE<br>) &lt;&lt; 16))))</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="466"><td class="num" id="LN466">466</td><td class="line">      CType *sct = ctype_rawchild(cts, ct);</td></tr>
<tr class="codeline" data-linenumber="467"><td class="num" id="LN467">467</td><td class="line">      <span class='keyword'>if</span> (sct-&gt;size)</td></tr>
<tr class="codeline" data-linenumber="468"><td class="num" id="LN468">468</td><td class="line">	<span class='keyword'>return</span> ccall_classify_struct(cts, sct);</td></tr>
<tr class="codeline" data-linenumber="469"><td class="num" id="LN469">469</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="470"><td class="num" id="LN470">470</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="471"><td class="num" id="LN471">471</td><td class="line">  <span class='keyword'>return</span> 0;</td></tr>
<tr class="codeline" data-linenumber="472"><td class="num" id="LN472">472</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="473"><td class="num" id="LN473">473</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="474"><td class="num" id="LN474">474</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="475"><td class="num" id="LN475">475</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="476"><td class="num" id="LN476">476</td><td class="line"><span class='comment'>/* -- x64 struct classification ------------------------------------------- */</span></td></tr>
<tr class="codeline" data-linenumber="477"><td class="num" id="LN477">477</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="478"><td class="num" id="LN478">478</td><td class="line"><span class='directive'>#if <span class='macro'>LJ_TARGET_X64<span class='macro_popup'>1</span></span> &amp;&amp; !<span class='macro'>LJ_ABI_WIN<span class='macro_popup'>(2 == 1)</span></span></span></td></tr>
<tr class="codeline" data-linenumber="479"><td class="num" id="LN479">479</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="480"><td class="num" id="LN480">480</td><td class="line"><span class='comment'>/* Register classes for x64 struct classification. */</span></td></tr>
<tr class="codeline" data-linenumber="481"><td class="num" id="LN481">481</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_RCL_INT<span class='macro_popup'>1</span></span>	1</span></td></tr>
<tr class="codeline" data-linenumber="482"><td class="num" id="LN482">482</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_RCL_SSE<span class='macro_popup'>2</span></span>	2</span></td></tr>
<tr class="codeline" data-linenumber="483"><td class="num" id="LN483">483</td><td class="line"><span class='directive'>#define <span class='macro'>CCALL_RCL_MEM<span class='macro_popup'>4</span></span>	4</span></td></tr>
<tr class="codeline" data-linenumber="484"><td class="num" id="LN484">484</td><td class="line"><span class='comment'>/* NYI: classify vectors. */</span></td></tr>
<tr class="codeline" data-linenumber="485"><td class="num" id="LN485">485</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="486"><td class="num" id="LN486">486</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> ccall_classify_struct(CTState *cts, CType *ct, <span class='keyword'>int</span> *rcl, CTSize ofs);</td></tr>
<tr class="codeline" data-linenumber="487"><td class="num" id="LN487">487</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="488"><td class="num" id="LN488">488</td><td class="line"><span class='comment'>/* Classify a C type. */</span></td></tr>
<tr class="codeline" data-linenumber="489"><td class="num" id="LN489">489</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> ccall_classify_ct(CTState *cts, CType *ct, <span class='keyword'>int</span> *rcl, CTSize ofs)</td></tr>
<tr class="codeline" data-linenumber="490"><td class="num" id="LN490">490</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="491"><td class="num" id="LN491">491</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>ctype_isarray(ct-&gt;info)<span class='macro_popup'>((((ct-&gt;info)) &gt;&gt; 28) == CT_ARRAY)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="492"><td class="num" id="LN492">492</td><td class="line">    CType *cct = ctype_rawchild(cts, ct);</td></tr>
<tr class="codeline" data-linenumber="493"><td class="num" id="LN493">493</td><td class="line">    CTSize eofs, esz = cct-&gt;size, asz = ct-&gt;size;</td></tr>
<tr class="codeline" data-linenumber="494"><td class="num" id="LN494">494</td><td class="line">    <span class='keyword'>for</span> (eofs = 0; eofs &lt; asz; eofs += esz)</td></tr>
<tr class="codeline" data-linenumber="495"><td class="num" id="LN495">495</td><td class="line">      ccall_classify_ct(cts, cct, rcl, ofs+eofs);</td></tr>
<tr class="codeline" data-linenumber="496"><td class="num" id="LN496">496</td><td class="line">  } <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>ctype_isstruct(ct-&gt;info)<span class='macro_popup'>((((ct-&gt;info)) &gt;&gt; 28) == CT_STRUCT)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="497"><td class="num" id="LN497">497</td><td class="line">    ccall_classify_struct(cts, ct, rcl, ofs);</td></tr>
<tr class="codeline" data-linenumber="498"><td class="num" id="LN498">498</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="499"><td class="num" id="LN499">499</td><td class="line">    <span class='keyword'>int</span> cl = <span class='macro'>ctype_isfp(ct-&gt;info)<span class='macro_popup'>(((ct-&gt;info) &amp; (0xf0000000u|0x04000000u)) == (((CTInfo<br>)(CT_NUM) &lt;&lt; 28) + (0x04000000u)))</span></span> ? <span class='macro'>CCALL_RCL_SSE<span class='macro_popup'>2</span></span> : <span class='macro'>CCALL_RCL_INT<span class='macro_popup'>1</span></span>;</td></tr>
<tr class="codeline" data-linenumber="500"><td class="num" id="LN500">500</td><td class="line">    <span class='macro'>lua_assert(ctype_hassize(ct-&gt;info))<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="501"><td class="num" id="LN501">501</td><td class="line">    <span class='keyword'>if</span> ((ofs &amp; (ct-&gt;size-1))) cl = <span class='macro'>CCALL_RCL_MEM<span class='macro_popup'>4</span></span>;  <span class='comment'>/* Unaligned. */</span></td></tr>
<tr class="codeline" data-linenumber="502"><td class="num" id="LN502">502</td><td class="line">    rcl[(ofs &gt;= 8)] |= cl;</td></tr>
<tr class="codeline" data-linenumber="503"><td class="num" id="LN503">503</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="504"><td class="num" id="LN504">504</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="505"><td class="num" id="LN505">505</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="506"><td class="num" id="LN506">506</td><td class="line"><span class='comment'>/* Recursively classify a struct based on its fields. */</span></td></tr>
<tr class="codeline" data-linenumber="507"><td class="num" id="LN507">507</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> ccall_classify_struct(CTState *cts, CType *ct, <span class='keyword'>int</span> *rcl, CTSize ofs)</td></tr>
<tr class="codeline" data-linenumber="508"><td class="num" id="LN508">508</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="509"><td class="num" id="LN509">509</td><td class="line">  <span class='keyword'>if</span> (ct-&gt;size &gt; 16) <span class='keyword'>return</span> <span class='macro'>CCALL_RCL_MEM<span class='macro_popup'>4</span></span>;  <span class='comment'>/* Too big, gets memory class. */</span></td></tr>
<tr class="codeline" data-linenumber="510"><td class="num" id="LN510">510</td><td class="line">  <span class='keyword'>while</span> (ct-&gt;sib) {</td></tr>
<tr class="codeline" data-linenumber="511"><td class="num" id="LN511">511</td><td class="line">    CTSize fofs;</td></tr>
<tr class="codeline" data-linenumber="512"><td class="num" id="LN512">512</td><td class="line">    ct = ctype_get(cts, ct-&gt;sib);</td></tr>
<tr class="codeline" data-linenumber="513"><td class="num" id="LN513">513</td><td class="line">    fofs = ofs+ct-&gt;size;</td></tr>
<tr class="codeline" data-linenumber="514"><td class="num" id="LN514">514</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>ctype_isfield(ct-&gt;info)<span class='macro_popup'>((((ct-&gt;info)) &gt;&gt; 28) == CT_FIELD)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="515"><td class="num" id="LN515">515</td><td class="line">      ccall_classify_ct(cts, ctype_rawchild(cts, ct), rcl, fofs);</td></tr>
<tr class="codeline" data-linenumber="516"><td class="num" id="LN516">516</td><td class="line">    <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>ctype_isbitfield(ct-&gt;info)<span class='macro_popup'>((((ct-&gt;info)) &gt;&gt; 28) == CT_BITFIELD)</span></span>)</td></tr>
<tr class="codeline" data-linenumber="517"><td class="num" id="LN517">517</td><td class="line">      rcl[(fofs &gt;= 8)] |= <span class='macro'>CCALL_RCL_INT<span class='macro_popup'>1</span></span>;  <span class='comment'>/* NYI: unaligned bitfields? */</span></td></tr>
<tr class="codeline" data-linenumber="518"><td class="num" id="LN518">518</td><td class="line">    <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>ctype_isxattrib(ct-&gt;info, CTA_SUBTYPE)<span class='macro_popup'>(((ct-&gt;info) &amp; (0xf0000000u|((CTInfo)(255) &lt;&lt; 16<br>))) == (((CTInfo)(CT_ATTRIB) &lt;&lt; 28) + (((CTInfo)(CTA_SUBTYPE<br>) &lt;&lt; 16))))</span></span>)</td></tr>
<tr class="codeline" data-linenumber="519"><td class="num" id="LN519">519</td><td class="line">      ccall_classify_struct(cts, ctype_rawchild(cts, ct), rcl, fofs);</td></tr>
<tr class="codeline" data-linenumber="520"><td class="num" id="LN520">520</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="521"><td class="num" id="LN521">521</td><td class="line">  <span class='keyword'>return</span> ((rcl[0]|rcl[1]) &amp; <span class='macro'>CCALL_RCL_MEM<span class='macro_popup'>4</span></span>);  <span class='comment'>/* Memory class? */</span></td></tr>
<tr class="codeline" data-linenumber="522"><td class="num" id="LN522">522</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="523"><td class="num" id="LN523">523</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="524"><td class="num" id="LN524">524</td><td class="line"><span class='comment'>/* Try to split up a small struct into registers. */</span></td></tr>
<tr class="codeline" data-linenumber="525"><td class="num" id="LN525">525</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> ccall_struct_reg(CCallState *cc, GPRArg *dp, <span class='keyword'>int</span> *rcl)</td></tr>
<tr class="codeline" data-linenumber="526"><td class="num" id="LN526">526</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="527"><td class="num" id="LN527">527</td><td class="line">  MSize ngpr = cc-&gt;ngpr, nfpr = cc-&gt;nfpr;</td></tr>
<tr class="codeline" data-linenumber="528"><td class="num" id="LN528">528</td><td class="line">  uint32_t i;</td></tr>
<tr class="codeline" data-linenumber="529"><td class="num" id="LN529">529</td><td class="line">  <span class='keyword'>for</span> (i = 0; i &lt; 2; i++) {</td></tr>
<tr class="codeline" data-linenumber="530"><td class="num" id="LN530">530</td><td class="line">    <span class='macro'>lua_assert(!(rcl[i] &amp; CCALL_RCL_MEM))<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="531"><td class="num" id="LN531">531</td><td class="line">    <span class='keyword'>if</span> ((rcl[i] &amp; <span class='macro'>CCALL_RCL_INT<span class='macro_popup'>1</span></span>)) {  <span class='comment'>/* Integer class takes precedence. */</span></td></tr>
<tr class="codeline" data-linenumber="532"><td class="num" id="LN532">532</td><td class="line">      <span class='keyword'>if</span> (ngpr &gt;= <span class='macro'>CCALL_NARG_GPR<span class='macro_popup'>6</span></span>) <span class='keyword'>return</span> 1;  <span class='comment'>/* Register overflow. */</span></td></tr>
<tr class="codeline" data-linenumber="533"><td class="num" id="LN533">533</td><td class="line">      cc-&gt;gpr[ngpr++] = dp[i];</td></tr>
<tr class="codeline" data-linenumber="534"><td class="num" id="LN534">534</td><td class="line">    } <span class='keyword'>else</span> <span class='keyword'>if</span> ((rcl[i] &amp; <span class='macro'>CCALL_RCL_SSE<span class='macro_popup'>2</span></span>)) {</td></tr>
<tr class="codeline" data-linenumber="535"><td class="num" id="LN535">535</td><td class="line">      <span class='keyword'>if</span> (nfpr &gt;= <span class='macro'>CCALL_NARG_FPR<span class='macro_popup'>8</span></span>) <span class='keyword'>return</span> 1;  <span class='comment'>/* Register overflow. */</span></td></tr>
<tr class="codeline" data-linenumber="536"><td class="num" id="LN536">536</td><td class="line">      cc-&gt;fpr[nfpr++].l[0] = dp[i];</td></tr>
<tr class="codeline" data-linenumber="537"><td class="num" id="LN537">537</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="538"><td class="num" id="LN538">538</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="539"><td class="num" id="LN539">539</td><td class="line">  cc-&gt;ngpr = ngpr; cc-&gt;nfpr = nfpr;</td></tr>
<tr class="codeline" data-linenumber="540"><td class="num" id="LN540">540</td><td class="line">  <span class='keyword'>return</span> 0;  <span class='comment'>/* Ok. */</span></td></tr>
<tr class="codeline" data-linenumber="541"><td class="num" id="LN541">541</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="542"><td class="num" id="LN542">542</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="543"><td class="num" id="LN543">543</td><td class="line"><span class='comment'>/* Pass a small struct argument. */</span></td></tr>
<tr class="codeline" data-linenumber="544"><td class="num" id="LN544">544</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> ccall_struct_arg(CCallState *cc, CTState *cts, CType *d, <span class='keyword'>int</span> *rcl,</td></tr>
<tr class="codeline" data-linenumber="545"><td class="num" id="LN545">545</td><td class="line">			    TValue *o, <span class='keyword'>int</span> narg)</td></tr>
<tr class="codeline" data-linenumber="546"><td class="num" id="LN546">546</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="547"><td class="num" id="LN547">547</td><td class="line">  GPRArg dp[2];</td></tr>
<tr class="codeline" data-linenumber="548"><td class="num" id="LN548">548</td><td class="line">  dp[0] = dp[1] = 0;</td></tr>
<tr class="codeline" data-linenumber="549"><td class="num" id="LN549">549</td><td class="line">  <span class='comment'>/* Convert to temp. struct. */</span></td></tr>
<tr class="codeline" data-linenumber="550"><td class="num" id="LN550">550</td><td class="line">  lj_cconv_ct_tv(cts, d, (uint8_t *)dp, o, <span class='macro'>CCF_ARG(narg)<span class='macro_popup'>((narg) &lt;&lt; 8)</span></span>);</td></tr>
<tr class="codeline" data-linenumber="551"><td class="num" id="LN551">551</td><td class="line">  <span class='keyword'>if</span> (ccall_struct_reg(cc, dp, rcl)) {  <span class='comment'>/* Register overflow? Pass on stack. */</span></td></tr>
<tr class="codeline" data-linenumber="552"><td class="num" id="LN552">552</td><td class="line">    MSize nsp = cc-&gt;nsp, n = rcl[1] ? 2 : 1;</td></tr>
<tr class="codeline" data-linenumber="553"><td class="num" id="LN553">553</td><td class="line">    <span class='keyword'>if</span> (nsp + n &gt; <span class='macro'>CCALL_MAXSTACK<span class='macro_popup'>32</span></span>) <span class='keyword'>return</span> 1;  <span class='comment'>/* Too many arguments. */</span></td></tr>
<tr class="codeline" data-linenumber="554"><td class="num" id="LN554">554</td><td class="line">    cc-&gt;nsp = nsp + n;</td></tr>
<tr class="codeline" data-linenumber="555"><td class="num" id="LN555">555</td><td class="line">    memcpy(&amp;cc-&gt;stack[nsp], dp, n*<span class='macro'>CTSIZE_PTR<span class='macro_popup'>8</span></span>);</td></tr>
<tr class="codeline" data-linenumber="556"><td class="num" id="LN556">556</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="557"><td class="num" id="LN557">557</td><td class="line">  <span class='keyword'>return</span> 0;  <span class='comment'>/* Ok. */</span></td></tr>
<tr class="codeline" data-linenumber="558"><td class="num" id="LN558">558</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="559"><td class="num" id="LN559">559</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="560"><td class="num" id="LN560">560</td><td class="line"><span class='comment'>/* Combine returned small struct. */</span></td></tr>
<tr class="codeline" data-linenumber="561"><td class="num" id="LN561">561</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> ccall_struct_ret(CCallState *cc, <span class='keyword'>int</span> *rcl, uint8_t *dp, CTSize sz)</td></tr>
<tr class="codeline" data-linenumber="562"><td class="num" id="LN562">562</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="563"><td class="num" id="LN563">563</td><td class="line">  GPRArg sp[2];</td></tr>
<tr class="codeline" data-linenumber="564"><td class="num" id="LN564">564</td><td class="line">  MSize ngpr = 0, nfpr = 0;</td></tr>
<tr class="codeline" data-linenumber="565"><td class="num" id="LN565">565</td><td class="line">  uint32_t i;</td></tr>
<tr class="codeline" data-linenumber="566"><td class="num" id="LN566">566</td><td class="line">  <span class='keyword'>for</span> (i = 0; i &lt; 2; i++) {</td></tr>
<tr class="codeline" data-linenumber="567"><td class="num" id="LN567">567</td><td class="line">    <span class='keyword'>if</span> ((rcl[i] &amp; <span class='macro'>CCALL_RCL_INT<span class='macro_popup'>1</span></span>)) {  <span class='comment'>/* Integer class takes precedence. */</span></td></tr>
<tr class="codeline" data-linenumber="568"><td class="num" id="LN568">568</td><td class="line">      sp[i] = cc-&gt;gpr[ngpr++];</td></tr>
<tr class="codeline" data-linenumber="569"><td class="num" id="LN569">569</td><td class="line">    } <span class='keyword'>else</span> <span class='keyword'>if</span> ((rcl[i] &amp; <span class='macro'>CCALL_RCL_SSE<span class='macro_popup'>2</span></span>)) {</td></tr>
<tr class="codeline" data-linenumber="570"><td class="num" id="LN570">570</td><td class="line">      sp[i] = cc-&gt;fpr[nfpr++].l[0];</td></tr>
<tr class="codeline" data-linenumber="571"><td class="num" id="LN571">571</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="572"><td class="num" id="LN572">572</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="573"><td class="num" id="LN573">573</td><td class="line">  <span class="mrange">memcpy</span>(dp, sp, sz);</td></tr>
<tr><td class="num"></td><td class="line"><div id="EndPath" class="msg msgEvent" style="margin-left:3ex; max-width:58em">Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11</div></td></tr>
<tr class="codeline" data-linenumber="574"><td class="num" id="LN574">574</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="575"><td class="num" id="LN575">575</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="576"><td class="num" id="LN576">576</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="577"><td class="num" id="LN577">577</td><td class="line"><span class='comment'>/* -- ARM hard-float ABI struct classification ---------------------------- */</span></td></tr>
<tr class="codeline" data-linenumber="578"><td class="num" id="LN578">578</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="579"><td class="num" id="LN579">579</td><td class="line"><span class='directive'>#if LJ_TARGET_ARM &amp;&amp; !<span class='macro'>LJ_ABI_SOFTFP<span class='macro_popup'>0</span></span></span></td></tr>
<tr class="codeline" data-linenumber="580"><td class="num" id="LN580">580</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="581"><td class="num" id="LN581">581</td><td class="line"><span class='comment'>/* Classify a struct based on its fields. */</span></td></tr>
<tr class="codeline" data-linenumber="582"><td class="num" id="LN582">582</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>unsigned</span> <span class='keyword'>int</span> ccall_classify_struct(CTState *cts, CType *ct, CType *ctf)</td></tr>
<tr class="codeline" data-linenumber="583"><td class="num" id="LN583">583</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="584"><td class="num" id="LN584">584</td><td class="line">  CTSize sz = ct-&gt;size;</td></tr>
<tr class="codeline" data-linenumber="585"><td class="num" id="LN585">585</td><td class="line">  <span class='keyword'>unsigned</span> <span class='keyword'>int</span> r = 0, n = 0, isu = (ct-&gt;info &amp; <span class='macro'>CTF_UNION<span class='macro_popup'>0x00800000u</span></span>);</td></tr>
<tr class="codeline" data-linenumber="586"><td class="num" id="LN586">586</td><td class="line">  <span class='keyword'>if</span> ((ctf-&gt;info &amp; <span class='macro'>CTF_VARARG<span class='macro_popup'>0x00800000u</span></span>)) <span class='keyword'>goto</span> noth;</td></tr>
<tr class="codeline" data-linenumber="587"><td class="num" id="LN587">587</td><td class="line">  <span class='keyword'>while</span> (ct-&gt;sib) {</td></tr>
<tr class="codeline" data-linenumber="588"><td class="num" id="LN588">588</td><td class="line">    CType *sct;</td></tr>
<tr class="codeline" data-linenumber="589"><td class="num" id="LN589">589</td><td class="line">    ct = ctype_get(cts, ct-&gt;sib);</td></tr>
<tr class="codeline" data-linenumber="590"><td class="num" id="LN590">590</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>ctype_isfield(ct-&gt;info)<span class='macro_popup'>((((ct-&gt;info)) &gt;&gt; 28) == CT_FIELD)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="591"><td class="num" id="LN591">591</td><td class="line">      sct = ctype_rawchild(cts, ct);</td></tr>
<tr class="codeline" data-linenumber="592"><td class="num" id="LN592">592</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>ctype_isfp(sct-&gt;info)<span class='macro_popup'>(((sct-&gt;info) &amp; (0xf0000000u|0x04000000u)) == (((CTInfo<br>)(CT_NUM) &lt;&lt; 28) + (0x04000000u)))</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="593"><td class="num" id="LN593">593</td><td class="line">	r |= sct-&gt;size;</td></tr>
<tr class="codeline" data-linenumber="594"><td class="num" id="LN594">594</td><td class="line">	<span class='keyword'>if</span> (!isu) n++; <span class='keyword'>else</span> <span class='keyword'>if</span> (n == 0) n = 1;</td></tr>
<tr class="codeline" data-linenumber="595"><td class="num" id="LN595">595</td><td class="line">      } <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>ctype_iscomplex(sct-&gt;info)<span class='macro_popup'>(((sct-&gt;info) &amp; (0xf0000000u|0x04000000u)) == (((CTInfo<br>)(CT_ARRAY) &lt;&lt; 28) + (0x04000000u)))</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="596"><td class="num" id="LN596">596</td><td class="line">	r |= (sct-&gt;size &gt;&gt; 1);</td></tr>
<tr class="codeline" data-linenumber="597"><td class="num" id="LN597">597</td><td class="line">	<span class='keyword'>if</span> (!isu) n += 2; <span class='keyword'>else</span> <span class='keyword'>if</span> (n &lt; 2) n = 2;</td></tr>
<tr class="codeline" data-linenumber="598"><td class="num" id="LN598">598</td><td class="line">      } <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>ctype_isstruct(sct-&gt;info)<span class='macro_popup'>((((sct-&gt;info)) &gt;&gt; 28) == CT_STRUCT)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="599"><td class="num" id="LN599">599</td><td class="line">	<span class='keyword'>goto</span> substruct;</td></tr>
<tr class="codeline" data-linenumber="600"><td class="num" id="LN600">600</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="601"><td class="num" id="LN601">601</td><td class="line">	<span class='keyword'>goto</span> noth;</td></tr>
<tr class="codeline" data-linenumber="602"><td class="num" id="LN602">602</td><td class="line">      }</td></tr>
<tr class="codeline" data-linenumber="603"><td class="num" id="LN603">603</td><td class="line">    } <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>ctype_isbitfield(ct-&gt;info)<span class='macro_popup'>((((ct-&gt;info)) &gt;&gt; 28) == CT_BITFIELD)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="604"><td class="num" id="LN604">604</td><td class="line">      <span class='keyword'>goto</span> noth;</td></tr>
<tr class="codeline" data-linenumber="605"><td class="num" id="LN605">605</td><td class="line">    } <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>ctype_isxattrib(ct-&gt;info, CTA_SUBTYPE)<span class='macro_popup'>(((ct-&gt;info) &amp; (0xf0000000u|((CTInfo)(255) &lt;&lt; 16<br>))) == (((CTInfo)(CT_ATTRIB) &lt;&lt; 28) + (((CTInfo)(CTA_SUBTYPE<br>) &lt;&lt; 16))))</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="606"><td class="num" id="LN606">606</td><td class="line">      sct = ctype_rawchild(cts, ct);</td></tr>
<tr class="codeline" data-linenumber="607"><td class="num" id="LN607">607</td><td class="line">    substruct:</td></tr>
<tr class="codeline" data-linenumber="608"><td class="num" id="LN608">608</td><td class="line">      <span class='keyword'>if</span> (sct-&gt;size &gt; 0) {</td></tr>
<tr class="codeline" data-linenumber="609"><td class="num" id="LN609">609</td><td class="line">	<span class='keyword'>unsigned</span> <span class='keyword'>int</span> s = ccall_classify_struct(cts, sct, ctf);</td></tr>
<tr class="codeline" data-linenumber="610"><td class="num" id="LN610">610</td><td class="line">	<span class='keyword'>if</span> (s &lt;= 1) <span class='keyword'>goto</span> noth;</td></tr>
<tr class="codeline" data-linenumber="611"><td class="num" id="LN611">611</td><td class="line">	r |= (s &amp; 255);</td></tr>
<tr class="codeline" data-linenumber="612"><td class="num" id="LN612">612</td><td class="line">	<span class='keyword'>if</span> (!isu) n += (s &gt;&gt; 8); <span class='keyword'>else</span> <span class='keyword'>if</span> (n &lt; (s &gt;&gt;8)) n = (s &gt;&gt; 8);</td></tr>
<tr class="codeline" data-linenumber="613"><td class="num" id="LN613">613</td><td class="line">      }</td></tr>
<tr class="codeline" data-linenumber="614"><td class="num" id="LN614">614</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="615"><td class="num" id="LN615">615</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="616"><td class="num" id="LN616">616</td><td class="line">  <span class='keyword'>if</span> ((r == 4 || r == 8) &amp;&amp; n &lt;= 4)</td></tr>
<tr class="codeline" data-linenumber="617"><td class="num" id="LN617">617</td><td class="line">    <span class='keyword'>return</span> r + (n &lt;&lt; 8);</td></tr>
<tr class="codeline" data-linenumber="618"><td class="num" id="LN618">618</td><td class="line">noth:  <span class='comment'>/* Not a homogeneous float/double aggregate. */</span></td></tr>
<tr class="codeline" data-linenumber="619"><td class="num" id="LN619">619</td><td class="line">  <span class='keyword'>return</span> (sz &lt;= 4);  <span class='comment'>/* Return structs of size &lt;= 4 in a GPR. */</span></td></tr>
<tr class="codeline" data-linenumber="620"><td class="num" id="LN620">620</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="621"><td class="num" id="LN621">621</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="622"><td class="num" id="LN622">622</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="623"><td class="num" id="LN623">623</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="624"><td class="num" id="LN624">624</td><td class="line"><span class='comment'>/* -- Common C call handling ---------------------------------------------- */</span></td></tr>
<tr class="codeline" data-linenumber="625"><td class="num" id="LN625">625</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="626"><td class="num" id="LN626">626</td><td class="line"><span class='comment'>/* Infer the destination CTypeID for a vararg argument. */</span></td></tr>
<tr class="codeline" data-linenumber="627"><td class="num" id="LN627">627</td><td class="line">CTypeID lj_ccall_ctid_vararg(CTState *cts, cTValue *o)</td></tr>
<tr class="codeline" data-linenumber="628"><td class="num" id="LN628">628</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="629"><td class="num" id="LN629">629</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>tvisnumber(o)<span class='macro_popup'>(((o)-&gt;it) &lt;= 0xfffeffffu)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="630"><td class="num" id="LN630">630</td><td class="line">    <span class='keyword'>return</span> CTID_DOUBLE;</td></tr>
<tr class="codeline" data-linenumber="631"><td class="num" id="LN631">631</td><td class="line">  } <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>tviscdata(o)<span class='macro_popup'>(((o)-&gt;it) == (~10u))</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="632"><td class="num" id="LN632">632</td><td class="line">    CTypeID id = <span class='macro'>cdataV(o)<span class='macro_popup'>(&amp;(((GCobj *)(uintptr_t)((o)-&gt;gcr).gcptr32))-&gt;cd)</span></span>-&gt;ctypeid;</td></tr>
<tr class="codeline" data-linenumber="633"><td class="num" id="LN633">633</td><td class="line">    CType *s = ctype_get(cts, id);</td></tr>
<tr class="codeline" data-linenumber="634"><td class="num" id="LN634">634</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>ctype_isrefarray(s-&gt;info)<span class='macro_popup'>(((s-&gt;info) &amp; (0xf0000000u|0x08000000u|0x04000000u)) ==<br> (((CTInfo)(CT_ARRAY) &lt;&lt; 28) + (0)))</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="635"><td class="num" id="LN635">635</td><td class="line">      <span class='keyword'>return</span> lj_ctype_intern(cts,</td></tr>
<tr class="codeline" data-linenumber="636"><td class="num" id="LN636">636</td><td class="line">	       <span class='macro'>CTINFO(CT_PTR, CTALIGN_PTR|ctype_cid(s-&gt;info))<span class='macro_popup'>(((CTInfo)(CT_PTR) &lt;&lt; 28) + (((CTSize)(3) &lt;&lt; 16)|<br>((CTypeID)((s-&gt;info) &amp; 0x0000ffffu))))</span></span>, <span class='macro'>CTSIZE_PTR<span class='macro_popup'>8</span></span>);</td></tr>
<tr class="codeline" data-linenumber="637"><td class="num" id="LN637">637</td><td class="line">    } <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>ctype_isstruct(s-&gt;info)<span class='macro_popup'>((((s-&gt;info)) &gt;&gt; 28) == CT_STRUCT)</span></span> || <span class='macro'>ctype_isfunc(s-&gt;info)<span class='macro_popup'>((((s-&gt;info)) &gt;&gt; 28) == CT_FUNC)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="638"><td class="num" id="LN638">638</td><td class="line">      <span class='comment'>/* NYI: how to pass a struct by value in a vararg argument? */</span></td></tr>
<tr class="codeline" data-linenumber="639"><td class="num" id="LN639">639</td><td class="line">      <span class='keyword'>return</span> lj_ctype_intern(cts, <span class='macro'>CTINFO(CT_PTR, CTALIGN_PTR|id)<span class='macro_popup'>(((CTInfo)(CT_PTR) &lt;&lt; 28) + (((CTSize)(3) &lt;&lt; 16)|<br>id))</span></span>, <span class='macro'>CTSIZE_PTR<span class='macro_popup'>8</span></span>);</td></tr>
<tr class="codeline" data-linenumber="640"><td class="num" id="LN640">640</td><td class="line">    } <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>ctype_isfp(s-&gt;info)<span class='macro_popup'>(((s-&gt;info) &amp; (0xf0000000u|0x04000000u)) == (((CTInfo)<br>(CT_NUM) &lt;&lt; 28) + (0x04000000u)))</span></span> &amp;&amp; s-&gt;size == <span class='keyword'>sizeof</span>(<span class='keyword'>float</span>)) {</td></tr>
<tr class="codeline" data-linenumber="641"><td class="num" id="LN641">641</td><td class="line">      <span class='keyword'>return</span> CTID_DOUBLE;</td></tr>
<tr class="codeline" data-linenumber="642"><td class="num" id="LN642">642</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="643"><td class="num" id="LN643">643</td><td class="line">      <span class='keyword'>return</span> id;</td></tr>
<tr class="codeline" data-linenumber="644"><td class="num" id="LN644">644</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="645"><td class="num" id="LN645">645</td><td class="line">  } <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>tvisstr(o)<span class='macro_popup'>(((o)-&gt;it) == (~4u))</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="646"><td class="num" id="LN646">646</td><td class="line">    <span class='keyword'>return</span> CTID_P_CCHAR;</td></tr>
<tr class="codeline" data-linenumber="647"><td class="num" id="LN647">647</td><td class="line">  } <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>tvisbool(o)<span class='macro_popup'>((((o)-&gt;it) == (~1u)) || (((o)-&gt;it) == (~2u)))</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="648"><td class="num" id="LN648">648</td><td class="line">    <span class='keyword'>return</span> CTID_BOOL;</td></tr>
<tr class="codeline" data-linenumber="649"><td class="num" id="LN649">649</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="650"><td class="num" id="LN650">650</td><td class="line">    <span class='keyword'>return</span> CTID_P_VOID;</td></tr>
<tr class="codeline" data-linenumber="651"><td class="num" id="LN651">651</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="652"><td class="num" id="LN652">652</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="653"><td class="num" id="LN653">653</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="654"><td class="num" id="LN654">654</td><td class="line"><span class='comment'>/* Setup arguments for C call. */</span></td></tr>
<tr class="codeline" data-linenumber="655"><td class="num" id="LN655">655</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> ccall_set_args(lua_State *L, CTState *cts, CType *ct,</td></tr>
<tr class="codeline" data-linenumber="656"><td class="num" id="LN656">656</td><td class="line">			  CCallState *cc)</td></tr>
<tr class="codeline" data-linenumber="657"><td class="num" id="LN657">657</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="658"><td class="num" id="LN658">658</td><td class="line">  <span class='keyword'>int</span> gcsteps = 0;</td></tr>
<tr class="codeline" data-linenumber="659"><td class="num" id="LN659">659</td><td class="line">  TValue *o, *top = L-&gt;top;</td></tr>
<tr class="codeline" data-linenumber="660"><td class="num" id="LN660">660</td><td class="line">  CTypeID fid;</td></tr>
<tr class="codeline" data-linenumber="661"><td class="num" id="LN661">661</td><td class="line">  CType *ctr;</td></tr>
<tr class="codeline" data-linenumber="662"><td class="num" id="LN662">662</td><td class="line">  MSize maxgpr, ngpr = 0, nsp = 0, narg;</td></tr>
<tr class="codeline" data-linenumber="663"><td class="num" id="LN663">663</td><td class="line"><span class='directive'>#if <span class='macro'>CCALL_NARG_FPR<span class='macro_popup'>8</span></span></span></td></tr>
<tr class="codeline" data-linenumber="664"><td class="num" id="LN664">664</td><td class="line">  MSize nfpr = 0;</td></tr>
<tr class="codeline" data-linenumber="665"><td class="num" id="LN665">665</td><td class="line"><span class='directive'>#if LJ_TARGET_ARM</span></td></tr>
<tr class="codeline" data-linenumber="666"><td class="num" id="LN666">666</td><td class="line">  MSize fprodd = 0;</td></tr>
<tr class="codeline" data-linenumber="667"><td class="num" id="LN667">667</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="668"><td class="num" id="LN668">668</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="669"><td class="num" id="LN669">669</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="670"><td class="num" id="LN670">670</td><td class="line">  <span class='comment'>/* Clear unused regs to get some determinism in case of misdeclaration. */</span></td></tr>
<tr class="codeline" data-linenumber="671"><td class="num" id="LN671">671</td><td class="line">  memset(cc-&gt;gpr, 0, <span class='keyword'>sizeof</span>(cc-&gt;gpr));</td></tr>
<tr class="codeline" data-linenumber="672"><td class="num" id="LN672">672</td><td class="line"><span class='directive'>#if <span class='macro'>CCALL_NUM_FPR<span class='macro_popup'>(8 &gt; 2 ? 8 : 2)</span></span></span></td></tr>
<tr class="codeline" data-linenumber="673"><td class="num" id="LN673">673</td><td class="line">  memset(cc-&gt;fpr, 0, <span class='keyword'>sizeof</span>(cc-&gt;fpr));</td></tr>
<tr class="codeline" data-linenumber="674"><td class="num" id="LN674">674</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="675"><td class="num" id="LN675">675</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="676"><td class="num" id="LN676">676</td><td class="line"><span class='directive'>#if LJ_TARGET_X86</span></td></tr>
<tr class="codeline" data-linenumber="677"><td class="num" id="LN677">677</td><td class="line">  <span class='comment'>/* x86 has several different calling conventions. */</span></td></tr>
<tr class="codeline" data-linenumber="678"><td class="num" id="LN678">678</td><td class="line">  cc-&gt;resx87 = 0;</td></tr>
<tr class="codeline" data-linenumber="679"><td class="num" id="LN679">679</td><td class="line">  <span class='keyword'>switch</span> (<span class='macro'>ctype_cconv(ct-&gt;info)<span class='macro_popup'>(((ct-&gt;info) &gt;&gt; 16) &amp; 3)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="680"><td class="num" id="LN680">680</td><td class="line">  <span class='keyword'>case</span> CTCC_FASTCALL: maxgpr = 2; <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="681"><td class="num" id="LN681">681</td><td class="line">  <span class='keyword'>case</span> CTCC_THISCALL: maxgpr = 1; <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="682"><td class="num" id="LN682">682</td><td class="line">  <span class='keyword'>default</span>: maxgpr = 0; <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="683"><td class="num" id="LN683">683</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="684"><td class="num" id="LN684">684</td><td class="line"><span class='directive'>#else</span></td></tr>
<tr class="codeline" data-linenumber="685"><td class="num" id="LN685">685</td><td class="line">  maxgpr = <span class='macro'>CCALL_NARG_GPR<span class='macro_popup'>6</span></span>;</td></tr>
<tr class="codeline" data-linenumber="686"><td class="num" id="LN686">686</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="687"><td class="num" id="LN687">687</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="688"><td class="num" id="LN688">688</td><td class="line">  <span class='comment'>/* Perform required setup for some result types. */</span></td></tr>
<tr class="codeline" data-linenumber="689"><td class="num" id="LN689">689</td><td class="line">  ctr = ctype_rawchild(cts, ct);</td></tr>
<tr class="codeline" data-linenumber="690"><td class="num" id="LN690">690</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>ctype_isvector(ctr-&gt;info)<span class='macro_popup'>(((ctr-&gt;info) &amp; (0xf0000000u|0x08000000u)) == (((CTInfo<br>)(CT_ARRAY) &lt;&lt; 28) + (0x08000000u)))</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="691"><td class="num" id="LN691">691</td><td class="line">    <span class='keyword'>if</span> (!(<span class='macro'>CCALL_VECTOR_REG<span class='macro_popup'>1</span></span> &amp;&amp; (ctr-&gt;size == 8 || ctr-&gt;size == 16)))</td></tr>
<tr class="codeline" data-linenumber="692"><td class="num" id="LN692">692</td><td class="line">      <span class='keyword'>goto</span> err_nyi;</td></tr>
<tr class="codeline" data-linenumber="693"><td class="num" id="LN693">693</td><td class="line">  } <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>ctype_iscomplex(ctr-&gt;info)<span class='macro_popup'>(((ctr-&gt;info) &amp; (0xf0000000u|0x04000000u)) == (((CTInfo<br>)(CT_ARRAY) &lt;&lt; 28) + (0x04000000u)))</span></span> || <span class='macro'>ctype_isstruct(ctr-&gt;info)<span class='macro_popup'>((((ctr-&gt;info)) &gt;&gt; 28) == CT_STRUCT)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="694"><td class="num" id="LN694">694</td><td class="line">    <span class='comment'>/* Preallocate cdata object and anchor it after arguments. */</span></td></tr>
<tr class="codeline" data-linenumber="695"><td class="num" id="LN695">695</td><td class="line">    CTSize sz = ctr-&gt;size;</td></tr>
<tr class="codeline" data-linenumber="696"><td class="num" id="LN696">696</td><td class="line">    GCcdata *cd = lj_cdata_new(cts, <span class='macro'>ctype_cid(ct-&gt;info)<span class='macro_popup'>((CTypeID)((ct-&gt;info) &amp; 0x0000ffffu))</span></span>, sz);</td></tr>
<tr class="codeline" data-linenumber="697"><td class="num" id="LN697">697</td><td class="line">    <span class='keyword'>void</span> *dp = <span class='macro'>cdataptr(cd)<span class='macro_popup'>((void *)((cd)+1))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="698"><td class="num" id="LN698">698</td><td class="line">    setcdataV(L, L-&gt;top++, cd);</td></tr>
<tr class="codeline" data-linenumber="699"><td class="num" id="LN699">699</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>ctype_isstruct(ctr-&gt;info)<span class='macro_popup'>((((ctr-&gt;info)) &gt;&gt; 28) == CT_STRUCT)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="700"><td class="num" id="LN700">700</td><td class="line">      <span class='macro'>CCALL_HANDLE_STRUCTRET<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; if (ccall_classify_struct(cts<br>, ctr, rcl, 0)) { cc-&gt;retref = 1; cc-&gt;gpr[ngpr++] = (GPRArg<br>)dp; } else { cc-&gt;retref = 0; }</span></span></td></tr>
<tr class="codeline" data-linenumber="701"><td class="num" id="LN701">701</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="702"><td class="num" id="LN702">702</td><td class="line">      <span class='macro'>CCALL_HANDLE_COMPLEXRET<span class='macro_popup'>cc-&gt;retref = 0;</span></span></td></tr>
<tr class="codeline" data-linenumber="703"><td class="num" id="LN703">703</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="704"><td class="num" id="LN704">704</td><td class="line"><span class='directive'>#if LJ_TARGET_X86</span></td></tr>
<tr class="codeline" data-linenumber="705"><td class="num" id="LN705">705</td><td class="line">  } <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>ctype_isfp(ctr-&gt;info)<span class='macro_popup'>(((ctr-&gt;info) &amp; (0xf0000000u|0x04000000u)) == (((CTInfo<br>)(CT_NUM) &lt;&lt; 28) + (0x04000000u)))</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="706"><td class="num" id="LN706">706</td><td class="line">    cc-&gt;resx87 = ctr-&gt;size == <span class='keyword'>sizeof</span>(<span class='keyword'>float</span>) ? 1 : 2;</td></tr>
<tr class="codeline" data-linenumber="707"><td class="num" id="LN707">707</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="708"><td class="num" id="LN708">708</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="709"><td class="num" id="LN709">709</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="710"><td class="num" id="LN710">710</td><td class="line">  <span class='comment'>/* Skip initial attributes. */</span></td></tr>
<tr class="codeline" data-linenumber="711"><td class="num" id="LN711">711</td><td class="line">  fid = ct-&gt;sib;</td></tr>
<tr class="codeline" data-linenumber="712"><td class="num" id="LN712">712</td><td class="line">  <span class='keyword'>while</span> (fid) {</td></tr>
<tr class="codeline" data-linenumber="713"><td class="num" id="LN713">713</td><td class="line">    CType *ctf = ctype_get(cts, fid);</td></tr>
<tr class="codeline" data-linenumber="714"><td class="num" id="LN714">714</td><td class="line">    <span class='keyword'>if</span> (!<span class='macro'>ctype_isattrib(ctf-&gt;info)<span class='macro_popup'>((((ctf-&gt;info)) &gt;&gt; 28) == CT_ATTRIB)</span></span>) <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="715"><td class="num" id="LN715">715</td><td class="line">    fid = ctf-&gt;sib;</td></tr>
<tr class="codeline" data-linenumber="716"><td class="num" id="LN716">716</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="717"><td class="num" id="LN717">717</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="718"><td class="num" id="LN718">718</td><td class="line">  <span class='comment'>/* Walk through all passed arguments. */</span></td></tr>
<tr class="codeline" data-linenumber="719"><td class="num" id="LN719">719</td><td class="line">  <span class='keyword'>for</span> (o = L-&gt;base+1, narg = 1; o &lt; top; o++, narg++) {</td></tr>
<tr class="codeline" data-linenumber="720"><td class="num" id="LN720">720</td><td class="line">    CTypeID did;</td></tr>
<tr class="codeline" data-linenumber="721"><td class="num" id="LN721">721</td><td class="line">    CType *d;</td></tr>
<tr class="codeline" data-linenumber="722"><td class="num" id="LN722">722</td><td class="line">    CTSize sz;</td></tr>
<tr class="codeline" data-linenumber="723"><td class="num" id="LN723">723</td><td class="line">    MSize n, isfp = 0, isva = 0;</td></tr>
<tr class="codeline" data-linenumber="724"><td class="num" id="LN724">724</td><td class="line">    <span class='keyword'>void</span> *dp, *rp = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="725"><td class="num" id="LN725">725</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="726"><td class="num" id="LN726">726</td><td class="line">    <span class='keyword'>if</span> (fid) {  <span class='comment'>/* Get argument type from field. */</span></td></tr>
<tr class="codeline" data-linenumber="727"><td class="num" id="LN727">727</td><td class="line">      CType *ctf = ctype_get(cts, fid);</td></tr>
<tr class="codeline" data-linenumber="728"><td class="num" id="LN728">728</td><td class="line">      fid = ctf-&gt;sib;</td></tr>
<tr class="codeline" data-linenumber="729"><td class="num" id="LN729">729</td><td class="line">      <span class='macro'>lua_assert(ctype_isfield(ctf-&gt;info))<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="730"><td class="num" id="LN730">730</td><td class="line">      did = <span class='macro'>ctype_cid(ctf-&gt;info)<span class='macro_popup'>((CTypeID)((ctf-&gt;info) &amp; 0x0000ffffu))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="731"><td class="num" id="LN731">731</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="732"><td class="num" id="LN732">732</td><td class="line">      <span class='keyword'>if</span> (!(ct-&gt;info &amp; <span class='macro'>CTF_VARARG<span class='macro_popup'>0x00800000u</span></span>))</td></tr>
<tr class="codeline" data-linenumber="733"><td class="num" id="LN733">733</td><td class="line">	lj_err_caller(L, LJ_ERR_FFI_NUMARG);  <span class='comment'>/* Too many arguments. */</span></td></tr>
<tr class="codeline" data-linenumber="734"><td class="num" id="LN734">734</td><td class="line">      did = lj_ccall_ctid_vararg(cts, o);  <span class='comment'>/* Infer vararg type. */</span></td></tr>
<tr class="codeline" data-linenumber="735"><td class="num" id="LN735">735</td><td class="line">      isva = 1;</td></tr>
<tr class="codeline" data-linenumber="736"><td class="num" id="LN736">736</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="737"><td class="num" id="LN737">737</td><td class="line">    d = ctype_raw(cts, did);</td></tr>
<tr class="codeline" data-linenumber="738"><td class="num" id="LN738">738</td><td class="line">    sz = d-&gt;size;</td></tr>
<tr class="codeline" data-linenumber="739"><td class="num" id="LN739">739</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="740"><td class="num" id="LN740">740</td><td class="line">    <span class='comment'>/* Find out how (by value/ref) and where (GPR/FPR) to pass an argument. */</span></td></tr>
<tr class="codeline" data-linenumber="741"><td class="num" id="LN741">741</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>ctype_isnum(d-&gt;info)<span class='macro_popup'>((((d-&gt;info)) &gt;&gt; 28) == CT_NUM)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="742"><td class="num" id="LN742">742</td><td class="line">      <span class='keyword'>if</span> (sz &gt; 8) <span class='keyword'>goto</span> err_nyi;</td></tr>
<tr class="codeline" data-linenumber="743"><td class="num" id="LN743">743</td><td class="line">      <span class='keyword'>if</span> ((d-&gt;info &amp; <span class='macro'>CTF_FP<span class='macro_popup'>0x04000000u</span></span>))</td></tr>
<tr class="codeline" data-linenumber="744"><td class="num" id="LN744">744</td><td class="line">	isfp = 1;</td></tr>
<tr class="codeline" data-linenumber="745"><td class="num" id="LN745">745</td><td class="line">    } <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>ctype_isvector(d-&gt;info)<span class='macro_popup'>(((d-&gt;info) &amp; (0xf0000000u|0x08000000u)) == (((CTInfo)<br>(CT_ARRAY) &lt;&lt; 28) + (0x08000000u)))</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="746"><td class="num" id="LN746">746</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>CCALL_VECTOR_REG<span class='macro_popup'>1</span></span> &amp;&amp; (sz == 8 || sz == 16))</td></tr>
<tr class="codeline" data-linenumber="747"><td class="num" id="LN747">747</td><td class="line">	isfp = 1;</td></tr>
<tr class="codeline" data-linenumber="748"><td class="num" id="LN748">748</td><td class="line">      <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="749"><td class="num" id="LN749">749</td><td class="line">	<span class='keyword'>goto</span> err_nyi;</td></tr>
<tr class="codeline" data-linenumber="750"><td class="num" id="LN750">750</td><td class="line">    } <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>ctype_isstruct(d-&gt;info)<span class='macro_popup'>((((d-&gt;info)) &gt;&gt; 28) == CT_STRUCT)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="751"><td class="num" id="LN751">751</td><td class="line">      <span class='macro'>CCALL_HANDLE_STRUCTARG<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; if (!ccall_classify_struct(cts<br>, d, rcl, 0)) { cc-&gt;nsp = nsp; cc-&gt;ngpr = ngpr; cc-&gt;<br>nfpr = nfpr; if (ccall_struct_arg(cc, cts, d, rcl, o, narg)) goto<br> err_nyi; nsp = cc-&gt;nsp; ngpr = cc-&gt;ngpr; nfpr = cc-&gt;<br>nfpr; continue; }</span></span></td></tr>
<tr class="codeline" data-linenumber="752"><td class="num" id="LN752">752</td><td class="line">    } <span class='keyword'>else</span> <span class='keyword'>if</span> (<span class='macro'>ctype_iscomplex(d-&gt;info)<span class='macro_popup'>(((d-&gt;info) &amp; (0xf0000000u|0x04000000u)) == (((CTInfo)<br>(CT_ARRAY) &lt;&lt; 28) + (0x04000000u)))</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="753"><td class="num" id="LN753">753</td><td class="line">      <span class='macro'>CCALL_HANDLE_COMPLEXARG<span class='macro_popup'>isfp = 2;</span></span></td></tr>
<tr class="codeline" data-linenumber="754"><td class="num" id="LN754">754</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="755"><td class="num" id="LN755">755</td><td class="line">      sz = <span class='macro'>CTSIZE_PTR<span class='macro_popup'>8</span></span>;</td></tr>
<tr class="codeline" data-linenumber="756"><td class="num" id="LN756">756</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="757"><td class="num" id="LN757">757</td><td class="line">    sz = (sz + <span class='macro'>CTSIZE_PTR<span class='macro_popup'>8</span></span>-1) &amp; ~(<span class='macro'>CTSIZE_PTR<span class='macro_popup'>8</span></span>-1);</td></tr>
<tr class="codeline" data-linenumber="758"><td class="num" id="LN758">758</td><td class="line">    n = sz / <span class='macro'>CTSIZE_PTR<span class='macro_popup'>8</span></span>;  <span class='comment'>/* Number of GPRs or stack slots needed. */</span></td></tr>
<tr class="codeline" data-linenumber="759"><td class="num" id="LN759">759</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="760"><td class="num" id="LN760">760</td><td class="line">    <span class='macro'>CCALL_HANDLE_REGARG<span class='macro_popup'>if (isfp) { int n2 = (((d-&gt;info) &amp; (0xf0000000u|0x08000000u<br>)) == (((CTInfo)(CT_ARRAY) &lt;&lt; 28) + (0x08000000u))) ? 1<br> : n; if (nfpr + n2 &lt;= 8) { dp = &amp;cc-&gt;fpr[nfpr]; nfpr<br> += n2; goto done; } } else { if (n &lt;= 2 &amp;&amp; ngpr +<br> n &lt;= maxgpr) { dp = &amp;cc-&gt;gpr[ngpr]; ngpr += n; goto<br> done; } }</span></span>  <span class='comment'>/* Handle register arguments. */</span></td></tr>
<tr class="codeline" data-linenumber="761"><td class="num" id="LN761">761</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="762"><td class="num" id="LN762">762</td><td class="line">    <span class='comment'>/* Otherwise pass argument on stack. */</span></td></tr>
<tr class="codeline" data-linenumber="763"><td class="num" id="LN763">763</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>CCALL_ALIGN_STACKARG<span class='macro_popup'>1</span></span> &amp;&amp; !rp &amp;&amp; (d-&gt;info &amp; <span class='macro'>CTF_ALIGN<span class='macro_popup'>(15&lt;&lt;16)</span></span>) &gt; <span class='macro'>CTALIGN_PTR<span class='macro_popup'>((CTSize)(3) &lt;&lt; 16)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="764"><td class="num" id="LN764">764</td><td class="line">      MSize align = (1u &lt;&lt; <span class='macro'>ctype_align(d-&gt;info-CTALIGN_PTR)<span class='macro_popup'>(((d-&gt;info-((CTSize)(3) &lt;&lt; 16)) &gt;&gt; 16) &amp; 15<br>)</span></span>) -1;</td></tr>
<tr class="codeline" data-linenumber="765"><td class="num" id="LN765">765</td><td class="line">      nsp = (nsp + align) &amp; ~align;  <span class='comment'>/* Align argument on stack. */</span></td></tr>
<tr class="codeline" data-linenumber="766"><td class="num" id="LN766">766</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="767"><td class="num" id="LN767">767</td><td class="line">    <span class='keyword'>if</span> (nsp + n &gt; <span class='macro'>CCALL_MAXSTACK<span class='macro_popup'>32</span></span>) {  <span class='comment'>/* Too many arguments. */</span></td></tr>
<tr class="codeline" data-linenumber="768"><td class="num" id="LN768">768</td><td class="line">    err_nyi:</td></tr>
<tr class="codeline" data-linenumber="769"><td class="num" id="LN769">769</td><td class="line">      lj_err_caller(L, LJ_ERR_FFI_NYICALL);</td></tr>
<tr class="codeline" data-linenumber="770"><td class="num" id="LN770">770</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="771"><td class="num" id="LN771">771</td><td class="line">    dp = &amp;cc-&gt;stack[nsp];</td></tr>
<tr class="codeline" data-linenumber="772"><td class="num" id="LN772">772</td><td class="line">    nsp += n;</td></tr>
<tr class="codeline" data-linenumber="773"><td class="num" id="LN773">773</td><td class="line">    isva = 0;</td></tr>
<tr class="codeline" data-linenumber="774"><td class="num" id="LN774">774</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="775"><td class="num" id="LN775">775</td><td class="line">  done:</td></tr>
<tr class="codeline" data-linenumber="776"><td class="num" id="LN776">776</td><td class="line">    <span class='keyword'>if</span> (rp) {  <span class='comment'>/* Pass by reference. */</span></td></tr>
<tr class="codeline" data-linenumber="777"><td class="num" id="LN777">777</td><td class="line">      gcsteps++;</td></tr>
<tr class="codeline" data-linenumber="778"><td class="num" id="LN778">778</td><td class="line">      *(<span class='keyword'>void</span> **)dp = rp;</td></tr>
<tr class="codeline" data-linenumber="779"><td class="num" id="LN779">779</td><td class="line">      dp = rp;</td></tr>
<tr class="codeline" data-linenumber="780"><td class="num" id="LN780">780</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="781"><td class="num" id="LN781">781</td><td class="line">    lj_cconv_ct_tv(cts, d, (uint8_t *)dp, o, <span class='macro'>CCF_ARG(narg)<span class='macro_popup'>((narg) &lt;&lt; 8)</span></span>);</td></tr>
<tr class="codeline" data-linenumber="782"><td class="num" id="LN782">782</td><td class="line">    <span class='comment'>/* Extend passed integers to 32 bits at least. */</span></td></tr>
<tr class="codeline" data-linenumber="783"><td class="num" id="LN783">783</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>ctype_isinteger_or_bool(d-&gt;info)<span class='macro_popup'>(((d-&gt;info) &amp; (0xf0000000u|0x04000000u)) == (((CTInfo)<br>(CT_NUM) &lt;&lt; 28) + (0)))</span></span> &amp;&amp; d-&gt;size &lt; 4) {</td></tr>
<tr class="codeline" data-linenumber="784"><td class="num" id="LN784">784</td><td class="line">      <span class='keyword'>if</span> (d-&gt;info &amp; <span class='macro'>CTF_UNSIGNED<span class='macro_popup'>0x00800000u</span></span>)</td></tr>
<tr class="codeline" data-linenumber="785"><td class="num" id="LN785">785</td><td class="line">	*(uint32_t *)dp = d-&gt;size == 1 ? (uint32_t)*(uint8_t *)dp :</td></tr>
<tr class="codeline" data-linenumber="786"><td class="num" id="LN786">786</td><td class="line">					 (uint32_t)*(uint16_t *)dp;</td></tr>
<tr class="codeline" data-linenumber="787"><td class="num" id="LN787">787</td><td class="line">      <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="788"><td class="num" id="LN788">788</td><td class="line">	*(int32_t *)dp = d-&gt;size == 1 ? (int32_t)*(int8_t *)dp :</td></tr>
<tr class="codeline" data-linenumber="789"><td class="num" id="LN789">789</td><td class="line">					(int32_t)*(int16_t *)dp;</td></tr>
<tr class="codeline" data-linenumber="790"><td class="num" id="LN790">790</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="791"><td class="num" id="LN791">791</td><td class="line"><span class='directive'>#if <span class='macro'>LJ_TARGET_X64<span class='macro_popup'>1</span></span> &amp;&amp; <span class='macro'>LJ_ABI_WIN<span class='macro_popup'>(2 == 1)</span></span></span></td></tr>
<tr class="codeline" data-linenumber="792"><td class="num" id="LN792">792</td><td class="line">    <span class='keyword'>if</span> (isva) {  <span class='comment'>/* Windows/x64 mirrors varargs in both register sets. */</span></td></tr>
<tr class="codeline" data-linenumber="793"><td class="num" id="LN793">793</td><td class="line">      <span class='keyword'>if</span> (nfpr == ngpr)</td></tr>
<tr class="codeline" data-linenumber="794"><td class="num" id="LN794">794</td><td class="line">	cc-&gt;gpr[ngpr-1] = cc-&gt;fpr[ngpr-1].l[0];</td></tr>
<tr class="codeline" data-linenumber="795"><td class="num" id="LN795">795</td><td class="line">      <span class='keyword'>else</span></td></tr>
<tr class="codeline" data-linenumber="796"><td class="num" id="LN796">796</td><td class="line">	cc-&gt;fpr[ngpr-1].l[0] = cc-&gt;gpr[ngpr-1];</td></tr>
<tr class="codeline" data-linenumber="797"><td class="num" id="LN797">797</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="798"><td class="num" id="LN798">798</td><td class="line"><span class='directive'>#else</span></td></tr>
<tr class="codeline" data-linenumber="799"><td class="num" id="LN799">799</td><td class="line">    <span class='macro'>UNUSED(isva)<span class='macro_popup'>((void)(isva))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="800"><td class="num" id="LN800">800</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="801"><td class="num" id="LN801">801</td><td class="line"><span class='directive'>#if <span class='macro'>LJ_TARGET_X64<span class='macro_popup'>1</span></span> &amp;&amp; !<span class='macro'>LJ_ABI_WIN<span class='macro_popup'>(2 == 1)</span></span></span></td></tr>
<tr class="codeline" data-linenumber="802"><td class="num" id="LN802">802</td><td class="line">    <span class='keyword'>if</span> (isfp == 2 &amp;&amp; n == 2 &amp;&amp; (uint8_t *)dp == (uint8_t *)&amp;cc-&gt;fpr[nfpr-2]) {</td></tr>
<tr class="codeline" data-linenumber="803"><td class="num" id="LN803">803</td><td class="line">      cc-&gt;fpr[nfpr-1].d[0] = cc-&gt;fpr[nfpr-2].d[1];  <span class='comment'>/* Split complex double. */</span></td></tr>
<tr class="codeline" data-linenumber="804"><td class="num" id="LN804">804</td><td class="line">      cc-&gt;fpr[nfpr-2].d[1] = 0;</td></tr>
<tr class="codeline" data-linenumber="805"><td class="num" id="LN805">805</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="806"><td class="num" id="LN806">806</td><td class="line"><span class='directive'>#else</span></td></tr>
<tr class="codeline" data-linenumber="807"><td class="num" id="LN807">807</td><td class="line">    <span class='macro'>UNUSED(isfp)<span class='macro_popup'>((void)(isfp))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="808"><td class="num" id="LN808">808</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="809"><td class="num" id="LN809">809</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="810"><td class="num" id="LN810">810</td><td class="line">  <span class='keyword'>if</span> (fid) lj_err_caller(L, LJ_ERR_FFI_NUMARG);  <span class='comment'>/* Too few arguments. */</span></td></tr>
<tr class="codeline" data-linenumber="811"><td class="num" id="LN811">811</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="812"><td class="num" id="LN812">812</td><td class="line"><span class='directive'>#if <span class='macro'>LJ_TARGET_X64<span class='macro_popup'>1</span></span> || LJ_TARGET_PPC</span></td></tr>
<tr class="codeline" data-linenumber="813"><td class="num" id="LN813">813</td><td class="line">  cc-&gt;nfpr = nfpr;  <span class='comment'>/* Required for vararg functions. */</span></td></tr>
<tr class="codeline" data-linenumber="814"><td class="num" id="LN814">814</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="815"><td class="num" id="LN815">815</td><td class="line">  cc-&gt;nsp = nsp;</td></tr>
<tr class="codeline" data-linenumber="816"><td class="num" id="LN816">816</td><td class="line">  cc-&gt;spadj = (<span class='macro'>CCALL_SPS_FREE<span class='macro_popup'>1</span></span> + <span class='macro'>CCALL_SPS_EXTRA<span class='macro_popup'>0</span></span>)*<span class='macro'>CTSIZE_PTR<span class='macro_popup'>8</span></span>;</td></tr>
<tr class="codeline" data-linenumber="817"><td class="num" id="LN817">817</td><td class="line">  <span class='keyword'>if</span> (nsp &gt; <span class='macro'>CCALL_SPS_FREE<span class='macro_popup'>1</span></span>)</td></tr>
<tr class="codeline" data-linenumber="818"><td class="num" id="LN818">818</td><td class="line">    cc-&gt;spadj += (((nsp-<span class='macro'>CCALL_SPS_FREE<span class='macro_popup'>1</span></span>)*<span class='macro'>CTSIZE_PTR<span class='macro_popup'>8</span></span> + 15u) &amp; ~15u);</td></tr>
<tr class="codeline" data-linenumber="819"><td class="num" id="LN819">819</td><td class="line">  <span class='keyword'>return</span> gcsteps;</td></tr>
<tr class="codeline" data-linenumber="820"><td class="num" id="LN820">820</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="821"><td class="num" id="LN821">821</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="822"><td class="num" id="LN822">822</td><td class="line"><span class='comment'>/* Get results from C call. */</span></td></tr>
<tr class="codeline" data-linenumber="823"><td class="num" id="LN823">823</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> ccall_get_results(lua_State *L, CTState *cts, CType *ct,</td></tr>
<tr class="codeline" data-linenumber="824"><td class="num" id="LN824">824</td><td class="line">			     CCallState *cc, <span class='keyword'>int</span> *ret)</td></tr>
<tr class="codeline" data-linenumber="825"><td class="num" id="LN825">825</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="826"><td class="num" id="LN826">826</td><td class="line">  CType *ctr = ctype_rawchild(cts, ct);</td></tr>
<tr class="codeline" data-linenumber="827"><td class="num" id="LN827">827</td><td class="line">  uint8_t *sp = (uint8_t *)&amp;cc-&gt;gpr[0];</td></tr>
<tr class="codeline" data-linenumber="828"><td class="num" id="LN828">828</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>ctype_isvoid(ctr-&gt;info)<span class='macro_popup'>((((ctr-&gt;info)) &gt;&gt; 28) == CT_VOID)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="829"><td class="num" id="LN829">829</td><td class="line">    *ret = 0;  <span class='comment'>/* Zero results. */</span></td></tr>
<tr class="codeline" data-linenumber="830"><td class="num" id="LN830">830</td><td class="line">    <span class='keyword'>return</span> 0;  <span class='comment'>/* No additional GC step. */</span></td></tr>
<tr class="codeline" data-linenumber="831"><td class="num" id="LN831">831</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="832"><td class="num" id="LN832">832</td><td class="line">  *ret = 1;  <span class='comment'>/* One result. */</span></td></tr>
<tr class="codeline" data-linenumber="833"><td class="num" id="LN833">833</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>ctype_isstruct(ctr-&gt;info)<span class='macro_popup'>((((ctr-&gt;info)) &gt;&gt; 28) == CT_STRUCT)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="834"><td class="num" id="LN834">834</td><td class="line">    <span class='comment'>/* Return cdata object which is already on top of stack. */</span></td></tr>
<tr class="codeline" data-linenumber="835"><td class="num" id="LN835">835</td><td class="line">    <span class='keyword'>if</span> (!cc-&gt;retref) {</td></tr>
<tr class="codeline" data-linenumber="836"><td class="num" id="LN836">836</td><td class="line">      <span class='keyword'>void</span> *dp = <span class='macro'>cdataptr(cdataV(L-&gt;top-1))<span class='macro_popup'>((void *)(((&amp;(((GCobj *)(uintptr_t)((L-&gt;top-1)-&gt;gcr<br>).gcptr32))-&gt;cd))+1))</span></span>;  <span class='comment'>/* Use preallocated object. */</span></td></tr>
<tr class="codeline" data-linenumber="837"><td class="num" id="LN837">837</td><td class="line">      <span class='macro'>CCALL_HANDLE_STRUCTRET2<span class='macro_popup'>int rcl[2]; rcl[0] = rcl[1] = 0; ccall_classify_struct(cts, ctr<br>, rcl, 0); ccall_struct_ret(cc, rcl, dp, ctr-&gt;size);</span></span></td></tr>
<tr class="codeline" data-linenumber="838"><td class="num" id="LN838">838</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="839"><td class="num" id="LN839">839</td><td class="line">    <span class='keyword'>return</span> 1;  <span class='comment'>/* One GC step. */</span></td></tr>
<tr class="codeline" data-linenumber="840"><td class="num" id="LN840">840</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="841"><td class="num" id="LN841">841</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>ctype_iscomplex(ctr-&gt;info)<span class='macro_popup'>(((ctr-&gt;info) &amp; (0xf0000000u|0x04000000u)) == (((CTInfo<br>)(CT_ARRAY) &lt;&lt; 28) + (0x04000000u)))</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="842"><td class="num" id="LN842">842</td><td class="line">    <span class='comment'>/* Return cdata object which is already on top of stack. */</span></td></tr>
<tr class="codeline" data-linenumber="843"><td class="num" id="LN843">843</td><td class="line">    <span class='keyword'>void</span> *dp = <span class='macro'>cdataptr(cdataV(L-&gt;top-1))<span class='macro_popup'>((void *)(((&amp;(((GCobj *)(uintptr_t)((L-&gt;top-1)-&gt;gcr<br>).gcptr32))-&gt;cd))+1))</span></span>;  <span class='comment'>/* Use preallocated object. */</span></td></tr>
<tr class="codeline" data-linenumber="844"><td class="num" id="LN844">844</td><td class="line">    <span class='macro'>CCALL_HANDLE_COMPLEXRET2<span class='macro_popup'>if (ctr-&gt;size == 2*sizeof(float)) { *(int64_t *)dp = cc-&gt;<br>fpr[0].l[0]; } else { ((int64_t *)dp)[0] = cc-&gt;fpr[0].l[0]<br>; ((int64_t *)dp)[1] = cc-&gt;fpr[1].l[0]; }</span></span></td></tr>
<tr class="codeline" data-linenumber="845"><td class="num" id="LN845">845</td><td class="line">    <span class='keyword'>return</span> 1;  <span class='comment'>/* One GC step. */</span></td></tr>
<tr class="codeline" data-linenumber="846"><td class="num" id="LN846">846</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="847"><td class="num" id="LN847">847</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>LJ_BE<span class='macro_popup'>0</span></span> &amp;&amp; <span class='macro'>ctype_isinteger_or_bool(ctr-&gt;info)<span class='macro_popup'>(((ctr-&gt;info) &amp; (0xf0000000u|0x04000000u)) == (((CTInfo<br>)(CT_NUM) &lt;&lt; 28) + (0)))</span></span> &amp;&amp; ctr-&gt;size &lt; <span class='macro'>CTSIZE_PTR<span class='macro_popup'>8</span></span>)</td></tr>
<tr class="codeline" data-linenumber="848"><td class="num" id="LN848">848</td><td class="line">    sp += (<span class='macro'>CTSIZE_PTR<span class='macro_popup'>8</span></span> - ctr-&gt;size);</td></tr>
<tr class="codeline" data-linenumber="849"><td class="num" id="LN849">849</td><td class="line"><span class='directive'>#if <span class='macro'>CCALL_NUM_FPR<span class='macro_popup'>(8 &gt; 2 ? 8 : 2)</span></span></span></td></tr>
<tr class="codeline" data-linenumber="850"><td class="num" id="LN850">850</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>ctype_isfp(ctr-&gt;info)<span class='macro_popup'>(((ctr-&gt;info) &amp; (0xf0000000u|0x04000000u)) == (((CTInfo<br>)(CT_NUM) &lt;&lt; 28) + (0x04000000u)))</span></span> || <span class='macro'>ctype_isvector(ctr-&gt;info)<span class='macro_popup'>(((ctr-&gt;info) &amp; (0xf0000000u|0x08000000u)) == (((CTInfo<br>)(CT_ARRAY) &lt;&lt; 28) + (0x08000000u)))</span></span>)</td></tr>
<tr class="codeline" data-linenumber="851"><td class="num" id="LN851">851</td><td class="line">    sp = (uint8_t *)&amp;cc-&gt;fpr[0];</td></tr>
<tr class="codeline" data-linenumber="852"><td class="num" id="LN852">852</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="853"><td class="num" id="LN853">853</td><td class="line"><span class='directive'>#ifdef CCALL_HANDLE_RET</span></td></tr>
<tr class="codeline" data-linenumber="854"><td class="num" id="LN854">854</td><td class="line">  CCALL_HANDLE_RET</td></tr>
<tr class="codeline" data-linenumber="855"><td class="num" id="LN855">855</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="856"><td class="num" id="LN856">856</td><td class="line">  <span class='comment'>/* No reference types end up here, so there's no need for the CTypeID. */</span></td></tr>
<tr class="codeline" data-linenumber="857"><td class="num" id="LN857">857</td><td class="line">  <span class='macro'>lua_assert(!(ctype_isrefarray(ctr-&gt;info) || ctype_isstruct(ctr-&gt;info)))<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="858"><td class="num" id="LN858">858</td><td class="line">  <span class='keyword'>return</span> lj_cconv_tv_ct(cts, ctr, 0, L-&gt;top-1, sp);</td></tr>
<tr class="codeline" data-linenumber="859"><td class="num" id="LN859">859</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="860"><td class="num" id="LN860">860</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="861"><td class="num" id="LN861">861</td><td class="line"><span class='comment'>/* Call C function. */</span></td></tr>
<tr class="codeline" data-linenumber="862"><td class="num" id="LN862">862</td><td class="line"><span class='keyword'>int</span> lj_ccall_func(lua_State *L, GCcdata *cd)</td></tr>
<tr class="codeline" data-linenumber="863"><td class="num" id="LN863">863</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="864"><td class="num" id="LN864">864</td><td class="line">  CTState *cts = ctype_cts(L);</td></tr>
<tr class="codeline" data-linenumber="865"><td class="num" id="LN865">865</td><td class="line">  CType *ct = ctype_raw(cts, cd-&gt;ctypeid);</td></tr>
<tr class="codeline" data-linenumber="866"><td class="num" id="LN866">866</td><td class="line">  CTSize sz = <span class='macro'>CTSIZE_PTR<span class='macro_popup'>8</span></span>;</td></tr>
<tr class="codeline" data-linenumber="867"><td class="num" id="LN867">867</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>ctype_isptr(ct-&gt;info)<span class='macro_popup'>((((ct-&gt;info)) &gt;&gt; 28) == CT_PTR)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="868"><td class="num" id="LN868">868</td><td class="line">    sz = ct-&gt;size;</td></tr>
<tr class="codeline" data-linenumber="869"><td class="num" id="LN869">869</td><td class="line">    ct = ctype_rawchild(cts, ct);</td></tr>
<tr class="codeline" data-linenumber="870"><td class="num" id="LN870">870</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="871"><td class="num" id="LN871">871</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>ctype_isfunc(ct-&gt;info)<span class='macro_popup'>((((ct-&gt;info)) &gt;&gt; 28) == CT_FUNC)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="872"><td class="num" id="LN872">872</td><td class="line">    CCallState cc;</td></tr>
<tr class="codeline" data-linenumber="873"><td class="num" id="LN873">873</td><td class="line">    <span class='keyword'>int</span> gcsteps, ret;</td></tr>
<tr class="codeline" data-linenumber="874"><td class="num" id="LN874">874</td><td class="line">    cc.func = (<span class='keyword'>void</span> (*)(<span class='keyword'>void</span>))cdata_getptr(<span class='macro'>cdataptr(cd)<span class='macro_popup'>((void *)((cd)+1))</span></span>, sz);</td></tr>
<tr class="codeline" data-linenumber="875"><td class="num" id="LN875">875</td><td class="line">    gcsteps = ccall_set_args(L, cts, ct, &amp;cc);</td></tr>
<tr class="codeline" data-linenumber="876"><td class="num" id="LN876">876</td><td class="line">    ct = (CType *)((intptr_t)ct-(intptr_t)cts-&gt;tab);</td></tr>
<tr class="codeline" data-linenumber="877"><td class="num" id="LN877">877</td><td class="line">    cts-&gt;cb.slot = ~0u;</td></tr>
<tr class="codeline" data-linenumber="878"><td class="num" id="LN878">878</td><td class="line">    lj_vm_ffi_call(&amp;cc);</td></tr>
<tr class="codeline" data-linenumber="879"><td class="num" id="LN879">879</td><td class="line">    <span class='keyword'>if</span> (cts-&gt;cb.slot != ~0u) {  <span class='comment'>/* Blacklist function that called a callback. */</span></td></tr>
<tr class="codeline" data-linenumber="880"><td class="num" id="LN880">880</td><td class="line">      TValue tv;</td></tr>
<tr class="codeline" data-linenumber="881"><td class="num" id="LN881">881</td><td class="line">      setlightudV(&amp;tv, (<span class='keyword'>void</span> *)cc.func);</td></tr>
<tr class="codeline" data-linenumber="882"><td class="num" id="LN882">882</td><td class="line">      <span class='macro'>setboolV(lj_tab_set(L, cts-&gt;miscmap, &amp;tv), 1)<span class='macro_popup'>((lj_tab_set(L, cts-&gt;miscmap, &amp;tv))-&gt;it = (~1u)-(uint32_t<br>)(1))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="883"><td class="num" id="LN883">883</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="884"><td class="num" id="LN884">884</td><td class="line">    ct = (CType *)((intptr_t)ct+(intptr_t)cts-&gt;tab);  <span class='comment'>/* May be reallocated. */</span></td></tr>
<tr class="codeline" data-linenumber="885"><td class="num" id="LN885">885</td><td class="line">    gcsteps += ccall_get_results(L, cts, ct, &amp;cc, &amp;ret);</td></tr>
<tr class="codeline" data-linenumber="886"><td class="num" id="LN886">886</td><td class="line"><span class='directive'>#if LJ_TARGET_X86 &amp;&amp; <span class='macro'>LJ_ABI_WIN<span class='macro_popup'>(2 == 1)</span></span></span></td></tr>
<tr class="codeline" data-linenumber="887"><td class="num" id="LN887">887</td><td class="line">    <span class='comment'>/* Automatically detect __stdcall and fix up C function declaration. */</span></td></tr>
<tr class="codeline" data-linenumber="888"><td class="num" id="LN888">888</td><td class="line">    <span class='keyword'>if</span> (cc.spadj &amp;&amp; <span class='macro'>ctype_cconv(ct-&gt;info)<span class='macro_popup'>(((ct-&gt;info) &gt;&gt; 16) &amp; 3)</span></span> == CTCC_CDECL) {</td></tr>
<tr class="codeline" data-linenumber="889"><td class="num" id="LN889">889</td><td class="line">      <span class='macro'>CTF_INSERT(ct-&gt;info, CCONV, CTCC_STDCALL)<span class='macro_popup'>ct-&gt;info = (ct-&gt;info &amp; ~(3&lt;&lt;16)) | (((CTSize)<br>(CTCC_STDCALL) &amp; 3) &lt;&lt; 16)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="890"><td class="num" id="LN890">890</td><td class="line">      <span class='macro'>lj_trace_abort(G(L))<span class='macro_popup'>((&amp;((GG_State *)((char *)((((global_State *)(void *)(uintptr_t<br>)(L-&gt;glref).ptr32))) - ((int)__builtin_offsetof(GG_State, g<br>))))-&gt;J)-&gt;state &amp;= ~LJ_TRACE_ACTIVE)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="891"><td class="num" id="LN891">891</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="892"><td class="num" id="LN892">892</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="893"><td class="num" id="LN893">893</td><td class="line">    <span class='keyword'>while</span> (gcsteps-- &gt; 0)</td></tr>
<tr class="codeline" data-linenumber="894"><td class="num" id="LN894">894</td><td class="line">      <span class='macro'>lj_gc_check(L)<span class='macro_popup'>{ if (__builtin_expect(!!((((global_State *)(void *)(uintptr_t<br>)(L-&gt;glref).ptr32))-&gt;gc.total &gt;= (((global_State *)(<br>void *)(uintptr_t)(L-&gt;glref).ptr32))-&gt;gc.threshold), 0)<br>) lj_gc_step(L); }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="895"><td class="num" id="LN895">895</td><td class="line">    <span class='keyword'>return</span> ret;</td></tr>
<tr class="codeline" data-linenumber="896"><td class="num" id="LN896">896</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="897"><td class="num" id="LN897">897</td><td class="line">  <span class='keyword'>return</span> -1;  <span class='comment'>/* Not a function. */</span></td></tr>
<tr class="codeline" data-linenumber="898"><td class="num" id="LN898">898</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="899"><td class="num" id="LN899">899</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="900"><td class="num" id="LN900">900</td><td class="line"><span class='directive'>#endif</span></td></tr>
</table></body></html>
