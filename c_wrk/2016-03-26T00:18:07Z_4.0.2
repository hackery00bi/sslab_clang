scan-build: Using '/llvm-project/build/bin/clang-12' for static analysis
Building LuaJIT...
make[1]: Entering directory '/tmp/real/c_wrk/wrk1/obj/LuaJIT-2.0.4'
==== Building LuaJIT 2.0.4 ====
make -C src
make[2]: Entering directory '/tmp/real/c_wrk/wrk1/obj/LuaJIT-2.0.4/src'
HOSTCC    host/minilua.o
HOSTLINK  host/minilua
DYNASM    host/buildvm_arch.h
HOSTCC    host/buildvm.o
In file included from host/buildvm.c:59:0:
./../dynasm/dasm_x86.h: In function 'dasm_put':
./../dynasm/dasm_x86.h:207:2: warning: this 'if' clause does not guard... [-Wmisleading-indentation]
  if (*p++ == 1 && *p == DASM_DISP) mrm = n; continue;
  ^~
./../dynasm/dasm_x86.h:207:45: note: ...this statement, but the latter is misleadingly indented as if it were guarded by the 'if'
  if (*p++ == 1 && *p == DASM_DISP) mrm = n; continue;
                                             ^~~~~~~~
HOSTCC    host/buildvm_asm.o
HOSTCC    host/buildvm_peobj.o
HOSTCC    host/buildvm_lib.o
HOSTCC    host/buildvm_fold.o
host/buildvm_fold.c:22:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(htab, 0xff, (sz+1)*sizeof(uint32_t));
  ^~~~~~
1 warning generated.
HOSTLINK  host/buildvm
BUILDVM   lj_vm.s
ASM       lj_vm.o
CC        lj_gc.o
BUILDVM   lj_ffdef.h
CC        lj_err.o
CC        lj_char.o
BUILDVM   lj_bcdef.h
CC        lj_bc.o
CC        lj_obj.o
could not find clang line
Makefile:645: recipe for target 'lj_obj.o' failed
make[2]: *** [lj_obj.o] Error 255
make[2]: Leaving directory '/tmp/real/c_wrk/wrk1/obj/LuaJIT-2.0.4/src'
Makefile:103: recipe for target 'src/luajit' failed
make[1]: *** [src/luajit] Error 2
make[1]: Leaving directory '/tmp/real/c_wrk/wrk1/obj/LuaJIT-2.0.4'
Makefile:86: recipe for target 'obj/lib/libluajit-5.1.a' failed
make: *** [obj/lib/libluajit-5.1.a] Error 2
scan-build: Analysis run complete.
scan-build: 1 bug found.
scan-build: Run 'scan-view /tmp/scan-build-2020-11-20-010034-3003-1' to examine bug reports.
scan-build: The analyzer encountered problems on some source files.
scan-build: Preprocessed versions of these sources were deposited in '/tmp/scan-build-2020-11-20-010034-3003-1/failures'.
scan-build: Please consider submitting a bug report using these files:
scan-build:   http://clang-analyzer.llvm.org/filing_bugs.html
scan-build: Using '/llvm-project/build/bin/clang-12' for static analysis
Building LuaJIT...
make[1]: Entering directory '/tmp/real/c_wrk/wrk0/obj/LuaJIT-2.0.4'
==== Building LuaJIT 2.0.4 ====
make -C src
make[2]: Entering directory '/tmp/real/c_wrk/wrk0/obj/LuaJIT-2.0.4/src'
HOSTCC    host/minilua.o
host/minilua.c:698:1: warning: Call to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
sprintf(buff,"%p",va_arg(argp,void*));
^~~~~~~
host/minilua.c:733:1: warning: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
strncpy(out,source+1,bufflen);
^~~~~~~
host/minilua.c:742:1: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [security.insecureAPI.strcpy]
strcpy(out,"");
^~~~~~
host/minilua.c:745:1: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [security.insecureAPI.strcpy]
strcat(out,"...");
^~~~~~
host/minilua.c:747:1: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [security.insecureAPI.strcpy]
strcat(out,source);
^~~~~~
host/minilua.c:753:1: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [security.insecureAPI.strcpy]
strcpy(out,"[string \"");
^~~~~~
host/minilua.c:755:1: warning: Call to function 'strncat' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncat_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
strncat(out,source,len);
^~~~~~~
host/minilua.c:756:1: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [security.insecureAPI.strcpy]
strcat(out,"...");
^~~~~~
host/minilua.c:759:1: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [security.insecureAPI.strcpy]
strcat(out,source);
^~~~~~
host/minilua.c:760:1: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [security.insecureAPI.strcpy]
strcat(out,"\"]");
^~~~~~
host/minilua.c:1295:1: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
memcpy(ts+1,str,l*sizeof(char));
^~~~~~
host/minilua.c:1352:1: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
memcpy(a,&n,sizeof(a));
^~~~~~
host/minilua.c:4349:10: warning: The left operand of '==' is a garbage value [core.UndefinedBinaryOperatorResult]
if(nv.v.k==VLOCAL)
   ~~~~~~^
host/minilua.c:4591:9: warning: The left operand of '==' is a garbage value [core.UndefinedBinaryOperatorResult]
if(v.v.k==VCALL)
   ~~~~~^
host/minilua.c:4704:1: warning: Call to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
lua_number2str(s,n);
^~~~~~~~~~~~~~~~~~~
host/minilua.c:145:28: note: expanded from macro 'lua_number2str'
#define lua_number2str(s,n)sprintf((s),"%.14g",(n))
                           ^~~~~~~
host/minilua.c:4905:1: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
memcpy(buffer+tl,svalue(top-i),l);
^~~~~~
host/minilua.c:6102:1: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
memcpy(B->p,s,vl);
^~~~~~
host/minilua.c:6762:4: warning: Call to function 'fscanf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fscanf_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
if(fscanf(f,"%lf",&d)==1){
   ^~~~~~
host/minilua.c:7568:1: warning: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
strncpy(form,strfrmt,p-strfrmt+1);
^~~~~~~
host/minilua.c:7576:1: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [security.insecureAPI.strcpy]
strcpy(form+l-1,"l");
^~~~~~
host/minilua.c:7601:1: warning: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
sprintf(buff,form,(int)luaL_checknumber(L,arg));
^~~~~~~
host/minilua.c:7606:1: warning: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
sprintf(buff,form,(long)luaL_checknumber(L,arg));
^~~~~~~
host/minilua.c:7611:1: warning: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
sprintf(buff,form,(unsigned long)luaL_checknumber(L,arg));
^~~~~~~
host/minilua.c:7616:1: warning: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
sprintf(buff,form,(double)luaL_checknumber(L,arg));
^~~~~~~
host/minilua.c:7632:1: warning: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
sprintf(buff,form,s);
^~~~~~~
25 warnings generated.
HOSTLINK  host/minilua
DYNASM    host/buildvm_arch.h
HOSTCC    host/buildvm.o
In file included from host/buildvm.c:59:0:
./../dynasm/dasm_x86.h: In function 'dasm_put':
./../dynasm/dasm_x86.h:207:2: warning: this 'if' clause does not guard... [-Wmisleading-indentation]
  if (*p++ == 1 && *p == DASM_DISP) mrm = n; continue;
  ^~
./../dynasm/dasm_x86.h:207:45: note: ...this statement, but the latter is misleadingly indented as if it were guarded by the 'if'
  if (*p++ == 1 && *p == DASM_DISP) mrm = n; continue;
                                             ^~~~~~~~
In file included from host/buildvm.c:59:
./../dynasm/dasm_x86.h:134:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset((void *)(((unsigned char *)D->pclabels)+osz), 0, D->pcsize-osz);
  ^~~~~~
./../dynasm/dasm_x86.h:145:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset((void *)D->lglabels, 0, D->lgsize);
  ^~~~~~
./../dynasm/dasm_x86.h:146:20: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  if (D->pclabels) memset((void *)D->pclabels, 0, D->pcsize);
                   ^~~~~~
host/buildvm.c:108:3: warning: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  sprintf(name, "%s%s%s", symprefix, prefix, suffix);
  ^~~~~~~
host/buildvm.c:123:3: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [security.insecureAPI.strcpy]
  strcpy(p, name);
  ^~~~~~
host/buildvm.c:178:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(ctx->glob, 0, ctx->nglob*sizeof(void *));
  ^~~~~~
6 warnings generated.
HOSTCC    host/buildvm_asm.o
HOSTCC    host/buildvm_peobj.o
host/buildvm_peobj.c:138:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(sym.n.name, name, len);
    ^~~~~~
host/buildvm_peobj.c:139:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(sym.n.name+len, 0, 8-len);
    ^~~~~~
host/buildvm_peobj.c:143:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(strtab + strtabofs, name, len);
    ^~~~~~
host/buildvm_peobj.c:161:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(sym.n.name, pesect[sect].name, 8);
  ^~~~~~
host/buildvm_peobj.c:168:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&aux, 0, sizeof(PEsymaux));
  ^~~~~~
host/buildvm_peobj.c:186:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&pesect, 0, PEOBJ_NSECTIONS*sizeof(PEsection));
  ^~~~~~
host/buildvm_peobj.c:187:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(pesect[PEOBJ_SECT_TEXT].name, ".text", sizeof(".text")-1);
  ^~~~~~
host/buildvm_peobj.c:196:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(pesect[PEOBJ_SECT_PDATA].name, ".pdata", sizeof(".pdata")-1);
  ^~~~~~
host/buildvm_peobj.c:204:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(pesect[PEOBJ_SECT_XDATA].name, ".xdata", sizeof(".xdata")-1);
  ^~~~~~
host/buildvm_peobj.c:213:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(pesect[PEOBJ_SECT_RDATA_Z].name, ".rdata$Z", sizeof(".rdata$Z")-1);
  ^~~~~~
10 warnings generated.
HOSTCC    host/buildvm_lib.o
host/buildvm_lib.c:44:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(optr, p, n);
  ^~~~~~
host/buildvm_lib.c:61:12: warning: Call to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      n += sprintf(line+n, "%d,", *p);
           ^~~~~~~
host/buildvm_lib.c:92:3: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [security.insecureAPI.strcpy]
  strcpy(modname, p);
  ^~~~~~
host/buildvm_lib.c:140:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [security.insecureAPI.strcpy]
    strcpy(funcname, p);
    ^~~~~~
host/buildvm_lib.c:167:3: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [security.insecureAPI.strcpy]
  strcpy(p, name);
  ^~~~~~
host/buildvm_lib.c:196:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(dst, src, n);
    ^~~~~~
6 warnings generated.
HOSTCC    host/buildvm_fold.o
host/buildvm_fold.c:22:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(htab, 0xff, (sz+1)*sizeof(uint32_t));
  ^~~~~~
1 warning generated.
HOSTLINK  host/buildvm
BUILDVM   lj_vm.s
ASM       lj_vm.o
CC        lj_gc.o
BUILDVM   lj_ffdef.h
CC        lj_err.o
CC        lj_char.o
BUILDVM   lj_bcdef.h
CC        lj_bc.o
CC        lj_obj.o
CC        lj_str.o
lj_str.c:76:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(newhash, 0, (newmask+1)*sizeof(GCRef));
  ^~~~~~
lj_str.c:152:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(strdatawr(s), str, len);
  ^~~~~~
lj_str.c:180:20: warning: Call to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    return (size_t)lua_number2str(s, n);
                   ^~~~~~~~~~~~~~~~~~~~
./luaconf.h:125:30: note: expanded from macro 'lua_number2str'
#define lua_number2str(s, n)    sprintf((s), LUA_NUMBER_FMT, (n))
                                ^~~~~~~
3 warnings generated.
CC        lj_tab.o
lj_tab.c:179:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(array, karray, asize*sizeof(TValue));
      ^~~~~~
1 warning generated.
CC        lj_func.o
CC        lj_udata.o
CC        lj_meta.o
lj_meta.c:298:2: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(buffer + tlen, strVdata(top-i), len);
        ^~~~~~
1 warning generated.
CC        lj_debug.o
lj_debug.c:337:5: warning: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    strncpy(out, src+1, LUA_IDSIZE);  /* Remove first char. */
    ^~~~~~~
lj_debug.c:346:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [security.insecureAPI.strcpy]
    strcpy(out, src);
    ^~~~~~
lj_debug.c:351:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [security.insecureAPI.strcpy]
    strcpy(out, "[string \""); out += 9;
    ^~~~~~
lj_debug.c:354:7: warning: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      strncpy(out, src, len); out += len;
      ^~~~~~~
lj_debug.c:355:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [security.insecureAPI.strcpy]
      strcpy(out, "..."); out += 3;
      ^~~~~~
lj_debug.c:357:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [security.insecureAPI.strcpy]
      strcpy(out, src); out += len;
      ^~~~~~
lj_debug.c:359:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [security.insecureAPI.strcpy]
    strcpy(out, "\"]");
    ^~~~~~
7 warnings generated.
CC        lj_state.o
lj_state.c:188:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(GG, 0, sizeof(GG_State));
  ^~~~~~
1 warning generated.
CC        lj_dispatch.o
lj_dispatch.c:133:2: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(&disp[0], &disp[GG_LEN_DDISP], GG_LEN_SDISP*sizeof(ASMFunction));
        ^~~~~~
1 warning generated.
CC        lj_vmevent.o
CC        lj_vmmath.o
CC        lj_strscan.o
lj_strscan.c:295:5: warning: Assigned value is garbage or undefined [core.uninitialized.Assign]
        cy += xi[i];
           ^  ~~~~~
lj_strscan.c:310:7: warning: Assigned value is garbage or undefined [core.uninitialized.Assign]
      uint64_t x = xi[hi];
      ^~~~~~~~~~   ~~~~~~
2 warnings generated.
CC        lj_api.o
CC        lj_lex.o
CC        lj_parse.o
lj_parse.c:1390:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(uv, fs->uvtmp, fs->nuv*sizeof(VarIndex));
  ^~~~~~
lj_parse.c:1513:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(p, ls->sb.buf, ls->sb.n);  /* Copy from temp. string buffer. */
  ^~~~~~
2 warnings generated.
CC        lj_bcread.o
lj_bcread.c:69:4: warning: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
          memmove(ls->sb.buf, ls->p, ls->n);
          ^~~~~~~
lj_bcread.c:72:2: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(ls->sb.buf, ls->p, ls->n);
        ^~~~~~
lj_bcread.c:86:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(ls->sb.buf + ls->sb.n, buf, size);
      ^~~~~~
lj_bcread.c:125:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(q, bcread_mem(ls, len), len);
  ^~~~~~
4 warnings generated.
CC        lj_bcwrite.o
CC        lj_load.o
CC        lj_ir.o
lj_ir.c:96:5: warning: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memmove(baseir + ofs, baseir, (J->cur.nins - J->irbotlim)*sizeof(IRIns));
    ^~~~~~~
lj_ir.c:104:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(newbase + ofs, baseir, (J->cur.nins - J->irbotlim)*sizeof(IRIns));
    ^~~~~~
2 warnings generated.
CC        lj_opt_mem.o
lj_opt_mem.c:46:9: warning: Dereference of null pointer [core.NullDereference]
    if (ir->op2 == ref &&
        ^~~~~~~
1 warning generated.
BUILDVM   lj_folddef.h
CC        lj_opt_fold.o
CC        lj_opt_narrow.o
lj_opt_narrow.c:382:8: warning: 2nd function call argument is an uninitialized value [core.CallAndMessage]
              lj_ir_kint64(J, (int64_t)(int32_t)*next++) :
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
lj_opt_narrow.c:383:8: warning: 2nd function call argument is an uninitialized value [core.CallAndMessage]
              lj_ir_kint(J, *next++);
              ^~~~~~~~~~~~~~~~~~~~~~
2 warnings generated.
CC        lj_opt_dce.o
lj_opt_dce.c:72:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(J->bpropcache, 0, sizeof(J->bpropcache));  /* Invalidate cache. */
    ^~~~~~
1 warning generated.
CC        lj_opt_loop.o
CC        lj_opt_split.o
CC        lj_opt_sink.o
CC        lj_mcode.o
CC        lj_snap.o
lj_snap.c:182:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(udf, 1, maxslot);
  ^~~~~~
lj_snap.c:567:8: warning: Value stored to 'tmp' is never read [deadcode.DeadStores]
              tmp = emitir(irs->ot, tmp, val);
              ^     ~~~~~~~~~~~~~~~~~~~~~~~~~
2 warnings generated.
CC        lj_record.o
In file included from lj_record.c:9:
./lj_obj.h:842:5: warning: Undefined or garbage value returned to caller [core.uninitialized.UndefReturn]
    return numV(o);
    ^~~~~~~~~~~~~~
lj_record.c:651:3: warning: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memmove(&J->base[-1], &J->base[func], sizeof(TRef)*(J->maxslot+1));
  ^~~~~~~
lj_record.c:758:7: warning: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memmove(J->base + cbase, J->base-1, sizeof(TRef)*nresults);
      ^~~~~~~
lj_record.c:759:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(J->base-1, 0, sizeof(TRef)*(cbase+1));
      ^~~~~~
lj_record.c:813:7: warning: The left operand of '&' is a garbage value [core.UndefinedBinaryOperatorResult]
  if (tref_istab(ix->tab)) {
      ^          ~~~~~~~
./lj_ir.h:470:26: note: expanded from macro 'tref_istab'
#define tref_istab(tr)          (tref_istype((tr), IRT_TAB))
                                 ^            ~~
./lj_ir.h:463:35: note: expanded from macro 'tref_istype'
#define tref_istype(tr, t)      (((tr) & (IRT_TYPE<<24)) == ((t)<<24))
                                   ~~  ^
lj_record.c:883:11: warning: Assigned value is garbage or undefined [core.uninitialized.Assign]
  base[1] = ix->tab; base[2] = ix->key;
          ^ ~~~~~~~
lj_record.c:883:30: warning: Assigned value is garbage or undefined [core.uninitialized.Assign]
  base[1] = ix->tab; base[2] = ix->key;
                             ^ ~~~~~~~
lj_record.c:1171:11: warning: The left operand of '&' is a garbage value [core.UndefinedBinaryOperatorResult]
  while (!tref_istab(ix->tab)) { /* Handle non-table lookup. */
          ^          ~~~~~~~
./lj_ir.h:470:26: note: expanded from macro 'tref_istab'
#define tref_istab(tr)          (tref_istype((tr), IRT_TAB))
                                 ^            ~~
./lj_ir.h:463:35: note: expanded from macro 'tref_istype'
#define tref_istype(tr, t)      (((tr) & (IRT_TYPE<<24)) == ((t)<<24))
                                   ~~  ^
lj_record.c:1787:7: warning: 1st function call argument is an uninitialized value [core.CallAndMessage]
        if (!lj_ir_strcmp(strV(rav), strV(rcv), (IROp)irop)) irop ^= 1;
             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
lj_record.c:2155:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(J->slot, 0, sizeof(J->slot));
  ^~~~~~
lj_record.c:2156:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(J->chain, 0, sizeof(J->chain));
  ^~~~~~
lj_record.c:2157:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(J->bpropcache, 0, sizeof(J->bpropcache));
  ^~~~~~
12 warnings generated.
CC        lj_crecord.o
lj_crecord.c:247:2: warning: Value stored to 'step' is never read [deadcode.DeadStores]
        step = (1u << ctype_align(ct->info));
        ^      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1 warning generated.
BUILDVM   lj_recdef.h
CC        lj_ffrecord.o
CC        lj_asm.o
lj_asm.c:304:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(as->phireg, 0, sizeof(as->phireg));
  ^~~~~~
In file included from lj_asm.c:1331:
./lj_asm_x86.h:403:11: warning: Branch condition evaluates to a garbage value [core.uninitialized.Branch]
      if (args[i] && irt_isfp(IR(args[i])->t)) {
          ^~~~~~~
./lj_asm_x86.h:463:5: warning: Assigned value is garbage or undefined [core.uninitialized.Assign]
    IRRef ref = args[n];
    ^~~~~~~~~   ~~~~~~~
./lj_asm_x86.h:1302:11: warning: Although the value stored to 'osrc' is used in the enclosing expression, the value is never actually read from 'osrc' [deadcode.DeadStores]
    src = osrc = ra_alloc1(as, ir->op2, allow8);
          ^      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4 warnings generated.
CC        lj_trace.o
lj_trace.c:130:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(T, &J->cur, sizeof(GCtrace));
  ^~~~~~
lj_trace.c:136:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(p, J->cur.ir+J->cur.nk, szins);
  ^~~~~~
lj_trace.c:138:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  TRACE_APPENDVEC(snap, nsnap, SnapShot)
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
lj_trace.c:82:3: note: expanded from macro 'TRACE_APPENDVEC'
  memcpy(p, J->cur.field, J->cur.szfield*sizeof(tp)); \
  ^~~~~~
lj_trace.c:139:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  TRACE_APPENDVEC(snapmap, nsnapmap, SnapEntry)
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
lj_trace.c:82:3: note: expanded from macro 'TRACE_APPENDVEC'
  memcpy(p, J->cur.field, J->cur.szfield*sizeof(tp)); \
  ^~~~~~
lj_trace.c:277:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(J->penalty, 0, sizeof(J->penalty));
  ^~~~~~
lj_trace.c:280:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(J->exitstubgroup, 0, sizeof(J->exitstubgroup));
  ^~~~~~
lj_trace.c:385:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(&J->cur, 0, sizeof(GCtrace));
  ^~~~~~
7 warnings generated.
CC        lj_gdbjit.o
CC        lj_ctype.o
lj_ctype.c:595:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(cts, 0, sizeof(CTState));
  ^~~~~~
1 warning generated.
CC        lj_cdata.o
CC        lj_cconv.o
lj_cconv.c:169:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(dp, sp, ssize);
      ^~~~~~
lj_cconv.c:170:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(dp + ssize, fill, dsize-ssize);
      ^~~~~~
lj_cconv.c:178:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(dp, sp, dsize);
      ^~~~~~
lj_cconv.c:212:5: warning: Value stored to 'sinfo' is never read [deadcode.DeadStores]
    sinfo = s->info;
    ^       ~~~~~~~
lj_cconv.c:276:5: warning: Value stored to 'sinfo' is never read [deadcode.DeadStores]
    sinfo = s->info;
    ^       ~~~~~~~
lj_cconv.c:283:5: warning: Value stored to 'dinfo' is never read [deadcode.DeadStores]
    dinfo = d->info;
    ^       ~~~~~~~
lj_cconv.c:285:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(dp + dsize, 0, dsize);  /* Clear im. */
    ^~~~~~
lj_cconv.c:289:5: warning: Value stored to 'dinfo' is never read [deadcode.DeadStores]
    dinfo = d->info;
    ^       ~~~~~~~
lj_cconv.c:291:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(dp + dsize, 0, dsize);  /* Clear im. */
    ^~~~~~
lj_cconv.c:315:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(dp, sp, esize);
      ^~~~~~
lj_cconv.c:328:5: warning: Value stored to 'dinfo' is never read [deadcode.DeadStores]
    dinfo = CTINFO(CT_NUM, CTF_UNSIGNED);
    ^       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
lj_cconv.c:361:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(dp, sp, dsize);
    ^~~~~~
lj_cconv.c:413:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(cdataptr(cd), sp, sz);
    ^~~~~~
lj_cconv.c:479:40: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      for (; ofs < size; ofs += esize) memcpy(dp + ofs, dp, esize);
                                       ^~~~~~
lj_cconv.c:481:7: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memset(dp + ofs, 0, size - ofs);
      ^~~~~~
lj_cconv.c:503:25: warning: Although the value stored to 'i' is used in the enclosing expression, the value is never actually read from 'i' [deadcode.DeadStores]
          if (iz == 0) { *ip = i = -1; goto tryname; }  /* Init named fields. */
                               ^   ~~
lj_cconv.c:529:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(dp, 0, d->size);  /* Much simpler to clear the struct first. */
  ^~~~~~
lj_cconv.c:582:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
      memcpy(dp, strdata(str), sz);
      ^~~~~~
lj_cconv.c:678:36: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    for (; ofs < sz; ofs += esize) memcpy(dp + ofs, dp, esize);
                                   ^~~~~~
lj_cconv.c:680:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(dp + ofs, 0, sz - ofs);
    ^~~~~~
lj_cconv.c:715:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(dp, 0, sz);  /* Much simpler to clear the struct first. */
  ^~~~~~
lj_cconv.c:741:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(dp, 0, sz);
    ^~~~~~
22 warnings generated.
CC        lj_ccall.o
lj_ccall.c:555:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(&cc->stack[nsp], dp, n*CTSIZE_PTR);
    ^~~~~~
lj_ccall.c:573:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(dp, sp, sz);
  ^~~~~~
lj_ccall.c:671:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(cc->gpr, 0, sizeof(cc->gpr));
  ^~~~~~
lj_ccall.c:673:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(cc->fpr, 0, sizeof(cc->fpr));
  ^~~~~~
4 warnings generated.
CC        lj_ccallback.o
lj_ccallback.c:590:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(cbid+top, 0, (cts->cb.sizeid-top)*sizeof(CTypeID1));
  ^~~~~~
1 warning generated.
CC        lj_carith.o
lj_carith.c:158:7: warning: Access to field 'info' results in a dereference of a null pointer [core.NullDereference]
  if (ctype_isnum(ca->ct[0]->info) && ca->ct[0]->size <= 8 &&
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
./lj_ctype.h:202:28: note: expanded from macro 'ctype_isnum'
#define ctype_isnum(info)       (ctype_type((info)) == CT_NUM)
                                 ^~~~~~~~~~~~~~~~~~
./lj_ctype.h:190:27: note: expanded from macro 'ctype_type'
#define ctype_type(info)        ((info) >> CTSHIFT_NUM)
                                 ^~~~~~
1 warning generated.
CC        lj_clib.o
CC        lj_cparse.o
lj_cparse.c: In function 'cp_next_':
lj_cparse.c:313:7: warning: this 'if' clause does not guard... [-Wmisleading-indentation]
       if (cp_get(cp) != '|') return '|'; cp_get(cp); return CTOK_OROR;
       ^~
lj_cparse.c:313:42: note: ...this statement, but the latter is misleadingly indented as if it were guarded by the 'if'
       if (cp_get(cp) != '|') return '|'; cp_get(cp); return CTOK_OROR;
                                          ^~~~~~
lj_cparse.c:315:7: warning: this 'if' clause does not guard... [-Wmisleading-indentation]
       if (cp_get(cp) != '&') return '&'; cp_get(cp); return CTOK_ANDAND;
       ^~
lj_cparse.c:315:42: note: ...this statement, but the latter is misleadingly indented as if it were guarded by the 'if'
       if (cp_get(cp) != '&') return '&'; cp_get(cp); return CTOK_ANDAND;
                                          ^~~~~~
lj_cparse.c:317:7: warning: this 'if' clause does not guard... [-Wmisleading-indentation]
       if (cp_get(cp) != '=') return '='; cp_get(cp); return CTOK_EQ;
       ^~
lj_cparse.c:317:42: note: ...this statement, but the latter is misleadingly indented as if it were guarded by the 'if'
       if (cp_get(cp) != '=') return '='; cp_get(cp); return CTOK_EQ;
                                          ^~~~~~
lj_cparse.c:319:7: warning: this 'if' clause does not guard... [-Wmisleading-indentation]
       if (cp_get(cp) != '=') return '!'; cp_get(cp); return CTOK_NE;
       ^~
lj_cparse.c:319:42: note: ...this statement, but the latter is misleadingly indented as if it were guarded by the 'if'
       if (cp_get(cp) != '=') return '!'; cp_get(cp); return CTOK_NE;
                                          ^~~~~~
lj_cparse.c:329:7: warning: this 'if' clause does not guard... [-Wmisleading-indentation]
       if (cp_get(cp) != '>') return '-'; cp_get(cp); return CTOK_DEREF;
       ^~
lj_cparse.c:329:42: note: ...this statement, but the latter is misleadingly indented as if it were guarded by the 'if'
       if (cp_get(cp) != '>') return '-'; cp_get(cp); return CTOK_DEREF;
                                          ^~~~~~
lj_cparse.c:1867:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    LJ_CTYPE_RESTORE(cp->cts);
    ^~~~~~~~~~~~~~~~~~~~~~~~~
./lj_ctype.h:390:4: note: expanded from macro 'LJ_CTYPE_RESTORE'
   memcpy((cts)->hash, savects_.hash, sizeof(savects_.hash)))
   ^~~~~~
1 warning generated.
CC        lj_lib.o
lj_lib.c:70:2: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(fn->c.upvalue, L->top, sizeof(TValue)*nuv);
        ^~~~~~
lj_lib.c:80:12: warning: Dereference of null pointer [core.NullDereference]
        fn->c.f = ofn->c.f;  /* Copy handler from previous function. */
                  ^~~~~~~~
lj_lib.c:98:2: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(&L->top->n, p, sizeof(double));
        ^~~~~~
3 warnings generated.
CC        lj_alloc.o
lj_alloc.c:1155:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memset(m, 0, msize);
    ^~~~~~
lj_alloc.c:1376:2: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        memcpy(newmem, ptr, oc < nsize ? oc : nsize);
        ^~~~~~
2 warnings generated.
CC        lib_aux.o
lib_aux.c:232:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(B->p, s, vl);  /* put it there */
    ^~~~~~
1 warning generated.
BUILDVM   lj_libdef.h
CC        lib_base.o
CC        lib_math.o
CC        lib_bit.o
CC        lib_string.o
lib_string.c:324:43: warning: Dereference of null pointer (loaded from variable 's') [core.NullDereference]
    else if (s<ms->src_end && singlematch(uchar(*s), p, ep))
                                          ^~~~~~~~~
lib_string.c:168:41: note: expanded from macro 'uchar'
#define uchar(c)        ((unsigned char)(c))
                                        ^~~
lib_string.c:687:7: warning: Dereference of null pointer [core.NullDereference]
      luaL_addchar(&b, *src++);
      ^~~~~~~~~~~~~~~~~~~~~~~~
./lauxlib.h:133:23: note: expanded from macro 'luaL_addchar'
   (*(B)->p++ = (char)(c)))
                      ^~~
lib_string.c:755:3: warning: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  strncpy(form, strfrmt, (size_t)(p - strfrmt + 1));
  ^~~~~~~
lib_string.c:765:3: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [security.insecureAPI.strcpy]
  strcpy(form + l - 1, LUA_INTFRMLEN);
  ^~~~~~
lib_string.c:858:2: warning: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        sprintf(buff, form, lj_lib_checkint(L, arg));
        ^~~~~~~
lib_string.c:862:2: warning: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        sprintf(buff, form, num2intfrm(L, arg));
        ^~~~~~~
lib_string.c:866:2: warning: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        sprintf(buff, form, num2uintfrm(L, arg));
        ^~~~~~~
lib_string.c:883:4: warning: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
          sprintf(buff, form, nbuf);
          ^~~~~~~
lib_string.c:886:2: warning: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        sprintf(buff, form, (double)tv.n);
        ^~~~~~~
lib_string.c:905:2: warning: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
        sprintf(buff, form, strdata(str));
        ^~~~~~~
10 warnings generated.
CC        lib_table.o
CC        lib_io.o
lib_io.c:127:7: warning: Call to function 'fscanf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'fscanf_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  if (fscanf(fp, LUA_NUMBER_SCAN, &d) == 1) {
      ^~~~~~
lib_io.c:268:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
    memcpy(L->top, &fn->c.upvalue[1], n*sizeof(TValue));
    ^~~~~~
2 warnings generated.
CC        lib_os.o
CC        lib_package.o
CC        lib_debug.o
CC        lib_jit.o
lib_jit.c:639:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(J->param, jit_param_default, sizeof(J->param));
  ^~~~~~
1 warning generated.
CC        lib_ffi.o
lib_ffi.c:686:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memcpy(dp, sp, len);
  ^~~~~~
lib_ffi.c:696:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  memset(dp, fill, len);
  ^~~~~~
2 warnings generated.
CC        lib_init.o
AR        libluajit.a
ar: `u' modifier ignored since `D' is the default (see `U')
CC        luajit.o
luajit.c:284:34: warning: Null pointer passed to 1st parameter expecting 'nonnull' [core.NonNullParamChecker]
  if (strcmp(fname, "-") == 0 && strcmp(argv[n-1], "--") != 0)
                                 ^~~~~~~~~~~~~~~~~~~~~~~
1 warning generated.
BUILDVM   jit/vmdef.lua
LINK      luajit
OK        Successfully built LuaJIT
make[2]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/LuaJIT-2.0.4/src'
==== Successfully built LuaJIT 2.0.4 ====
==== Installing LuaJIT 2.0.4 to /tmp/real/c_wrk/wrk0/obj ====
mkdir -p /tmp/real/c_wrk/wrk0/obj/bin /tmp/real/c_wrk/wrk0/obj/lib /tmp/real/c_wrk/wrk0/obj/include/luajit-2.0 /tmp/real/c_wrk/wrk0/obj/share/man/man1 /tmp/real/c_wrk/wrk0/obj/lib/pkgconfig /tmp/real/c_wrk/wrk0/obj/share/luajit-2.0.4/jit /tmp/real/c_wrk/wrk0/obj/share/lua/5.1 /tmp/real/c_wrk/wrk0/obj/lib/lua/5.1
cd src && install -m 0755 luajit /tmp/real/c_wrk/wrk0/obj/bin/luajit-2.0.4
cd src && test -f libluajit.a && install -m 0644 libluajit.a /tmp/real/c_wrk/wrk0/obj/lib/libluajit-5.1.a || :
rm -f /tmp/real/c_wrk/wrk0/obj/bin/luajit /tmp/real/c_wrk/wrk0/obj/lib/libluajit-5.1.so.2.0.4 /tmp/real/c_wrk/wrk0/obj/lib/libluajit-5.1.so /tmp/real/c_wrk/wrk0/obj/lib/libluajit-5.1.so
cd src && test -f libluajit.so && \
  install -m 0755 libluajit.so /tmp/real/c_wrk/wrk0/obj/lib/libluajit-5.1.so.2.0.4 && \
  ldconfig -n /tmp/real/c_wrk/wrk0/obj/lib && \
  ln -sf libluajit-5.1.so.2.0.4 /tmp/real/c_wrk/wrk0/obj/lib/libluajit-5.1.so && \
  ln -sf libluajit-5.1.so.2.0.4 /tmp/real/c_wrk/wrk0/obj/lib/libluajit-5.1.so || :
cd etc && install -m 0644 luajit.1 /tmp/real/c_wrk/wrk0/obj/share/man/man1
cd etc && sed -e "s|^prefix=.*|prefix=/tmp/real/c_wrk/wrk0/obj|" -e "s|^multilib=.*|multilib=lib|" luajit.pc > luajit.pc.tmp && \
  install -m 0644 luajit.pc.tmp /tmp/real/c_wrk/wrk0/obj/lib/pkgconfig/luajit.pc && \
  rm -f luajit.pc.tmp
cd src && install -m 0644 lua.h lualib.h lauxlib.h luaconf.h lua.hpp luajit.h /tmp/real/c_wrk/wrk0/obj/include/luajit-2.0
cd src/jit && install -m 0644 bc.lua v.lua dump.lua dis_x86.lua dis_x64.lua dis_arm.lua dis_ppc.lua dis_mips.lua dis_mipsel.lua bcsave.lua vmdef.lua /tmp/real/c_wrk/wrk0/obj/share/luajit-2.0.4/jit
ln -sf luajit-2.0.4 /tmp/real/c_wrk/wrk0/obj/bin/luajit
==== Successfully installed LuaJIT 2.0.4 to /tmp/real/c_wrk/wrk0/obj ====
make[1]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/LuaJIT-2.0.4'
Building OpenSSL...
Operating system: x86_64-whatever-linux2
Configuring for linux-x86_64
Configuring for linux-x86_64
    no-dtls         [option]   OPENSSL_NO_DTLS (skip dir)
    no-ec_nistp_64_gcc_128 [default]  OPENSSL_NO_EC_NISTP_64_GCC_128 (skip dir)
    no-gmp          [default]  OPENSSL_NO_GMP (skip dir)
    no-idea         [option]   OPENSSL_NO_IDEA (skip dir)
    no-jpake        [experimental] OPENSSL_NO_JPAKE (skip dir)
    no-krb5         [krb5-flavor not specified] OPENSSL_NO_KRB5
    no-libunbound   [experimental] OPENSSL_NO_LIBUNBOUND (skip dir)
    no-md2          [default]  OPENSSL_NO_MD2 (skip dir)
    no-psk          [option]   OPENSSL_NO_PSK (skip dir)
    no-rc5          [default]  OPENSSL_NO_RC5 (skip dir)
    no-rfc3779      [default]  OPENSSL_NO_RFC3779 (skip dir)
    no-sctp         [default]  OPENSSL_NO_SCTP (skip dir)
    no-shared       [option]  
    no-srp          [option]   OPENSSL_NO_SRP (skip dir)
    no-ssl-trace    [default]  OPENSSL_NO_SSL_TRACE (skip dir)
    no-ssl2         [option]   OPENSSL_NO_SSL2 (skip dir)
    no-store        [experimental] OPENSSL_NO_STORE (skip dir)
    no-unit-test    [default]  OPENSSL_NO_UNIT_TEST (skip dir)
    no-weak-ssl-ciphers [default]  OPENSSL_NO_WEAK_SSL_CIPHERS (skip dir)
    no-zlib         [default] 
    no-zlib-dynamic [default] 
IsMK1MF=0
CC            =/llvm-project/build/bin/../libexec/ccc-analyzer
CFLAG         =-DOPENSSL_THREADS -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -Wa,--noexecstack -m64 -DL_ENDIAN -O3 -Wall -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DMD5_ASM -DAES_ASM -DVPAES_ASM -DBSAES_ASM -DWHIRLPOOL_ASM -DGHASH_ASM -DECP_NISTZ256_ASM
EX_LIBS       =-ldl
CPUID_OBJ     =x86_64cpuid.o
BN_ASM        =x86_64-gcc.o x86_64-mont.o x86_64-mont5.o x86_64-gf2m.o rsaz_exp.o rsaz-x86_64.o rsaz-avx2.o
EC_ASM        =ecp_nistz256.o ecp_nistz256-x86_64.o
DES_ENC       =des_enc.o fcrypt_b.o
AES_ENC       =aes-x86_64.o vpaes-x86_64.o bsaes-x86_64.o aesni-x86_64.o aesni-sha1-x86_64.o aesni-sha256-x86_64.o aesni-mb-x86_64.o
BF_ENC        =bf_enc.o
CAST_ENC      =c_enc.o
RC4_ENC       =rc4-x86_64.o rc4-md5-x86_64.o
RC5_ENC       =rc5_enc.o
MD5_OBJ_ASM   =md5-x86_64.o
SHA1_OBJ_ASM  =sha1-x86_64.o sha256-x86_64.o sha512-x86_64.o sha1-mb-x86_64.o sha256-mb-x86_64.o
RMD160_OBJ_ASM=
CMLL_ENC      =cmll-x86_64.o cmll_misc.o
MODES_OBJ     =ghash-x86_64.o aesni-gcm-x86_64.o
ENGINES_OBJ   =
PROCESSOR     =
RANLIB        =/usr/bin/ranlib
ARFLAGS       =
PERL          =/usr/bin/perl
SIXTY_FOUR_BIT_LONG mode
DES_UNROLL used
DES_INT used
RC4_CHUNK is unsigned long
make[1]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g'
created directory `include/openssl'
e_os2.h => include/openssl/e_os2.h
making links in crypto...
make[2]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto'
crypto.h => ../include/openssl/crypto.h
opensslv.h => ../include/openssl/opensslv.h
opensslconf.h => ../include/openssl/opensslconf.h
ebcdic.h => ../include/openssl/ebcdic.h
symhacks.h => ../include/openssl/symhacks.h
ossl_typ.h => ../include/openssl/ossl_typ.h
constant_time_test.c => ../test/constant_time_test.c
making links in crypto/objects...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/objects'
objects.h => ../../include/openssl/objects.h
obj_mac.h => ../../include/openssl/obj_mac.h
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/objects'
making links in crypto/md4...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/md4'
md4.h => ../../include/openssl/md4.h
md4test.c => ../../test/md4test.c
md4.c => ../../apps/md4.c
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/md4'
making links in crypto/md5...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/md5'
md5.h => ../../include/openssl/md5.h
md5test.c => ../../test/md5test.c
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/md5'
making links in crypto/sha...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/sha'
sha.h => ../../include/openssl/sha.h
shatest.c => ../../test/shatest.c
sha1test.c => ../../test/sha1test.c
sha256t.c => ../../test/sha256t.c
sha512t.c => ../../test/sha512t.c
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/sha'
making links in crypto/mdc2...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/mdc2'
mdc2.h => ../../include/openssl/mdc2.h
mdc2test.c => ../../test/mdc2test.c
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/mdc2'
making links in crypto/hmac...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/hmac'
hmac.h => ../../include/openssl/hmac.h
hmactest.c => ../../test/hmactest.c
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/hmac'
making links in crypto/ripemd...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/ripemd'
ripemd.h => ../../include/openssl/ripemd.h
rmdtest.c => ../../test/rmdtest.c
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/ripemd'
making links in crypto/whrlpool...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/whrlpool'
whrlpool.h => ../../include/openssl/whrlpool.h
wp_test.c => ../../test/wp_test.c
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/whrlpool'
making links in crypto/des...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/des'
des.h => ../../include/openssl/des.h
des_old.h => ../../include/openssl/des_old.h
destest.c => ../../test/destest.c
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/des'
making links in crypto/aes...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/aes'
aes.h => ../../include/openssl/aes.h
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/aes'
making links in crypto/rc2...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/rc2'
rc2.h => ../../include/openssl/rc2.h
rc2test.c => ../../test/rc2test.c
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/rc2'
making links in crypto/rc4...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/rc4'
rc4.h => ../../include/openssl/rc4.h
rc4test.c => ../../test/rc4test.c
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/rc4'
making links in crypto/bf...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/bf'
blowfish.h => ../../include/openssl/blowfish.h
bftest.c => ../../test/bftest.c
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/bf'
making links in crypto/cast...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/cast'
cast.h => ../../include/openssl/cast.h
casttest.c => ../../test/casttest.c
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/cast'
making links in crypto/camellia...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/camellia'
camellia.h => ../../include/openssl/camellia.h
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/camellia'
making links in crypto/seed...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/seed'
seed.h => ../../include/openssl/seed.h
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/seed'
making links in crypto/modes...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/modes'
modes.h => ../../include/openssl/modes.h
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/modes'
making links in crypto/bn...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/bn'
bn.h => ../../include/openssl/bn.h
bntest.c => ../../test/bntest.c
exptest.c => ../../test/exptest.c
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/bn'
making links in crypto/ec...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/ec'
ec.h => ../../include/openssl/ec.h
ectest.c => ../../test/ectest.c
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/ec'
making links in crypto/rsa...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/rsa'
rsa.h => ../../include/openssl/rsa.h
rsa_test.c => ../../test/rsa_test.c
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/rsa'
making links in crypto/dsa...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/dsa'
dsa.h => ../../include/openssl/dsa.h
dsatest.c => ../../test/dsatest.c
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/dsa'
making links in crypto/ecdsa...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/ecdsa'
ecdsa.h => ../../include/openssl/ecdsa.h
ecdsatest.c => ../../test/ecdsatest.c
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/ecdsa'
making links in crypto/dh...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/dh'
dh.h => ../../include/openssl/dh.h
dhtest.c => ../../test/dhtest.c
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/dh'
making links in crypto/ecdh...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/ecdh'
ecdh.h => ../../include/openssl/ecdh.h
ecdhtest.c => ../../test/ecdhtest.c
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/ecdh'
making links in crypto/dso...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/dso'
dso.h => ../../include/openssl/dso.h
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/dso'
making links in crypto/engine...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/engine'
engine.h => ../../include/openssl/engine.h
enginetest.c => ../../test/enginetest.c
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/engine'
making links in crypto/buffer...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/buffer'
buffer.h => ../../include/openssl/buffer.h
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/buffer'
making links in crypto/bio...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/bio'
bio.h => ../../include/openssl/bio.h
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/bio'
making links in crypto/stack...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/stack'
stack.h => ../../include/openssl/stack.h
safestack.h => ../../include/openssl/safestack.h
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/stack'
making links in crypto/lhash...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/lhash'
lhash.h => ../../include/openssl/lhash.h
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/lhash'
making links in crypto/rand...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/rand'
rand.h => ../../include/openssl/rand.h
randtest.c => ../../test/randtest.c
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/rand'
making links in crypto/err...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/err'
err.h => ../../include/openssl/err.h
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/err'
making links in crypto/evp...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/evp'
evp.h => ../../include/openssl/evp.h
evp_test.c => ../../test/evp_test.c
evp_extra_test.c => ../../test/evp_extra_test.c
evptests.txt -> ../../test/evptests.txt
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/evp'
making links in crypto/asn1...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/asn1'
asn1.h => ../../include/openssl/asn1.h
asn1_mac.h => ../../include/openssl/asn1_mac.h
asn1t.h => ../../include/openssl/asn1t.h
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/asn1'
making links in crypto/pem...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/pem'
pem.h => ../../include/openssl/pem.h
pem2.h => ../../include/openssl/pem2.h
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/pem'
making links in crypto/x509...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/x509'
x509.h => ../../include/openssl/x509.h
x509_vfy.h => ../../include/openssl/x509_vfy.h
verify_extra_test.c => ../../test/verify_extra_test.c
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/x509'
making links in crypto/x509v3...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/x509v3'
x509v3.h => ../../include/openssl/x509v3.h
v3nametest.c => ../../test/v3nametest.c
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/x509v3'
making links in crypto/conf...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/conf'
conf.h => ../../include/openssl/conf.h
conf_api.h => ../../include/openssl/conf_api.h
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/conf'
making links in crypto/txt_db...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/txt_db'
txt_db.h => ../../include/openssl/txt_db.h
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/txt_db'
making links in crypto/pkcs7...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/pkcs7'
pkcs7.h => ../../include/openssl/pkcs7.h
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/pkcs7'
making links in crypto/pkcs12...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/pkcs12'
pkcs12.h => ../../include/openssl/pkcs12.h
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/pkcs12'
making links in crypto/comp...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/comp'
comp.h => ../../include/openssl/comp.h
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/comp'
making links in crypto/ocsp...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/ocsp'
ocsp.h => ../../include/openssl/ocsp.h
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/ocsp'
making links in crypto/ui...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/ui'
ui.h => ../../include/openssl/ui.h
ui_compat.h => ../../include/openssl/ui_compat.h
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/ui'
making links in crypto/krb5...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/krb5'
krb5_asn.h => ../../include/openssl/krb5_asn.h
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/krb5'
making links in crypto/cms...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/cms'
cms.h => ../../include/openssl/cms.h
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/cms'
making links in crypto/pqueue...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/pqueue'
pqueue.h => ../../include/openssl/pqueue.h
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/pqueue'
making links in crypto/ts...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/ts'
ts.h => ../../include/openssl/ts.h
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/ts'
making links in crypto/cmac...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/cmac'
cmac.h => ../../include/openssl/cmac.h
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto/cmac'
make[2]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto'
making links in ssl...
make[2]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/ssl'
ssl.h => ../include/openssl/ssl.h
ssl2.h => ../include/openssl/ssl2.h
ssl3.h => ../include/openssl/ssl3.h
ssl23.h => ../include/openssl/ssl23.h
tls1.h => ../include/openssl/tls1.h
dtls1.h => ../include/openssl/dtls1.h
kssl.h => ../include/openssl/kssl.h
srtp.h => ../include/openssl/srtp.h
ssltest.c => ../test/ssltest.c
heartbeat_test.c => ../test/heartbeat_test.c
clienthellotest.c => ../test/clienthellotest.c
sslv2conftest.c => ../test/sslv2conftest.c
make[2]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/ssl'
making links in engines...
make[2]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/engines'
making links in engines/ccgost...
make[3]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/engines/ccgost'
make[3]: Nothing to be done for 'links'.
make[3]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/engines/ccgost'
make[2]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/engines'
making links in apps...
make[2]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/apps'
make[2]: Nothing to be done for 'links'.
make[2]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/apps'
making links in test...
make[2]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/test'
make[2]: Nothing to be done for 'links'.
make[2]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/test'
making links in tools...
make[2]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/tools'
make[2]: Nothing to be done for 'links'.
make[2]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/tools'
generating dummy tests (if needed)...
make[2]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/test'
ideatest.c => dummytest.c
md2test.c => dummytest.c
rc5test.c => dummytest.c
jpaketest.c => dummytest.c
srptest.c => dummytest.c
make[2]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/test'
make[1]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g'

Configured for linux-x86_64.

*** Because of configuration changes, you MUST do the following before
*** building:

	make depend
make[1]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g'
making depend in crypto...
make[2]: Entering directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto'
../util/domd: 31: ../util/domd: makedepend: not found
mv: cannot stat 'Makefile.new': No such file or directory
Makefile:136: recipe for target 'local_depend' failed
make[2]: *** [local_depend] Error 127
make[2]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g/crypto'
Makefile:471: recipe for target 'depend' failed
make[1]: *** [depend] Error 1
make[1]: Leaving directory '/tmp/real/c_wrk/wrk0/obj/openssl-1.0.2g'
Makefile:90: recipe for target 'obj/lib/libssl.a' failed
make: *** [obj/lib/libssl.a] Error 2
scan-build: Analysis run complete.
scan-build: 154 bugs found.
scan-build: Run 'scan-view /tmp/scan-build-2020-11-20-032833-32183-1' to examine bug reports.
