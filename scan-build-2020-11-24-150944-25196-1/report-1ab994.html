<!doctype html>
<html>
<head>
<title>../lib/dictBuilder/cover.c</title>

<style type="text/css">
body { color:#000000; background-color:#ffffff }
body { font-family:Helvetica, sans-serif; font-size:10pt }
h1 { font-size:14pt }
.FileName { margin-top: 5px; margin-bottom: 5px; display: inline; }
.FileNav { margin-left: 5px; margin-right: 5px; display: inline; }
.FileNav a { text-decoration:none; font-size: larger; }
.divider { margin-top: 30px; margin-bottom: 30px; height: 15px; }
.divider { background-color: gray; }
.code { border-collapse:collapse; width:100%; }
.code { font-family: "Monospace", monospace; font-size:10pt }
.code { line-height: 1.2em }
.comment { color: green; font-style: oblique }
.keyword { color: blue }
.string_literal { color: red }
.directive { color: darkmagenta }

/* Macros and variables could have pop-up notes hidden by default.
  - Macro pop-up:    expansion of the macro
  - Variable pop-up: value (table) of the variable */
.macro_popup, .variable_popup { display: none; }

/* Pop-up appears on mouse-hover event. */
.macro:hover .macro_popup, .variable:hover .variable_popup {
  display: block;
  padding: 2px;
  -webkit-border-radius:5px;
  -webkit-box-shadow:1px 1px 7px #000;
  border-radius:5px;
  box-shadow:1px 1px 7px #000;
  position: absolute;
  top: -1em;
  left:10em;
  z-index: 1
}

.macro_popup {
  border: 2px solid red;
  background-color:#FFF0F0;
  font-weight: normal;
}

.variable_popup {
  border: 2px solid blue;
  background-color:#F0F0FF;
  font-weight: bold;
  font-family: Helvetica, sans-serif;
  font-size: 9pt;
}

/* Pop-up notes needs a relative position as a base where they pops up. */
.macro, .variable {
  background-color: PaleGoldenRod;
  position: relative;
}
.macro { color: DarkMagenta; }

#tooltiphint {
  position: fixed;
  width: 50em;
  margin-left: -25em;
  left: 50%;
  padding: 10px;
  border: 1px solid #b0b0b0;
  border-radius: 2px;
  box-shadow: 1px 1px 7px black;
  background-color: #c0c0c0;
  z-index: 2;
}

.num { width:2.5em; padding-right:2ex; background-color:#eeeeee }
.num { text-align:right; font-size:8pt }
.num { color:#444444 }
.line { padding-left: 1ex; border-left: 3px solid #ccc }
.line { white-space: pre }
.msg { -webkit-box-shadow:1px 1px 7px #000 }
.msg { box-shadow:1px 1px 7px #000 }
.msg { -webkit-border-radius:5px }
.msg { border-radius:5px }
.msg { font-family:Helvetica, sans-serif; font-size:8pt }
.msg { float:left }
.msg { padding:0.25em 1ex 0.25em 1ex }
.msg { margin-top:10px; margin-bottom:10px }
.msg { font-weight:bold }
.msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }
.msgT { padding:0x; spacing:0x }
.msgEvent { background-color:#fff8b4; color:#000000 }
.msgControl { background-color:#bbbbbb; color:#000000 }
.msgNote { background-color:#ddeeff; color:#000000 }
.mrange { background-color:#dfddf3 }
.mrange { border-bottom:1px solid #6F9DBE }
.PathIndex { font-weight: bold; padding:0px 5px; margin-right:5px; }
.PathIndex { -webkit-border-radius:8px }
.PathIndex { border-radius:8px }
.PathIndexEvent { background-color:#bfba87 }
.PathIndexControl { background-color:#8c8c8c }
.PathIndexPopUp { background-color: #879abc; }
.PathNav a { text-decoration:none; font-size: larger }
.CodeInsertionHint { font-weight: bold; background-color: #10dd10 }
.CodeRemovalHint { background-color:#de1010 }
.CodeRemovalHint { border-bottom:1px solid #6F9DBE }
.selected{ background-color:orange !important; }

table.simpletable {
  padding: 5px;
  font-size:12pt;
  margin:20px;
  border-collapse: collapse; border-spacing: 0px;
}
td.rowname {
  text-align: right;
  vertical-align: top;
  font-weight: bold;
  color:#444444;
  padding-right:2ex;
}

/* Hidden text. */
input.spoilerhider + label {
  cursor: pointer;
  text-decoration: underline;
  display: block;
}
input.spoilerhider {
 display: none;
}
input.spoilerhider ~ .spoiler {
  overflow: hidden;
  margin: 10px auto 0;
  height: 0;
  opacity: 0;
}
input.spoilerhider:checked + label + .spoiler{
  height: auto;
  opacity: 1;
}
</style>
</head>
<body>
<!-- BUGDESC Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 -->

<!-- BUGTYPE Potential insecure memory buffer bounds restriction in call 'memcpy' -->

<!-- BUGCATEGORY Security -->

<!-- BUGFILE /tmp/sslab_clang/c_zstd/zstd/programs/../lib/dictBuilder/cover.c -->

<!-- FILENAME cover.c -->

<!-- FUNCTIONNAME COVER_best_finish -->

<!-- ISSUEHASHCONTENTOFLINEINCONTEXT b476236d321cff705a54810bace0b227 -->

<!-- BUGLINE 923 -->

<!-- BUGCOLUMN 9 -->

<!-- BUGPATHLENGTH 1 -->

<!-- BUGMETAEND -->
<!-- REPORTHEADER -->
<h3>Bug Summary</h3>
<table class="simpletable">
<tr><td class="rowname">File:</td><td>programs/../lib/dictBuilder/cover.c</td></tr>
<tr><td class="rowname">Warning:</td><td><a href="#EndPath">line 923, column 9</a><br />Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11</td></tr>

</table>
<!-- REPORTSUMMARYEXTRA -->
<h3>Annotated Source Code</h3>
<p>Press <a href="#" onclick="toggleHelp(); return false;">'?'</a>
   to see keyboard shortcuts</p>
<input type="checkbox" class="spoilerhider" id="showinvocation" />
<label for="showinvocation" >Show analyzer invocation</label>
<div class="spoiler">clang -cc1 -cc1 -triple x86_64-unknown-linux-gnu -analyze -disable-free -main-file-name cover.c -analyzer-store=region -analyzer-opt-analyze-nested-blocks -analyzer-checker=core -analyzer-checker=apiModeling -analyzer-checker=unix -analyzer-checker=deadcode -analyzer-checker=security.insecureAPI.UncheckedReturn -analyzer-checker=security.insecureAPI.getpw -analyzer-checker=security.insecureAPI.gets -analyzer-checker=security.insecureAPI.mktemp -analyzer-checker=security.insecureAPI.mkstemp -analyzer-checker=security.insecureAPI.vfork -analyzer-checker=nullability.NullPassedToNonnull -analyzer-checker=nullability.NullReturnedFromNonnull -analyzer-output plist -w -setup-static-analyzer -mrelocation-model static -mframe-pointer=none -fmath-errno -fno-rounding-math -mconstructor-aliases -munwind-tables -target-cpu x86-64 -fno-split-dwarf-inlining -debugger-tuning=gdb -resource-dir /llvm-project/build/lib/clang/12.0.0 -D XXH_NAMESPACE=ZSTD_ -D ZSTD_MULTITHREAD -D ZSTD_GZCOMPRESS -D ZSTD_GZDECOMPRESS -D ZSTD_LZMACOMPRESS -D ZSTD_LZMADECOMPRESS -D ZSTD_LZ4COMPRESS -D ZSTD_LZ4DECOMPRESS -D ZSTD_LEGACY_SUPPORT=5 -D BACKTRACE_ENABLE=0 -internal-isystem /usr/local/include -internal-isystem /llvm-project/build/lib/clang/12.0.0/include -internal-externc-isystem /usr/include/x86_64-linux-gnu -internal-externc-isystem /include -internal-externc-isystem /usr/include -O3 -fdebug-compilation-dir /tmp/sslab_clang/c_zstd/zstd/programs -ferror-limit 19 -fgnuc-version=4.2.1 -vectorize-loops -vectorize-slp -analyzer-checker core -analyzer-checker cplusplus -analyzer-checker nullability -analyzer-checker optin -analyzer-checker security -analyzer-checker unix -analyzer-checker osx -analyzer-checker fuchsia -analyzer-checker webkit -analyzer-output=html -faddrsig -o /tmp/scan-build-2020-11-24-150944-25196-1 -x c ../lib/dictBuilder/cover.c
</div>
<div id='tooltiphint' hidden="true">
  <p>Keyboard shortcuts: </p>
  <ul>
    <li>Use 'j/k' keys for keyboard navigation</li>
    <li>Use 'Shift+S' to show/hide relevant lines</li>
    <li>Use '?' to toggle this window</li>
  </ul>
  <a href="#" onclick="toggleHelp(); return false;">Close</a>
</div>
<script type='text/javascript'>
var relevant_lines = {"1": {"923": 1}};

var filterCounterexample = function (hide) {
  var tables = document.getElementsByClassName("code");
  for (var t=0; t<tables.length; t++) {
    var table = tables[t];
    var file_id = table.getAttribute("data-fileid");
    var lines_in_fid = relevant_lines[file_id];
    if (!lines_in_fid) {
      lines_in_fid = {};
    }
    var lines = table.getElementsByClassName("codeline");
    for (var i=0; i<lines.length; i++) {
        var el = lines[i];
        var lineNo = el.getAttribute("data-linenumber");
        if (!lines_in_fid[lineNo]) {
          if (hide) {
            el.setAttribute("hidden", "");
          } else {
            el.removeAttribute("hidden");
          }
        }
    }
  }
}

window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.key == "S") {
    var checked = document.getElementsByName("showCounterexample")[0].checked;
    filterCounterexample(!checked);
    document.getElementsByName("showCounterexample")[0].checked = !checked;
  } else {
    return;
  }
  event.preventDefault();
}, true);

document.addEventListener("DOMContentLoaded", function() {
    document.querySelector('input[name="showCounterexample"]').onchange=
        function (event) {
      filterCounterexample(this.checked);
    };
});
</script>

<form>
    <input type="checkbox" name="showCounterexample" id="showCounterexample" />
    <label for="showCounterexample">
       Show only relevant lines
    </label>
</form>

<script type='text/javascript'>
var digitMatcher = new RegExp("[0-9]+");

var querySelectorAllArray = function(selector) {
  return Array.prototype.slice.call(
    document.querySelectorAll(selector));
}

document.addEventListener("DOMContentLoaded", function() {
    querySelectorAllArray(".PathNav > a").forEach(
        function(currentValue, currentIndex) {
            var hrefValue = currentValue.getAttribute("href");
            currentValue.onclick = function() {
                scrollTo(document.querySelector(hrefValue));
                return false;
            };
        });
});

var findNum = function() {
    var s = document.querySelector(".selected");
    if (!s || s.id == "EndPath") {
        return 0;
    }
    var out = parseInt(digitMatcher.exec(s.id)[0]);
    return out;
};

var scrollTo = function(el) {
    querySelectorAllArray(".selected").forEach(function(s) {
        s.classList.remove("selected");
    });
    el.classList.add("selected");
    window.scrollBy(0, el.getBoundingClientRect().top -
        (window.innerHeight / 2));
}

var move = function(num, up, numItems) {
  if (num == 1 && up || num == numItems - 1 && !up) {
    return 0;
  } else if (num == 0 && up) {
    return numItems - 1;
  } else if (num == 0 && !up) {
    return 1 % numItems;
  }
  return up ? num - 1 : num + 1;
}

var numToId = function(num) {
  if (num == 0) {
    return document.getElementById("EndPath")
  }
  return document.getElementById("Path" + num);
};

var navigateTo = function(up) {
  var numItems = document.querySelectorAll(
      ".line > .msgEvent, .line > .msgControl").length;
  var currentSelected = findNum();
  var newSelected = move(currentSelected, up, numItems);
  var newEl = numToId(newSelected, numItems);

  // Scroll element into center.
  scrollTo(newEl);
};

window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.key == "j") {
    navigateTo(/*up=*/false);
  } else if (event.key == "k") {
    navigateTo(/*up=*/true);
  } else {
    return;
  }
  event.preventDefault();
}, true);
</script>
  
<script type='text/javascript'>

var toggleHelp = function() {
    var hint = document.querySelector("#tooltiphint");
    var attributeName = "hidden";
    if (hint.hasAttribute(attributeName)) {
      hint.removeAttribute(attributeName);
    } else {
      hint.setAttribute("hidden", "true");
    }
};
window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.key == "?") {
    toggleHelp();
  } else {
    return;
  }
  event.preventDefault();
});
</script>
<table class="code" data-fileid="1">
<tr class="codeline" data-linenumber="1"><td class="num" id="LN1">1</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="2"><td class="num" id="LN2">2</td><td class="line"> <span class='comment'>* Copyright (c) 2016-2020, Yann Collet, Facebook, Inc.</span></td></tr>
<tr class="codeline" data-linenumber="3"><td class="num" id="LN3">3</td><td class="line"> <span class='comment'>* All rights reserved.</span></td></tr>
<tr class="codeline" data-linenumber="4"><td class="num" id="LN4">4</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="5"><td class="num" id="LN5">5</td><td class="line"> <span class='comment'>* This source code is licensed under both the BSD-style license (found in the</span></td></tr>
<tr class="codeline" data-linenumber="6"><td class="num" id="LN6">6</td><td class="line"> <span class='comment'>* LICENSE file in the root directory of this source tree) and the GPLv2 (found</span></td></tr>
<tr class="codeline" data-linenumber="7"><td class="num" id="LN7">7</td><td class="line"> <span class='comment'>* in the COPYING file in the root directory of this source tree).</span></td></tr>
<tr class="codeline" data-linenumber="8"><td class="num" id="LN8">8</td><td class="line"> <span class='comment'>* You may select, at your option, one of the above-listed licenses.</span></td></tr>
<tr class="codeline" data-linenumber="9"><td class="num" id="LN9">9</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="10"><td class="num" id="LN10">10</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="11"><td class="num" id="LN11">11</td><td class="line"><span class='comment'>/* *****************************************************************************</span></td></tr>
<tr class="codeline" data-linenumber="12"><td class="num" id="LN12">12</td><td class="line"> <span class='comment'>* Constructs a dictionary using a heuristic based on the following paper:</span></td></tr>
<tr class="codeline" data-linenumber="13"><td class="num" id="LN13">13</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="14"><td class="num" id="LN14">14</td><td class="line"> <span class='comment'>* Liao, Petri, Moffat, Wirth</span></td></tr>
<tr class="codeline" data-linenumber="15"><td class="num" id="LN15">15</td><td class="line"> <span class='comment'>* Effective Construction of Relative Lempel-Ziv Dictionaries</span></td></tr>
<tr class="codeline" data-linenumber="16"><td class="num" id="LN16">16</td><td class="line"> <span class='comment'>* Published in WWW 2016.</span></td></tr>
<tr class="codeline" data-linenumber="17"><td class="num" id="LN17">17</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="18"><td class="num" id="LN18">18</td><td class="line"> <span class='comment'>* Adapted from code originally written by @ot (Giuseppe Ottaviano).</span></td></tr>
<tr class="codeline" data-linenumber="19"><td class="num" id="LN19">19</td><td class="line"> <span class='comment'>******************************************************************************/</span></td></tr>
<tr class="codeline" data-linenumber="20"><td class="num" id="LN20">20</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="21"><td class="num" id="LN21">21</td><td class="line"><span class='comment'>/*-*************************************</span></td></tr>
<tr class="codeline" data-linenumber="22"><td class="num" id="LN22">22</td><td class="line"><span class='comment'>*  Dependencies</span></td></tr>
<tr class="codeline" data-linenumber="23"><td class="num" id="LN23">23</td><td class="line"><span class='comment'>***************************************/</span></td></tr>
<tr class="codeline" data-linenumber="24"><td class="num" id="LN24">24</td><td class="line"><span class='directive'>#include &lt;stdio.h&gt;  /* fprintf */</span></td></tr>
<tr class="codeline" data-linenumber="25"><td class="num" id="LN25">25</td><td class="line"><span class='directive'>#include &lt;stdlib.h&gt; /* malloc, free, qsort */</span></td></tr>
<tr class="codeline" data-linenumber="26"><td class="num" id="LN26">26</td><td class="line"><span class='directive'>#include &lt;string.h&gt; /* memset */</span></td></tr>
<tr class="codeline" data-linenumber="27"><td class="num" id="LN27">27</td><td class="line"><span class='directive'>#include &lt;time.h&gt;   /* clock */</span></td></tr>
<tr class="codeline" data-linenumber="28"><td class="num" id="LN28">28</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="29"><td class="num" id="LN29">29</td><td class="line"><span class='directive'>#include "../common/mem.h" /* read */</span></td></tr>
<tr class="codeline" data-linenumber="30"><td class="num" id="LN30">30</td><td class="line"><span class='directive'>#include "../common/pool.h"</span></td></tr>
<tr class="codeline" data-linenumber="31"><td class="num" id="LN31">31</td><td class="line"><span class='directive'>#include "../common/threading.h"</span></td></tr>
<tr class="codeline" data-linenumber="32"><td class="num" id="LN32">32</td><td class="line"><span class='directive'>#include "cover.h"</span></td></tr>
<tr class="codeline" data-linenumber="33"><td class="num" id="LN33">33</td><td class="line"><span class='directive'>#include "../common/zstd_internal.h" /* includes zstd.h */</span></td></tr>
<tr class="codeline" data-linenumber="34"><td class="num" id="LN34">34</td><td class="line"><span class='directive'>#ifndef ZDICT_STATIC_LINKING_ONLY</span></td></tr>
<tr class="codeline" data-linenumber="35"><td class="num" id="LN35">35</td><td class="line"><span class='directive'>#define ZDICT_STATIC_LINKING_ONLY</span></td></tr>
<tr class="codeline" data-linenumber="36"><td class="num" id="LN36">36</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="37"><td class="num" id="LN37">37</td><td class="line"><span class='directive'>#include "zdict.h"</span></td></tr>
<tr class="codeline" data-linenumber="38"><td class="num" id="LN38">38</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="39"><td class="num" id="LN39">39</td><td class="line"><span class='comment'>/*-*************************************</span></td></tr>
<tr class="codeline" data-linenumber="40"><td class="num" id="LN40">40</td><td class="line"><span class='comment'>*  Constants</span></td></tr>
<tr class="codeline" data-linenumber="41"><td class="num" id="LN41">41</td><td class="line"><span class='comment'>***************************************/</span></td></tr>
<tr class="codeline" data-linenumber="42"><td class="num" id="LN42">42</td><td class="line"><span class='directive'>#define <span class='macro'>COVER_MAX_SAMPLES_SIZE<span class='macro_popup'>(sizeof(size_t) == 8 ? ((unsigned)-1) : ((unsigned)1 *(1U&lt;&lt;<br>30)))</span></span> (sizeof(size_t) == 8 ? ((unsigned)-1) : ((unsigned)1 <span class='macro'>GB<span class='macro_popup'>*(1U&lt;&lt;30)</span></span>))</span></td></tr>
<tr class="codeline" data-linenumber="43"><td class="num" id="LN43">43</td><td class="line"><span class='directive'>#define <span class='macro'>DEFAULT_SPLITPOINT<span class='macro_popup'>1.0</span></span> 1.0</span></td></tr>
<tr class="codeline" data-linenumber="44"><td class="num" id="LN44">44</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="45"><td class="num" id="LN45">45</td><td class="line"><span class='comment'>/*-*************************************</span></td></tr>
<tr class="codeline" data-linenumber="46"><td class="num" id="LN46">46</td><td class="line"><span class='comment'>*  Console display</span></td></tr>
<tr class="codeline" data-linenumber="47"><td class="num" id="LN47">47</td><td class="line"><span class='comment'>***************************************/</span></td></tr>
<tr class="codeline" data-linenumber="48"><td class="num" id="LN48">48</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> g_displayLevel = 2;</td></tr>
<tr class="codeline" data-linenumber="49"><td class="num" id="LN49">49</td><td class="line"><span class='directive'>#define <span class='macro'>DISPLAY(...)<span class='macro_popup'>{ fprintf(stderr, ...); fflush(stderr); }</span></span>                                                           \</span></td></tr>
<tr class="codeline" data-linenumber="50"><td class="num" id="LN50">50</td><td class="line">  <span class='directive'>{                                                                            \</span></td></tr>
<tr class="codeline" data-linenumber="51"><td class="num" id="LN51">51</td><td class="line">    <span class='directive'>fprintf(<span class='macro'>stderr<span class='macro_popup'>stderr</span></span>, __VA_ARGS__);                                              \</span></td></tr>
<tr class="codeline" data-linenumber="52"><td class="num" id="LN52">52</td><td class="line">    <span class='directive'>fflush(<span class='macro'>stderr<span class='macro_popup'>stderr</span></span>);                                                            \</span></td></tr>
<tr class="codeline" data-linenumber="53"><td class="num" id="LN53">53</td><td class="line">  <span class='directive'>}</span></td></tr>
<tr class="codeline" data-linenumber="54"><td class="num" id="LN54">54</td><td class="line"><span class='directive'>#define <span class='macro'>LOCALDISPLAYLEVEL(displayLevel, l, ...)<span class='macro_popup'>if (displayLevel &gt;= l) { { fprintf(stderr, ...); fflush(stderr<br>); }; }</span></span>                                \</span></td></tr>
<tr class="codeline" data-linenumber="55"><td class="num" id="LN55">55</td><td class="line">  <span class='directive'>if (displayLevel &gt;= l) {                                                     \</span></td></tr>
<tr class="codeline" data-linenumber="56"><td class="num" id="LN56">56</td><td class="line">    <span class='directive'><span class='macro'>DISPLAY(__VA_ARGS__)<span class='macro_popup'>{ fprintf(stderr, __VA_ARGS__); fflush(stderr); }</span></span>;                                                      \</span></td></tr>
<tr class="codeline" data-linenumber="57"><td class="num" id="LN57">57</td><td class="line">  <span class='directive'>} /* 0 : no display;   1: errors;   2: default;  3: details;  4: debug */</span></td></tr>
<tr class="codeline" data-linenumber="58"><td class="num" id="LN58">58</td><td class="line"><span class='directive'>#define <span class='macro'>DISPLAYLEVEL(l, ...)<span class='macro_popup'>if (g_displayLevel &gt;= l) { { fprintf(stderr, ...); fflush(<br>stderr); }; }</span></span> <span class='macro'>LOCALDISPLAYLEVEL(g_displayLevel, l, __VA_ARGS__)<span class='macro_popup'>if (g_displayLevel &gt;= l) { { fprintf(stderr, __VA_ARGS__);<br> fflush(stderr); }; }</span></span></span></td></tr>
<tr class="codeline" data-linenumber="59"><td class="num" id="LN59">59</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="60"><td class="num" id="LN60">60</td><td class="line"><span class='directive'>#define <span class='macro'>LOCALDISPLAYUPDATE(displayLevel, l, ...)<span class='macro_popup'>if (displayLevel &gt;= l) { if ((clock() - g_time &gt; refreshRate<br>) || (displayLevel &gt;= 4)) { g_time = clock(); { fprintf(stderr<br>, ...); fflush(stderr); }; } }</span></span>                               \</span></td></tr>
<tr class="codeline" data-linenumber="61"><td class="num" id="LN61">61</td><td class="line">  <span class='directive'>if (displayLevel &gt;= l) {                                                     \</span></td></tr>
<tr class="codeline" data-linenumber="62"><td class="num" id="LN62">62</td><td class="line">    <span class='directive'>if ((clock() - g_time &gt; refreshRate) || (displayLevel &gt;= 4)) {             \</span></td></tr>
<tr class="codeline" data-linenumber="63"><td class="num" id="LN63">63</td><td class="line">      <span class='directive'>g_time = clock();                                                        \</span></td></tr>
<tr class="codeline" data-linenumber="64"><td class="num" id="LN64">64</td><td class="line">      <span class='directive'><span class='macro'>DISPLAY(__VA_ARGS__)<span class='macro_popup'>{ fprintf(stderr, __VA_ARGS__); fflush(stderr); }</span></span>;                                                    \</span></td></tr>
<tr class="codeline" data-linenumber="65"><td class="num" id="LN65">65</td><td class="line">    <span class='directive'>}                                                                          \</span></td></tr>
<tr class="codeline" data-linenumber="66"><td class="num" id="LN66">66</td><td class="line">  <span class='directive'>}</span></td></tr>
<tr class="codeline" data-linenumber="67"><td class="num" id="LN67">67</td><td class="line"><span class='directive'>#define <span class='macro'>DISPLAYUPDATE(l, ...)<span class='macro_popup'>if (g_displayLevel &gt;= l) { if ((clock() - g_time &gt; refreshRate<br>) || (g_displayLevel &gt;= 4)) { g_time = clock(); { fprintf(<br>stderr, ...); fflush(stderr); }; } }</span></span> <span class='macro'>LOCALDISPLAYUPDATE(g_displayLevel, l, __VA_ARGS__)<span class='macro_popup'>if (g_displayLevel &gt;= l) { if ((clock() - g_time &gt; refreshRate<br>) || (g_displayLevel &gt;= 4)) { g_time = clock(); { fprintf(<br>stderr, __VA_ARGS__); fflush(stderr); }; } }</span></span></span></td></tr>
<tr class="codeline" data-linenumber="68"><td class="num" id="LN68">68</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>const</span> clock_t refreshRate = <span class='macro'>CLOCKS_PER_SEC<span class='macro_popup'>((__clock_t) 1000000)</span></span> * 15 / 100;</td></tr>
<tr class="codeline" data-linenumber="69"><td class="num" id="LN69">69</td><td class="line"><span class='keyword'>static</span> clock_t g_time = 0;</td></tr>
<tr class="codeline" data-linenumber="70"><td class="num" id="LN70">70</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="71"><td class="num" id="LN71">71</td><td class="line"><span class='comment'>/*-*************************************</span></td></tr>
<tr class="codeline" data-linenumber="72"><td class="num" id="LN72">72</td><td class="line"><span class='comment'>* Hash table</span></td></tr>
<tr class="codeline" data-linenumber="73"><td class="num" id="LN73">73</td><td class="line"><span class='comment'>***************************************</span></td></tr>
<tr class="codeline" data-linenumber="74"><td class="num" id="LN74">74</td><td class="line"><span class='comment'>* A small specialized hash map for storing activeDmers.</span></td></tr>
<tr class="codeline" data-linenumber="75"><td class="num" id="LN75">75</td><td class="line"><span class='comment'>* The map does not resize, so if it becomes full it will loop forever.</span></td></tr>
<tr class="codeline" data-linenumber="76"><td class="num" id="LN76">76</td><td class="line"><span class='comment'>* Thus, the map must be large enough to store every value.</span></td></tr>
<tr class="codeline" data-linenumber="77"><td class="num" id="LN77">77</td><td class="line"><span class='comment'>* The map implements linear probing and keeps its load less than 0.5.</span></td></tr>
<tr class="codeline" data-linenumber="78"><td class="num" id="LN78">78</td><td class="line"><span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="79"><td class="num" id="LN79">79</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="80"><td class="num" id="LN80">80</td><td class="line"><span class='directive'>#define <span class='macro'>MAP_EMPTY_VALUE<span class='macro_popup'>((U32)-1)</span></span> ((U32)-1)</span></td></tr>
<tr class="codeline" data-linenumber="81"><td class="num" id="LN81">81</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> COVER_map_pair_t_s {</td></tr>
<tr class="codeline" data-linenumber="82"><td class="num" id="LN82">82</td><td class="line">  U32 key;</td></tr>
<tr class="codeline" data-linenumber="83"><td class="num" id="LN83">83</td><td class="line">  U32 value;</td></tr>
<tr class="codeline" data-linenumber="84"><td class="num" id="LN84">84</td><td class="line">} COVER_map_pair_t;</td></tr>
<tr class="codeline" data-linenumber="85"><td class="num" id="LN85">85</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="86"><td class="num" id="LN86">86</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> COVER_map_s {</td></tr>
<tr class="codeline" data-linenumber="87"><td class="num" id="LN87">87</td><td class="line">  COVER_map_pair_t *data;</td></tr>
<tr class="codeline" data-linenumber="88"><td class="num" id="LN88">88</td><td class="line">  U32 sizeLog;</td></tr>
<tr class="codeline" data-linenumber="89"><td class="num" id="LN89">89</td><td class="line">  U32 size;</td></tr>
<tr class="codeline" data-linenumber="90"><td class="num" id="LN90">90</td><td class="line">  U32 sizeMask;</td></tr>
<tr class="codeline" data-linenumber="91"><td class="num" id="LN91">91</td><td class="line">} COVER_map_t;</td></tr>
<tr class="codeline" data-linenumber="92"><td class="num" id="LN92">92</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="93"><td class="num" id="LN93">93</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="94"><td class="num" id="LN94">94</td><td class="line"> <span class='comment'>* Clear the map.</span></td></tr>
<tr class="codeline" data-linenumber="95"><td class="num" id="LN95">95</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="96"><td class="num" id="LN96">96</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> COVER_map_clear(COVER_map_t *map) {</td></tr>
<tr class="codeline" data-linenumber="97"><td class="num" id="LN97">97</td><td class="line">  memset(map-&gt;data, <span class='macro'>MAP_EMPTY_VALUE<span class='macro_popup'>((U32)-1)</span></span>, map-&gt;size * <span class='keyword'>sizeof</span>(COVER_map_pair_t));</td></tr>
<tr class="codeline" data-linenumber="98"><td class="num" id="LN98">98</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="99"><td class="num" id="LN99">99</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="100"><td class="num" id="LN100">100</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="101"><td class="num" id="LN101">101</td><td class="line"> <span class='comment'>* Initializes a map of the given size.</span></td></tr>
<tr class="codeline" data-linenumber="102"><td class="num" id="LN102">102</td><td class="line"> <span class='comment'>* Returns 1 on success and 0 on failure.</span></td></tr>
<tr class="codeline" data-linenumber="103"><td class="num" id="LN103">103</td><td class="line"> <span class='comment'>* The map must be destroyed with COVER_map_destroy().</span></td></tr>
<tr class="codeline" data-linenumber="104"><td class="num" id="LN104">104</td><td class="line"> <span class='comment'>* The map is only guaranteed to be large enough to hold size elements.</span></td></tr>
<tr class="codeline" data-linenumber="105"><td class="num" id="LN105">105</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="106"><td class="num" id="LN106">106</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> COVER_map_init(COVER_map_t *map, U32 size) {</td></tr>
<tr class="codeline" data-linenumber="107"><td class="num" id="LN107">107</td><td class="line">  map-&gt;sizeLog = ZSTD_highbit32(size) + 2;</td></tr>
<tr class="codeline" data-linenumber="108"><td class="num" id="LN108">108</td><td class="line">  map-&gt;size = (U32)1 &lt;&lt; map-&gt;sizeLog;</td></tr>
<tr class="codeline" data-linenumber="109"><td class="num" id="LN109">109</td><td class="line">  map-&gt;sizeMask = map-&gt;size - 1;</td></tr>
<tr class="codeline" data-linenumber="110"><td class="num" id="LN110">110</td><td class="line">  map-&gt;data = (COVER_map_pair_t *)malloc(map-&gt;size * <span class='keyword'>sizeof</span>(COVER_map_pair_t));</td></tr>
<tr class="codeline" data-linenumber="111"><td class="num" id="LN111">111</td><td class="line">  <span class='keyword'>if</span> (!map-&gt;data) {</td></tr>
<tr class="codeline" data-linenumber="112"><td class="num" id="LN112">112</td><td class="line">    map-&gt;sizeLog = 0;</td></tr>
<tr class="codeline" data-linenumber="113"><td class="num" id="LN113">113</td><td class="line">    map-&gt;size = 0;</td></tr>
<tr class="codeline" data-linenumber="114"><td class="num" id="LN114">114</td><td class="line">    <span class='keyword'>return</span> 0;</td></tr>
<tr class="codeline" data-linenumber="115"><td class="num" id="LN115">115</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="116"><td class="num" id="LN116">116</td><td class="line">  COVER_map_clear(map);</td></tr>
<tr class="codeline" data-linenumber="117"><td class="num" id="LN117">117</td><td class="line">  <span class='keyword'>return</span> 1;</td></tr>
<tr class="codeline" data-linenumber="118"><td class="num" id="LN118">118</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="119"><td class="num" id="LN119">119</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="120"><td class="num" id="LN120">120</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="121"><td class="num" id="LN121">121</td><td class="line"> <span class='comment'>* Internal hash function</span></td></tr>
<tr class="codeline" data-linenumber="122"><td class="num" id="LN122">122</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="123"><td class="num" id="LN123">123</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>const</span> U32 prime4bytes = 2654435761U;</td></tr>
<tr class="codeline" data-linenumber="124"><td class="num" id="LN124">124</td><td class="line"><span class='keyword'>static</span> U32 COVER_map_hash(COVER_map_t *map, U32 key) {</td></tr>
<tr class="codeline" data-linenumber="125"><td class="num" id="LN125">125</td><td class="line">  <span class='keyword'>return</span> (key * prime4bytes) &gt;&gt; (32 - map-&gt;sizeLog);</td></tr>
<tr class="codeline" data-linenumber="126"><td class="num" id="LN126">126</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="127"><td class="num" id="LN127">127</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="128"><td class="num" id="LN128">128</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="129"><td class="num" id="LN129">129</td><td class="line"> <span class='comment'>* Helper function that returns the index that a key should be placed into.</span></td></tr>
<tr class="codeline" data-linenumber="130"><td class="num" id="LN130">130</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="131"><td class="num" id="LN131">131</td><td class="line"><span class='keyword'>static</span> U32 COVER_map_index(COVER_map_t *map, U32 key) {</td></tr>
<tr class="codeline" data-linenumber="132"><td class="num" id="LN132">132</td><td class="line">  <span class='keyword'>const</span> U32 hash = COVER_map_hash(map, key);</td></tr>
<tr class="codeline" data-linenumber="133"><td class="num" id="LN133">133</td><td class="line">  U32 i;</td></tr>
<tr class="codeline" data-linenumber="134"><td class="num" id="LN134">134</td><td class="line">  <span class='keyword'>for</span> (i = hash;; i = (i + 1) &amp; map-&gt;sizeMask) {</td></tr>
<tr class="codeline" data-linenumber="135"><td class="num" id="LN135">135</td><td class="line">    COVER_map_pair_t *pos = &amp;map-&gt;data[i];</td></tr>
<tr class="codeline" data-linenumber="136"><td class="num" id="LN136">136</td><td class="line">    <span class='keyword'>if</span> (pos-&gt;value == <span class='macro'>MAP_EMPTY_VALUE<span class='macro_popup'>((U32)-1)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="137"><td class="num" id="LN137">137</td><td class="line">      <span class='keyword'>return</span> i;</td></tr>
<tr class="codeline" data-linenumber="138"><td class="num" id="LN138">138</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="139"><td class="num" id="LN139">139</td><td class="line">    <span class='keyword'>if</span> (pos-&gt;key == key) {</td></tr>
<tr class="codeline" data-linenumber="140"><td class="num" id="LN140">140</td><td class="line">      <span class='keyword'>return</span> i;</td></tr>
<tr class="codeline" data-linenumber="141"><td class="num" id="LN141">141</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="142"><td class="num" id="LN142">142</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="143"><td class="num" id="LN143">143</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="144"><td class="num" id="LN144">144</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="145"><td class="num" id="LN145">145</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="146"><td class="num" id="LN146">146</td><td class="line"> <span class='comment'>* Returns the pointer to the value for key.</span></td></tr>
<tr class="codeline" data-linenumber="147"><td class="num" id="LN147">147</td><td class="line"> <span class='comment'>* If key is not in the map, it is inserted and the value is set to 0.</span></td></tr>
<tr class="codeline" data-linenumber="148"><td class="num" id="LN148">148</td><td class="line"> <span class='comment'>* The map must not be full.</span></td></tr>
<tr class="codeline" data-linenumber="149"><td class="num" id="LN149">149</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="150"><td class="num" id="LN150">150</td><td class="line"><span class='keyword'>static</span> U32 *COVER_map_at(COVER_map_t *map, U32 key) {</td></tr>
<tr class="codeline" data-linenumber="151"><td class="num" id="LN151">151</td><td class="line">  COVER_map_pair_t *pos = &amp;map-&gt;data[COVER_map_index(map, key)];</td></tr>
<tr class="codeline" data-linenumber="152"><td class="num" id="LN152">152</td><td class="line">  <span class='keyword'>if</span> (pos-&gt;value == <span class='macro'>MAP_EMPTY_VALUE<span class='macro_popup'>((U32)-1)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="153"><td class="num" id="LN153">153</td><td class="line">    pos-&gt;key = key;</td></tr>
<tr class="codeline" data-linenumber="154"><td class="num" id="LN154">154</td><td class="line">    pos-&gt;value = 0;</td></tr>
<tr class="codeline" data-linenumber="155"><td class="num" id="LN155">155</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="156"><td class="num" id="LN156">156</td><td class="line">  <span class='keyword'>return</span> &amp;pos-&gt;value;</td></tr>
<tr class="codeline" data-linenumber="157"><td class="num" id="LN157">157</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="158"><td class="num" id="LN158">158</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="159"><td class="num" id="LN159">159</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="160"><td class="num" id="LN160">160</td><td class="line"> <span class='comment'>* Deletes key from the map if present.</span></td></tr>
<tr class="codeline" data-linenumber="161"><td class="num" id="LN161">161</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="162"><td class="num" id="LN162">162</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> COVER_map_remove(COVER_map_t *map, U32 key) {</td></tr>
<tr class="codeline" data-linenumber="163"><td class="num" id="LN163">163</td><td class="line">  U32 i = COVER_map_index(map, key);</td></tr>
<tr class="codeline" data-linenumber="164"><td class="num" id="LN164">164</td><td class="line">  COVER_map_pair_t *del = &amp;map-&gt;data[i];</td></tr>
<tr class="codeline" data-linenumber="165"><td class="num" id="LN165">165</td><td class="line">  U32 shift = 1;</td></tr>
<tr class="codeline" data-linenumber="166"><td class="num" id="LN166">166</td><td class="line">  <span class='keyword'>if</span> (del-&gt;value == <span class='macro'>MAP_EMPTY_VALUE<span class='macro_popup'>((U32)-1)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="167"><td class="num" id="LN167">167</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="168"><td class="num" id="LN168">168</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="169"><td class="num" id="LN169">169</td><td class="line">  <span class='keyword'>for</span> (i = (i + 1) &amp; map-&gt;sizeMask;; i = (i + 1) &amp; map-&gt;sizeMask) {</td></tr>
<tr class="codeline" data-linenumber="170"><td class="num" id="LN170">170</td><td class="line">    COVER_map_pair_t *<span class='keyword'>const</span> pos = &amp;map-&gt;data[i];</td></tr>
<tr class="codeline" data-linenumber="171"><td class="num" id="LN171">171</td><td class="line">    <span class='comment'>/* If the position is empty we are done */</span></td></tr>
<tr class="codeline" data-linenumber="172"><td class="num" id="LN172">172</td><td class="line">    <span class='keyword'>if</span> (pos-&gt;value == <span class='macro'>MAP_EMPTY_VALUE<span class='macro_popup'>((U32)-1)</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="173"><td class="num" id="LN173">173</td><td class="line">      del-&gt;value = <span class='macro'>MAP_EMPTY_VALUE<span class='macro_popup'>((U32)-1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="174"><td class="num" id="LN174">174</td><td class="line">      <span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="175"><td class="num" id="LN175">175</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="176"><td class="num" id="LN176">176</td><td class="line">    <span class='comment'>/* If pos can be moved to del do so */</span></td></tr>
<tr class="codeline" data-linenumber="177"><td class="num" id="LN177">177</td><td class="line">    <span class='keyword'>if</span> (((i - COVER_map_hash(map, pos-&gt;key)) &amp; map-&gt;sizeMask) &gt;= shift) {</td></tr>
<tr class="codeline" data-linenumber="178"><td class="num" id="LN178">178</td><td class="line">      del-&gt;key = pos-&gt;key;</td></tr>
<tr class="codeline" data-linenumber="179"><td class="num" id="LN179">179</td><td class="line">      del-&gt;value = pos-&gt;value;</td></tr>
<tr class="codeline" data-linenumber="180"><td class="num" id="LN180">180</td><td class="line">      del = pos;</td></tr>
<tr class="codeline" data-linenumber="181"><td class="num" id="LN181">181</td><td class="line">      shift = 1;</td></tr>
<tr class="codeline" data-linenumber="182"><td class="num" id="LN182">182</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="183"><td class="num" id="LN183">183</td><td class="line">      ++shift;</td></tr>
<tr class="codeline" data-linenumber="184"><td class="num" id="LN184">184</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="185"><td class="num" id="LN185">185</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="186"><td class="num" id="LN186">186</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="187"><td class="num" id="LN187">187</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="188"><td class="num" id="LN188">188</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="189"><td class="num" id="LN189">189</td><td class="line"> <span class='comment'>* Destroys a map that is inited with COVER_map_init().</span></td></tr>
<tr class="codeline" data-linenumber="190"><td class="num" id="LN190">190</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="191"><td class="num" id="LN191">191</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> COVER_map_destroy(COVER_map_t *map) {</td></tr>
<tr class="codeline" data-linenumber="192"><td class="num" id="LN192">192</td><td class="line">  <span class='keyword'>if</span> (map-&gt;data) {</td></tr>
<tr class="codeline" data-linenumber="193"><td class="num" id="LN193">193</td><td class="line">    free(map-&gt;data);</td></tr>
<tr class="codeline" data-linenumber="194"><td class="num" id="LN194">194</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="195"><td class="num" id="LN195">195</td><td class="line">  map-&gt;data = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="196"><td class="num" id="LN196">196</td><td class="line">  map-&gt;size = 0;</td></tr>
<tr class="codeline" data-linenumber="197"><td class="num" id="LN197">197</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="198"><td class="num" id="LN198">198</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="199"><td class="num" id="LN199">199</td><td class="line"><span class='comment'>/*-*************************************</span></td></tr>
<tr class="codeline" data-linenumber="200"><td class="num" id="LN200">200</td><td class="line"><span class='comment'>* Context</span></td></tr>
<tr class="codeline" data-linenumber="201"><td class="num" id="LN201">201</td><td class="line"><span class='comment'>***************************************/</span></td></tr>
<tr class="codeline" data-linenumber="202"><td class="num" id="LN202">202</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="203"><td class="num" id="LN203">203</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> {</td></tr>
<tr class="codeline" data-linenumber="204"><td class="num" id="LN204">204</td><td class="line">  <span class='keyword'>const</span> BYTE *samples;</td></tr>
<tr class="codeline" data-linenumber="205"><td class="num" id="LN205">205</td><td class="line">  size_t *offsets;</td></tr>
<tr class="codeline" data-linenumber="206"><td class="num" id="LN206">206</td><td class="line">  <span class='keyword'>const</span> size_t *samplesSizes;</td></tr>
<tr class="codeline" data-linenumber="207"><td class="num" id="LN207">207</td><td class="line">  size_t nbSamples;</td></tr>
<tr class="codeline" data-linenumber="208"><td class="num" id="LN208">208</td><td class="line">  size_t nbTrainSamples;</td></tr>
<tr class="codeline" data-linenumber="209"><td class="num" id="LN209">209</td><td class="line">  size_t nbTestSamples;</td></tr>
<tr class="codeline" data-linenumber="210"><td class="num" id="LN210">210</td><td class="line">  U32 *suffix;</td></tr>
<tr class="codeline" data-linenumber="211"><td class="num" id="LN211">211</td><td class="line">  size_t suffixSize;</td></tr>
<tr class="codeline" data-linenumber="212"><td class="num" id="LN212">212</td><td class="line">  U32 *freqs;</td></tr>
<tr class="codeline" data-linenumber="213"><td class="num" id="LN213">213</td><td class="line">  U32 *dmerAt;</td></tr>
<tr class="codeline" data-linenumber="214"><td class="num" id="LN214">214</td><td class="line">  <span class='keyword'>unsigned</span> d;</td></tr>
<tr class="codeline" data-linenumber="215"><td class="num" id="LN215">215</td><td class="line">} COVER_ctx_t;</td></tr>
<tr class="codeline" data-linenumber="216"><td class="num" id="LN216">216</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="217"><td class="num" id="LN217">217</td><td class="line"><span class='comment'>/* We need a global context for qsort... */</span></td></tr>
<tr class="codeline" data-linenumber="218"><td class="num" id="LN218">218</td><td class="line"><span class='keyword'>static</span> COVER_ctx_t *g_ctx = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="219"><td class="num" id="LN219">219</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="220"><td class="num" id="LN220">220</td><td class="line"><span class='comment'>/*-*************************************</span></td></tr>
<tr class="codeline" data-linenumber="221"><td class="num" id="LN221">221</td><td class="line"><span class='comment'>*  Helper functions</span></td></tr>
<tr class="codeline" data-linenumber="222"><td class="num" id="LN222">222</td><td class="line"><span class='comment'>***************************************/</span></td></tr>
<tr class="codeline" data-linenumber="223"><td class="num" id="LN223">223</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="224"><td class="num" id="LN224">224</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="225"><td class="num" id="LN225">225</td><td class="line"> <span class='comment'>* Returns the sum of the sample sizes.</span></td></tr>
<tr class="codeline" data-linenumber="226"><td class="num" id="LN226">226</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="227"><td class="num" id="LN227">227</td><td class="line">size_t COVER_sum(<span class='keyword'>const</span> size_t *samplesSizes, <span class='keyword'>unsigned</span> nbSamples) {</td></tr>
<tr class="codeline" data-linenumber="228"><td class="num" id="LN228">228</td><td class="line">  size_t sum = 0;</td></tr>
<tr class="codeline" data-linenumber="229"><td class="num" id="LN229">229</td><td class="line">  <span class='keyword'>unsigned</span> i;</td></tr>
<tr class="codeline" data-linenumber="230"><td class="num" id="LN230">230</td><td class="line">  <span class='keyword'>for</span> (i = 0; i &lt; nbSamples; ++i) {</td></tr>
<tr class="codeline" data-linenumber="231"><td class="num" id="LN231">231</td><td class="line">    sum += samplesSizes[i];</td></tr>
<tr class="codeline" data-linenumber="232"><td class="num" id="LN232">232</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="233"><td class="num" id="LN233">233</td><td class="line">  <span class='keyword'>return</span> sum;</td></tr>
<tr class="codeline" data-linenumber="234"><td class="num" id="LN234">234</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="235"><td class="num" id="LN235">235</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="236"><td class="num" id="LN236">236</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="237"><td class="num" id="LN237">237</td><td class="line"> <span class='comment'>* Returns -1 if the dmer at lp is less than the dmer at rp.</span></td></tr>
<tr class="codeline" data-linenumber="238"><td class="num" id="LN238">238</td><td class="line"> <span class='comment'>* Return 0 if the dmers at lp and rp are equal.</span></td></tr>
<tr class="codeline" data-linenumber="239"><td class="num" id="LN239">239</td><td class="line"> <span class='comment'>* Returns 1 if the dmer at lp is greater than the dmer at rp.</span></td></tr>
<tr class="codeline" data-linenumber="240"><td class="num" id="LN240">240</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="241"><td class="num" id="LN241">241</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> COVER_cmp(COVER_ctx_t *ctx, <span class='keyword'>const</span> <span class='keyword'>void</span> *lp, <span class='keyword'>const</span> <span class='keyword'>void</span> *rp) {</td></tr>
<tr class="codeline" data-linenumber="242"><td class="num" id="LN242">242</td><td class="line">  U32 <span class='keyword'>const</span> lhs = *(U32 <span class='keyword'>const</span> *)lp;</td></tr>
<tr class="codeline" data-linenumber="243"><td class="num" id="LN243">243</td><td class="line">  U32 <span class='keyword'>const</span> rhs = *(U32 <span class='keyword'>const</span> *)rp;</td></tr>
<tr class="codeline" data-linenumber="244"><td class="num" id="LN244">244</td><td class="line">  <span class='keyword'>return</span> memcmp(ctx-&gt;samples + lhs, ctx-&gt;samples + rhs, ctx-&gt;d);</td></tr>
<tr class="codeline" data-linenumber="245"><td class="num" id="LN245">245</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="246"><td class="num" id="LN246">246</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="247"><td class="num" id="LN247">247</td><td class="line"> <span class='comment'>* Faster version for d &lt;= 8.</span></td></tr>
<tr class="codeline" data-linenumber="248"><td class="num" id="LN248">248</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="249"><td class="num" id="LN249">249</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> COVER_cmp8(COVER_ctx_t *ctx, <span class='keyword'>const</span> <span class='keyword'>void</span> *lp, <span class='keyword'>const</span> <span class='keyword'>void</span> *rp) {</td></tr>
<tr class="codeline" data-linenumber="250"><td class="num" id="LN250">250</td><td class="line">  U64 <span class='keyword'>const</span> mask = (ctx-&gt;d == 8) ? (U64)-1 : (((U64)1 &lt;&lt; (8 * ctx-&gt;d)) - 1);</td></tr>
<tr class="codeline" data-linenumber="251"><td class="num" id="LN251">251</td><td class="line">  U64 <span class='keyword'>const</span> lhs = MEM_readLE64(ctx-&gt;samples + *(U32 <span class='keyword'>const</span> *)lp) &amp; mask;</td></tr>
<tr class="codeline" data-linenumber="252"><td class="num" id="LN252">252</td><td class="line">  U64 <span class='keyword'>const</span> rhs = MEM_readLE64(ctx-&gt;samples + *(U32 <span class='keyword'>const</span> *)rp) &amp; mask;</td></tr>
<tr class="codeline" data-linenumber="253"><td class="num" id="LN253">253</td><td class="line">  <span class='keyword'>if</span> (lhs &lt; rhs) {</td></tr>
<tr class="codeline" data-linenumber="254"><td class="num" id="LN254">254</td><td class="line">    <span class='keyword'>return</span> -1;</td></tr>
<tr class="codeline" data-linenumber="255"><td class="num" id="LN255">255</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="256"><td class="num" id="LN256">256</td><td class="line">  <span class='keyword'>return</span> (lhs &gt; rhs);</td></tr>
<tr class="codeline" data-linenumber="257"><td class="num" id="LN257">257</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="258"><td class="num" id="LN258">258</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="259"><td class="num" id="LN259">259</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="260"><td class="num" id="LN260">260</td><td class="line"> <span class='comment'>* Same as COVER_cmp() except ties are broken by pointer value</span></td></tr>
<tr class="codeline" data-linenumber="261"><td class="num" id="LN261">261</td><td class="line"> <span class='comment'>* NOTE: g_ctx must be set to call this function.  A global is required because</span></td></tr>
<tr class="codeline" data-linenumber="262"><td class="num" id="LN262">262</td><td class="line"> <span class='comment'>* qsort doesn't take an opaque pointer.</span></td></tr>
<tr class="codeline" data-linenumber="263"><td class="num" id="LN263">263</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="264"><td class="num" id="LN264">264</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> COVER_strict_cmp(<span class='keyword'>const</span> <span class='keyword'>void</span> *lp, <span class='keyword'>const</span> <span class='keyword'>void</span> *rp) {</td></tr>
<tr class="codeline" data-linenumber="265"><td class="num" id="LN265">265</td><td class="line">  <span class='keyword'>int</span> result = COVER_cmp(g_ctx, lp, rp);</td></tr>
<tr class="codeline" data-linenumber="266"><td class="num" id="LN266">266</td><td class="line">  <span class='keyword'>if</span> (result == 0) {</td></tr>
<tr class="codeline" data-linenumber="267"><td class="num" id="LN267">267</td><td class="line">    result = lp &lt; rp ? -1 : 1;</td></tr>
<tr class="codeline" data-linenumber="268"><td class="num" id="LN268">268</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="269"><td class="num" id="LN269">269</td><td class="line">  <span class='keyword'>return</span> result;</td></tr>
<tr class="codeline" data-linenumber="270"><td class="num" id="LN270">270</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="271"><td class="num" id="LN271">271</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="272"><td class="num" id="LN272">272</td><td class="line"> <span class='comment'>* Faster version for d &lt;= 8.</span></td></tr>
<tr class="codeline" data-linenumber="273"><td class="num" id="LN273">273</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="274"><td class="num" id="LN274">274</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> COVER_strict_cmp8(<span class='keyword'>const</span> <span class='keyword'>void</span> *lp, <span class='keyword'>const</span> <span class='keyword'>void</span> *rp) {</td></tr>
<tr class="codeline" data-linenumber="275"><td class="num" id="LN275">275</td><td class="line">  <span class='keyword'>int</span> result = COVER_cmp8(g_ctx, lp, rp);</td></tr>
<tr class="codeline" data-linenumber="276"><td class="num" id="LN276">276</td><td class="line">  <span class='keyword'>if</span> (result == 0) {</td></tr>
<tr class="codeline" data-linenumber="277"><td class="num" id="LN277">277</td><td class="line">    result = lp &lt; rp ? -1 : 1;</td></tr>
<tr class="codeline" data-linenumber="278"><td class="num" id="LN278">278</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="279"><td class="num" id="LN279">279</td><td class="line">  <span class='keyword'>return</span> result;</td></tr>
<tr class="codeline" data-linenumber="280"><td class="num" id="LN280">280</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="281"><td class="num" id="LN281">281</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="282"><td class="num" id="LN282">282</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="283"><td class="num" id="LN283">283</td><td class="line"> <span class='comment'>* Returns the first pointer in [first, last) whose element does not compare</span></td></tr>
<tr class="codeline" data-linenumber="284"><td class="num" id="LN284">284</td><td class="line"> <span class='comment'>* less than value.  If no such element exists it returns last.</span></td></tr>
<tr class="codeline" data-linenumber="285"><td class="num" id="LN285">285</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="286"><td class="num" id="LN286">286</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>const</span> size_t *COVER_lower_bound(<span class='keyword'>const</span> size_t *first, <span class='keyword'>const</span> size_t *last,</td></tr>
<tr class="codeline" data-linenumber="287"><td class="num" id="LN287">287</td><td class="line">                                       size_t value) {</td></tr>
<tr class="codeline" data-linenumber="288"><td class="num" id="LN288">288</td><td class="line">  size_t count = last - first;</td></tr>
<tr class="codeline" data-linenumber="289"><td class="num" id="LN289">289</td><td class="line">  <span class='keyword'>while</span> (count != 0) {</td></tr>
<tr class="codeline" data-linenumber="290"><td class="num" id="LN290">290</td><td class="line">    size_t step = count / 2;</td></tr>
<tr class="codeline" data-linenumber="291"><td class="num" id="LN291">291</td><td class="line">    <span class='keyword'>const</span> size_t *ptr = first;</td></tr>
<tr class="codeline" data-linenumber="292"><td class="num" id="LN292">292</td><td class="line">    ptr += step;</td></tr>
<tr class="codeline" data-linenumber="293"><td class="num" id="LN293">293</td><td class="line">    <span class='keyword'>if</span> (*ptr &lt; value) {</td></tr>
<tr class="codeline" data-linenumber="294"><td class="num" id="LN294">294</td><td class="line">      first = ++ptr;</td></tr>
<tr class="codeline" data-linenumber="295"><td class="num" id="LN295">295</td><td class="line">      count -= step + 1;</td></tr>
<tr class="codeline" data-linenumber="296"><td class="num" id="LN296">296</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="297"><td class="num" id="LN297">297</td><td class="line">      count = step;</td></tr>
<tr class="codeline" data-linenumber="298"><td class="num" id="LN298">298</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="299"><td class="num" id="LN299">299</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="300"><td class="num" id="LN300">300</td><td class="line">  <span class='keyword'>return</span> first;</td></tr>
<tr class="codeline" data-linenumber="301"><td class="num" id="LN301">301</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="302"><td class="num" id="LN302">302</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="303"><td class="num" id="LN303">303</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="304"><td class="num" id="LN304">304</td><td class="line"> <span class='comment'>* Generic groupBy function.</span></td></tr>
<tr class="codeline" data-linenumber="305"><td class="num" id="LN305">305</td><td class="line"> <span class='comment'>* Groups an array sorted by cmp into groups with equivalent values.</span></td></tr>
<tr class="codeline" data-linenumber="306"><td class="num" id="LN306">306</td><td class="line"> <span class='comment'>* Calls grp for each group.</span></td></tr>
<tr class="codeline" data-linenumber="307"><td class="num" id="LN307">307</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="308"><td class="num" id="LN308">308</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="309"><td class="num" id="LN309">309</td><td class="line">COVER_groupBy(<span class='keyword'>const</span> <span class='keyword'>void</span> *data, size_t count, size_t size, COVER_ctx_t *ctx,</td></tr>
<tr class="codeline" data-linenumber="310"><td class="num" id="LN310">310</td><td class="line">              <span class='keyword'>int</span> (*cmp)(COVER_ctx_t *, <span class='keyword'>const</span> <span class='keyword'>void</span> *, <span class='keyword'>const</span> <span class='keyword'>void</span> *),</td></tr>
<tr class="codeline" data-linenumber="311"><td class="num" id="LN311">311</td><td class="line">              <span class='keyword'>void</span> (*grp)(COVER_ctx_t *, <span class='keyword'>const</span> <span class='keyword'>void</span> *, <span class='keyword'>const</span> <span class='keyword'>void</span> *)) {</td></tr>
<tr class="codeline" data-linenumber="312"><td class="num" id="LN312">312</td><td class="line">  <span class='keyword'>const</span> BYTE *ptr = (<span class='keyword'>const</span> BYTE *)data;</td></tr>
<tr class="codeline" data-linenumber="313"><td class="num" id="LN313">313</td><td class="line">  size_t num = 0;</td></tr>
<tr class="codeline" data-linenumber="314"><td class="num" id="LN314">314</td><td class="line">  <span class='keyword'>while</span> (num &lt; count) {</td></tr>
<tr class="codeline" data-linenumber="315"><td class="num" id="LN315">315</td><td class="line">    <span class='keyword'>const</span> BYTE *grpEnd = ptr + size;</td></tr>
<tr class="codeline" data-linenumber="316"><td class="num" id="LN316">316</td><td class="line">    ++num;</td></tr>
<tr class="codeline" data-linenumber="317"><td class="num" id="LN317">317</td><td class="line">    <span class='keyword'>while</span> (num &lt; count &amp;&amp; cmp(ctx, ptr, grpEnd) == 0) {</td></tr>
<tr class="codeline" data-linenumber="318"><td class="num" id="LN318">318</td><td class="line">      grpEnd += size;</td></tr>
<tr class="codeline" data-linenumber="319"><td class="num" id="LN319">319</td><td class="line">      ++num;</td></tr>
<tr class="codeline" data-linenumber="320"><td class="num" id="LN320">320</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="321"><td class="num" id="LN321">321</td><td class="line">    grp(ctx, ptr, grpEnd);</td></tr>
<tr class="codeline" data-linenumber="322"><td class="num" id="LN322">322</td><td class="line">    ptr = grpEnd;</td></tr>
<tr class="codeline" data-linenumber="323"><td class="num" id="LN323">323</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="324"><td class="num" id="LN324">324</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="325"><td class="num" id="LN325">325</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="326"><td class="num" id="LN326">326</td><td class="line"><span class='comment'>/*-*************************************</span></td></tr>
<tr class="codeline" data-linenumber="327"><td class="num" id="LN327">327</td><td class="line"><span class='comment'>*  Cover functions</span></td></tr>
<tr class="codeline" data-linenumber="328"><td class="num" id="LN328">328</td><td class="line"><span class='comment'>***************************************/</span></td></tr>
<tr class="codeline" data-linenumber="329"><td class="num" id="LN329">329</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="330"><td class="num" id="LN330">330</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="331"><td class="num" id="LN331">331</td><td class="line"> <span class='comment'>* Called on each group of positions with the same dmer.</span></td></tr>
<tr class="codeline" data-linenumber="332"><td class="num" id="LN332">332</td><td class="line"> <span class='comment'>* Counts the frequency of each dmer and saves it in the suffix array.</span></td></tr>
<tr class="codeline" data-linenumber="333"><td class="num" id="LN333">333</td><td class="line"> <span class='comment'>* Fills `ctx-&gt;dmerAt`.</span></td></tr>
<tr class="codeline" data-linenumber="334"><td class="num" id="LN334">334</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="335"><td class="num" id="LN335">335</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> COVER_group(COVER_ctx_t *ctx, <span class='keyword'>const</span> <span class='keyword'>void</span> *group,</td></tr>
<tr class="codeline" data-linenumber="336"><td class="num" id="LN336">336</td><td class="line">                        <span class='keyword'>const</span> <span class='keyword'>void</span> *groupEnd) {</td></tr>
<tr class="codeline" data-linenumber="337"><td class="num" id="LN337">337</td><td class="line">  <span class='comment'>/* The group consists of all the positions with the same first d bytes. */</span></td></tr>
<tr class="codeline" data-linenumber="338"><td class="num" id="LN338">338</td><td class="line">  <span class='keyword'>const</span> U32 *grpPtr = (<span class='keyword'>const</span> U32 *)group;</td></tr>
<tr class="codeline" data-linenumber="339"><td class="num" id="LN339">339</td><td class="line">  <span class='keyword'>const</span> U32 *grpEnd = (<span class='keyword'>const</span> U32 *)groupEnd;</td></tr>
<tr class="codeline" data-linenumber="340"><td class="num" id="LN340">340</td><td class="line">  <span class='comment'>/* The dmerId is how we will reference this dmer.</span></td></tr>
<tr class="codeline" data-linenumber="341"><td class="num" id="LN341">341</td><td class="line">   <span class='comment'>* This allows us to map the whole dmer space to a much smaller space, the</span></td></tr>
<tr class="codeline" data-linenumber="342"><td class="num" id="LN342">342</td><td class="line">   <span class='comment'>* size of the suffix array.</span></td></tr>
<tr class="codeline" data-linenumber="343"><td class="num" id="LN343">343</td><td class="line">   <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="344"><td class="num" id="LN344">344</td><td class="line">  <span class='keyword'>const</span> U32 dmerId = (U32)(grpPtr - ctx-&gt;suffix);</td></tr>
<tr class="codeline" data-linenumber="345"><td class="num" id="LN345">345</td><td class="line">  <span class='comment'>/* Count the number of samples this dmer shows up in */</span></td></tr>
<tr class="codeline" data-linenumber="346"><td class="num" id="LN346">346</td><td class="line">  U32 freq = 0;</td></tr>
<tr class="codeline" data-linenumber="347"><td class="num" id="LN347">347</td><td class="line">  <span class='comment'>/* Details */</span></td></tr>
<tr class="codeline" data-linenumber="348"><td class="num" id="LN348">348</td><td class="line">  <span class='keyword'>const</span> size_t *curOffsetPtr = ctx-&gt;offsets;</td></tr>
<tr class="codeline" data-linenumber="349"><td class="num" id="LN349">349</td><td class="line">  <span class='keyword'>const</span> size_t *offsetsEnd = ctx-&gt;offsets + ctx-&gt;nbSamples;</td></tr>
<tr class="codeline" data-linenumber="350"><td class="num" id="LN350">350</td><td class="line">  <span class='comment'>/* Once *grpPtr &gt;= curSampleEnd this occurrence of the dmer is in a</span></td></tr>
<tr class="codeline" data-linenumber="351"><td class="num" id="LN351">351</td><td class="line">   <span class='comment'>* different sample than the last.</span></td></tr>
<tr class="codeline" data-linenumber="352"><td class="num" id="LN352">352</td><td class="line">   <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="353"><td class="num" id="LN353">353</td><td class="line">  size_t curSampleEnd = ctx-&gt;offsets[0];</td></tr>
<tr class="codeline" data-linenumber="354"><td class="num" id="LN354">354</td><td class="line">  <span class='keyword'>for</span> (; grpPtr != grpEnd; ++grpPtr) {</td></tr>
<tr class="codeline" data-linenumber="355"><td class="num" id="LN355">355</td><td class="line">    <span class='comment'>/* Save the dmerId for this position so we can get back to it. */</span></td></tr>
<tr class="codeline" data-linenumber="356"><td class="num" id="LN356">356</td><td class="line">    ctx-&gt;dmerAt[*grpPtr] = dmerId;</td></tr>
<tr class="codeline" data-linenumber="357"><td class="num" id="LN357">357</td><td class="line">    <span class='comment'>/* Dictionaries only help for the first reference to the dmer.</span></td></tr>
<tr class="codeline" data-linenumber="358"><td class="num" id="LN358">358</td><td class="line">     <span class='comment'>* After that zstd can reference the match from the previous reference.</span></td></tr>
<tr class="codeline" data-linenumber="359"><td class="num" id="LN359">359</td><td class="line">     <span class='comment'>* So only count each dmer once for each sample it is in.</span></td></tr>
<tr class="codeline" data-linenumber="360"><td class="num" id="LN360">360</td><td class="line">     <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="361"><td class="num" id="LN361">361</td><td class="line">    <span class='keyword'>if</span> (*grpPtr &lt; curSampleEnd) {</td></tr>
<tr class="codeline" data-linenumber="362"><td class="num" id="LN362">362</td><td class="line">      <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="363"><td class="num" id="LN363">363</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="364"><td class="num" id="LN364">364</td><td class="line">    freq += 1;</td></tr>
<tr class="codeline" data-linenumber="365"><td class="num" id="LN365">365</td><td class="line">    <span class='comment'>/* Binary search to find the end of the sample *grpPtr is in.</span></td></tr>
<tr class="codeline" data-linenumber="366"><td class="num" id="LN366">366</td><td class="line">     <span class='comment'>* In the common case that grpPtr + 1 == grpEnd we can skip the binary</span></td></tr>
<tr class="codeline" data-linenumber="367"><td class="num" id="LN367">367</td><td class="line">     <span class='comment'>* search because the loop is over.</span></td></tr>
<tr class="codeline" data-linenumber="368"><td class="num" id="LN368">368</td><td class="line">     <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="369"><td class="num" id="LN369">369</td><td class="line">    <span class='keyword'>if</span> (grpPtr + 1 != grpEnd) {</td></tr>
<tr class="codeline" data-linenumber="370"><td class="num" id="LN370">370</td><td class="line">      <span class='keyword'>const</span> size_t *sampleEndPtr =</td></tr>
<tr class="codeline" data-linenumber="371"><td class="num" id="LN371">371</td><td class="line">          COVER_lower_bound(curOffsetPtr, offsetsEnd, *grpPtr);</td></tr>
<tr class="codeline" data-linenumber="372"><td class="num" id="LN372">372</td><td class="line">      curSampleEnd = *sampleEndPtr;</td></tr>
<tr class="codeline" data-linenumber="373"><td class="num" id="LN373">373</td><td class="line">      curOffsetPtr = sampleEndPtr + 1;</td></tr>
<tr class="codeline" data-linenumber="374"><td class="num" id="LN374">374</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="375"><td class="num" id="LN375">375</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="376"><td class="num" id="LN376">376</td><td class="line">  <span class='comment'>/* At this point we are never going to look at this segment of the suffix</span></td></tr>
<tr class="codeline" data-linenumber="377"><td class="num" id="LN377">377</td><td class="line">   <span class='comment'>* array again.  We take advantage of this fact to save memory.</span></td></tr>
<tr class="codeline" data-linenumber="378"><td class="num" id="LN378">378</td><td class="line">   <span class='comment'>* We store the frequency of the dmer in the first position of the group,</span></td></tr>
<tr class="codeline" data-linenumber="379"><td class="num" id="LN379">379</td><td class="line">   <span class='comment'>* which is dmerId.</span></td></tr>
<tr class="codeline" data-linenumber="380"><td class="num" id="LN380">380</td><td class="line">   <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="381"><td class="num" id="LN381">381</td><td class="line">  ctx-&gt;suffix[dmerId] = freq;</td></tr>
<tr class="codeline" data-linenumber="382"><td class="num" id="LN382">382</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="383"><td class="num" id="LN383">383</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="384"><td class="num" id="LN384">384</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="385"><td class="num" id="LN385">385</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="386"><td class="num" id="LN386">386</td><td class="line"> <span class='comment'>* Selects the best segment in an epoch.</span></td></tr>
<tr class="codeline" data-linenumber="387"><td class="num" id="LN387">387</td><td class="line"> <span class='comment'>* Segments of are scored according to the function:</span></td></tr>
<tr class="codeline" data-linenumber="388"><td class="num" id="LN388">388</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="389"><td class="num" id="LN389">389</td><td class="line"> <span class='comment'>* Let F(d) be the frequency of dmer d.</span></td></tr>
<tr class="codeline" data-linenumber="390"><td class="num" id="LN390">390</td><td class="line"> <span class='comment'>* Let S_i be the dmer at position i of segment S which has length k.</span></td></tr>
<tr class="codeline" data-linenumber="391"><td class="num" id="LN391">391</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="392"><td class="num" id="LN392">392</td><td class="line"> <span class='comment'>*     Score(S) = F(S_1) + F(S_2) + ... + F(S_{k-d+1})</span></td></tr>
<tr class="codeline" data-linenumber="393"><td class="num" id="LN393">393</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="394"><td class="num" id="LN394">394</td><td class="line"> <span class='comment'>* Once the dmer d is in the dictionary we set F(d) = 0.</span></td></tr>
<tr class="codeline" data-linenumber="395"><td class="num" id="LN395">395</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="396"><td class="num" id="LN396">396</td><td class="line"><span class='keyword'>static</span> COVER_segment_t COVER_selectSegment(<span class='keyword'>const</span> COVER_ctx_t *ctx, U32 *freqs,</td></tr>
<tr class="codeline" data-linenumber="397"><td class="num" id="LN397">397</td><td class="line">                                           COVER_map_t *activeDmers, U32 begin,</td></tr>
<tr class="codeline" data-linenumber="398"><td class="num" id="LN398">398</td><td class="line">                                           U32 end,</td></tr>
<tr class="codeline" data-linenumber="399"><td class="num" id="LN399">399</td><td class="line">                                           ZDICT_cover_params_t parameters) {</td></tr>
<tr class="codeline" data-linenumber="400"><td class="num" id="LN400">400</td><td class="line">  <span class='comment'>/* Constants */</span></td></tr>
<tr class="codeline" data-linenumber="401"><td class="num" id="LN401">401</td><td class="line">  <span class='keyword'>const</span> U32 k = parameters.k;</td></tr>
<tr class="codeline" data-linenumber="402"><td class="num" id="LN402">402</td><td class="line">  <span class='keyword'>const</span> U32 d = parameters.d;</td></tr>
<tr class="codeline" data-linenumber="403"><td class="num" id="LN403">403</td><td class="line">  <span class='keyword'>const</span> U32 dmersInK = k - d + 1;</td></tr>
<tr class="codeline" data-linenumber="404"><td class="num" id="LN404">404</td><td class="line">  <span class='comment'>/* Try each segment (activeSegment) and save the best (bestSegment) */</span></td></tr>
<tr class="codeline" data-linenumber="405"><td class="num" id="LN405">405</td><td class="line">  COVER_segment_t bestSegment = {0, 0, 0};</td></tr>
<tr class="codeline" data-linenumber="406"><td class="num" id="LN406">406</td><td class="line">  COVER_segment_t activeSegment;</td></tr>
<tr class="codeline" data-linenumber="407"><td class="num" id="LN407">407</td><td class="line">  <span class='comment'>/* Reset the activeDmers in the segment */</span></td></tr>
<tr class="codeline" data-linenumber="408"><td class="num" id="LN408">408</td><td class="line">  COVER_map_clear(activeDmers);</td></tr>
<tr class="codeline" data-linenumber="409"><td class="num" id="LN409">409</td><td class="line">  <span class='comment'>/* The activeSegment starts at the beginning of the epoch. */</span></td></tr>
<tr class="codeline" data-linenumber="410"><td class="num" id="LN410">410</td><td class="line">  activeSegment.begin = begin;</td></tr>
<tr class="codeline" data-linenumber="411"><td class="num" id="LN411">411</td><td class="line">  activeSegment.end = begin;</td></tr>
<tr class="codeline" data-linenumber="412"><td class="num" id="LN412">412</td><td class="line">  activeSegment.score = 0;</td></tr>
<tr class="codeline" data-linenumber="413"><td class="num" id="LN413">413</td><td class="line">  <span class='comment'>/* Slide the activeSegment through the whole epoch.</span></td></tr>
<tr class="codeline" data-linenumber="414"><td class="num" id="LN414">414</td><td class="line">   <span class='comment'>* Save the best segment in bestSegment.</span></td></tr>
<tr class="codeline" data-linenumber="415"><td class="num" id="LN415">415</td><td class="line">   <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="416"><td class="num" id="LN416">416</td><td class="line">  <span class='keyword'>while</span> (activeSegment.end &lt; end) {</td></tr>
<tr class="codeline" data-linenumber="417"><td class="num" id="LN417">417</td><td class="line">    <span class='comment'>/* The dmerId for the dmer at the next position */</span></td></tr>
<tr class="codeline" data-linenumber="418"><td class="num" id="LN418">418</td><td class="line">    U32 newDmer = ctx-&gt;dmerAt[activeSegment.end];</td></tr>
<tr class="codeline" data-linenumber="419"><td class="num" id="LN419">419</td><td class="line">    <span class='comment'>/* The entry in activeDmers for this dmerId */</span></td></tr>
<tr class="codeline" data-linenumber="420"><td class="num" id="LN420">420</td><td class="line">    U32 *newDmerOcc = COVER_map_at(activeDmers, newDmer);</td></tr>
<tr class="codeline" data-linenumber="421"><td class="num" id="LN421">421</td><td class="line">    <span class='comment'>/* If the dmer isn't already present in the segment add its score. */</span></td></tr>
<tr class="codeline" data-linenumber="422"><td class="num" id="LN422">422</td><td class="line">    <span class='keyword'>if</span> (*newDmerOcc == 0) {</td></tr>
<tr class="codeline" data-linenumber="423"><td class="num" id="LN423">423</td><td class="line">      <span class='comment'>/* The paper suggest using the L-0.5 norm, but experiments show that it</span></td></tr>
<tr class="codeline" data-linenumber="424"><td class="num" id="LN424">424</td><td class="line">       <span class='comment'>* doesn't help.</span></td></tr>
<tr class="codeline" data-linenumber="425"><td class="num" id="LN425">425</td><td class="line">       <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="426"><td class="num" id="LN426">426</td><td class="line">      activeSegment.score += freqs[newDmer];</td></tr>
<tr class="codeline" data-linenumber="427"><td class="num" id="LN427">427</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="428"><td class="num" id="LN428">428</td><td class="line">    <span class='comment'>/* Add the dmer to the segment */</span></td></tr>
<tr class="codeline" data-linenumber="429"><td class="num" id="LN429">429</td><td class="line">    activeSegment.end += 1;</td></tr>
<tr class="codeline" data-linenumber="430"><td class="num" id="LN430">430</td><td class="line">    *newDmerOcc += 1;</td></tr>
<tr class="codeline" data-linenumber="431"><td class="num" id="LN431">431</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="432"><td class="num" id="LN432">432</td><td class="line">    <span class='comment'>/* If the window is now too large, drop the first position */</span></td></tr>
<tr class="codeline" data-linenumber="433"><td class="num" id="LN433">433</td><td class="line">    <span class='keyword'>if</span> (activeSegment.end - activeSegment.begin == dmersInK + 1) {</td></tr>
<tr class="codeline" data-linenumber="434"><td class="num" id="LN434">434</td><td class="line">      U32 delDmer = ctx-&gt;dmerAt[activeSegment.begin];</td></tr>
<tr class="codeline" data-linenumber="435"><td class="num" id="LN435">435</td><td class="line">      U32 *delDmerOcc = COVER_map_at(activeDmers, delDmer);</td></tr>
<tr class="codeline" data-linenumber="436"><td class="num" id="LN436">436</td><td class="line">      activeSegment.begin += 1;</td></tr>
<tr class="codeline" data-linenumber="437"><td class="num" id="LN437">437</td><td class="line">      *delDmerOcc -= 1;</td></tr>
<tr class="codeline" data-linenumber="438"><td class="num" id="LN438">438</td><td class="line">      <span class='comment'>/* If this is the last occurrence of the dmer, subtract its score */</span></td></tr>
<tr class="codeline" data-linenumber="439"><td class="num" id="LN439">439</td><td class="line">      <span class='keyword'>if</span> (*delDmerOcc == 0) {</td></tr>
<tr class="codeline" data-linenumber="440"><td class="num" id="LN440">440</td><td class="line">        COVER_map_remove(activeDmers, delDmer);</td></tr>
<tr class="codeline" data-linenumber="441"><td class="num" id="LN441">441</td><td class="line">        activeSegment.score -= freqs[delDmer];</td></tr>
<tr class="codeline" data-linenumber="442"><td class="num" id="LN442">442</td><td class="line">      }</td></tr>
<tr class="codeline" data-linenumber="443"><td class="num" id="LN443">443</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="444"><td class="num" id="LN444">444</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="445"><td class="num" id="LN445">445</td><td class="line">    <span class='comment'>/* If this segment is the best so far save it */</span></td></tr>
<tr class="codeline" data-linenumber="446"><td class="num" id="LN446">446</td><td class="line">    <span class='keyword'>if</span> (activeSegment.score &gt; bestSegment.score) {</td></tr>
<tr class="codeline" data-linenumber="447"><td class="num" id="LN447">447</td><td class="line">      bestSegment = activeSegment;</td></tr>
<tr class="codeline" data-linenumber="448"><td class="num" id="LN448">448</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="449"><td class="num" id="LN449">449</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="450"><td class="num" id="LN450">450</td><td class="line">  {</td></tr>
<tr class="codeline" data-linenumber="451"><td class="num" id="LN451">451</td><td class="line">    <span class='comment'>/* Trim off the zero frequency head and tail from the segment. */</span></td></tr>
<tr class="codeline" data-linenumber="452"><td class="num" id="LN452">452</td><td class="line">    U32 newBegin = bestSegment.end;</td></tr>
<tr class="codeline" data-linenumber="453"><td class="num" id="LN453">453</td><td class="line">    U32 newEnd = bestSegment.begin;</td></tr>
<tr class="codeline" data-linenumber="454"><td class="num" id="LN454">454</td><td class="line">    U32 pos;</td></tr>
<tr class="codeline" data-linenumber="455"><td class="num" id="LN455">455</td><td class="line">    <span class='keyword'>for</span> (pos = bestSegment.begin; pos != bestSegment.end; ++pos) {</td></tr>
<tr class="codeline" data-linenumber="456"><td class="num" id="LN456">456</td><td class="line">      U32 freq = freqs[ctx-&gt;dmerAt[pos]];</td></tr>
<tr class="codeline" data-linenumber="457"><td class="num" id="LN457">457</td><td class="line">      <span class='keyword'>if</span> (freq != 0) {</td></tr>
<tr class="codeline" data-linenumber="458"><td class="num" id="LN458">458</td><td class="line">        newBegin = <span class='macro'>MIN(newBegin, pos)<span class='macro_popup'>((newBegin)&lt;(pos) ? (newBegin) : (pos))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="459"><td class="num" id="LN459">459</td><td class="line">        newEnd = pos + 1;</td></tr>
<tr class="codeline" data-linenumber="460"><td class="num" id="LN460">460</td><td class="line">      }</td></tr>
<tr class="codeline" data-linenumber="461"><td class="num" id="LN461">461</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="462"><td class="num" id="LN462">462</td><td class="line">    bestSegment.begin = newBegin;</td></tr>
<tr class="codeline" data-linenumber="463"><td class="num" id="LN463">463</td><td class="line">    bestSegment.end = newEnd;</td></tr>
<tr class="codeline" data-linenumber="464"><td class="num" id="LN464">464</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="465"><td class="num" id="LN465">465</td><td class="line">  {</td></tr>
<tr class="codeline" data-linenumber="466"><td class="num" id="LN466">466</td><td class="line">    <span class='comment'>/* Zero out the frequency of each dmer covered by the chosen segment. */</span></td></tr>
<tr class="codeline" data-linenumber="467"><td class="num" id="LN467">467</td><td class="line">    U32 pos;</td></tr>
<tr class="codeline" data-linenumber="468"><td class="num" id="LN468">468</td><td class="line">    <span class='keyword'>for</span> (pos = bestSegment.begin; pos != bestSegment.end; ++pos) {</td></tr>
<tr class="codeline" data-linenumber="469"><td class="num" id="LN469">469</td><td class="line">      freqs[ctx-&gt;dmerAt[pos]] = 0;</td></tr>
<tr class="codeline" data-linenumber="470"><td class="num" id="LN470">470</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="471"><td class="num" id="LN471">471</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="472"><td class="num" id="LN472">472</td><td class="line">  <span class='keyword'>return</span> bestSegment;</td></tr>
<tr class="codeline" data-linenumber="473"><td class="num" id="LN473">473</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="474"><td class="num" id="LN474">474</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="475"><td class="num" id="LN475">475</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="476"><td class="num" id="LN476">476</td><td class="line"> <span class='comment'>* Check the validity of the parameters.</span></td></tr>
<tr class="codeline" data-linenumber="477"><td class="num" id="LN477">477</td><td class="line"> <span class='comment'>* Returns non-zero if the parameters are valid and 0 otherwise.</span></td></tr>
<tr class="codeline" data-linenumber="478"><td class="num" id="LN478">478</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="479"><td class="num" id="LN479">479</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> COVER_checkParameters(ZDICT_cover_params_t parameters,</td></tr>
<tr class="codeline" data-linenumber="480"><td class="num" id="LN480">480</td><td class="line">                                 size_t maxDictSize) {</td></tr>
<tr class="codeline" data-linenumber="481"><td class="num" id="LN481">481</td><td class="line">  <span class='comment'>/* k and d are required parameters */</span></td></tr>
<tr class="codeline" data-linenumber="482"><td class="num" id="LN482">482</td><td class="line">  <span class='keyword'>if</span> (parameters.d == 0 || parameters.k == 0) {</td></tr>
<tr class="codeline" data-linenumber="483"><td class="num" id="LN483">483</td><td class="line">    <span class='keyword'>return</span> 0;</td></tr>
<tr class="codeline" data-linenumber="484"><td class="num" id="LN484">484</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="485"><td class="num" id="LN485">485</td><td class="line">  <span class='comment'>/* k &lt;= maxDictSize */</span></td></tr>
<tr class="codeline" data-linenumber="486"><td class="num" id="LN486">486</td><td class="line">  <span class='keyword'>if</span> (parameters.k &gt; maxDictSize) {</td></tr>
<tr class="codeline" data-linenumber="487"><td class="num" id="LN487">487</td><td class="line">    <span class='keyword'>return</span> 0;</td></tr>
<tr class="codeline" data-linenumber="488"><td class="num" id="LN488">488</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="489"><td class="num" id="LN489">489</td><td class="line">  <span class='comment'>/* d &lt;= k */</span></td></tr>
<tr class="codeline" data-linenumber="490"><td class="num" id="LN490">490</td><td class="line">  <span class='keyword'>if</span> (parameters.d &gt; parameters.k) {</td></tr>
<tr class="codeline" data-linenumber="491"><td class="num" id="LN491">491</td><td class="line">    <span class='keyword'>return</span> 0;</td></tr>
<tr class="codeline" data-linenumber="492"><td class="num" id="LN492">492</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="493"><td class="num" id="LN493">493</td><td class="line">  <span class='comment'>/* 0 &lt; splitPoint &lt;= 1 */</span></td></tr>
<tr class="codeline" data-linenumber="494"><td class="num" id="LN494">494</td><td class="line">  <span class='keyword'>if</span> (parameters.splitPoint &lt;= 0 || parameters.splitPoint &gt; 1){</td></tr>
<tr class="codeline" data-linenumber="495"><td class="num" id="LN495">495</td><td class="line">    <span class='keyword'>return</span> 0;</td></tr>
<tr class="codeline" data-linenumber="496"><td class="num" id="LN496">496</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="497"><td class="num" id="LN497">497</td><td class="line">  <span class='keyword'>return</span> 1;</td></tr>
<tr class="codeline" data-linenumber="498"><td class="num" id="LN498">498</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="499"><td class="num" id="LN499">499</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="500"><td class="num" id="LN500">500</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="501"><td class="num" id="LN501">501</td><td class="line"> <span class='comment'>* Clean up a context initialized with `COVER_ctx_init()`.</span></td></tr>
<tr class="codeline" data-linenumber="502"><td class="num" id="LN502">502</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="503"><td class="num" id="LN503">503</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> COVER_ctx_destroy(COVER_ctx_t *ctx) {</td></tr>
<tr class="codeline" data-linenumber="504"><td class="num" id="LN504">504</td><td class="line">  <span class='keyword'>if</span> (!ctx) {</td></tr>
<tr class="codeline" data-linenumber="505"><td class="num" id="LN505">505</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="506"><td class="num" id="LN506">506</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="507"><td class="num" id="LN507">507</td><td class="line">  <span class='keyword'>if</span> (ctx-&gt;suffix) {</td></tr>
<tr class="codeline" data-linenumber="508"><td class="num" id="LN508">508</td><td class="line">    free(ctx-&gt;suffix);</td></tr>
<tr class="codeline" data-linenumber="509"><td class="num" id="LN509">509</td><td class="line">    ctx-&gt;suffix = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="510"><td class="num" id="LN510">510</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="511"><td class="num" id="LN511">511</td><td class="line">  <span class='keyword'>if</span> (ctx-&gt;freqs) {</td></tr>
<tr class="codeline" data-linenumber="512"><td class="num" id="LN512">512</td><td class="line">    free(ctx-&gt;freqs);</td></tr>
<tr class="codeline" data-linenumber="513"><td class="num" id="LN513">513</td><td class="line">    ctx-&gt;freqs = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="514"><td class="num" id="LN514">514</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="515"><td class="num" id="LN515">515</td><td class="line">  <span class='keyword'>if</span> (ctx-&gt;dmerAt) {</td></tr>
<tr class="codeline" data-linenumber="516"><td class="num" id="LN516">516</td><td class="line">    free(ctx-&gt;dmerAt);</td></tr>
<tr class="codeline" data-linenumber="517"><td class="num" id="LN517">517</td><td class="line">    ctx-&gt;dmerAt = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="518"><td class="num" id="LN518">518</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="519"><td class="num" id="LN519">519</td><td class="line">  <span class='keyword'>if</span> (ctx-&gt;offsets) {</td></tr>
<tr class="codeline" data-linenumber="520"><td class="num" id="LN520">520</td><td class="line">    free(ctx-&gt;offsets);</td></tr>
<tr class="codeline" data-linenumber="521"><td class="num" id="LN521">521</td><td class="line">    ctx-&gt;offsets = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="522"><td class="num" id="LN522">522</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="523"><td class="num" id="LN523">523</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="524"><td class="num" id="LN524">524</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="525"><td class="num" id="LN525">525</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="526"><td class="num" id="LN526">526</td><td class="line"> <span class='comment'>* Prepare a context for dictionary building.</span></td></tr>
<tr class="codeline" data-linenumber="527"><td class="num" id="LN527">527</td><td class="line"> <span class='comment'>* The context is only dependent on the parameter `d` and can used multiple</span></td></tr>
<tr class="codeline" data-linenumber="528"><td class="num" id="LN528">528</td><td class="line"> <span class='comment'>* times.</span></td></tr>
<tr class="codeline" data-linenumber="529"><td class="num" id="LN529">529</td><td class="line"> <span class='comment'>* Returns 0 on success or error code on error.</span></td></tr>
<tr class="codeline" data-linenumber="530"><td class="num" id="LN530">530</td><td class="line"> <span class='comment'>* The context must be destroyed with `COVER_ctx_destroy()`.</span></td></tr>
<tr class="codeline" data-linenumber="531"><td class="num" id="LN531">531</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="532"><td class="num" id="LN532">532</td><td class="line"><span class='keyword'>static</span> size_t COVER_ctx_init(COVER_ctx_t *ctx, <span class='keyword'>const</span> <span class='keyword'>void</span> *samplesBuffer,</td></tr>
<tr class="codeline" data-linenumber="533"><td class="num" id="LN533">533</td><td class="line">                          <span class='keyword'>const</span> size_t *samplesSizes, <span class='keyword'>unsigned</span> nbSamples,</td></tr>
<tr class="codeline" data-linenumber="534"><td class="num" id="LN534">534</td><td class="line">                          <span class='keyword'>unsigned</span> d, <span class='keyword'>double</span> splitPoint) {</td></tr>
<tr class="codeline" data-linenumber="535"><td class="num" id="LN535">535</td><td class="line">  <span class='keyword'>const</span> BYTE *<span class='keyword'>const</span> samples = (<span class='keyword'>const</span> BYTE *)samplesBuffer;</td></tr>
<tr class="codeline" data-linenumber="536"><td class="num" id="LN536">536</td><td class="line">  <span class='keyword'>const</span> size_t totalSamplesSize = COVER_sum(samplesSizes, nbSamples);</td></tr>
<tr class="codeline" data-linenumber="537"><td class="num" id="LN537">537</td><td class="line">  <span class='comment'>/* Split samples into testing and training sets */</span></td></tr>
<tr class="codeline" data-linenumber="538"><td class="num" id="LN538">538</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>unsigned</span> nbTrainSamples = splitPoint &lt; 1.0 ? (<span class='keyword'>unsigned</span>)((<span class='keyword'>double</span>)nbSamples * splitPoint) : nbSamples;</td></tr>
<tr class="codeline" data-linenumber="539"><td class="num" id="LN539">539</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>unsigned</span> nbTestSamples = splitPoint &lt; 1.0 ? nbSamples - nbTrainSamples : nbSamples;</td></tr>
<tr class="codeline" data-linenumber="540"><td class="num" id="LN540">540</td><td class="line">  <span class='keyword'>const</span> size_t trainingSamplesSize = splitPoint &lt; 1.0 ? COVER_sum(samplesSizes, nbTrainSamples) : totalSamplesSize;</td></tr>
<tr class="codeline" data-linenumber="541"><td class="num" id="LN541">541</td><td class="line">  <span class='keyword'>const</span> size_t testSamplesSize = splitPoint &lt; 1.0 ? COVER_sum(samplesSizes + nbTrainSamples, nbTestSamples) : totalSamplesSize;</td></tr>
<tr class="codeline" data-linenumber="542"><td class="num" id="LN542">542</td><td class="line">  <span class='comment'>/* Checks */</span></td></tr>
<tr class="codeline" data-linenumber="543"><td class="num" id="LN543">543</td><td class="line">  <span class='keyword'>if</span> (totalSamplesSize &lt; <span class='macro'>MAX(d, <span class='keyword'>sizeof</span>(U64))<span class='macro_popup'>((d)&gt;(sizeof(U64)) ? (d) : (sizeof(U64)))</span></span> ||</td></tr>
<tr class="codeline" data-linenumber="544"><td class="num" id="LN544">544</td><td class="line">      totalSamplesSize &gt;= (size_t)<span class='macro'>COVER_MAX_SAMPLES_SIZE<span class='macro_popup'>(sizeof(size_t) == 8 ? ((unsigned)-1) : ((unsigned)1 *(1U&lt;&lt;<br>30)))</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="545"><td class="num" id="LN545">545</td><td class="line">    <span class='macro'>DISPLAYLEVEL(1, <span class='string_literal'>"Total samples size is too large (%u MB), maximum size is %u MB\n"</span>,<span class='macro_popup'>if (g_displayLevel &gt;= 1) { { fprintf(stderr, "Total samples size is too large (%u MB), maximum size is %u MB\n"<br>, (unsigned)(totalSamplesSize&gt;&gt;20), ((sizeof(size_t) ==<br> 8 ? ((unsigned)-1) : ((unsigned)1 *(1U&lt;&lt;30))) &gt;&gt;<br> 20)); fflush(stderr); }; }</span></span></td></tr>
<tr class="codeline" data-linenumber="546"><td class="num" id="LN546">546</td><td class="line">                 <span class='macro'>(<span class='keyword'>unsigned</span>)(totalSamplesSize&gt;&gt;20), (COVER_MAX_SAMPLES_SIZE &gt;&gt; 20))<span class='macro_popup'>if (g_displayLevel &gt;= 1) { { fprintf(stderr, "Total samples size is too large (%u MB), maximum size is %u MB\n"<br>, (unsigned)(totalSamplesSize&gt;&gt;20), ((sizeof(size_t) ==<br> 8 ? ((unsigned)-1) : ((unsigned)1 *(1U&lt;&lt;30))) &gt;&gt;<br> 20)); fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="547"><td class="num" id="LN547">547</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>ERROR(srcSize_wrong)<span class='macro_popup'>((size_t)-ZSTD_error_srcSize_wrong)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="548"><td class="num" id="LN548">548</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="549"><td class="num" id="LN549">549</td><td class="line">  <span class='comment'>/* Check if there are at least 5 training samples */</span></td></tr>
<tr class="codeline" data-linenumber="550"><td class="num" id="LN550">550</td><td class="line">  <span class='keyword'>if</span> (nbTrainSamples &lt; 5) {</td></tr>
<tr class="codeline" data-linenumber="551"><td class="num" id="LN551">551</td><td class="line">    <span class='macro'>DISPLAYLEVEL(1, <span class='string_literal'>"Total number of training samples is %u and is invalid."</span>, nbTrainSamples)<span class='macro_popup'>if (g_displayLevel &gt;= 1) { { fprintf(stderr, "Total number of training samples is %u and is invalid."<br>, nbTrainSamples); fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="552"><td class="num" id="LN552">552</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>ERROR(srcSize_wrong)<span class='macro_popup'>((size_t)-ZSTD_error_srcSize_wrong)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="553"><td class="num" id="LN553">553</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="554"><td class="num" id="LN554">554</td><td class="line">  <span class='comment'>/* Check if there's testing sample */</span></td></tr>
<tr class="codeline" data-linenumber="555"><td class="num" id="LN555">555</td><td class="line">  <span class='keyword'>if</span> (nbTestSamples &lt; 1) {</td></tr>
<tr class="codeline" data-linenumber="556"><td class="num" id="LN556">556</td><td class="line">    <span class='macro'>DISPLAYLEVEL(1, <span class='string_literal'>"Total number of testing samples is %u and is invalid."</span>, nbTestSamples)<span class='macro_popup'>if (g_displayLevel &gt;= 1) { { fprintf(stderr, "Total number of testing samples is %u and is invalid."<br>, nbTestSamples); fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="557"><td class="num" id="LN557">557</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>ERROR(srcSize_wrong)<span class='macro_popup'>((size_t)-ZSTD_error_srcSize_wrong)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="558"><td class="num" id="LN558">558</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="559"><td class="num" id="LN559">559</td><td class="line">  <span class='comment'>/* Zero the context */</span></td></tr>
<tr class="codeline" data-linenumber="560"><td class="num" id="LN560">560</td><td class="line">  memset(ctx, 0, <span class='keyword'>sizeof</span>(*ctx));</td></tr>
<tr class="codeline" data-linenumber="561"><td class="num" id="LN561">561</td><td class="line">  <span class='macro'>DISPLAYLEVEL(2, <span class='string_literal'>"Training on %u samples of total size %u\n"</span>, nbTrainSamples,<span class='macro_popup'>if (g_displayLevel &gt;= 2) { { fprintf(stderr, "Training on %u samples of total size %u\n"<br>, nbTrainSamples, (unsigned)trainingSamplesSize); fflush(stderr<br>); }; }</span></span></td></tr>
<tr class="codeline" data-linenumber="562"><td class="num" id="LN562">562</td><td class="line">               <span class='macro'>(<span class='keyword'>unsigned</span>)trainingSamplesSize)<span class='macro_popup'>if (g_displayLevel &gt;= 2) { { fprintf(stderr, "Training on %u samples of total size %u\n"<br>, nbTrainSamples, (unsigned)trainingSamplesSize); fflush(stderr<br>); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="563"><td class="num" id="LN563">563</td><td class="line">  <span class='macro'>DISPLAYLEVEL(2, <span class='string_literal'>"Testing on %u samples of total size %u\n"</span>, nbTestSamples,<span class='macro_popup'>if (g_displayLevel &gt;= 2) { { fprintf(stderr, "Testing on %u samples of total size %u\n"<br>, nbTestSamples, (unsigned)testSamplesSize); fflush(stderr); }<br>; }</span></span></td></tr>
<tr class="codeline" data-linenumber="564"><td class="num" id="LN564">564</td><td class="line">               <span class='macro'>(<span class='keyword'>unsigned</span>)testSamplesSize)<span class='macro_popup'>if (g_displayLevel &gt;= 2) { { fprintf(stderr, "Testing on %u samples of total size %u\n"<br>, nbTestSamples, (unsigned)testSamplesSize); fflush(stderr); }<br>; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="565"><td class="num" id="LN565">565</td><td class="line">  ctx-&gt;samples = samples;</td></tr>
<tr class="codeline" data-linenumber="566"><td class="num" id="LN566">566</td><td class="line">  ctx-&gt;samplesSizes = samplesSizes;</td></tr>
<tr class="codeline" data-linenumber="567"><td class="num" id="LN567">567</td><td class="line">  ctx-&gt;nbSamples = nbSamples;</td></tr>
<tr class="codeline" data-linenumber="568"><td class="num" id="LN568">568</td><td class="line">  ctx-&gt;nbTrainSamples = nbTrainSamples;</td></tr>
<tr class="codeline" data-linenumber="569"><td class="num" id="LN569">569</td><td class="line">  ctx-&gt;nbTestSamples = nbTestSamples;</td></tr>
<tr class="codeline" data-linenumber="570"><td class="num" id="LN570">570</td><td class="line">  <span class='comment'>/* Partial suffix array */</span></td></tr>
<tr class="codeline" data-linenumber="571"><td class="num" id="LN571">571</td><td class="line">  ctx-&gt;suffixSize = trainingSamplesSize - <span class='macro'>MAX(d, <span class='keyword'>sizeof</span>(U64))<span class='macro_popup'>((d)&gt;(sizeof(U64)) ? (d) : (sizeof(U64)))</span></span> + 1;</td></tr>
<tr class="codeline" data-linenumber="572"><td class="num" id="LN572">572</td><td class="line">  ctx-&gt;suffix = (U32 *)malloc(ctx-&gt;suffixSize * <span class='keyword'>sizeof</span>(U32));</td></tr>
<tr class="codeline" data-linenumber="573"><td class="num" id="LN573">573</td><td class="line">  <span class='comment'>/* Maps index to the dmerID */</span></td></tr>
<tr class="codeline" data-linenumber="574"><td class="num" id="LN574">574</td><td class="line">  ctx-&gt;dmerAt = (U32 *)malloc(ctx-&gt;suffixSize * <span class='keyword'>sizeof</span>(U32));</td></tr>
<tr class="codeline" data-linenumber="575"><td class="num" id="LN575">575</td><td class="line">  <span class='comment'>/* The offsets of each file */</span></td></tr>
<tr class="codeline" data-linenumber="576"><td class="num" id="LN576">576</td><td class="line">  ctx-&gt;offsets = (size_t *)malloc((nbSamples + 1) * <span class='keyword'>sizeof</span>(size_t));</td></tr>
<tr class="codeline" data-linenumber="577"><td class="num" id="LN577">577</td><td class="line">  <span class='keyword'>if</span> (!ctx-&gt;suffix || !ctx-&gt;dmerAt || !ctx-&gt;offsets) {</td></tr>
<tr class="codeline" data-linenumber="578"><td class="num" id="LN578">578</td><td class="line">    <span class='macro'>DISPLAYLEVEL(1, <span class='string_literal'>"Failed to allocate scratch buffers\n"</span>)<span class='macro_popup'>if (g_displayLevel &gt;= 1) { { fprintf(stderr, "Failed to allocate scratch buffers\n"<br>); fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="579"><td class="num" id="LN579">579</td><td class="line">    COVER_ctx_destroy(ctx);</td></tr>
<tr class="codeline" data-linenumber="580"><td class="num" id="LN580">580</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>ERROR(memory_allocation)<span class='macro_popup'>((size_t)-ZSTD_error_memory_allocation)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="581"><td class="num" id="LN581">581</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="582"><td class="num" id="LN582">582</td><td class="line">  ctx-&gt;freqs = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="583"><td class="num" id="LN583">583</td><td class="line">  ctx-&gt;d = d;</td></tr>
<tr class="codeline" data-linenumber="584"><td class="num" id="LN584">584</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="585"><td class="num" id="LN585">585</td><td class="line">  <span class='comment'>/* Fill offsets from the samplesSizes */</span></td></tr>
<tr class="codeline" data-linenumber="586"><td class="num" id="LN586">586</td><td class="line">  {</td></tr>
<tr class="codeline" data-linenumber="587"><td class="num" id="LN587">587</td><td class="line">    U32 i;</td></tr>
<tr class="codeline" data-linenumber="588"><td class="num" id="LN588">588</td><td class="line">    ctx-&gt;offsets[0] = 0;</td></tr>
<tr class="codeline" data-linenumber="589"><td class="num" id="LN589">589</td><td class="line">    <span class='keyword'>for</span> (i = 1; i &lt;= nbSamples; ++i) {</td></tr>
<tr class="codeline" data-linenumber="590"><td class="num" id="LN590">590</td><td class="line">      ctx-&gt;offsets[i] = ctx-&gt;offsets[i - 1] + samplesSizes[i - 1];</td></tr>
<tr class="codeline" data-linenumber="591"><td class="num" id="LN591">591</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="592"><td class="num" id="LN592">592</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="593"><td class="num" id="LN593">593</td><td class="line">  <span class='macro'>DISPLAYLEVEL(2, <span class='string_literal'>"Constructing partial suffix array\n"</span>)<span class='macro_popup'>if (g_displayLevel &gt;= 2) { { fprintf(stderr, "Constructing partial suffix array\n"<br>); fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="594"><td class="num" id="LN594">594</td><td class="line">  {</td></tr>
<tr class="codeline" data-linenumber="595"><td class="num" id="LN595">595</td><td class="line">    <span class='comment'>/* suffix is a partial suffix array.</span></td></tr>
<tr class="codeline" data-linenumber="596"><td class="num" id="LN596">596</td><td class="line">     <span class='comment'>* It only sorts suffixes by their first parameters.d bytes.</span></td></tr>
<tr class="codeline" data-linenumber="597"><td class="num" id="LN597">597</td><td class="line">     <span class='comment'>* The sort is stable, so each dmer group is sorted by position in input.</span></td></tr>
<tr class="codeline" data-linenumber="598"><td class="num" id="LN598">598</td><td class="line">     <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="599"><td class="num" id="LN599">599</td><td class="line">    U32 i;</td></tr>
<tr class="codeline" data-linenumber="600"><td class="num" id="LN600">600</td><td class="line">    <span class='keyword'>for</span> (i = 0; i &lt; ctx-&gt;suffixSize; ++i) {</td></tr>
<tr class="codeline" data-linenumber="601"><td class="num" id="LN601">601</td><td class="line">      ctx-&gt;suffix[i] = i;</td></tr>
<tr class="codeline" data-linenumber="602"><td class="num" id="LN602">602</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="603"><td class="num" id="LN603">603</td><td class="line">    <span class='comment'>/* qsort doesn't take an opaque pointer, so pass as a global.</span></td></tr>
<tr class="codeline" data-linenumber="604"><td class="num" id="LN604">604</td><td class="line">     <span class='comment'>* On OpenBSD qsort() is not guaranteed to be stable, their mergesort() is.</span></td></tr>
<tr class="codeline" data-linenumber="605"><td class="num" id="LN605">605</td><td class="line">     <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="606"><td class="num" id="LN606">606</td><td class="line">    g_ctx = ctx;</td></tr>
<tr class="codeline" data-linenumber="607"><td class="num" id="LN607">607</td><td class="line"><span class='directive'>#if defined(__OpenBSD__)</span></td></tr>
<tr class="codeline" data-linenumber="608"><td class="num" id="LN608">608</td><td class="line">    mergesort(ctx-&gt;suffix, ctx-&gt;suffixSize, <span class='keyword'>sizeof</span>(U32),</td></tr>
<tr class="codeline" data-linenumber="609"><td class="num" id="LN609">609</td><td class="line">          (ctx-&gt;d &lt;= 8 ? &amp;COVER_strict_cmp8 : &amp;COVER_strict_cmp));</td></tr>
<tr class="codeline" data-linenumber="610"><td class="num" id="LN610">610</td><td class="line"><span class='directive'>#else</span></td></tr>
<tr class="codeline" data-linenumber="611"><td class="num" id="LN611">611</td><td class="line">    qsort(ctx-&gt;suffix, ctx-&gt;suffixSize, <span class='keyword'>sizeof</span>(U32),</td></tr>
<tr class="codeline" data-linenumber="612"><td class="num" id="LN612">612</td><td class="line">          (ctx-&gt;d &lt;= 8 ? &amp;COVER_strict_cmp8 : &amp;COVER_strict_cmp));</td></tr>
<tr class="codeline" data-linenumber="613"><td class="num" id="LN613">613</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="614"><td class="num" id="LN614">614</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="615"><td class="num" id="LN615">615</td><td class="line">  <span class='macro'>DISPLAYLEVEL(2, <span class='string_literal'>"Computing frequencies\n"</span>)<span class='macro_popup'>if (g_displayLevel &gt;= 2) { { fprintf(stderr, "Computing frequencies\n"<br>); fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="616"><td class="num" id="LN616">616</td><td class="line">  <span class='comment'>/* For each dmer group (group of positions with the same first d bytes):</span></td></tr>
<tr class="codeline" data-linenumber="617"><td class="num" id="LN617">617</td><td class="line">   <span class='comment'>* 1. For each position we set dmerAt[position] = dmerID.  The dmerID is</span></td></tr>
<tr class="codeline" data-linenumber="618"><td class="num" id="LN618">618</td><td class="line">   <span class='comment'>*    (groupBeginPtr - suffix).  This allows us to go from position to</span></td></tr>
<tr class="codeline" data-linenumber="619"><td class="num" id="LN619">619</td><td class="line">   <span class='comment'>*    dmerID so we can look up values in freq.</span></td></tr>
<tr class="codeline" data-linenumber="620"><td class="num" id="LN620">620</td><td class="line">   <span class='comment'>* 2. We calculate how many samples the dmer occurs in and save it in</span></td></tr>
<tr class="codeline" data-linenumber="621"><td class="num" id="LN621">621</td><td class="line">   <span class='comment'>*    freqs[dmerId].</span></td></tr>
<tr class="codeline" data-linenumber="622"><td class="num" id="LN622">622</td><td class="line">   <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="623"><td class="num" id="LN623">623</td><td class="line">  COVER_groupBy(ctx-&gt;suffix, ctx-&gt;suffixSize, <span class='keyword'>sizeof</span>(U32), ctx,</td></tr>
<tr class="codeline" data-linenumber="624"><td class="num" id="LN624">624</td><td class="line">                (ctx-&gt;d &lt;= 8 ? &amp;COVER_cmp8 : &amp;COVER_cmp), &amp;COVER_group);</td></tr>
<tr class="codeline" data-linenumber="625"><td class="num" id="LN625">625</td><td class="line">  ctx-&gt;freqs = ctx-&gt;suffix;</td></tr>
<tr class="codeline" data-linenumber="626"><td class="num" id="LN626">626</td><td class="line">  ctx-&gt;suffix = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="627"><td class="num" id="LN627">627</td><td class="line">  <span class='keyword'>return</span> 0;</td></tr>
<tr class="codeline" data-linenumber="628"><td class="num" id="LN628">628</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="629"><td class="num" id="LN629">629</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="630"><td class="num" id="LN630">630</td><td class="line"><span class='keyword'>void</span> COVER_warnOnSmallCorpus(size_t maxDictSize, size_t nbDmers, <span class='keyword'>int</span> displayLevel)</td></tr>
<tr class="codeline" data-linenumber="631"><td class="num" id="LN631">631</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="632"><td class="num" id="LN632">632</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>double</span> ratio = (<span class='keyword'>double</span>)nbDmers / maxDictSize;</td></tr>
<tr class="codeline" data-linenumber="633"><td class="num" id="LN633">633</td><td class="line">  <span class='keyword'>if</span> (ratio &gt;= 10) {</td></tr>
<tr class="codeline" data-linenumber="634"><td class="num" id="LN634">634</td><td class="line">      <span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="635"><td class="num" id="LN635">635</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="636"><td class="num" id="LN636">636</td><td class="line">  <span class='macro'>LOCALDISPLAYLEVEL(displayLevel, 1,<span class='macro_popup'>if (displayLevel &gt;= 1) { { fprintf(stderr, "WARNING: The maximum dictionary size %u is too large "<br> "compared to the source size %u! " "size(source)/size(dictionary) = %f, but it should be &gt;= "<br> "10! This may lead to a subpar dictionary! We recommend " "training on sources at least 10x, and preferably 100x "<br> "the size of the dictionary! \n", (U32)maxDictSize, (U32)nbDmers<br>, ratio); fflush(stderr); }; }</span></span></td></tr>
<tr class="codeline" data-linenumber="637"><td class="num" id="LN637">637</td><td class="line">                    <span class='string_literal'><span class='macro'>"WARNING: The maximum dictionary size %u is too large "<span class='macro_popup'>if (displayLevel &gt;= 1) { { fprintf(stderr, "WARNING: The maximum dictionary size %u is too large "<br> "compared to the source size %u! " "size(source)/size(dictionary) = %f, but it should be &gt;= "<br> "10! This may lead to a subpar dictionary! We recommend " "training on sources at least 10x, and preferably 100x "<br> "the size of the dictionary! \n", (U32)maxDictSize, (U32)nbDmers<br>, ratio); fflush(stderr); }; }</span></span></span></td></tr>
<tr class="codeline" data-linenumber="638"><td class="num" id="LN638">638</td><td class="line">                    <span class='string_literal'><span class='macro'>"compared to the source size %u! "<span class='macro_popup'>if (displayLevel &gt;= 1) { { fprintf(stderr, "WARNING: The maximum dictionary size %u is too large "<br> "compared to the source size %u! " "size(source)/size(dictionary) = %f, but it should be &gt;= "<br> "10! This may lead to a subpar dictionary! We recommend " "training on sources at least 10x, and preferably 100x "<br> "the size of the dictionary! \n", (U32)maxDictSize, (U32)nbDmers<br>, ratio); fflush(stderr); }; }</span></span></span></td></tr>
<tr class="codeline" data-linenumber="639"><td class="num" id="LN639">639</td><td class="line">                    <span class='string_literal'><span class='macro'>"size(source)/size(dictionary) = %f, but it should be &gt;= "<span class='macro_popup'>if (displayLevel &gt;= 1) { { fprintf(stderr, "WARNING: The maximum dictionary size %u is too large "<br> "compared to the source size %u! " "size(source)/size(dictionary) = %f, but it should be &gt;= "<br> "10! This may lead to a subpar dictionary! We recommend " "training on sources at least 10x, and preferably 100x "<br> "the size of the dictionary! \n", (U32)maxDictSize, (U32)nbDmers<br>, ratio); fflush(stderr); }; }</span></span></span></td></tr>
<tr class="codeline" data-linenumber="640"><td class="num" id="LN640">640</td><td class="line">                    <span class='string_literal'><span class='macro'>"10! This may lead to a subpar dictionary! We recommend "<span class='macro_popup'>if (displayLevel &gt;= 1) { { fprintf(stderr, "WARNING: The maximum dictionary size %u is too large "<br> "compared to the source size %u! " "size(source)/size(dictionary) = %f, but it should be &gt;= "<br> "10! This may lead to a subpar dictionary! We recommend " "training on sources at least 10x, and preferably 100x "<br> "the size of the dictionary! \n", (U32)maxDictSize, (U32)nbDmers<br>, ratio); fflush(stderr); }; }</span></span></span></td></tr>
<tr class="codeline" data-linenumber="641"><td class="num" id="LN641">641</td><td class="line">                    <span class='string_literal'><span class='macro'>"training on sources at least 10x, and preferably 100x "<span class='macro_popup'>if (displayLevel &gt;= 1) { { fprintf(stderr, "WARNING: The maximum dictionary size %u is too large "<br> "compared to the source size %u! " "size(source)/size(dictionary) = %f, but it should be &gt;= "<br> "10! This may lead to a subpar dictionary! We recommend " "training on sources at least 10x, and preferably 100x "<br> "the size of the dictionary! \n", (U32)maxDictSize, (U32)nbDmers<br>, ratio); fflush(stderr); }; }</span></span></span></td></tr>
<tr class="codeline" data-linenumber="642"><td class="num" id="LN642">642</td><td class="line">                    <span class='string_literal'><span class='macro'>"the size of the dictionary! \n"</span>, (U32)maxDictSize,<span class='macro_popup'>if (displayLevel &gt;= 1) { { fprintf(stderr, "WARNING: The maximum dictionary size %u is too large "<br> "compared to the source size %u! " "size(source)/size(dictionary) = %f, but it should be &gt;= "<br> "10! This may lead to a subpar dictionary! We recommend " "training on sources at least 10x, and preferably 100x "<br> "the size of the dictionary! \n", (U32)maxDictSize, (U32)nbDmers<br>, ratio); fflush(stderr); }; }</span></span></td></tr>
<tr class="codeline" data-linenumber="643"><td class="num" id="LN643">643</td><td class="line">                    <span class='macro'>(U32)nbDmers, ratio)<span class='macro_popup'>if (displayLevel &gt;= 1) { { fprintf(stderr, "WARNING: The maximum dictionary size %u is too large "<br> "compared to the source size %u! " "size(source)/size(dictionary) = %f, but it should be &gt;= "<br> "10! This may lead to a subpar dictionary! We recommend " "training on sources at least 10x, and preferably 100x "<br> "the size of the dictionary! \n", (U32)maxDictSize, (U32)nbDmers<br>, ratio); fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="644"><td class="num" id="LN644">644</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="645"><td class="num" id="LN645">645</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="646"><td class="num" id="LN646">646</td><td class="line">COVER_epoch_info_t COVER_computeEpochs(U32 maxDictSize,</td></tr>
<tr class="codeline" data-linenumber="647"><td class="num" id="LN647">647</td><td class="line">                                       U32 nbDmers, U32 k, U32 passes)</td></tr>
<tr class="codeline" data-linenumber="648"><td class="num" id="LN648">648</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="649"><td class="num" id="LN649">649</td><td class="line">  <span class='keyword'>const</span> U32 minEpochSize = k * 10;</td></tr>
<tr class="codeline" data-linenumber="650"><td class="num" id="LN650">650</td><td class="line">  COVER_epoch_info_t epochs;</td></tr>
<tr class="codeline" data-linenumber="651"><td class="num" id="LN651">651</td><td class="line">  epochs.num = <span class='macro'>MAX(1, maxDictSize / k / passes)<span class='macro_popup'>((1)&gt;(maxDictSize / k / passes) ? (1) : (maxDictSize / k /<br> passes))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="652"><td class="num" id="LN652">652</td><td class="line">  epochs.size = nbDmers / epochs.num;</td></tr>
<tr class="codeline" data-linenumber="653"><td class="num" id="LN653">653</td><td class="line">  <span class='keyword'>if</span> (epochs.size &gt;= minEpochSize) {</td></tr>
<tr class="codeline" data-linenumber="654"><td class="num" id="LN654">654</td><td class="line">      <span class='macro'>assert(epochs.size * epochs.num &lt;= nbDmers)<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="655"><td class="num" id="LN655">655</td><td class="line">      <span class='keyword'>return</span> epochs;</td></tr>
<tr class="codeline" data-linenumber="656"><td class="num" id="LN656">656</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="657"><td class="num" id="LN657">657</td><td class="line">  epochs.size = <span class='macro'>MIN(minEpochSize, nbDmers)<span class='macro_popup'>((minEpochSize)&lt;(nbDmers) ? (minEpochSize) : (nbDmers))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="658"><td class="num" id="LN658">658</td><td class="line">  epochs.num = nbDmers / epochs.size;</td></tr>
<tr class="codeline" data-linenumber="659"><td class="num" id="LN659">659</td><td class="line">  <span class='macro'>assert(epochs.size * epochs.num &lt;= nbDmers)<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="660"><td class="num" id="LN660">660</td><td class="line">  <span class='keyword'>return</span> epochs;</td></tr>
<tr class="codeline" data-linenumber="661"><td class="num" id="LN661">661</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="662"><td class="num" id="LN662">662</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="663"><td class="num" id="LN663">663</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="664"><td class="num" id="LN664">664</td><td class="line"> <span class='comment'>* Given the prepared context build the dictionary.</span></td></tr>
<tr class="codeline" data-linenumber="665"><td class="num" id="LN665">665</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="666"><td class="num" id="LN666">666</td><td class="line"><span class='keyword'>static</span> size_t COVER_buildDictionary(<span class='keyword'>const</span> COVER_ctx_t *ctx, U32 *freqs,</td></tr>
<tr class="codeline" data-linenumber="667"><td class="num" id="LN667">667</td><td class="line">                                    COVER_map_t *activeDmers, <span class='keyword'>void</span> *dictBuffer,</td></tr>
<tr class="codeline" data-linenumber="668"><td class="num" id="LN668">668</td><td class="line">                                    size_t dictBufferCapacity,</td></tr>
<tr class="codeline" data-linenumber="669"><td class="num" id="LN669">669</td><td class="line">                                    ZDICT_cover_params_t parameters) {</td></tr>
<tr class="codeline" data-linenumber="670"><td class="num" id="LN670">670</td><td class="line">  BYTE *<span class='keyword'>const</span> dict = (BYTE *)dictBuffer;</td></tr>
<tr class="codeline" data-linenumber="671"><td class="num" id="LN671">671</td><td class="line">  size_t tail = dictBufferCapacity;</td></tr>
<tr class="codeline" data-linenumber="672"><td class="num" id="LN672">672</td><td class="line">  <span class='comment'>/* Divide the data into epochs. We will select one segment from each epoch. */</span></td></tr>
<tr class="codeline" data-linenumber="673"><td class="num" id="LN673">673</td><td class="line">  <span class='keyword'>const</span> COVER_epoch_info_t epochs = COVER_computeEpochs(</td></tr>
<tr class="codeline" data-linenumber="674"><td class="num" id="LN674">674</td><td class="line">      (U32)dictBufferCapacity, (U32)ctx-&gt;suffixSize, parameters.k, 4);</td></tr>
<tr class="codeline" data-linenumber="675"><td class="num" id="LN675">675</td><td class="line">  <span class='keyword'>const</span> size_t maxZeroScoreRun = <span class='macro'>MAX(10, MIN(100, epochs.num &gt;&gt; 3))<span class='macro_popup'>((10)&gt;(((100)&lt;(epochs.num &gt;&gt; 3) ? (100) : (epochs<br>.num &gt;&gt; 3))) ? (10) : (((100)&lt;(epochs.num &gt;&gt; 3<br>) ? (100) : (epochs.num &gt;&gt; 3))))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="676"><td class="num" id="LN676">676</td><td class="line">  size_t zeroScoreRun = 0;</td></tr>
<tr class="codeline" data-linenumber="677"><td class="num" id="LN677">677</td><td class="line">  size_t epoch;</td></tr>
<tr class="codeline" data-linenumber="678"><td class="num" id="LN678">678</td><td class="line">  <span class='macro'>DISPLAYLEVEL(2, <span class='string_literal'>"Breaking content into %u epochs of size %u\n"</span>,<span class='macro_popup'>if (g_displayLevel &gt;= 2) { { fprintf(stderr, "Breaking content into %u epochs of size %u\n"<br>, (U32)epochs.num, (U32)epochs.size); fflush(stderr); }; }</span></span></td></tr>
<tr class="codeline" data-linenumber="679"><td class="num" id="LN679">679</td><td class="line">                <span class='macro'>(U32)epochs.num, (U32)epochs.size)<span class='macro_popup'>if (g_displayLevel &gt;= 2) { { fprintf(stderr, "Breaking content into %u epochs of size %u\n"<br>, (U32)epochs.num, (U32)epochs.size); fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="680"><td class="num" id="LN680">680</td><td class="line">  <span class='comment'>/* Loop through the epochs until there are no more segments or the dictionary</span></td></tr>
<tr class="codeline" data-linenumber="681"><td class="num" id="LN681">681</td><td class="line">   <span class='comment'>* is full.</span></td></tr>
<tr class="codeline" data-linenumber="682"><td class="num" id="LN682">682</td><td class="line">   <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="683"><td class="num" id="LN683">683</td><td class="line">  <span class='keyword'>for</span> (epoch = 0; tail &gt; 0; epoch = (epoch + 1) % epochs.num) {</td></tr>
<tr class="codeline" data-linenumber="684"><td class="num" id="LN684">684</td><td class="line">    <span class='keyword'>const</span> U32 epochBegin = (U32)(epoch * epochs.size);</td></tr>
<tr class="codeline" data-linenumber="685"><td class="num" id="LN685">685</td><td class="line">    <span class='keyword'>const</span> U32 epochEnd = epochBegin + epochs.size;</td></tr>
<tr class="codeline" data-linenumber="686"><td class="num" id="LN686">686</td><td class="line">    size_t segmentSize;</td></tr>
<tr class="codeline" data-linenumber="687"><td class="num" id="LN687">687</td><td class="line">    <span class='comment'>/* Select a segment */</span></td></tr>
<tr class="codeline" data-linenumber="688"><td class="num" id="LN688">688</td><td class="line">    COVER_segment_t segment = COVER_selectSegment(</td></tr>
<tr class="codeline" data-linenumber="689"><td class="num" id="LN689">689</td><td class="line">        ctx, freqs, activeDmers, epochBegin, epochEnd, parameters);</td></tr>
<tr class="codeline" data-linenumber="690"><td class="num" id="LN690">690</td><td class="line">    <span class='comment'>/* If the segment covers no dmers, then we are out of content.</span></td></tr>
<tr class="codeline" data-linenumber="691"><td class="num" id="LN691">691</td><td class="line">     <span class='comment'>* There may be new content in other epochs, for continue for some time.</span></td></tr>
<tr class="codeline" data-linenumber="692"><td class="num" id="LN692">692</td><td class="line">     <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="693"><td class="num" id="LN693">693</td><td class="line">    <span class='keyword'>if</span> (segment.score == 0) {</td></tr>
<tr class="codeline" data-linenumber="694"><td class="num" id="LN694">694</td><td class="line">      <span class='keyword'>if</span> (++zeroScoreRun &gt;= maxZeroScoreRun) {</td></tr>
<tr class="codeline" data-linenumber="695"><td class="num" id="LN695">695</td><td class="line">          <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="696"><td class="num" id="LN696">696</td><td class="line">      }</td></tr>
<tr class="codeline" data-linenumber="697"><td class="num" id="LN697">697</td><td class="line">      <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="698"><td class="num" id="LN698">698</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="699"><td class="num" id="LN699">699</td><td class="line">    zeroScoreRun = 0;</td></tr>
<tr class="codeline" data-linenumber="700"><td class="num" id="LN700">700</td><td class="line">    <span class='comment'>/* Trim the segment if necessary and if it is too small then we are done */</span></td></tr>
<tr class="codeline" data-linenumber="701"><td class="num" id="LN701">701</td><td class="line">    segmentSize = <span class='macro'>MIN(segment.end - segment.begin + parameters.d - 1, tail)<span class='macro_popup'>((segment.end - segment.begin + parameters.d - 1)&lt;(tail) ?<br> (segment.end - segment.begin + parameters.d - 1) : (tail))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="702"><td class="num" id="LN702">702</td><td class="line">    <span class='keyword'>if</span> (segmentSize &lt; parameters.d) {</td></tr>
<tr class="codeline" data-linenumber="703"><td class="num" id="LN703">703</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr class="codeline" data-linenumber="704"><td class="num" id="LN704">704</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="705"><td class="num" id="LN705">705</td><td class="line">    <span class='comment'>/* We fill the dictionary from the back to allow the best segments to be</span></td></tr>
<tr class="codeline" data-linenumber="706"><td class="num" id="LN706">706</td><td class="line">     <span class='comment'>* referenced with the smallest offsets.</span></td></tr>
<tr class="codeline" data-linenumber="707"><td class="num" id="LN707">707</td><td class="line">     <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="708"><td class="num" id="LN708">708</td><td class="line">    tail -= segmentSize;</td></tr>
<tr class="codeline" data-linenumber="709"><td class="num" id="LN709">709</td><td class="line">    memcpy(dict + tail, ctx-&gt;samples + segment.begin, segmentSize);</td></tr>
<tr class="codeline" data-linenumber="710"><td class="num" id="LN710">710</td><td class="line">    <span class='macro'>DISPLAYUPDATE(<span class='macro_popup'>if (g_displayLevel &gt;= 2) { if ((clock() - g_time &gt; refreshRate<br>) || (g_displayLevel &gt;= 4)) { g_time = clock(); { fprintf(<br>stderr, "\r%u%%       ", (unsigned)(((dictBufferCapacity - tail<br>) * 100) / dictBufferCapacity)); fflush(stderr); }; } }</span></span></td></tr>
<tr class="codeline" data-linenumber="711"><td class="num" id="LN711">711</td><td class="line">        <span class='macro'>2, <span class='string_literal'>"\r%u%%       "</span>,<span class='macro_popup'>if (g_displayLevel &gt;= 2) { if ((clock() - g_time &gt; refreshRate<br>) || (g_displayLevel &gt;= 4)) { g_time = clock(); { fprintf(<br>stderr, "\r%u%%       ", (unsigned)(((dictBufferCapacity - tail<br>) * 100) / dictBufferCapacity)); fflush(stderr); }; } }</span></span></td></tr>
<tr class="codeline" data-linenumber="712"><td class="num" id="LN712">712</td><td class="line">        <span class='macro'>(<span class='keyword'>unsigned</span>)(((dictBufferCapacity - tail) * 100) / dictBufferCapacity))<span class='macro_popup'>if (g_displayLevel &gt;= 2) { if ((clock() - g_time &gt; refreshRate<br>) || (g_displayLevel &gt;= 4)) { g_time = clock(); { fprintf(<br>stderr, "\r%u%%       ", (unsigned)(((dictBufferCapacity - tail<br>) * 100) / dictBufferCapacity)); fflush(stderr); }; } }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="713"><td class="num" id="LN713">713</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="714"><td class="num" id="LN714">714</td><td class="line">  <span class='macro'>DISPLAYLEVEL(2, <span class='string_literal'>"\r%79s\r"</span>, <span class='string_literal'>""</span>)<span class='macro_popup'>if (g_displayLevel &gt;= 2) { { fprintf(stderr, "\r%79s\r", ""<br>); fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="715"><td class="num" id="LN715">715</td><td class="line">  <span class='keyword'>return</span> tail;</td></tr>
<tr class="codeline" data-linenumber="716"><td class="num" id="LN716">716</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="717"><td class="num" id="LN717">717</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="718"><td class="num" id="LN718">718</td><td class="line"><span class='macro'>ZDICTLIB_API<span class='macro_popup'>__attribute__ ((visibility ("default")))</span></span> size_t ZDICT_trainFromBuffer_cover(</td></tr>
<tr class="codeline" data-linenumber="719"><td class="num" id="LN719">719</td><td class="line">    <span class='keyword'>void</span> *dictBuffer, size_t dictBufferCapacity,</td></tr>
<tr class="codeline" data-linenumber="720"><td class="num" id="LN720">720</td><td class="line">    <span class='keyword'>const</span> <span class='keyword'>void</span> *samplesBuffer, <span class='keyword'>const</span> size_t *samplesSizes, <span class='keyword'>unsigned</span> nbSamples,</td></tr>
<tr class="codeline" data-linenumber="721"><td class="num" id="LN721">721</td><td class="line">    ZDICT_cover_params_t parameters)</td></tr>
<tr class="codeline" data-linenumber="722"><td class="num" id="LN722">722</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="723"><td class="num" id="LN723">723</td><td class="line">  BYTE* <span class='keyword'>const</span> dict = (BYTE*)dictBuffer;</td></tr>
<tr class="codeline" data-linenumber="724"><td class="num" id="LN724">724</td><td class="line">  COVER_ctx_t ctx;</td></tr>
<tr class="codeline" data-linenumber="725"><td class="num" id="LN725">725</td><td class="line">  COVER_map_t activeDmers;</td></tr>
<tr class="codeline" data-linenumber="726"><td class="num" id="LN726">726</td><td class="line">  parameters.splitPoint = 1.0;</td></tr>
<tr class="codeline" data-linenumber="727"><td class="num" id="LN727">727</td><td class="line">  <span class='comment'>/* Initialize global data */</span></td></tr>
<tr class="codeline" data-linenumber="728"><td class="num" id="LN728">728</td><td class="line">  g_displayLevel = parameters.zParams.notificationLevel;</td></tr>
<tr class="codeline" data-linenumber="729"><td class="num" id="LN729">729</td><td class="line">  <span class='comment'>/* Checks */</span></td></tr>
<tr class="codeline" data-linenumber="730"><td class="num" id="LN730">730</td><td class="line">  <span class='keyword'>if</span> (!COVER_checkParameters(parameters, dictBufferCapacity)) {</td></tr>
<tr class="codeline" data-linenumber="731"><td class="num" id="LN731">731</td><td class="line">    <span class='macro'>DISPLAYLEVEL(1, <span class='string_literal'>"Cover parameters incorrect\n"</span>)<span class='macro_popup'>if (g_displayLevel &gt;= 1) { { fprintf(stderr, "Cover parameters incorrect\n"<br>); fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="732"><td class="num" id="LN732">732</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>ERROR(parameter_outOfBound)<span class='macro_popup'>((size_t)-ZSTD_error_parameter_outOfBound)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="733"><td class="num" id="LN733">733</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="734"><td class="num" id="LN734">734</td><td class="line">  <span class='keyword'>if</span> (nbSamples == 0) {</td></tr>
<tr class="codeline" data-linenumber="735"><td class="num" id="LN735">735</td><td class="line">    <span class='macro'>DISPLAYLEVEL(1, <span class='string_literal'>"Cover must have at least one input file\n"</span>)<span class='macro_popup'>if (g_displayLevel &gt;= 1) { { fprintf(stderr, "Cover must have at least one input file\n"<br>); fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="736"><td class="num" id="LN736">736</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>ERROR(srcSize_wrong)<span class='macro_popup'>((size_t)-ZSTD_error_srcSize_wrong)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="737"><td class="num" id="LN737">737</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="738"><td class="num" id="LN738">738</td><td class="line">  <span class='keyword'>if</span> (dictBufferCapacity &lt; <span class='macro'>ZDICT_DICTSIZE_MIN<span class='macro_popup'>256</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="739"><td class="num" id="LN739">739</td><td class="line">    <span class='macro'>DISPLAYLEVEL(1, <span class='string_literal'>"dictBufferCapacity must be at least %u\n"</span>,<span class='macro_popup'>if (g_displayLevel &gt;= 1) { { fprintf(stderr, "dictBufferCapacity must be at least %u\n"<br>, 256); fflush(stderr); }; }</span></span></td></tr>
<tr class="codeline" data-linenumber="740"><td class="num" id="LN740">740</td><td class="line">                 <span class='macro'>ZDICT_DICTSIZE_MIN)<span class='macro_popup'>if (g_displayLevel &gt;= 1) { { fprintf(stderr, "dictBufferCapacity must be at least %u\n"<br>, 256); fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="741"><td class="num" id="LN741">741</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>ERROR(dstSize_tooSmall)<span class='macro_popup'>((size_t)-ZSTD_error_dstSize_tooSmall)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="742"><td class="num" id="LN742">742</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="743"><td class="num" id="LN743">743</td><td class="line">  <span class='comment'>/* Initialize context and activeDmers */</span></td></tr>
<tr class="codeline" data-linenumber="744"><td class="num" id="LN744">744</td><td class="line">  {</td></tr>
<tr class="codeline" data-linenumber="745"><td class="num" id="LN745">745</td><td class="line">    size_t <span class='keyword'>const</span> initVal = COVER_ctx_init(&amp;ctx, samplesBuffer, samplesSizes, nbSamples,</td></tr>
<tr class="codeline" data-linenumber="746"><td class="num" id="LN746">746</td><td class="line">                      parameters.d, parameters.splitPoint);</td></tr>
<tr class="codeline" data-linenumber="747"><td class="num" id="LN747">747</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>ZSTD_isError<span class='macro_popup'>ERR_isError</span></span>(initVal)) {</td></tr>
<tr class="codeline" data-linenumber="748"><td class="num" id="LN748">748</td><td class="line">      <span class='keyword'>return</span> initVal;</td></tr>
<tr class="codeline" data-linenumber="749"><td class="num" id="LN749">749</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="750"><td class="num" id="LN750">750</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="751"><td class="num" id="LN751">751</td><td class="line">  COVER_warnOnSmallCorpus(dictBufferCapacity, ctx.suffixSize, g_displayLevel);</td></tr>
<tr class="codeline" data-linenumber="752"><td class="num" id="LN752">752</td><td class="line">  <span class='keyword'>if</span> (!COVER_map_init(&amp;activeDmers, parameters.k - parameters.d + 1)) {</td></tr>
<tr class="codeline" data-linenumber="753"><td class="num" id="LN753">753</td><td class="line">    <span class='macro'>DISPLAYLEVEL(1, <span class='string_literal'>"Failed to allocate dmer map: out of memory\n"</span>)<span class='macro_popup'>if (g_displayLevel &gt;= 1) { { fprintf(stderr, "Failed to allocate dmer map: out of memory\n"<br>); fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="754"><td class="num" id="LN754">754</td><td class="line">    COVER_ctx_destroy(&amp;ctx);</td></tr>
<tr class="codeline" data-linenumber="755"><td class="num" id="LN755">755</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>ERROR(memory_allocation)<span class='macro_popup'>((size_t)-ZSTD_error_memory_allocation)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="756"><td class="num" id="LN756">756</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="757"><td class="num" id="LN757">757</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="758"><td class="num" id="LN758">758</td><td class="line">  <span class='macro'>DISPLAYLEVEL(2, <span class='string_literal'>"Building dictionary\n"</span>)<span class='macro_popup'>if (g_displayLevel &gt;= 2) { { fprintf(stderr, "Building dictionary\n"<br>); fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="759"><td class="num" id="LN759">759</td><td class="line">  {</td></tr>
<tr class="codeline" data-linenumber="760"><td class="num" id="LN760">760</td><td class="line">    <span class='keyword'>const</span> size_t tail =</td></tr>
<tr class="codeline" data-linenumber="761"><td class="num" id="LN761">761</td><td class="line">        COVER_buildDictionary(&amp;ctx, ctx.freqs, &amp;activeDmers, dictBuffer,</td></tr>
<tr class="codeline" data-linenumber="762"><td class="num" id="LN762">762</td><td class="line">                              dictBufferCapacity, parameters);</td></tr>
<tr class="codeline" data-linenumber="763"><td class="num" id="LN763">763</td><td class="line">    <span class='keyword'>const</span> size_t dictionarySize = ZDICT_finalizeDictionary(</td></tr>
<tr class="codeline" data-linenumber="764"><td class="num" id="LN764">764</td><td class="line">        dict, dictBufferCapacity, dict + tail, dictBufferCapacity - tail,</td></tr>
<tr class="codeline" data-linenumber="765"><td class="num" id="LN765">765</td><td class="line">        samplesBuffer, samplesSizes, nbSamples, parameters.zParams);</td></tr>
<tr class="codeline" data-linenumber="766"><td class="num" id="LN766">766</td><td class="line">    <span class='keyword'>if</span> (!<span class='macro'>ZSTD_isError<span class='macro_popup'>ERR_isError</span></span>(dictionarySize)) {</td></tr>
<tr class="codeline" data-linenumber="767"><td class="num" id="LN767">767</td><td class="line">      <span class='macro'>DISPLAYLEVEL(2, <span class='string_literal'>"Constructed dictionary of size %u\n"</span>,<span class='macro_popup'>if (g_displayLevel &gt;= 2) { { fprintf(stderr, "Constructed dictionary of size %u\n"<br>, (unsigned)dictionarySize); fflush(stderr); }; }</span></span></td></tr>
<tr class="codeline" data-linenumber="768"><td class="num" id="LN768">768</td><td class="line">                   <span class='macro'>(<span class='keyword'>unsigned</span>)dictionarySize)<span class='macro_popup'>if (g_displayLevel &gt;= 2) { { fprintf(stderr, "Constructed dictionary of size %u\n"<br>, (unsigned)dictionarySize); fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="769"><td class="num" id="LN769">769</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="770"><td class="num" id="LN770">770</td><td class="line">    COVER_ctx_destroy(&amp;ctx);</td></tr>
<tr class="codeline" data-linenumber="771"><td class="num" id="LN771">771</td><td class="line">    COVER_map_destroy(&amp;activeDmers);</td></tr>
<tr class="codeline" data-linenumber="772"><td class="num" id="LN772">772</td><td class="line">    <span class='keyword'>return</span> dictionarySize;</td></tr>
<tr class="codeline" data-linenumber="773"><td class="num" id="LN773">773</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="774"><td class="num" id="LN774">774</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="775"><td class="num" id="LN775">775</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="776"><td class="num" id="LN776">776</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="777"><td class="num" id="LN777">777</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="778"><td class="num" id="LN778">778</td><td class="line">size_t COVER_checkTotalCompressedSize(<span class='keyword'>const</span> ZDICT_cover_params_t parameters,</td></tr>
<tr class="codeline" data-linenumber="779"><td class="num" id="LN779">779</td><td class="line">                                    <span class='keyword'>const</span> size_t *samplesSizes, <span class='keyword'>const</span> BYTE *samples,</td></tr>
<tr class="codeline" data-linenumber="780"><td class="num" id="LN780">780</td><td class="line">                                    size_t *offsets,</td></tr>
<tr class="codeline" data-linenumber="781"><td class="num" id="LN781">781</td><td class="line">                                    size_t nbTrainSamples, size_t nbSamples,</td></tr>
<tr class="codeline" data-linenumber="782"><td class="num" id="LN782">782</td><td class="line">                                    BYTE *<span class='keyword'>const</span> dict, size_t dictBufferCapacity) {</td></tr>
<tr class="codeline" data-linenumber="783"><td class="num" id="LN783">783</td><td class="line">  size_t totalCompressedSize = <span class='macro'>ERROR(GENERIC)<span class='macro_popup'>((size_t)-ZSTD_error_GENERIC)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="784"><td class="num" id="LN784">784</td><td class="line">  <span class='comment'>/* Pointers */</span></td></tr>
<tr class="codeline" data-linenumber="785"><td class="num" id="LN785">785</td><td class="line">  ZSTD_CCtx *cctx;</td></tr>
<tr class="codeline" data-linenumber="786"><td class="num" id="LN786">786</td><td class="line">  ZSTD_CDict *cdict;</td></tr>
<tr class="codeline" data-linenumber="787"><td class="num" id="LN787">787</td><td class="line">  <span class='keyword'>void</span> *dst;</td></tr>
<tr class="codeline" data-linenumber="788"><td class="num" id="LN788">788</td><td class="line">  <span class='comment'>/* Local variables */</span></td></tr>
<tr class="codeline" data-linenumber="789"><td class="num" id="LN789">789</td><td class="line">  size_t dstCapacity;</td></tr>
<tr class="codeline" data-linenumber="790"><td class="num" id="LN790">790</td><td class="line">  size_t i;</td></tr>
<tr class="codeline" data-linenumber="791"><td class="num" id="LN791">791</td><td class="line">  <span class='comment'>/* Allocate dst with enough space to compress the maximum sized sample */</span></td></tr>
<tr class="codeline" data-linenumber="792"><td class="num" id="LN792">792</td><td class="line">  {</td></tr>
<tr class="codeline" data-linenumber="793"><td class="num" id="LN793">793</td><td class="line">    size_t maxSampleSize = 0;</td></tr>
<tr class="codeline" data-linenumber="794"><td class="num" id="LN794">794</td><td class="line">    i = parameters.splitPoint &lt; 1.0 ? nbTrainSamples : 0;</td></tr>
<tr class="codeline" data-linenumber="795"><td class="num" id="LN795">795</td><td class="line">    <span class='keyword'>for</span> (; i &lt; nbSamples; ++i) {</td></tr>
<tr class="codeline" data-linenumber="796"><td class="num" id="LN796">796</td><td class="line">      maxSampleSize = <span class='macro'>MAX(samplesSizes[i], maxSampleSize)<span class='macro_popup'>((samplesSizes[i])&gt;(maxSampleSize) ? (samplesSizes[i]) : (<br>maxSampleSize))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="797"><td class="num" id="LN797">797</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="798"><td class="num" id="LN798">798</td><td class="line">    dstCapacity = ZSTD_compressBound(maxSampleSize);</td></tr>
<tr class="codeline" data-linenumber="799"><td class="num" id="LN799">799</td><td class="line">    dst = malloc(dstCapacity);</td></tr>
<tr class="codeline" data-linenumber="800"><td class="num" id="LN800">800</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="801"><td class="num" id="LN801">801</td><td class="line">  <span class='comment'>/* Create the cctx and cdict */</span></td></tr>
<tr class="codeline" data-linenumber="802"><td class="num" id="LN802">802</td><td class="line">  cctx = ZSTD_createCCtx();</td></tr>
<tr class="codeline" data-linenumber="803"><td class="num" id="LN803">803</td><td class="line">  cdict = ZSTD_createCDict(dict, dictBufferCapacity,</td></tr>
<tr class="codeline" data-linenumber="804"><td class="num" id="LN804">804</td><td class="line">                           parameters.zParams.compressionLevel);</td></tr>
<tr class="codeline" data-linenumber="805"><td class="num" id="LN805">805</td><td class="line">  <span class='keyword'>if</span> (!dst || !cctx || !cdict) {</td></tr>
<tr class="codeline" data-linenumber="806"><td class="num" id="LN806">806</td><td class="line">    <span class='keyword'>goto</span> _compressCleanup;</td></tr>
<tr class="codeline" data-linenumber="807"><td class="num" id="LN807">807</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="808"><td class="num" id="LN808">808</td><td class="line">  <span class='comment'>/* Compress each sample and sum their sizes (or error) */</span></td></tr>
<tr class="codeline" data-linenumber="809"><td class="num" id="LN809">809</td><td class="line">  totalCompressedSize = dictBufferCapacity;</td></tr>
<tr class="codeline" data-linenumber="810"><td class="num" id="LN810">810</td><td class="line">  i = parameters.splitPoint &lt; 1.0 ? nbTrainSamples : 0;</td></tr>
<tr class="codeline" data-linenumber="811"><td class="num" id="LN811">811</td><td class="line">  <span class='keyword'>for</span> (; i &lt; nbSamples; ++i) {</td></tr>
<tr class="codeline" data-linenumber="812"><td class="num" id="LN812">812</td><td class="line">    <span class='keyword'>const</span> size_t size = ZSTD_compress_usingCDict(</td></tr>
<tr class="codeline" data-linenumber="813"><td class="num" id="LN813">813</td><td class="line">        cctx, dst, dstCapacity, samples + offsets[i],</td></tr>
<tr class="codeline" data-linenumber="814"><td class="num" id="LN814">814</td><td class="line">        samplesSizes[i], cdict);</td></tr>
<tr class="codeline" data-linenumber="815"><td class="num" id="LN815">815</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>ZSTD_isError<span class='macro_popup'>ERR_isError</span></span>(size)) {</td></tr>
<tr class="codeline" data-linenumber="816"><td class="num" id="LN816">816</td><td class="line">      totalCompressedSize = size;</td></tr>
<tr class="codeline" data-linenumber="817"><td class="num" id="LN817">817</td><td class="line">      <span class='keyword'>goto</span> _compressCleanup;</td></tr>
<tr class="codeline" data-linenumber="818"><td class="num" id="LN818">818</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="819"><td class="num" id="LN819">819</td><td class="line">    totalCompressedSize += size;</td></tr>
<tr class="codeline" data-linenumber="820"><td class="num" id="LN820">820</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="821"><td class="num" id="LN821">821</td><td class="line">_compressCleanup:</td></tr>
<tr class="codeline" data-linenumber="822"><td class="num" id="LN822">822</td><td class="line">  ZSTD_freeCCtx(cctx);</td></tr>
<tr class="codeline" data-linenumber="823"><td class="num" id="LN823">823</td><td class="line">  ZSTD_freeCDict(cdict);</td></tr>
<tr class="codeline" data-linenumber="824"><td class="num" id="LN824">824</td><td class="line">  <span class='keyword'>if</span> (dst) {</td></tr>
<tr class="codeline" data-linenumber="825"><td class="num" id="LN825">825</td><td class="line">    free(dst);</td></tr>
<tr class="codeline" data-linenumber="826"><td class="num" id="LN826">826</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="827"><td class="num" id="LN827">827</td><td class="line">  <span class='keyword'>return</span> totalCompressedSize;</td></tr>
<tr class="codeline" data-linenumber="828"><td class="num" id="LN828">828</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="829"><td class="num" id="LN829">829</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="830"><td class="num" id="LN830">830</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="831"><td class="num" id="LN831">831</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="832"><td class="num" id="LN832">832</td><td class="line"> <span class='comment'>* Initialize the `COVER_best_t`.</span></td></tr>
<tr class="codeline" data-linenumber="833"><td class="num" id="LN833">833</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="834"><td class="num" id="LN834">834</td><td class="line"><span class='keyword'>void</span> COVER_best_init(COVER_best_t *best) {</td></tr>
<tr class="codeline" data-linenumber="835"><td class="num" id="LN835">835</td><td class="line">  <span class='keyword'>if</span> (best==<span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>) <span class='keyword'>return</span>; <span class='comment'>/* compatible with init on NULL */</span></td></tr>
<tr class="codeline" data-linenumber="836"><td class="num" id="LN836">836</td><td class="line">  (<span class='keyword'>void</span>)<span class='macro'>ZSTD_pthread_mutex_init(&amp;best-&gt;mutex, NULL)<span class='macro_popup'>pthread_mutex_init((&amp;best-&gt;mutex), (((void*)0)))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="837"><td class="num" id="LN837">837</td><td class="line">  (<span class='keyword'>void</span>)<span class='macro'>ZSTD_pthread_cond_init(&amp;best-&gt;cond, NULL)<span class='macro_popup'>pthread_cond_init((&amp;best-&gt;cond), (((void*)0)))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="838"><td class="num" id="LN838">838</td><td class="line">  best-&gt;liveJobs = 0;</td></tr>
<tr class="codeline" data-linenumber="839"><td class="num" id="LN839">839</td><td class="line">  best-&gt;dict = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="840"><td class="num" id="LN840">840</td><td class="line">  best-&gt;dictSize = 0;</td></tr>
<tr class="codeline" data-linenumber="841"><td class="num" id="LN841">841</td><td class="line">  best-&gt;compressedSize = (size_t)-1;</td></tr>
<tr class="codeline" data-linenumber="842"><td class="num" id="LN842">842</td><td class="line">  memset(&amp;best-&gt;parameters, 0, <span class='keyword'>sizeof</span>(best-&gt;parameters));</td></tr>
<tr class="codeline" data-linenumber="843"><td class="num" id="LN843">843</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="844"><td class="num" id="LN844">844</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="845"><td class="num" id="LN845">845</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="846"><td class="num" id="LN846">846</td><td class="line"> <span class='comment'>* Wait until liveJobs == 0.</span></td></tr>
<tr class="codeline" data-linenumber="847"><td class="num" id="LN847">847</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="848"><td class="num" id="LN848">848</td><td class="line"><span class='keyword'>void</span> COVER_best_wait(COVER_best_t *best) {</td></tr>
<tr class="codeline" data-linenumber="849"><td class="num" id="LN849">849</td><td class="line">  <span class='keyword'>if</span> (!best) {</td></tr>
<tr class="codeline" data-linenumber="850"><td class="num" id="LN850">850</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="851"><td class="num" id="LN851">851</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="852"><td class="num" id="LN852">852</td><td class="line">  <span class='macro'>ZSTD_pthread_mutex_lock(&amp;best-&gt;mutex)<span class='macro_popup'>pthread_mutex_lock((&amp;best-&gt;mutex))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="853"><td class="num" id="LN853">853</td><td class="line">  <span class='keyword'>while</span> (best-&gt;liveJobs != 0) {</td></tr>
<tr class="codeline" data-linenumber="854"><td class="num" id="LN854">854</td><td class="line">    <span class='macro'>ZSTD_pthread_cond_wait(&amp;best-&gt;cond, &amp;best-&gt;mutex)<span class='macro_popup'>pthread_cond_wait((&amp;best-&gt;cond), (&amp;best-&gt;mutex)<br>)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="855"><td class="num" id="LN855">855</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="856"><td class="num" id="LN856">856</td><td class="line">  <span class='macro'>ZSTD_pthread_mutex_unlock(&amp;best-&gt;mutex)<span class='macro_popup'>pthread_mutex_unlock((&amp;best-&gt;mutex))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="857"><td class="num" id="LN857">857</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="858"><td class="num" id="LN858">858</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="859"><td class="num" id="LN859">859</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="860"><td class="num" id="LN860">860</td><td class="line"> <span class='comment'>* Call COVER_best_wait() and then destroy the COVER_best_t.</span></td></tr>
<tr class="codeline" data-linenumber="861"><td class="num" id="LN861">861</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="862"><td class="num" id="LN862">862</td><td class="line"><span class='keyword'>void</span> COVER_best_destroy(COVER_best_t *best) {</td></tr>
<tr class="codeline" data-linenumber="863"><td class="num" id="LN863">863</td><td class="line">  <span class='keyword'>if</span> (!best) {</td></tr>
<tr class="codeline" data-linenumber="864"><td class="num" id="LN864">864</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="865"><td class="num" id="LN865">865</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="866"><td class="num" id="LN866">866</td><td class="line">  COVER_best_wait(best);</td></tr>
<tr class="codeline" data-linenumber="867"><td class="num" id="LN867">867</td><td class="line">  <span class='keyword'>if</span> (best-&gt;dict) {</td></tr>
<tr class="codeline" data-linenumber="868"><td class="num" id="LN868">868</td><td class="line">    free(best-&gt;dict);</td></tr>
<tr class="codeline" data-linenumber="869"><td class="num" id="LN869">869</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="870"><td class="num" id="LN870">870</td><td class="line">  <span class='macro'>ZSTD_pthread_mutex_destroy(&amp;best-&gt;mutex)<span class='macro_popup'>pthread_mutex_destroy((&amp;best-&gt;mutex))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="871"><td class="num" id="LN871">871</td><td class="line">  <span class='macro'>ZSTD_pthread_cond_destroy(&amp;best-&gt;cond)<span class='macro_popup'>pthread_cond_destroy((&amp;best-&gt;cond))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="872"><td class="num" id="LN872">872</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="873"><td class="num" id="LN873">873</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="874"><td class="num" id="LN874">874</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="875"><td class="num" id="LN875">875</td><td class="line"> <span class='comment'>* Called when a thread is about to be launched.</span></td></tr>
<tr class="codeline" data-linenumber="876"><td class="num" id="LN876">876</td><td class="line"> <span class='comment'>* Increments liveJobs.</span></td></tr>
<tr class="codeline" data-linenumber="877"><td class="num" id="LN877">877</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="878"><td class="num" id="LN878">878</td><td class="line"><span class='keyword'>void</span> COVER_best_start(COVER_best_t *best) {</td></tr>
<tr class="codeline" data-linenumber="879"><td class="num" id="LN879">879</td><td class="line">  <span class='keyword'>if</span> (!best) {</td></tr>
<tr class="codeline" data-linenumber="880"><td class="num" id="LN880">880</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="881"><td class="num" id="LN881">881</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="882"><td class="num" id="LN882">882</td><td class="line">  <span class='macro'>ZSTD_pthread_mutex_lock(&amp;best-&gt;mutex)<span class='macro_popup'>pthread_mutex_lock((&amp;best-&gt;mutex))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="883"><td class="num" id="LN883">883</td><td class="line">  ++best-&gt;liveJobs;</td></tr>
<tr class="codeline" data-linenumber="884"><td class="num" id="LN884">884</td><td class="line">  <span class='macro'>ZSTD_pthread_mutex_unlock(&amp;best-&gt;mutex)<span class='macro_popup'>pthread_mutex_unlock((&amp;best-&gt;mutex))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="885"><td class="num" id="LN885">885</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="886"><td class="num" id="LN886">886</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="887"><td class="num" id="LN887">887</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="888"><td class="num" id="LN888">888</td><td class="line"> <span class='comment'>* Called when a thread finishes executing, both on error or success.</span></td></tr>
<tr class="codeline" data-linenumber="889"><td class="num" id="LN889">889</td><td class="line"> <span class='comment'>* Decrements liveJobs and signals any waiting threads if liveJobs == 0.</span></td></tr>
<tr class="codeline" data-linenumber="890"><td class="num" id="LN890">890</td><td class="line"> <span class='comment'>* If this dictionary is the best so far save it and its parameters.</span></td></tr>
<tr class="codeline" data-linenumber="891"><td class="num" id="LN891">891</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="892"><td class="num" id="LN892">892</td><td class="line"><span class='keyword'>void</span> COVER_best_finish(COVER_best_t *best, ZDICT_cover_params_t parameters,</td></tr>
<tr class="codeline" data-linenumber="893"><td class="num" id="LN893">893</td><td class="line">                              COVER_dictSelection_t selection) {</td></tr>
<tr class="codeline" data-linenumber="894"><td class="num" id="LN894">894</td><td class="line">  <span class='keyword'>void</span>* dict = selection.dictContent;</td></tr>
<tr class="codeline" data-linenumber="895"><td class="num" id="LN895">895</td><td class="line">  size_t compressedSize = selection.totalCompressedSize;</td></tr>
<tr class="codeline" data-linenumber="896"><td class="num" id="LN896">896</td><td class="line">  size_t dictSize = selection.dictSize;</td></tr>
<tr class="codeline" data-linenumber="897"><td class="num" id="LN897">897</td><td class="line">  <span class='keyword'>if</span> (!best) {</td></tr>
<tr class="codeline" data-linenumber="898"><td class="num" id="LN898">898</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="899"><td class="num" id="LN899">899</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="900"><td class="num" id="LN900">900</td><td class="line">  {</td></tr>
<tr class="codeline" data-linenumber="901"><td class="num" id="LN901">901</td><td class="line">    size_t liveJobs;</td></tr>
<tr class="codeline" data-linenumber="902"><td class="num" id="LN902">902</td><td class="line">    <span class='macro'>ZSTD_pthread_mutex_lock(&amp;best-&gt;mutex)<span class='macro_popup'>pthread_mutex_lock((&amp;best-&gt;mutex))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="903"><td class="num" id="LN903">903</td><td class="line">    --best-&gt;liveJobs;</td></tr>
<tr class="codeline" data-linenumber="904"><td class="num" id="LN904">904</td><td class="line">    liveJobs = best-&gt;liveJobs;</td></tr>
<tr class="codeline" data-linenumber="905"><td class="num" id="LN905">905</td><td class="line">    <span class='comment'>/* If the new dictionary is better */</span></td></tr>
<tr class="codeline" data-linenumber="906"><td class="num" id="LN906">906</td><td class="line">    <span class='keyword'>if</span> (compressedSize &lt; best-&gt;compressedSize) {</td></tr>
<tr class="codeline" data-linenumber="907"><td class="num" id="LN907">907</td><td class="line">      <span class='comment'>/* Allocate space if necessary */</span></td></tr>
<tr class="codeline" data-linenumber="908"><td class="num" id="LN908">908</td><td class="line">      <span class='keyword'>if</span> (!best-&gt;dict || best-&gt;dictSize &lt; dictSize) {</td></tr>
<tr class="codeline" data-linenumber="909"><td class="num" id="LN909">909</td><td class="line">        <span class='keyword'>if</span> (best-&gt;dict) {</td></tr>
<tr class="codeline" data-linenumber="910"><td class="num" id="LN910">910</td><td class="line">          free(best-&gt;dict);</td></tr>
<tr class="codeline" data-linenumber="911"><td class="num" id="LN911">911</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="912"><td class="num" id="LN912">912</td><td class="line">        best-&gt;dict = malloc(dictSize);</td></tr>
<tr class="codeline" data-linenumber="913"><td class="num" id="LN913">913</td><td class="line">        <span class='keyword'>if</span> (!best-&gt;dict) {</td></tr>
<tr class="codeline" data-linenumber="914"><td class="num" id="LN914">914</td><td class="line">          best-&gt;compressedSize = <span class='macro'>ERROR(GENERIC)<span class='macro_popup'>((size_t)-ZSTD_error_GENERIC)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="915"><td class="num" id="LN915">915</td><td class="line">          best-&gt;dictSize = 0;</td></tr>
<tr class="codeline" data-linenumber="916"><td class="num" id="LN916">916</td><td class="line">          <span class='macro'>ZSTD_pthread_cond_signal(&amp;best-&gt;cond)<span class='macro_popup'>pthread_cond_signal((&amp;best-&gt;cond))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="917"><td class="num" id="LN917">917</td><td class="line">          <span class='macro'>ZSTD_pthread_mutex_unlock(&amp;best-&gt;mutex)<span class='macro_popup'>pthread_mutex_unlock((&amp;best-&gt;mutex))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="918"><td class="num" id="LN918">918</td><td class="line">          <span class='keyword'>return</span>;</td></tr>
<tr class="codeline" data-linenumber="919"><td class="num" id="LN919">919</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="920"><td class="num" id="LN920">920</td><td class="line">      }</td></tr>
<tr class="codeline" data-linenumber="921"><td class="num" id="LN921">921</td><td class="line">      <span class='comment'>/* Save the dictionary, parameters, and size */</span></td></tr>
<tr class="codeline" data-linenumber="922"><td class="num" id="LN922">922</td><td class="line">      <span class='keyword'>if</span> (dict) {</td></tr>
<tr class="codeline" data-linenumber="923"><td class="num" id="LN923">923</td><td class="line">        <span class="mrange">memcpy</span>(best-&gt;dict, dict, dictSize);</td></tr>
<tr><td class="num"></td><td class="line"><div id="EndPath" class="msg msgEvent" style="margin-left:9ex; max-width:58em">Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11</div></td></tr>
<tr class="codeline" data-linenumber="924"><td class="num" id="LN924">924</td><td class="line">        best-&gt;dictSize = dictSize;</td></tr>
<tr class="codeline" data-linenumber="925"><td class="num" id="LN925">925</td><td class="line">        best-&gt;parameters = parameters;</td></tr>
<tr class="codeline" data-linenumber="926"><td class="num" id="LN926">926</td><td class="line">        best-&gt;compressedSize = compressedSize;</td></tr>
<tr class="codeline" data-linenumber="927"><td class="num" id="LN927">927</td><td class="line">      }</td></tr>
<tr class="codeline" data-linenumber="928"><td class="num" id="LN928">928</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="929"><td class="num" id="LN929">929</td><td class="line">    <span class='keyword'>if</span> (liveJobs == 0) {</td></tr>
<tr class="codeline" data-linenumber="930"><td class="num" id="LN930">930</td><td class="line">      <span class='macro'>ZSTD_pthread_cond_broadcast(&amp;best-&gt;cond)<span class='macro_popup'>pthread_cond_broadcast((&amp;best-&gt;cond))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="931"><td class="num" id="LN931">931</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="932"><td class="num" id="LN932">932</td><td class="line">    <span class='macro'>ZSTD_pthread_mutex_unlock(&amp;best-&gt;mutex)<span class='macro_popup'>pthread_mutex_unlock((&amp;best-&gt;mutex))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="933"><td class="num" id="LN933">933</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="934"><td class="num" id="LN934">934</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="935"><td class="num" id="LN935">935</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="936"><td class="num" id="LN936">936</td><td class="line">COVER_dictSelection_t COVER_dictSelectionError(size_t error) {</td></tr>
<tr class="codeline" data-linenumber="937"><td class="num" id="LN937">937</td><td class="line">    COVER_dictSelection_t selection = { <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>, 0, error };</td></tr>
<tr class="codeline" data-linenumber="938"><td class="num" id="LN938">938</td><td class="line">    <span class='keyword'>return</span> selection;</td></tr>
<tr class="codeline" data-linenumber="939"><td class="num" id="LN939">939</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="940"><td class="num" id="LN940">940</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="941"><td class="num" id="LN941">941</td><td class="line"><span class='keyword'>unsigned</span> COVER_dictSelectionIsError(COVER_dictSelection_t selection) {</td></tr>
<tr class="codeline" data-linenumber="942"><td class="num" id="LN942">942</td><td class="line">  <span class='keyword'>return</span> (<span class='macro'>ZSTD_isError<span class='macro_popup'>ERR_isError</span></span>(selection.totalCompressedSize) || !selection.dictContent);</td></tr>
<tr class="codeline" data-linenumber="943"><td class="num" id="LN943">943</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="944"><td class="num" id="LN944">944</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="945"><td class="num" id="LN945">945</td><td class="line"><span class='keyword'>void</span> COVER_dictSelectionFree(COVER_dictSelection_t selection){</td></tr>
<tr class="codeline" data-linenumber="946"><td class="num" id="LN946">946</td><td class="line">  free(selection.dictContent);</td></tr>
<tr class="codeline" data-linenumber="947"><td class="num" id="LN947">947</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="948"><td class="num" id="LN948">948</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="949"><td class="num" id="LN949">949</td><td class="line">COVER_dictSelection_t COVER_selectDict(BYTE* customDictContent,</td></tr>
<tr class="codeline" data-linenumber="950"><td class="num" id="LN950">950</td><td class="line">        size_t dictContentSize, <span class='keyword'>const</span> BYTE* samplesBuffer, <span class='keyword'>const</span> size_t* samplesSizes, <span class='keyword'>unsigned</span> nbFinalizeSamples,</td></tr>
<tr class="codeline" data-linenumber="951"><td class="num" id="LN951">951</td><td class="line">        size_t nbCheckSamples, size_t nbSamples, ZDICT_cover_params_t params, size_t* offsets, size_t totalCompressedSize) {</td></tr>
<tr class="codeline" data-linenumber="952"><td class="num" id="LN952">952</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="953"><td class="num" id="LN953">953</td><td class="line">  size_t largestDict = 0;</td></tr>
<tr class="codeline" data-linenumber="954"><td class="num" id="LN954">954</td><td class="line">  size_t largestCompressed = 0;</td></tr>
<tr class="codeline" data-linenumber="955"><td class="num" id="LN955">955</td><td class="line">  BYTE* customDictContentEnd = customDictContent + dictContentSize;</td></tr>
<tr class="codeline" data-linenumber="956"><td class="num" id="LN956">956</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="957"><td class="num" id="LN957">957</td><td class="line">  BYTE * largestDictbuffer = (BYTE *)malloc(dictContentSize);</td></tr>
<tr class="codeline" data-linenumber="958"><td class="num" id="LN958">958</td><td class="line">  BYTE * candidateDictBuffer = (BYTE *)malloc(dictContentSize);</td></tr>
<tr class="codeline" data-linenumber="959"><td class="num" id="LN959">959</td><td class="line">  <span class='keyword'>double</span> regressionTolerance = ((<span class='keyword'>double</span>)params.shrinkDictMaxRegression / 100.0) + 1.00;</td></tr>
<tr class="codeline" data-linenumber="960"><td class="num" id="LN960">960</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="961"><td class="num" id="LN961">961</td><td class="line">  <span class='keyword'>if</span> (!largestDictbuffer || !candidateDictBuffer) {</td></tr>
<tr class="codeline" data-linenumber="962"><td class="num" id="LN962">962</td><td class="line">    free(largestDictbuffer);</td></tr>
<tr class="codeline" data-linenumber="963"><td class="num" id="LN963">963</td><td class="line">    free(candidateDictBuffer);</td></tr>
<tr class="codeline" data-linenumber="964"><td class="num" id="LN964">964</td><td class="line">    <span class='keyword'>return</span> COVER_dictSelectionError(dictContentSize);</td></tr>
<tr class="codeline" data-linenumber="965"><td class="num" id="LN965">965</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="966"><td class="num" id="LN966">966</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="967"><td class="num" id="LN967">967</td><td class="line">  <span class='comment'>/* Initial dictionary size and compressed size */</span></td></tr>
<tr class="codeline" data-linenumber="968"><td class="num" id="LN968">968</td><td class="line">  memcpy(largestDictbuffer, customDictContent, dictContentSize);</td></tr>
<tr class="codeline" data-linenumber="969"><td class="num" id="LN969">969</td><td class="line">  dictContentSize = ZDICT_finalizeDictionary(</td></tr>
<tr class="codeline" data-linenumber="970"><td class="num" id="LN970">970</td><td class="line">    largestDictbuffer, dictContentSize, customDictContent, dictContentSize,</td></tr>
<tr class="codeline" data-linenumber="971"><td class="num" id="LN971">971</td><td class="line">    samplesBuffer, samplesSizes, nbFinalizeSamples, params.zParams);</td></tr>
<tr class="codeline" data-linenumber="972"><td class="num" id="LN972">972</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="973"><td class="num" id="LN973">973</td><td class="line">  <span class='keyword'>if</span> (ZDICT_isError(dictContentSize)) {</td></tr>
<tr class="codeline" data-linenumber="974"><td class="num" id="LN974">974</td><td class="line">    free(largestDictbuffer);</td></tr>
<tr class="codeline" data-linenumber="975"><td class="num" id="LN975">975</td><td class="line">    free(candidateDictBuffer);</td></tr>
<tr class="codeline" data-linenumber="976"><td class="num" id="LN976">976</td><td class="line">    <span class='keyword'>return</span> COVER_dictSelectionError(dictContentSize);</td></tr>
<tr class="codeline" data-linenumber="977"><td class="num" id="LN977">977</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="978"><td class="num" id="LN978">978</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="979"><td class="num" id="LN979">979</td><td class="line">  totalCompressedSize = COVER_checkTotalCompressedSize(params, samplesSizes,</td></tr>
<tr class="codeline" data-linenumber="980"><td class="num" id="LN980">980</td><td class="line">                                                       samplesBuffer, offsets,</td></tr>
<tr class="codeline" data-linenumber="981"><td class="num" id="LN981">981</td><td class="line">                                                       nbCheckSamples, nbSamples,</td></tr>
<tr class="codeline" data-linenumber="982"><td class="num" id="LN982">982</td><td class="line">                                                       largestDictbuffer, dictContentSize);</td></tr>
<tr class="codeline" data-linenumber="983"><td class="num" id="LN983">983</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="984"><td class="num" id="LN984">984</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>ZSTD_isError<span class='macro_popup'>ERR_isError</span></span>(totalCompressedSize)) {</td></tr>
<tr class="codeline" data-linenumber="985"><td class="num" id="LN985">985</td><td class="line">    free(largestDictbuffer);</td></tr>
<tr class="codeline" data-linenumber="986"><td class="num" id="LN986">986</td><td class="line">    free(candidateDictBuffer);</td></tr>
<tr class="codeline" data-linenumber="987"><td class="num" id="LN987">987</td><td class="line">    <span class='keyword'>return</span> COVER_dictSelectionError(totalCompressedSize);</td></tr>
<tr class="codeline" data-linenumber="988"><td class="num" id="LN988">988</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="989"><td class="num" id="LN989">989</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="990"><td class="num" id="LN990">990</td><td class="line">  <span class='keyword'>if</span> (params.shrinkDict == 0) {</td></tr>
<tr class="codeline" data-linenumber="991"><td class="num" id="LN991">991</td><td class="line">    COVER_dictSelection_t selection = { largestDictbuffer, dictContentSize, totalCompressedSize };</td></tr>
<tr class="codeline" data-linenumber="992"><td class="num" id="LN992">992</td><td class="line">    free(candidateDictBuffer);</td></tr>
<tr class="codeline" data-linenumber="993"><td class="num" id="LN993">993</td><td class="line">    <span class='keyword'>return</span> selection;</td></tr>
<tr class="codeline" data-linenumber="994"><td class="num" id="LN994">994</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="995"><td class="num" id="LN995">995</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="996"><td class="num" id="LN996">996</td><td class="line">  largestDict = dictContentSize;</td></tr>
<tr class="codeline" data-linenumber="997"><td class="num" id="LN997">997</td><td class="line">  largestCompressed = totalCompressedSize;</td></tr>
<tr class="codeline" data-linenumber="998"><td class="num" id="LN998">998</td><td class="line">  dictContentSize = <span class='macro'>ZDICT_DICTSIZE_MIN<span class='macro_popup'>256</span></span>;</td></tr>
<tr class="codeline" data-linenumber="999"><td class="num" id="LN999">999</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1000"><td class="num" id="LN1000">1000</td><td class="line">  <span class='comment'>/* Largest dict is initially at least ZDICT_DICTSIZE_MIN */</span></td></tr>
<tr class="codeline" data-linenumber="1001"><td class="num" id="LN1001">1001</td><td class="line">  <span class='keyword'>while</span> (dictContentSize &lt; largestDict) {</td></tr>
<tr class="codeline" data-linenumber="1002"><td class="num" id="LN1002">1002</td><td class="line">    memcpy(candidateDictBuffer, largestDictbuffer, largestDict);</td></tr>
<tr class="codeline" data-linenumber="1003"><td class="num" id="LN1003">1003</td><td class="line">    dictContentSize = ZDICT_finalizeDictionary(</td></tr>
<tr class="codeline" data-linenumber="1004"><td class="num" id="LN1004">1004</td><td class="line">      candidateDictBuffer, dictContentSize, customDictContentEnd - dictContentSize, dictContentSize,</td></tr>
<tr class="codeline" data-linenumber="1005"><td class="num" id="LN1005">1005</td><td class="line">      samplesBuffer, samplesSizes, nbFinalizeSamples, params.zParams);</td></tr>
<tr class="codeline" data-linenumber="1006"><td class="num" id="LN1006">1006</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1007"><td class="num" id="LN1007">1007</td><td class="line">    <span class='keyword'>if</span> (ZDICT_isError(dictContentSize)) {</td></tr>
<tr class="codeline" data-linenumber="1008"><td class="num" id="LN1008">1008</td><td class="line">      free(largestDictbuffer);</td></tr>
<tr class="codeline" data-linenumber="1009"><td class="num" id="LN1009">1009</td><td class="line">      free(candidateDictBuffer);</td></tr>
<tr class="codeline" data-linenumber="1010"><td class="num" id="LN1010">1010</td><td class="line">      <span class='keyword'>return</span> COVER_dictSelectionError(dictContentSize);</td></tr>
<tr class="codeline" data-linenumber="1011"><td class="num" id="LN1011">1011</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1012"><td class="num" id="LN1012">1012</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1013"><td class="num" id="LN1013">1013</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1014"><td class="num" id="LN1014">1014</td><td class="line">    totalCompressedSize = COVER_checkTotalCompressedSize(params, samplesSizes,</td></tr>
<tr class="codeline" data-linenumber="1015"><td class="num" id="LN1015">1015</td><td class="line">                                                         samplesBuffer, offsets,</td></tr>
<tr class="codeline" data-linenumber="1016"><td class="num" id="LN1016">1016</td><td class="line">                                                         nbCheckSamples, nbSamples,</td></tr>
<tr class="codeline" data-linenumber="1017"><td class="num" id="LN1017">1017</td><td class="line">                                                         candidateDictBuffer, dictContentSize);</td></tr>
<tr class="codeline" data-linenumber="1018"><td class="num" id="LN1018">1018</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1019"><td class="num" id="LN1019">1019</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>ZSTD_isError<span class='macro_popup'>ERR_isError</span></span>(totalCompressedSize)) {</td></tr>
<tr class="codeline" data-linenumber="1020"><td class="num" id="LN1020">1020</td><td class="line">      free(largestDictbuffer);</td></tr>
<tr class="codeline" data-linenumber="1021"><td class="num" id="LN1021">1021</td><td class="line">      free(candidateDictBuffer);</td></tr>
<tr class="codeline" data-linenumber="1022"><td class="num" id="LN1022">1022</td><td class="line">      <span class='keyword'>return</span> COVER_dictSelectionError(totalCompressedSize);</td></tr>
<tr class="codeline" data-linenumber="1023"><td class="num" id="LN1023">1023</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1024"><td class="num" id="LN1024">1024</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1025"><td class="num" id="LN1025">1025</td><td class="line">    <span class='keyword'>if</span> (totalCompressedSize &lt;= largestCompressed * regressionTolerance) {</td></tr>
<tr class="codeline" data-linenumber="1026"><td class="num" id="LN1026">1026</td><td class="line">      COVER_dictSelection_t selection = { candidateDictBuffer, dictContentSize, totalCompressedSize };</td></tr>
<tr class="codeline" data-linenumber="1027"><td class="num" id="LN1027">1027</td><td class="line">      free(largestDictbuffer);</td></tr>
<tr class="codeline" data-linenumber="1028"><td class="num" id="LN1028">1028</td><td class="line">      <span class='keyword'>return</span> selection;</td></tr>
<tr class="codeline" data-linenumber="1029"><td class="num" id="LN1029">1029</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1030"><td class="num" id="LN1030">1030</td><td class="line">    dictContentSize *= 2;</td></tr>
<tr class="codeline" data-linenumber="1031"><td class="num" id="LN1031">1031</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="1032"><td class="num" id="LN1032">1032</td><td class="line">  dictContentSize = largestDict;</td></tr>
<tr class="codeline" data-linenumber="1033"><td class="num" id="LN1033">1033</td><td class="line">  totalCompressedSize = largestCompressed;</td></tr>
<tr class="codeline" data-linenumber="1034"><td class="num" id="LN1034">1034</td><td class="line">  {</td></tr>
<tr class="codeline" data-linenumber="1035"><td class="num" id="LN1035">1035</td><td class="line">    COVER_dictSelection_t selection = { largestDictbuffer, dictContentSize, totalCompressedSize };</td></tr>
<tr class="codeline" data-linenumber="1036"><td class="num" id="LN1036">1036</td><td class="line">    free(candidateDictBuffer);</td></tr>
<tr class="codeline" data-linenumber="1037"><td class="num" id="LN1037">1037</td><td class="line">    <span class='keyword'>return</span> selection;</td></tr>
<tr class="codeline" data-linenumber="1038"><td class="num" id="LN1038">1038</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="1039"><td class="num" id="LN1039">1039</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1040"><td class="num" id="LN1040">1040</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1041"><td class="num" id="LN1041">1041</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="1042"><td class="num" id="LN1042">1042</td><td class="line"> <span class='comment'>* Parameters for COVER_tryParameters().</span></td></tr>
<tr class="codeline" data-linenumber="1043"><td class="num" id="LN1043">1043</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1044"><td class="num" id="LN1044">1044</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> COVER_tryParameters_data_s {</td></tr>
<tr class="codeline" data-linenumber="1045"><td class="num" id="LN1045">1045</td><td class="line">  <span class='keyword'>const</span> COVER_ctx_t *ctx;</td></tr>
<tr class="codeline" data-linenumber="1046"><td class="num" id="LN1046">1046</td><td class="line">  COVER_best_t *best;</td></tr>
<tr class="codeline" data-linenumber="1047"><td class="num" id="LN1047">1047</td><td class="line">  size_t dictBufferCapacity;</td></tr>
<tr class="codeline" data-linenumber="1048"><td class="num" id="LN1048">1048</td><td class="line">  ZDICT_cover_params_t parameters;</td></tr>
<tr class="codeline" data-linenumber="1049"><td class="num" id="LN1049">1049</td><td class="line">} COVER_tryParameters_data_t;</td></tr>
<tr class="codeline" data-linenumber="1050"><td class="num" id="LN1050">1050</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1051"><td class="num" id="LN1051">1051</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="1052"><td class="num" id="LN1052">1052</td><td class="line"> <span class='comment'>* Tries a set of parameters and updates the COVER_best_t with the results.</span></td></tr>
<tr class="codeline" data-linenumber="1053"><td class="num" id="LN1053">1053</td><td class="line"> <span class='comment'>* This function is thread safe if zstd is compiled with multithreaded support.</span></td></tr>
<tr class="codeline" data-linenumber="1054"><td class="num" id="LN1054">1054</td><td class="line"> <span class='comment'>* It takes its parameters as an *OWNING* opaque pointer to support threading.</span></td></tr>
<tr class="codeline" data-linenumber="1055"><td class="num" id="LN1055">1055</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1056"><td class="num" id="LN1056">1056</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> COVER_tryParameters(<span class='keyword'>void</span> *opaque) {</td></tr>
<tr class="codeline" data-linenumber="1057"><td class="num" id="LN1057">1057</td><td class="line">  <span class='comment'>/* Save parameters as local variables */</span></td></tr>
<tr class="codeline" data-linenumber="1058"><td class="num" id="LN1058">1058</td><td class="line">  COVER_tryParameters_data_t *<span class='keyword'>const</span> data = (COVER_tryParameters_data_t *)opaque;</td></tr>
<tr class="codeline" data-linenumber="1059"><td class="num" id="LN1059">1059</td><td class="line">  <span class='keyword'>const</span> COVER_ctx_t *<span class='keyword'>const</span> ctx = data-&gt;ctx;</td></tr>
<tr class="codeline" data-linenumber="1060"><td class="num" id="LN1060">1060</td><td class="line">  <span class='keyword'>const</span> ZDICT_cover_params_t parameters = data-&gt;parameters;</td></tr>
<tr class="codeline" data-linenumber="1061"><td class="num" id="LN1061">1061</td><td class="line">  size_t dictBufferCapacity = data-&gt;dictBufferCapacity;</td></tr>
<tr class="codeline" data-linenumber="1062"><td class="num" id="LN1062">1062</td><td class="line">  size_t totalCompressedSize = <span class='macro'>ERROR(GENERIC)<span class='macro_popup'>((size_t)-ZSTD_error_GENERIC)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1063"><td class="num" id="LN1063">1063</td><td class="line">  <span class='comment'>/* Allocate space for hash table, dict, and freqs */</span></td></tr>
<tr class="codeline" data-linenumber="1064"><td class="num" id="LN1064">1064</td><td class="line">  COVER_map_t activeDmers;</td></tr>
<tr class="codeline" data-linenumber="1065"><td class="num" id="LN1065">1065</td><td class="line">  BYTE *<span class='keyword'>const</span> dict = (BYTE * <span class='keyword'>const</span>)malloc(dictBufferCapacity);</td></tr>
<tr class="codeline" data-linenumber="1066"><td class="num" id="LN1066">1066</td><td class="line">  COVER_dictSelection_t selection = COVER_dictSelectionError(<span class='macro'>ERROR(GENERIC)<span class='macro_popup'>((size_t)-ZSTD_error_GENERIC)</span></span>);</td></tr>
<tr class="codeline" data-linenumber="1067"><td class="num" id="LN1067">1067</td><td class="line">  U32 *freqs = (U32 *)malloc(ctx-&gt;suffixSize * <span class='keyword'>sizeof</span>(U32));</td></tr>
<tr class="codeline" data-linenumber="1068"><td class="num" id="LN1068">1068</td><td class="line">  <span class='keyword'>if</span> (!COVER_map_init(&amp;activeDmers, parameters.k - parameters.d + 1)) {</td></tr>
<tr class="codeline" data-linenumber="1069"><td class="num" id="LN1069">1069</td><td class="line">    <span class='macro'>DISPLAYLEVEL(1, <span class='string_literal'>"Failed to allocate dmer map: out of memory\n"</span>)<span class='macro_popup'>if (g_displayLevel &gt;= 1) { { fprintf(stderr, "Failed to allocate dmer map: out of memory\n"<br>); fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1070"><td class="num" id="LN1070">1070</td><td class="line">    <span class='keyword'>goto</span> _cleanup;</td></tr>
<tr class="codeline" data-linenumber="1071"><td class="num" id="LN1071">1071</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="1072"><td class="num" id="LN1072">1072</td><td class="line">  <span class='keyword'>if</span> (!dict || !freqs) {</td></tr>
<tr class="codeline" data-linenumber="1073"><td class="num" id="LN1073">1073</td><td class="line">    <span class='macro'>DISPLAYLEVEL(1, <span class='string_literal'>"Failed to allocate buffers: out of memory\n"</span>)<span class='macro_popup'>if (g_displayLevel &gt;= 1) { { fprintf(stderr, "Failed to allocate buffers: out of memory\n"<br>); fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1074"><td class="num" id="LN1074">1074</td><td class="line">    <span class='keyword'>goto</span> _cleanup;</td></tr>
<tr class="codeline" data-linenumber="1075"><td class="num" id="LN1075">1075</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="1076"><td class="num" id="LN1076">1076</td><td class="line">  <span class='comment'>/* Copy the frequencies because we need to modify them */</span></td></tr>
<tr class="codeline" data-linenumber="1077"><td class="num" id="LN1077">1077</td><td class="line">  memcpy(freqs, ctx-&gt;freqs, ctx-&gt;suffixSize * <span class='keyword'>sizeof</span>(U32));</td></tr>
<tr class="codeline" data-linenumber="1078"><td class="num" id="LN1078">1078</td><td class="line">  <span class='comment'>/* Build the dictionary */</span></td></tr>
<tr class="codeline" data-linenumber="1079"><td class="num" id="LN1079">1079</td><td class="line">  {</td></tr>
<tr class="codeline" data-linenumber="1080"><td class="num" id="LN1080">1080</td><td class="line">    <span class='keyword'>const</span> size_t tail = COVER_buildDictionary(ctx, freqs, &amp;activeDmers, dict,</td></tr>
<tr class="codeline" data-linenumber="1081"><td class="num" id="LN1081">1081</td><td class="line">                                              dictBufferCapacity, parameters);</td></tr>
<tr class="codeline" data-linenumber="1082"><td class="num" id="LN1082">1082</td><td class="line">    selection = COVER_selectDict(dict + tail, dictBufferCapacity - tail,</td></tr>
<tr class="codeline" data-linenumber="1083"><td class="num" id="LN1083">1083</td><td class="line">        ctx-&gt;samples, ctx-&gt;samplesSizes, (<span class='keyword'>unsigned</span>)ctx-&gt;nbTrainSamples, ctx-&gt;nbTrainSamples, ctx-&gt;nbSamples, parameters, ctx-&gt;offsets,</td></tr>
<tr class="codeline" data-linenumber="1084"><td class="num" id="LN1084">1084</td><td class="line">        totalCompressedSize);</td></tr>
<tr class="codeline" data-linenumber="1085"><td class="num" id="LN1085">1085</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1086"><td class="num" id="LN1086">1086</td><td class="line">    <span class='keyword'>if</span> (COVER_dictSelectionIsError(selection)) {</td></tr>
<tr class="codeline" data-linenumber="1087"><td class="num" id="LN1087">1087</td><td class="line">      <span class='macro'>DISPLAYLEVEL(1, <span class='string_literal'>"Failed to select dictionary\n"</span>)<span class='macro_popup'>if (g_displayLevel &gt;= 1) { { fprintf(stderr, "Failed to select dictionary\n"<br>); fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1088"><td class="num" id="LN1088">1088</td><td class="line">      <span class='keyword'>goto</span> _cleanup;</td></tr>
<tr class="codeline" data-linenumber="1089"><td class="num" id="LN1089">1089</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1090"><td class="num" id="LN1090">1090</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="1091"><td class="num" id="LN1091">1091</td><td class="line">_cleanup:</td></tr>
<tr class="codeline" data-linenumber="1092"><td class="num" id="LN1092">1092</td><td class="line">  free(dict);</td></tr>
<tr class="codeline" data-linenumber="1093"><td class="num" id="LN1093">1093</td><td class="line">  COVER_best_finish(data-&gt;best, parameters, selection);</td></tr>
<tr class="codeline" data-linenumber="1094"><td class="num" id="LN1094">1094</td><td class="line">  free(data);</td></tr>
<tr class="codeline" data-linenumber="1095"><td class="num" id="LN1095">1095</td><td class="line">  COVER_map_destroy(&amp;activeDmers);</td></tr>
<tr class="codeline" data-linenumber="1096"><td class="num" id="LN1096">1096</td><td class="line">  COVER_dictSelectionFree(selection);</td></tr>
<tr class="codeline" data-linenumber="1097"><td class="num" id="LN1097">1097</td><td class="line">  <span class='keyword'>if</span> (freqs) {</td></tr>
<tr class="codeline" data-linenumber="1098"><td class="num" id="LN1098">1098</td><td class="line">    free(freqs);</td></tr>
<tr class="codeline" data-linenumber="1099"><td class="num" id="LN1099">1099</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="1100"><td class="num" id="LN1100">1100</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1101"><td class="num" id="LN1101">1101</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1102"><td class="num" id="LN1102">1102</td><td class="line"><span class='macro'>ZDICTLIB_API<span class='macro_popup'>__attribute__ ((visibility ("default")))</span></span> size_t ZDICT_optimizeTrainFromBuffer_cover(</td></tr>
<tr class="codeline" data-linenumber="1103"><td class="num" id="LN1103">1103</td><td class="line">    <span class='keyword'>void</span> *dictBuffer, size_t dictBufferCapacity, <span class='keyword'>const</span> <span class='keyword'>void</span> *samplesBuffer,</td></tr>
<tr class="codeline" data-linenumber="1104"><td class="num" id="LN1104">1104</td><td class="line">    <span class='keyword'>const</span> size_t *samplesSizes, <span class='keyword'>unsigned</span> nbSamples,</td></tr>
<tr class="codeline" data-linenumber="1105"><td class="num" id="LN1105">1105</td><td class="line">    ZDICT_cover_params_t *parameters) {</td></tr>
<tr class="codeline" data-linenumber="1106"><td class="num" id="LN1106">1106</td><td class="line">  <span class='comment'>/* constants */</span></td></tr>
<tr class="codeline" data-linenumber="1107"><td class="num" id="LN1107">1107</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>unsigned</span> nbThreads = parameters-&gt;nbThreads;</td></tr>
<tr class="codeline" data-linenumber="1108"><td class="num" id="LN1108">1108</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>double</span> splitPoint =</td></tr>
<tr class="codeline" data-linenumber="1109"><td class="num" id="LN1109">1109</td><td class="line">      parameters-&gt;splitPoint &lt;= 0.0 ? <span class='macro'>DEFAULT_SPLITPOINT<span class='macro_popup'>1.0</span></span> : parameters-&gt;splitPoint;</td></tr>
<tr class="codeline" data-linenumber="1110"><td class="num" id="LN1110">1110</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>unsigned</span> kMinD = parameters-&gt;d == 0 ? 6 : parameters-&gt;d;</td></tr>
<tr class="codeline" data-linenumber="1111"><td class="num" id="LN1111">1111</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>unsigned</span> kMaxD = parameters-&gt;d == 0 ? 8 : parameters-&gt;d;</td></tr>
<tr class="codeline" data-linenumber="1112"><td class="num" id="LN1112">1112</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>unsigned</span> kMinK = parameters-&gt;k == 0 ? 50 : parameters-&gt;k;</td></tr>
<tr class="codeline" data-linenumber="1113"><td class="num" id="LN1113">1113</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>unsigned</span> kMaxK = parameters-&gt;k == 0 ? 2000 : parameters-&gt;k;</td></tr>
<tr class="codeline" data-linenumber="1114"><td class="num" id="LN1114">1114</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>unsigned</span> kSteps = parameters-&gt;steps == 0 ? 40 : parameters-&gt;steps;</td></tr>
<tr class="codeline" data-linenumber="1115"><td class="num" id="LN1115">1115</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>unsigned</span> kStepSize = <span class='macro'>MAX((kMaxK - kMinK) / kSteps, 1)<span class='macro_popup'>(((kMaxK - kMinK) / kSteps)&gt;(1) ? ((kMaxK - kMinK) / kSteps<br>) : (1))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1116"><td class="num" id="LN1116">1116</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>unsigned</span> kIterations =</td></tr>
<tr class="codeline" data-linenumber="1117"><td class="num" id="LN1117">1117</td><td class="line">      (1 + (kMaxD - kMinD) / 2) * (1 + (kMaxK - kMinK) / kStepSize);</td></tr>
<tr class="codeline" data-linenumber="1118"><td class="num" id="LN1118">1118</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>unsigned</span> shrinkDict = 0;</td></tr>
<tr class="codeline" data-linenumber="1119"><td class="num" id="LN1119">1119</td><td class="line">  <span class='comment'>/* Local variables */</span></td></tr>
<tr class="codeline" data-linenumber="1120"><td class="num" id="LN1120">1120</td><td class="line">  <span class='keyword'>const</span> <span class='keyword'>int</span> displayLevel = parameters-&gt;zParams.notificationLevel;</td></tr>
<tr class="codeline" data-linenumber="1121"><td class="num" id="LN1121">1121</td><td class="line">  <span class='keyword'>unsigned</span> iteration = 1;</td></tr>
<tr class="codeline" data-linenumber="1122"><td class="num" id="LN1122">1122</td><td class="line">  <span class='keyword'>unsigned</span> d;</td></tr>
<tr class="codeline" data-linenumber="1123"><td class="num" id="LN1123">1123</td><td class="line">  <span class='keyword'>unsigned</span> k;</td></tr>
<tr class="codeline" data-linenumber="1124"><td class="num" id="LN1124">1124</td><td class="line">  COVER_best_t best;</td></tr>
<tr class="codeline" data-linenumber="1125"><td class="num" id="LN1125">1125</td><td class="line">  POOL_ctx *pool = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1126"><td class="num" id="LN1126">1126</td><td class="line">  <span class='keyword'>int</span> warned = 0;</td></tr>
<tr class="codeline" data-linenumber="1127"><td class="num" id="LN1127">1127</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1128"><td class="num" id="LN1128">1128</td><td class="line">  <span class='comment'>/* Checks */</span></td></tr>
<tr class="codeline" data-linenumber="1129"><td class="num" id="LN1129">1129</td><td class="line">  <span class='keyword'>if</span> (splitPoint &lt;= 0 || splitPoint &gt; 1) {</td></tr>
<tr class="codeline" data-linenumber="1130"><td class="num" id="LN1130">1130</td><td class="line">    <span class='macro'>LOCALDISPLAYLEVEL(displayLevel, 1, <span class='string_literal'>"Incorrect parameters\n"</span>)<span class='macro_popup'>if (displayLevel &gt;= 1) { { fprintf(stderr, "Incorrect parameters\n"<br>); fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1131"><td class="num" id="LN1131">1131</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>ERROR(parameter_outOfBound)<span class='macro_popup'>((size_t)-ZSTD_error_parameter_outOfBound)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1132"><td class="num" id="LN1132">1132</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="1133"><td class="num" id="LN1133">1133</td><td class="line">  <span class='keyword'>if</span> (kMinK &lt; kMaxD || kMaxK &lt; kMinK) {</td></tr>
<tr class="codeline" data-linenumber="1134"><td class="num" id="LN1134">1134</td><td class="line">    <span class='macro'>LOCALDISPLAYLEVEL(displayLevel, 1, <span class='string_literal'>"Incorrect parameters\n"</span>)<span class='macro_popup'>if (displayLevel &gt;= 1) { { fprintf(stderr, "Incorrect parameters\n"<br>); fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1135"><td class="num" id="LN1135">1135</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>ERROR(parameter_outOfBound)<span class='macro_popup'>((size_t)-ZSTD_error_parameter_outOfBound)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1136"><td class="num" id="LN1136">1136</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="1137"><td class="num" id="LN1137">1137</td><td class="line">  <span class='keyword'>if</span> (nbSamples == 0) {</td></tr>
<tr class="codeline" data-linenumber="1138"><td class="num" id="LN1138">1138</td><td class="line">    <span class='macro'>DISPLAYLEVEL(1, <span class='string_literal'>"Cover must have at least one input file\n"</span>)<span class='macro_popup'>if (g_displayLevel &gt;= 1) { { fprintf(stderr, "Cover must have at least one input file\n"<br>); fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1139"><td class="num" id="LN1139">1139</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>ERROR(srcSize_wrong)<span class='macro_popup'>((size_t)-ZSTD_error_srcSize_wrong)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1140"><td class="num" id="LN1140">1140</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="1141"><td class="num" id="LN1141">1141</td><td class="line">  <span class='keyword'>if</span> (dictBufferCapacity &lt; <span class='macro'>ZDICT_DICTSIZE_MIN<span class='macro_popup'>256</span></span>) {</td></tr>
<tr class="codeline" data-linenumber="1142"><td class="num" id="LN1142">1142</td><td class="line">    <span class='macro'>DISPLAYLEVEL(1, <span class='string_literal'>"dictBufferCapacity must be at least %u\n"</span>,<span class='macro_popup'>if (g_displayLevel &gt;= 1) { { fprintf(stderr, "dictBufferCapacity must be at least %u\n"<br>, 256); fflush(stderr); }; }</span></span></td></tr>
<tr class="codeline" data-linenumber="1143"><td class="num" id="LN1143">1143</td><td class="line">                 <span class='macro'>ZDICT_DICTSIZE_MIN)<span class='macro_popup'>if (g_displayLevel &gt;= 1) { { fprintf(stderr, "dictBufferCapacity must be at least %u\n"<br>, 256); fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1144"><td class="num" id="LN1144">1144</td><td class="line">    <span class='keyword'>return</span> <span class='macro'>ERROR(dstSize_tooSmall)<span class='macro_popup'>((size_t)-ZSTD_error_dstSize_tooSmall)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1145"><td class="num" id="LN1145">1145</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="1146"><td class="num" id="LN1146">1146</td><td class="line">  <span class='keyword'>if</span> (nbThreads &gt; 1) {</td></tr>
<tr class="codeline" data-linenumber="1147"><td class="num" id="LN1147">1147</td><td class="line">    pool = POOL_create(nbThreads, 1);</td></tr>
<tr class="codeline" data-linenumber="1148"><td class="num" id="LN1148">1148</td><td class="line">    <span class='keyword'>if</span> (!pool) {</td></tr>
<tr class="codeline" data-linenumber="1149"><td class="num" id="LN1149">1149</td><td class="line">      <span class='keyword'>return</span> <span class='macro'>ERROR(memory_allocation)<span class='macro_popup'>((size_t)-ZSTD_error_memory_allocation)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1150"><td class="num" id="LN1150">1150</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1151"><td class="num" id="LN1151">1151</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="1152"><td class="num" id="LN1152">1152</td><td class="line">  <span class='comment'>/* Initialization */</span></td></tr>
<tr class="codeline" data-linenumber="1153"><td class="num" id="LN1153">1153</td><td class="line">  COVER_best_init(&amp;best);</td></tr>
<tr class="codeline" data-linenumber="1154"><td class="num" id="LN1154">1154</td><td class="line">  <span class='comment'>/* Turn down global display level to clean up display at level 2 and below */</span></td></tr>
<tr class="codeline" data-linenumber="1155"><td class="num" id="LN1155">1155</td><td class="line">  g_displayLevel = displayLevel == 0 ? 0 : displayLevel - 1;</td></tr>
<tr class="codeline" data-linenumber="1156"><td class="num" id="LN1156">1156</td><td class="line">  <span class='comment'>/* Loop through d first because each new value needs a new context */</span></td></tr>
<tr class="codeline" data-linenumber="1157"><td class="num" id="LN1157">1157</td><td class="line">  <span class='macro'>LOCALDISPLAYLEVEL(displayLevel, 2, <span class='string_literal'>"Trying %u different sets of parameters\n"</span>,<span class='macro_popup'>if (displayLevel &gt;= 2) { { fprintf(stderr, "Trying %u different sets of parameters\n"<br>, kIterations); fflush(stderr); }; }</span></span></td></tr>
<tr class="codeline" data-linenumber="1158"><td class="num" id="LN1158">1158</td><td class="line">                    <span class='macro'>kIterations)<span class='macro_popup'>if (displayLevel &gt;= 2) { { fprintf(stderr, "Trying %u different sets of parameters\n"<br>, kIterations); fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1159"><td class="num" id="LN1159">1159</td><td class="line">  <span class='keyword'>for</span> (d = kMinD; d &lt;= kMaxD; d += 2) {</td></tr>
<tr class="codeline" data-linenumber="1160"><td class="num" id="LN1160">1160</td><td class="line">    <span class='comment'>/* Initialize the context for this value of d */</span></td></tr>
<tr class="codeline" data-linenumber="1161"><td class="num" id="LN1161">1161</td><td class="line">    COVER_ctx_t ctx;</td></tr>
<tr class="codeline" data-linenumber="1162"><td class="num" id="LN1162">1162</td><td class="line">    <span class='macro'>LOCALDISPLAYLEVEL(displayLevel, 3, <span class='string_literal'>"d=%u\n"</span>, d)<span class='macro_popup'>if (displayLevel &gt;= 3) { { fprintf(stderr, "d=%u\n", d); fflush<br>(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1163"><td class="num" id="LN1163">1163</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="1164"><td class="num" id="LN1164">1164</td><td class="line">      <span class='keyword'>const</span> size_t initVal = COVER_ctx_init(&amp;ctx, samplesBuffer, samplesSizes, nbSamples, d, splitPoint);</td></tr>
<tr class="codeline" data-linenumber="1165"><td class="num" id="LN1165">1165</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>ZSTD_isError<span class='macro_popup'>ERR_isError</span></span>(initVal)) {</td></tr>
<tr class="codeline" data-linenumber="1166"><td class="num" id="LN1166">1166</td><td class="line">        <span class='macro'>LOCALDISPLAYLEVEL(displayLevel, 1, <span class='string_literal'>"Failed to initialize context\n"</span>)<span class='macro_popup'>if (displayLevel &gt;= 1) { { fprintf(stderr, "Failed to initialize context\n"<br>); fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1167"><td class="num" id="LN1167">1167</td><td class="line">        COVER_best_destroy(&amp;best);</td></tr>
<tr class="codeline" data-linenumber="1168"><td class="num" id="LN1168">1168</td><td class="line">        POOL_free(pool);</td></tr>
<tr class="codeline" data-linenumber="1169"><td class="num" id="LN1169">1169</td><td class="line">        <span class='keyword'>return</span> initVal;</td></tr>
<tr class="codeline" data-linenumber="1170"><td class="num" id="LN1170">1170</td><td class="line">      }</td></tr>
<tr class="codeline" data-linenumber="1171"><td class="num" id="LN1171">1171</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1172"><td class="num" id="LN1172">1172</td><td class="line">    <span class='keyword'>if</span> (!warned) {</td></tr>
<tr class="codeline" data-linenumber="1173"><td class="num" id="LN1173">1173</td><td class="line">      COVER_warnOnSmallCorpus(dictBufferCapacity, ctx.suffixSize, displayLevel);</td></tr>
<tr class="codeline" data-linenumber="1174"><td class="num" id="LN1174">1174</td><td class="line">      warned = 1;</td></tr>
<tr class="codeline" data-linenumber="1175"><td class="num" id="LN1175">1175</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1176"><td class="num" id="LN1176">1176</td><td class="line">    <span class='comment'>/* Loop through k reusing the same context */</span></td></tr>
<tr class="codeline" data-linenumber="1177"><td class="num" id="LN1177">1177</td><td class="line">    <span class='keyword'>for</span> (k = kMinK; k &lt;= kMaxK; k += kStepSize) {</td></tr>
<tr class="codeline" data-linenumber="1178"><td class="num" id="LN1178">1178</td><td class="line">      <span class='comment'>/* Prepare the arguments */</span></td></tr>
<tr class="codeline" data-linenumber="1179"><td class="num" id="LN1179">1179</td><td class="line">      COVER_tryParameters_data_t *data = (COVER_tryParameters_data_t *)malloc(</td></tr>
<tr class="codeline" data-linenumber="1180"><td class="num" id="LN1180">1180</td><td class="line">          <span class='keyword'>sizeof</span>(COVER_tryParameters_data_t));</td></tr>
<tr class="codeline" data-linenumber="1181"><td class="num" id="LN1181">1181</td><td class="line">      <span class='macro'>LOCALDISPLAYLEVEL(displayLevel, 3, <span class='string_literal'>"k=%u\n"</span>, k)<span class='macro_popup'>if (displayLevel &gt;= 3) { { fprintf(stderr, "k=%u\n", k); fflush<br>(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1182"><td class="num" id="LN1182">1182</td><td class="line">      <span class='keyword'>if</span> (!data) {</td></tr>
<tr class="codeline" data-linenumber="1183"><td class="num" id="LN1183">1183</td><td class="line">        <span class='macro'>LOCALDISPLAYLEVEL(displayLevel, 1, <span class='string_literal'>"Failed to allocate parameters\n"</span>)<span class='macro_popup'>if (displayLevel &gt;= 1) { { fprintf(stderr, "Failed to allocate parameters\n"<br>); fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1184"><td class="num" id="LN1184">1184</td><td class="line">        COVER_best_destroy(&amp;best);</td></tr>
<tr class="codeline" data-linenumber="1185"><td class="num" id="LN1185">1185</td><td class="line">        COVER_ctx_destroy(&amp;ctx);</td></tr>
<tr class="codeline" data-linenumber="1186"><td class="num" id="LN1186">1186</td><td class="line">        POOL_free(pool);</td></tr>
<tr class="codeline" data-linenumber="1187"><td class="num" id="LN1187">1187</td><td class="line">        <span class='keyword'>return</span> <span class='macro'>ERROR(memory_allocation)<span class='macro_popup'>((size_t)-ZSTD_error_memory_allocation)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1188"><td class="num" id="LN1188">1188</td><td class="line">      }</td></tr>
<tr class="codeline" data-linenumber="1189"><td class="num" id="LN1189">1189</td><td class="line">      data-&gt;ctx = &amp;ctx;</td></tr>
<tr class="codeline" data-linenumber="1190"><td class="num" id="LN1190">1190</td><td class="line">      data-&gt;best = &amp;best;</td></tr>
<tr class="codeline" data-linenumber="1191"><td class="num" id="LN1191">1191</td><td class="line">      data-&gt;dictBufferCapacity = dictBufferCapacity;</td></tr>
<tr class="codeline" data-linenumber="1192"><td class="num" id="LN1192">1192</td><td class="line">      data-&gt;parameters = *parameters;</td></tr>
<tr class="codeline" data-linenumber="1193"><td class="num" id="LN1193">1193</td><td class="line">      data-&gt;parameters.k = k;</td></tr>
<tr class="codeline" data-linenumber="1194"><td class="num" id="LN1194">1194</td><td class="line">      data-&gt;parameters.d = d;</td></tr>
<tr class="codeline" data-linenumber="1195"><td class="num" id="LN1195">1195</td><td class="line">      data-&gt;parameters.splitPoint = splitPoint;</td></tr>
<tr class="codeline" data-linenumber="1196"><td class="num" id="LN1196">1196</td><td class="line">      data-&gt;parameters.steps = kSteps;</td></tr>
<tr class="codeline" data-linenumber="1197"><td class="num" id="LN1197">1197</td><td class="line">      data-&gt;parameters.shrinkDict = shrinkDict;</td></tr>
<tr class="codeline" data-linenumber="1198"><td class="num" id="LN1198">1198</td><td class="line">      data-&gt;parameters.zParams.notificationLevel = g_displayLevel;</td></tr>
<tr class="codeline" data-linenumber="1199"><td class="num" id="LN1199">1199</td><td class="line">      <span class='comment'>/* Check the parameters */</span></td></tr>
<tr class="codeline" data-linenumber="1200"><td class="num" id="LN1200">1200</td><td class="line">      <span class='keyword'>if</span> (!COVER_checkParameters(data-&gt;parameters, dictBufferCapacity)) {</td></tr>
<tr class="codeline" data-linenumber="1201"><td class="num" id="LN1201">1201</td><td class="line">        <span class='macro'>DISPLAYLEVEL(1, <span class='string_literal'>"Cover parameters incorrect\n"</span>)<span class='macro_popup'>if (g_displayLevel &gt;= 1) { { fprintf(stderr, "Cover parameters incorrect\n"<br>); fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1202"><td class="num" id="LN1202">1202</td><td class="line">        free(data);</td></tr>
<tr class="codeline" data-linenumber="1203"><td class="num" id="LN1203">1203</td><td class="line">        <span class='keyword'>continue</span>;</td></tr>
<tr class="codeline" data-linenumber="1204"><td class="num" id="LN1204">1204</td><td class="line">      }</td></tr>
<tr class="codeline" data-linenumber="1205"><td class="num" id="LN1205">1205</td><td class="line">      <span class='comment'>/* Call the function and pass ownership of data to it */</span></td></tr>
<tr class="codeline" data-linenumber="1206"><td class="num" id="LN1206">1206</td><td class="line">      COVER_best_start(&amp;best);</td></tr>
<tr class="codeline" data-linenumber="1207"><td class="num" id="LN1207">1207</td><td class="line">      <span class='keyword'>if</span> (pool) {</td></tr>
<tr class="codeline" data-linenumber="1208"><td class="num" id="LN1208">1208</td><td class="line">        POOL_add(pool, &amp;COVER_tryParameters, data);</td></tr>
<tr class="codeline" data-linenumber="1209"><td class="num" id="LN1209">1209</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="1210"><td class="num" id="LN1210">1210</td><td class="line">        COVER_tryParameters(data);</td></tr>
<tr class="codeline" data-linenumber="1211"><td class="num" id="LN1211">1211</td><td class="line">      }</td></tr>
<tr class="codeline" data-linenumber="1212"><td class="num" id="LN1212">1212</td><td class="line">      <span class='comment'>/* Print status */</span></td></tr>
<tr class="codeline" data-linenumber="1213"><td class="num" id="LN1213">1213</td><td class="line">      <span class='macro'>LOCALDISPLAYUPDATE(displayLevel, 2, <span class='string_literal'>"\r%u%%       "</span>,<span class='macro_popup'>if (displayLevel &gt;= 2) { if ((clock() - g_time &gt; refreshRate<br>) || (displayLevel &gt;= 4)) { g_time = clock(); { fprintf(stderr<br>, "\r%u%%       ", (unsigned)((iteration * 100) / kIterations<br>)); fflush(stderr); }; } }</span></span></td></tr>
<tr class="codeline" data-linenumber="1214"><td class="num" id="LN1214">1214</td><td class="line">                         <span class='macro'>(<span class='keyword'>unsigned</span>)((iteration * 100) / kIterations))<span class='macro_popup'>if (displayLevel &gt;= 2) { if ((clock() - g_time &gt; refreshRate<br>) || (displayLevel &gt;= 4)) { g_time = clock(); { fprintf(stderr<br>, "\r%u%%       ", (unsigned)((iteration * 100) / kIterations<br>)); fflush(stderr); }; } }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1215"><td class="num" id="LN1215">1215</td><td class="line">      ++iteration;</td></tr>
<tr class="codeline" data-linenumber="1216"><td class="num" id="LN1216">1216</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1217"><td class="num" id="LN1217">1217</td><td class="line">    COVER_best_wait(&amp;best);</td></tr>
<tr class="codeline" data-linenumber="1218"><td class="num" id="LN1218">1218</td><td class="line">    COVER_ctx_destroy(&amp;ctx);</td></tr>
<tr class="codeline" data-linenumber="1219"><td class="num" id="LN1219">1219</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="1220"><td class="num" id="LN1220">1220</td><td class="line">  <span class='macro'>LOCALDISPLAYLEVEL(displayLevel, 2, <span class='string_literal'>"\r%79s\r"</span>, <span class='string_literal'>""</span>)<span class='macro_popup'>if (displayLevel &gt;= 2) { { fprintf(stderr, "\r%79s\r", "")<br>; fflush(stderr); }; }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1221"><td class="num" id="LN1221">1221</td><td class="line">  <span class='comment'>/* Fill the output buffer and parameters with output of the best parameters */</span></td></tr>
<tr class="codeline" data-linenumber="1222"><td class="num" id="LN1222">1222</td><td class="line">  {</td></tr>
<tr class="codeline" data-linenumber="1223"><td class="num" id="LN1223">1223</td><td class="line">    <span class='keyword'>const</span> size_t dictSize = best.dictSize;</td></tr>
<tr class="codeline" data-linenumber="1224"><td class="num" id="LN1224">1224</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>ZSTD_isError<span class='macro_popup'>ERR_isError</span></span>(best.compressedSize)) {</td></tr>
<tr class="codeline" data-linenumber="1225"><td class="num" id="LN1225">1225</td><td class="line">      <span class='keyword'>const</span> size_t compressedSize = best.compressedSize;</td></tr>
<tr class="codeline" data-linenumber="1226"><td class="num" id="LN1226">1226</td><td class="line">      COVER_best_destroy(&amp;best);</td></tr>
<tr class="codeline" data-linenumber="1227"><td class="num" id="LN1227">1227</td><td class="line">      POOL_free(pool);</td></tr>
<tr class="codeline" data-linenumber="1228"><td class="num" id="LN1228">1228</td><td class="line">      <span class='keyword'>return</span> compressedSize;</td></tr>
<tr class="codeline" data-linenumber="1229"><td class="num" id="LN1229">1229</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1230"><td class="num" id="LN1230">1230</td><td class="line">    *parameters = best.parameters;</td></tr>
<tr class="codeline" data-linenumber="1231"><td class="num" id="LN1231">1231</td><td class="line">    memcpy(dictBuffer, best.dict, dictSize);</td></tr>
<tr class="codeline" data-linenumber="1232"><td class="num" id="LN1232">1232</td><td class="line">    COVER_best_destroy(&amp;best);</td></tr>
<tr class="codeline" data-linenumber="1233"><td class="num" id="LN1233">1233</td><td class="line">    POOL_free(pool);</td></tr>
<tr class="codeline" data-linenumber="1234"><td class="num" id="LN1234">1234</td><td class="line">    <span class='keyword'>return</span> dictSize;</td></tr>
<tr class="codeline" data-linenumber="1235"><td class="num" id="LN1235">1235</td><td class="line">  }</td></tr>
<tr class="codeline" data-linenumber="1236"><td class="num" id="LN1236">1236</td><td class="line">}</td></tr>
</table></body></html>
