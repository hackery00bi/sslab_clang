<!doctype html>
<html>
<head>
<title>../lib/compress/zstd_compress_internal.h</title>

<style type="text/css">
body { color:#000000; background-color:#ffffff }
body { font-family:Helvetica, sans-serif; font-size:10pt }
h1 { font-size:14pt }
.FileName { margin-top: 5px; margin-bottom: 5px; display: inline; }
.FileNav { margin-left: 5px; margin-right: 5px; display: inline; }
.FileNav a { text-decoration:none; font-size: larger; }
.divider { margin-top: 30px; margin-bottom: 30px; height: 15px; }
.divider { background-color: gray; }
.code { border-collapse:collapse; width:100%; }
.code { font-family: "Monospace", monospace; font-size:10pt }
.code { line-height: 1.2em }
.comment { color: green; font-style: oblique }
.keyword { color: blue }
.string_literal { color: red }
.directive { color: darkmagenta }

/* Macros and variables could have pop-up notes hidden by default.
  - Macro pop-up:    expansion of the macro
  - Variable pop-up: value (table) of the variable */
.macro_popup, .variable_popup { display: none; }

/* Pop-up appears on mouse-hover event. */
.macro:hover .macro_popup, .variable:hover .variable_popup {
  display: block;
  padding: 2px;
  -webkit-border-radius:5px;
  -webkit-box-shadow:1px 1px 7px #000;
  border-radius:5px;
  box-shadow:1px 1px 7px #000;
  position: absolute;
  top: -1em;
  left:10em;
  z-index: 1
}

.macro_popup {
  border: 2px solid red;
  background-color:#FFF0F0;
  font-weight: normal;
}

.variable_popup {
  border: 2px solid blue;
  background-color:#F0F0FF;
  font-weight: bold;
  font-family: Helvetica, sans-serif;
  font-size: 9pt;
}

/* Pop-up notes needs a relative position as a base where they pops up. */
.macro, .variable {
  background-color: PaleGoldenRod;
  position: relative;
}
.macro { color: DarkMagenta; }

#tooltiphint {
  position: fixed;
  width: 50em;
  margin-left: -25em;
  left: 50%;
  padding: 10px;
  border: 1px solid #b0b0b0;
  border-radius: 2px;
  box-shadow: 1px 1px 7px black;
  background-color: #c0c0c0;
  z-index: 2;
}

.num { width:2.5em; padding-right:2ex; background-color:#eeeeee }
.num { text-align:right; font-size:8pt }
.num { color:#444444 }
.line { padding-left: 1ex; border-left: 3px solid #ccc }
.line { white-space: pre }
.msg { -webkit-box-shadow:1px 1px 7px #000 }
.msg { box-shadow:1px 1px 7px #000 }
.msg { -webkit-border-radius:5px }
.msg { border-radius:5px }
.msg { font-family:Helvetica, sans-serif; font-size:8pt }
.msg { float:left }
.msg { padding:0.25em 1ex 0.25em 1ex }
.msg { margin-top:10px; margin-bottom:10px }
.msg { font-weight:bold }
.msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }
.msgT { padding:0x; spacing:0x }
.msgEvent { background-color:#fff8b4; color:#000000 }
.msgControl { background-color:#bbbbbb; color:#000000 }
.msgNote { background-color:#ddeeff; color:#000000 }
.mrange { background-color:#dfddf3 }
.mrange { border-bottom:1px solid #6F9DBE }
.PathIndex { font-weight: bold; padding:0px 5px; margin-right:5px; }
.PathIndex { -webkit-border-radius:8px }
.PathIndex { border-radius:8px }
.PathIndexEvent { background-color:#bfba87 }
.PathIndexControl { background-color:#8c8c8c }
.PathIndexPopUp { background-color: #879abc; }
.PathNav a { text-decoration:none; font-size: larger }
.CodeInsertionHint { font-weight: bold; background-color: #10dd10 }
.CodeRemovalHint { background-color:#de1010 }
.CodeRemovalHint { border-bottom:1px solid #6F9DBE }
.selected{ background-color:orange !important; }

table.simpletable {
  padding: 5px;
  font-size:12pt;
  margin:20px;
  border-collapse: collapse; border-spacing: 0px;
}
td.rowname {
  text-align: right;
  vertical-align: top;
  font-weight: bold;
  color:#444444;
  padding-right:2ex;
}

/* Hidden text. */
input.spoilerhider + label {
  cursor: pointer;
  text-decoration: underline;
  display: block;
}
input.spoilerhider {
 display: none;
}
input.spoilerhider ~ .spoiler {
  overflow: hidden;
  margin: 10px auto 0;
  height: 0;
  opacity: 0;
}
input.spoilerhider:checked + label + .spoiler{
  height: auto;
  opacity: 1;
}
</style>
</head>
<body>
<!-- BUGDESC Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 -->

<!-- BUGTYPE Potential insecure memory buffer bounds restriction in call 'memcpy' -->

<!-- BUGCATEGORY Security -->

<!-- BUGFILE /tmp/sslab_clang/c_zstd/zstd/programs/../lib/compress/zstd_compress_internal.h -->

<!-- FILENAME zstd_compress_internal.h -->

<!-- FUNCTIONNAME ZSTD_updateRep -->

<!-- ISSUEHASHCONTENTOFLINEINCONTEXT dec4927d8749fa8e81693e04ad5c8153 -->

<!-- BUGLINE 348 -->

<!-- BUGCOLUMN 13 -->

<!-- BUGPATHLENGTH 1 -->

<!-- BUGMETAEND -->
<!-- REPORTHEADER -->
<h3>Bug Summary</h3>
<table class="simpletable">
<tr><td class="rowname">File:</td><td>programs/../lib/compress/zstd_compress_internal.h</td></tr>
<tr><td class="rowname">Warning:</td><td><a href="#EndPath">line 348, column 13</a><br />Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11</td></tr>

</table>
<!-- REPORTSUMMARYEXTRA -->
<h3>Annotated Source Code</h3>
<p>Press <a href="#" onclick="toggleHelp(); return false;">'?'</a>
   to see keyboard shortcuts</p>
<input type="checkbox" class="spoilerhider" id="showinvocation" />
<label for="showinvocation" >Show analyzer invocation</label>
<div class="spoiler">clang -cc1 -cc1 -triple x86_64-unknown-linux-gnu -analyze -disable-free -main-file-name zstd_double_fast.c -analyzer-store=region -analyzer-opt-analyze-nested-blocks -analyzer-checker=core -analyzer-checker=apiModeling -analyzer-checker=unix -analyzer-checker=deadcode -analyzer-checker=security.insecureAPI.UncheckedReturn -analyzer-checker=security.insecureAPI.getpw -analyzer-checker=security.insecureAPI.gets -analyzer-checker=security.insecureAPI.mktemp -analyzer-checker=security.insecureAPI.mkstemp -analyzer-checker=security.insecureAPI.vfork -analyzer-checker=nullability.NullPassedToNonnull -analyzer-checker=nullability.NullReturnedFromNonnull -analyzer-output plist -w -setup-static-analyzer -mrelocation-model static -mframe-pointer=none -fmath-errno -fno-rounding-math -mconstructor-aliases -munwind-tables -target-cpu x86-64 -fno-split-dwarf-inlining -debugger-tuning=gdb -resource-dir /llvm-project/build/lib/clang/12.0.0 -D XXH_NAMESPACE=ZSTD_ -D ZSTD_MULTITHREAD -D ZSTD_GZCOMPRESS -D ZSTD_GZDECOMPRESS -D ZSTD_LZMACOMPRESS -D ZSTD_LZMADECOMPRESS -D ZSTD_LZ4COMPRESS -D ZSTD_LZ4DECOMPRESS -D ZSTD_LEGACY_SUPPORT=5 -D BACKTRACE_ENABLE=0 -internal-isystem /usr/local/include -internal-isystem /llvm-project/build/lib/clang/12.0.0/include -internal-externc-isystem /usr/include/x86_64-linux-gnu -internal-externc-isystem /include -internal-externc-isystem /usr/include -O3 -fdebug-compilation-dir /tmp/sslab_clang/c_zstd/zstd/programs -ferror-limit 19 -fgnuc-version=4.2.1 -vectorize-loops -vectorize-slp -analyzer-checker core -analyzer-checker cplusplus -analyzer-checker nullability -analyzer-checker optin -analyzer-checker security -analyzer-checker unix -analyzer-checker osx -analyzer-checker fuchsia -analyzer-checker webkit -analyzer-output=html -faddrsig -o /tmp/scan-build-2020-11-24-150944-25196-1 -x c ../lib/compress/zstd_double_fast.c
</div>
<div id='tooltiphint' hidden="true">
  <p>Keyboard shortcuts: </p>
  <ul>
    <li>Use 'j/k' keys for keyboard navigation</li>
    <li>Use 'Shift+S' to show/hide relevant lines</li>
    <li>Use '?' to toggle this window</li>
  </ul>
  <a href="#" onclick="toggleHelp(); return false;">Close</a>
</div>
<script type='text/javascript'>
var relevant_lines = {"3": {"348": 1}};

var filterCounterexample = function (hide) {
  var tables = document.getElementsByClassName("code");
  for (var t=0; t<tables.length; t++) {
    var table = tables[t];
    var file_id = table.getAttribute("data-fileid");
    var lines_in_fid = relevant_lines[file_id];
    if (!lines_in_fid) {
      lines_in_fid = {};
    }
    var lines = table.getElementsByClassName("codeline");
    for (var i=0; i<lines.length; i++) {
        var el = lines[i];
        var lineNo = el.getAttribute("data-linenumber");
        if (!lines_in_fid[lineNo]) {
          if (hide) {
            el.setAttribute("hidden", "");
          } else {
            el.removeAttribute("hidden");
          }
        }
    }
  }
}

window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.key == "S") {
    var checked = document.getElementsByName("showCounterexample")[0].checked;
    filterCounterexample(!checked);
    document.getElementsByName("showCounterexample")[0].checked = !checked;
  } else {
    return;
  }
  event.preventDefault();
}, true);

document.addEventListener("DOMContentLoaded", function() {
    document.querySelector('input[name="showCounterexample"]').onchange=
        function (event) {
      filterCounterexample(this.checked);
    };
});
</script>

<form>
    <input type="checkbox" name="showCounterexample" id="showCounterexample" />
    <label for="showCounterexample">
       Show only relevant lines
    </label>
</form>

<script type='text/javascript'>
var digitMatcher = new RegExp("[0-9]+");

var querySelectorAllArray = function(selector) {
  return Array.prototype.slice.call(
    document.querySelectorAll(selector));
}

document.addEventListener("DOMContentLoaded", function() {
    querySelectorAllArray(".PathNav > a").forEach(
        function(currentValue, currentIndex) {
            var hrefValue = currentValue.getAttribute("href");
            currentValue.onclick = function() {
                scrollTo(document.querySelector(hrefValue));
                return false;
            };
        });
});

var findNum = function() {
    var s = document.querySelector(".selected");
    if (!s || s.id == "EndPath") {
        return 0;
    }
    var out = parseInt(digitMatcher.exec(s.id)[0]);
    return out;
};

var scrollTo = function(el) {
    querySelectorAllArray(".selected").forEach(function(s) {
        s.classList.remove("selected");
    });
    el.classList.add("selected");
    window.scrollBy(0, el.getBoundingClientRect().top -
        (window.innerHeight / 2));
}

var move = function(num, up, numItems) {
  if (num == 1 && up || num == numItems - 1 && !up) {
    return 0;
  } else if (num == 0 && up) {
    return numItems - 1;
  } else if (num == 0 && !up) {
    return 1 % numItems;
  }
  return up ? num - 1 : num + 1;
}

var numToId = function(num) {
  if (num == 0) {
    return document.getElementById("EndPath")
  }
  return document.getElementById("Path" + num);
};

var navigateTo = function(up) {
  var numItems = document.querySelectorAll(
      ".line > .msgEvent, .line > .msgControl").length;
  var currentSelected = findNum();
  var newSelected = move(currentSelected, up, numItems);
  var newEl = numToId(newSelected, numItems);

  // Scroll element into center.
  scrollTo(newEl);
};

window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.key == "j") {
    navigateTo(/*up=*/false);
  } else if (event.key == "k") {
    navigateTo(/*up=*/true);
  } else {
    return;
  }
  event.preventDefault();
}, true);
</script>
  
<script type='text/javascript'>

var toggleHelp = function() {
    var hint = document.querySelector("#tooltiphint");
    var attributeName = "hidden";
    if (hint.hasAttribute(attributeName)) {
      hint.removeAttribute(attributeName);
    } else {
      hint.setAttribute("hidden", "true");
    }
};
window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.key == "?") {
    toggleHelp();
  } else {
    return;
  }
  event.preventDefault();
});
</script>
<table class="code" data-fileid="3">
<tr class="codeline" data-linenumber="1"><td class="num" id="LN1">1</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr class="codeline" data-linenumber="2"><td class="num" id="LN2">2</td><td class="line"> <span class='comment'>* Copyright (c) 2016-2020, Yann Collet, Facebook, Inc.</span></td></tr>
<tr class="codeline" data-linenumber="3"><td class="num" id="LN3">3</td><td class="line"> <span class='comment'>* All rights reserved.</span></td></tr>
<tr class="codeline" data-linenumber="4"><td class="num" id="LN4">4</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="5"><td class="num" id="LN5">5</td><td class="line"> <span class='comment'>* This source code is licensed under both the BSD-style license (found in the</span></td></tr>
<tr class="codeline" data-linenumber="6"><td class="num" id="LN6">6</td><td class="line"> <span class='comment'>* LICENSE file in the root directory of this source tree) and the GPLv2 (found</span></td></tr>
<tr class="codeline" data-linenumber="7"><td class="num" id="LN7">7</td><td class="line"> <span class='comment'>* in the COPYING file in the root directory of this source tree).</span></td></tr>
<tr class="codeline" data-linenumber="8"><td class="num" id="LN8">8</td><td class="line"> <span class='comment'>* You may select, at your option, one of the above-listed licenses.</span></td></tr>
<tr class="codeline" data-linenumber="9"><td class="num" id="LN9">9</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="10"><td class="num" id="LN10">10</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="11"><td class="num" id="LN11">11</td><td class="line"><span class='comment'>/* This header contains definitions</span></td></tr>
<tr class="codeline" data-linenumber="12"><td class="num" id="LN12">12</td><td class="line"> <span class='comment'>* that shall **only** be used by modules within lib/compress.</span></td></tr>
<tr class="codeline" data-linenumber="13"><td class="num" id="LN13">13</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="14"><td class="num" id="LN14">14</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="15"><td class="num" id="LN15">15</td><td class="line"><span class='directive'>#ifndef ZSTD_COMPRESS_H</span></td></tr>
<tr class="codeline" data-linenumber="16"><td class="num" id="LN16">16</td><td class="line"><span class='directive'>#define ZSTD_COMPRESS_H</span></td></tr>
<tr class="codeline" data-linenumber="17"><td class="num" id="LN17">17</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="18"><td class="num" id="LN18">18</td><td class="line"><span class='comment'>/*-*************************************</span></td></tr>
<tr class="codeline" data-linenumber="19"><td class="num" id="LN19">19</td><td class="line"><span class='comment'>*  Dependencies</span></td></tr>
<tr class="codeline" data-linenumber="20"><td class="num" id="LN20">20</td><td class="line"><span class='comment'>***************************************/</span></td></tr>
<tr class="codeline" data-linenumber="21"><td class="num" id="LN21">21</td><td class="line"><span class='directive'>#include "../common/zstd_internal.h"</span></td></tr>
<tr class="codeline" data-linenumber="22"><td class="num" id="LN22">22</td><td class="line"><span class='directive'>#include "zstd_cwksp.h"</span></td></tr>
<tr class="codeline" data-linenumber="23"><td class="num" id="LN23">23</td><td class="line"><span class='directive'>#ifdef <span class='macro'>ZSTD_MULTITHREAD<span class='macro_popup'>1</span></span></span></td></tr>
<tr class="codeline" data-linenumber="24"><td class="num" id="LN24">24</td><td class="line"><span class='directive'>#  include "zstdmt_compress.h"</span></td></tr>
<tr class="codeline" data-linenumber="25"><td class="num" id="LN25">25</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="26"><td class="num" id="LN26">26</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="27"><td class="num" id="LN27">27</td><td class="line"><span class='directive'>#if defined (__cplusplus)</span></td></tr>
<tr class="codeline" data-linenumber="28"><td class="num" id="LN28">28</td><td class="line"><span class='keyword'>extern</span> <span class='string_literal'>"C"</span> {</td></tr>
<tr class="codeline" data-linenumber="29"><td class="num" id="LN29">29</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="30"><td class="num" id="LN30">30</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="31"><td class="num" id="LN31">31</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="32"><td class="num" id="LN32">32</td><td class="line"><span class='comment'>/*-*************************************</span></td></tr>
<tr class="codeline" data-linenumber="33"><td class="num" id="LN33">33</td><td class="line"><span class='comment'>*  Constants</span></td></tr>
<tr class="codeline" data-linenumber="34"><td class="num" id="LN34">34</td><td class="line"><span class='comment'>***************************************/</span></td></tr>
<tr class="codeline" data-linenumber="35"><td class="num" id="LN35">35</td><td class="line"><span class='directive'>#define <span class='macro'>kSearchStrength<span class='macro_popup'>8</span></span>      8</span></td></tr>
<tr class="codeline" data-linenumber="36"><td class="num" id="LN36">36</td><td class="line"><span class='directive'>#define <span class='macro'>HASH_READ_SIZE<span class='macro_popup'>8</span></span>       8</span></td></tr>
<tr class="codeline" data-linenumber="37"><td class="num" id="LN37">37</td><td class="line"><span class='directive'>#define <span class='macro'>ZSTD_DUBT_UNSORTED_MARK<span class='macro_popup'>1</span></span> 1   /* For btlazy2 strategy, index ZSTD_DUBT_UNSORTED_MARK==1 means "unsorted".</span></td></tr>
<tr class="codeline" data-linenumber="38"><td class="num" id="LN38">38</td><td class="line">                                       <span class='directive'>It could be confused for a real successor at index "1", if sorted as larger than its predecessor.</span></td></tr>
<tr class="codeline" data-linenumber="39"><td class="num" id="LN39">39</td><td class="line">                                       <span class='directive'>It's not a big deal though : candidate will just be sorted again.</span></td></tr>
<tr class="codeline" data-linenumber="40"><td class="num" id="LN40">40</td><td class="line">                                       <span class='directive'>Additionally, candidate position 1 will be lost.</span></td></tr>
<tr class="codeline" data-linenumber="41"><td class="num" id="LN41">41</td><td class="line">                                       <span class='directive'>But candidate 1 cannot hide a large tree of candidates, so it's a minimal loss.</span></td></tr>
<tr class="codeline" data-linenumber="42"><td class="num" id="LN42">42</td><td class="line">                                       <span class='directive'>The benefit is that ZSTD_DUBT_UNSORTED_MARK cannot be mishandled after table re-use with a different strategy.</span></td></tr>
<tr class="codeline" data-linenumber="43"><td class="num" id="LN43">43</td><td class="line">                                       <span class='directive'>This constant is required by ZSTD_compressBlock_btlazy2() and ZSTD_reduceTable_internal() */</span></td></tr>
<tr class="codeline" data-linenumber="44"><td class="num" id="LN44">44</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="45"><td class="num" id="LN45">45</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="46"><td class="num" id="LN46">46</td><td class="line"><span class='comment'>/*-*************************************</span></td></tr>
<tr class="codeline" data-linenumber="47"><td class="num" id="LN47">47</td><td class="line"><span class='comment'>*  Context memory management</span></td></tr>
<tr class="codeline" data-linenumber="48"><td class="num" id="LN48">48</td><td class="line"><span class='comment'>***************************************/</span></td></tr>
<tr class="codeline" data-linenumber="49"><td class="num" id="LN49">49</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>enum</span> { ZSTDcs_created=0, ZSTDcs_init, ZSTDcs_ongoing, ZSTDcs_ending } ZSTD_compressionStage_e;</td></tr>
<tr class="codeline" data-linenumber="50"><td class="num" id="LN50">50</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>enum</span> { zcss_init=0, zcss_load, zcss_flush } ZSTD_cStreamStage;</td></tr>
<tr class="codeline" data-linenumber="51"><td class="num" id="LN51">51</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="52"><td class="num" id="LN52">52</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> ZSTD_prefixDict_s {</td></tr>
<tr class="codeline" data-linenumber="53"><td class="num" id="LN53">53</td><td class="line">    <span class='keyword'>const</span> <span class='keyword'>void</span>* dict;</td></tr>
<tr class="codeline" data-linenumber="54"><td class="num" id="LN54">54</td><td class="line">    size_t dictSize;</td></tr>
<tr class="codeline" data-linenumber="55"><td class="num" id="LN55">55</td><td class="line">    ZSTD_dictContentType_e dictContentType;</td></tr>
<tr class="codeline" data-linenumber="56"><td class="num" id="LN56">56</td><td class="line">} ZSTD_prefixDict;</td></tr>
<tr class="codeline" data-linenumber="57"><td class="num" id="LN57">57</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="58"><td class="num" id="LN58">58</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> {</td></tr>
<tr class="codeline" data-linenumber="59"><td class="num" id="LN59">59</td><td class="line">    <span class='keyword'>void</span>* dictBuffer;</td></tr>
<tr class="codeline" data-linenumber="60"><td class="num" id="LN60">60</td><td class="line">    <span class='keyword'>void</span> <span class='keyword'>const</span>* dict;</td></tr>
<tr class="codeline" data-linenumber="61"><td class="num" id="LN61">61</td><td class="line">    size_t dictSize;</td></tr>
<tr class="codeline" data-linenumber="62"><td class="num" id="LN62">62</td><td class="line">    ZSTD_dictContentType_e dictContentType;</td></tr>
<tr class="codeline" data-linenumber="63"><td class="num" id="LN63">63</td><td class="line">    ZSTD_CDict* cdict;</td></tr>
<tr class="codeline" data-linenumber="64"><td class="num" id="LN64">64</td><td class="line">} ZSTD_localDict;</td></tr>
<tr class="codeline" data-linenumber="65"><td class="num" id="LN65">65</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="66"><td class="num" id="LN66">66</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> {</td></tr>
<tr class="codeline" data-linenumber="67"><td class="num" id="LN67">67</td><td class="line">    U32 CTable[<span class='macro'>HUF_CTABLE_SIZE_U32(255)<span class='macro_popup'>((255)+1)</span></span>];</td></tr>
<tr class="codeline" data-linenumber="68"><td class="num" id="LN68">68</td><td class="line">    HUF_repeat repeatMode;</td></tr>
<tr class="codeline" data-linenumber="69"><td class="num" id="LN69">69</td><td class="line">} ZSTD_hufCTables_t;</td></tr>
<tr class="codeline" data-linenumber="70"><td class="num" id="LN70">70</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="71"><td class="num" id="LN71">71</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> {</td></tr>
<tr class="codeline" data-linenumber="72"><td class="num" id="LN72">72</td><td class="line">    FSE_CTable offcodeCTable[<span class='macro'>FSE_CTABLE_SIZE_U32(OffFSELog, MaxOff)<span class='macro_popup'>(1 + (1&lt;&lt;(8 -1)) + ((31 +1)*2))</span></span>];</td></tr>
<tr class="codeline" data-linenumber="73"><td class="num" id="LN73">73</td><td class="line">    FSE_CTable matchlengthCTable[<span class='macro'>FSE_CTABLE_SIZE_U32(MLFSELog, MaxML)<span class='macro_popup'>(1 + (1&lt;&lt;(9 -1)) + ((52 +1)*2))</span></span>];</td></tr>
<tr class="codeline" data-linenumber="74"><td class="num" id="LN74">74</td><td class="line">    FSE_CTable litlengthCTable[<span class='macro'>FSE_CTABLE_SIZE_U32(LLFSELog, MaxLL)<span class='macro_popup'>(1 + (1&lt;&lt;(9 -1)) + ((35 +1)*2))</span></span>];</td></tr>
<tr class="codeline" data-linenumber="75"><td class="num" id="LN75">75</td><td class="line">    FSE_repeat offcode_repeatMode;</td></tr>
<tr class="codeline" data-linenumber="76"><td class="num" id="LN76">76</td><td class="line">    FSE_repeat matchlength_repeatMode;</td></tr>
<tr class="codeline" data-linenumber="77"><td class="num" id="LN77">77</td><td class="line">    FSE_repeat litlength_repeatMode;</td></tr>
<tr class="codeline" data-linenumber="78"><td class="num" id="LN78">78</td><td class="line">} ZSTD_fseCTables_t;</td></tr>
<tr class="codeline" data-linenumber="79"><td class="num" id="LN79">79</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="80"><td class="num" id="LN80">80</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> {</td></tr>
<tr class="codeline" data-linenumber="81"><td class="num" id="LN81">81</td><td class="line">    ZSTD_hufCTables_t huf;</td></tr>
<tr class="codeline" data-linenumber="82"><td class="num" id="LN82">82</td><td class="line">    ZSTD_fseCTables_t fse;</td></tr>
<tr class="codeline" data-linenumber="83"><td class="num" id="LN83">83</td><td class="line">} ZSTD_entropyCTables_t;</td></tr>
<tr class="codeline" data-linenumber="84"><td class="num" id="LN84">84</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="85"><td class="num" id="LN85">85</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> {</td></tr>
<tr class="codeline" data-linenumber="86"><td class="num" id="LN86">86</td><td class="line">    U32 off;</td></tr>
<tr class="codeline" data-linenumber="87"><td class="num" id="LN87">87</td><td class="line">    U32 len;</td></tr>
<tr class="codeline" data-linenumber="88"><td class="num" id="LN88">88</td><td class="line">} ZSTD_match_t;</td></tr>
<tr class="codeline" data-linenumber="89"><td class="num" id="LN89">89</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="90"><td class="num" id="LN90">90</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> {</td></tr>
<tr class="codeline" data-linenumber="91"><td class="num" id="LN91">91</td><td class="line">    <span class='keyword'>int</span> price;</td></tr>
<tr class="codeline" data-linenumber="92"><td class="num" id="LN92">92</td><td class="line">    U32 off;</td></tr>
<tr class="codeline" data-linenumber="93"><td class="num" id="LN93">93</td><td class="line">    U32 mlen;</td></tr>
<tr class="codeline" data-linenumber="94"><td class="num" id="LN94">94</td><td class="line">    U32 litlen;</td></tr>
<tr class="codeline" data-linenumber="95"><td class="num" id="LN95">95</td><td class="line">    U32 rep[<span class='macro'>ZSTD_REP_NUM<span class='macro_popup'>3</span></span>];</td></tr>
<tr class="codeline" data-linenumber="96"><td class="num" id="LN96">96</td><td class="line">} ZSTD_optimal_t;</td></tr>
<tr class="codeline" data-linenumber="97"><td class="num" id="LN97">97</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="98"><td class="num" id="LN98">98</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>enum</span> { zop_dynamic=0, zop_predef } ZSTD_OptPrice_e;</td></tr>
<tr class="codeline" data-linenumber="99"><td class="num" id="LN99">99</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="100"><td class="num" id="LN100">100</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> {</td></tr>
<tr class="codeline" data-linenumber="101"><td class="num" id="LN101">101</td><td class="line">    <span class='comment'>/* All tables are allocated inside cctx-&gt;workspace by ZSTD_resetCCtx_internal() */</span></td></tr>
<tr class="codeline" data-linenumber="102"><td class="num" id="LN102">102</td><td class="line">    <span class='keyword'>unsigned</span>* litFreq;           <span class='comment'>/* table of literals statistics, of size 256 */</span></td></tr>
<tr class="codeline" data-linenumber="103"><td class="num" id="LN103">103</td><td class="line">    <span class='keyword'>unsigned</span>* litLengthFreq;     <span class='comment'>/* table of litLength statistics, of size (MaxLL+1) */</span></td></tr>
<tr class="codeline" data-linenumber="104"><td class="num" id="LN104">104</td><td class="line">    <span class='keyword'>unsigned</span>* matchLengthFreq;   <span class='comment'>/* table of matchLength statistics, of size (MaxML+1) */</span></td></tr>
<tr class="codeline" data-linenumber="105"><td class="num" id="LN105">105</td><td class="line">    <span class='keyword'>unsigned</span>* offCodeFreq;       <span class='comment'>/* table of offCode statistics, of size (MaxOff+1) */</span></td></tr>
<tr class="codeline" data-linenumber="106"><td class="num" id="LN106">106</td><td class="line">    ZSTD_match_t* matchTable;    <span class='comment'>/* list of found matches, of size ZSTD_OPT_NUM+1 */</span></td></tr>
<tr class="codeline" data-linenumber="107"><td class="num" id="LN107">107</td><td class="line">    ZSTD_optimal_t* priceTable;  <span class='comment'>/* All positions tracked by optimal parser, of size ZSTD_OPT_NUM+1 */</span></td></tr>
<tr class="codeline" data-linenumber="108"><td class="num" id="LN108">108</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="109"><td class="num" id="LN109">109</td><td class="line">    U32  litSum;                 <span class='comment'>/* nb of literals */</span></td></tr>
<tr class="codeline" data-linenumber="110"><td class="num" id="LN110">110</td><td class="line">    U32  litLengthSum;           <span class='comment'>/* nb of litLength codes */</span></td></tr>
<tr class="codeline" data-linenumber="111"><td class="num" id="LN111">111</td><td class="line">    U32  matchLengthSum;         <span class='comment'>/* nb of matchLength codes */</span></td></tr>
<tr class="codeline" data-linenumber="112"><td class="num" id="LN112">112</td><td class="line">    U32  offCodeSum;             <span class='comment'>/* nb of offset codes */</span></td></tr>
<tr class="codeline" data-linenumber="113"><td class="num" id="LN113">113</td><td class="line">    U32  litSumBasePrice;        <span class='comment'>/* to compare to log2(litfreq) */</span></td></tr>
<tr class="codeline" data-linenumber="114"><td class="num" id="LN114">114</td><td class="line">    U32  litLengthSumBasePrice;  <span class='comment'>/* to compare to log2(llfreq)  */</span></td></tr>
<tr class="codeline" data-linenumber="115"><td class="num" id="LN115">115</td><td class="line">    U32  matchLengthSumBasePrice;<span class='comment'>/* to compare to log2(mlfreq)  */</span></td></tr>
<tr class="codeline" data-linenumber="116"><td class="num" id="LN116">116</td><td class="line">    U32  offCodeSumBasePrice;    <span class='comment'>/* to compare to log2(offreq)  */</span></td></tr>
<tr class="codeline" data-linenumber="117"><td class="num" id="LN117">117</td><td class="line">    ZSTD_OptPrice_e priceType;   <span class='comment'>/* prices can be determined dynamically, or follow a pre-defined cost structure */</span></td></tr>
<tr class="codeline" data-linenumber="118"><td class="num" id="LN118">118</td><td class="line">    <span class='keyword'>const</span> ZSTD_entropyCTables_t* symbolCosts;  <span class='comment'>/* pre-calculated dictionary statistics */</span></td></tr>
<tr class="codeline" data-linenumber="119"><td class="num" id="LN119">119</td><td class="line">    ZSTD_literalCompressionMode_e literalCompressionMode;</td></tr>
<tr class="codeline" data-linenumber="120"><td class="num" id="LN120">120</td><td class="line">} optState_t;</td></tr>
<tr class="codeline" data-linenumber="121"><td class="num" id="LN121">121</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="122"><td class="num" id="LN122">122</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> {</td></tr>
<tr class="codeline" data-linenumber="123"><td class="num" id="LN123">123</td><td class="line">  ZSTD_entropyCTables_t entropy;</td></tr>
<tr class="codeline" data-linenumber="124"><td class="num" id="LN124">124</td><td class="line">  U32 rep[<span class='macro'>ZSTD_REP_NUM<span class='macro_popup'>3</span></span>];</td></tr>
<tr class="codeline" data-linenumber="125"><td class="num" id="LN125">125</td><td class="line">} ZSTD_compressedBlockState_t;</td></tr>
<tr class="codeline" data-linenumber="126"><td class="num" id="LN126">126</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="127"><td class="num" id="LN127">127</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> {</td></tr>
<tr class="codeline" data-linenumber="128"><td class="num" id="LN128">128</td><td class="line">    BYTE <span class='keyword'>const</span>* nextSrc;    <span class='comment'>/* next block here to continue on current prefix */</span></td></tr>
<tr class="codeline" data-linenumber="129"><td class="num" id="LN129">129</td><td class="line">    BYTE <span class='keyword'>const</span>* base;       <span class='comment'>/* All regular indexes relative to this position */</span></td></tr>
<tr class="codeline" data-linenumber="130"><td class="num" id="LN130">130</td><td class="line">    BYTE <span class='keyword'>const</span>* dictBase;   <span class='comment'>/* extDict indexes relative to this position */</span></td></tr>
<tr class="codeline" data-linenumber="131"><td class="num" id="LN131">131</td><td class="line">    U32 dictLimit;          <span class='comment'>/* below that point, need extDict */</span></td></tr>
<tr class="codeline" data-linenumber="132"><td class="num" id="LN132">132</td><td class="line">    U32 lowLimit;           <span class='comment'>/* below that point, no more valid data */</span></td></tr>
<tr class="codeline" data-linenumber="133"><td class="num" id="LN133">133</td><td class="line">} ZSTD_window_t;</td></tr>
<tr class="codeline" data-linenumber="134"><td class="num" id="LN134">134</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="135"><td class="num" id="LN135">135</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> ZSTD_matchState_t ZSTD_matchState_t;</td></tr>
<tr class="codeline" data-linenumber="136"><td class="num" id="LN136">136</td><td class="line"><span class='keyword'>struct</span> ZSTD_matchState_t {</td></tr>
<tr class="codeline" data-linenumber="137"><td class="num" id="LN137">137</td><td class="line">    ZSTD_window_t window;   <span class='comment'>/* State for window round buffer management */</span></td></tr>
<tr class="codeline" data-linenumber="138"><td class="num" id="LN138">138</td><td class="line">    U32 loadedDictEnd;      <span class='comment'>/* index of end of dictionary, within context's referential.</span></td></tr>
<tr class="codeline" data-linenumber="139"><td class="num" id="LN139">139</td><td class="line">                             <span class='comment'>* When loadedDictEnd != 0, a dictionary is in use, and still valid.</span></td></tr>
<tr class="codeline" data-linenumber="140"><td class="num" id="LN140">140</td><td class="line">                             <span class='comment'>* This relies on a mechanism to set loadedDictEnd=0 when dictionary is no longer within distance.</span></td></tr>
<tr class="codeline" data-linenumber="141"><td class="num" id="LN141">141</td><td class="line">                             <span class='comment'>* Such mechanism is provided within ZSTD_window_enforceMaxDist() and ZSTD_checkDictValidity().</span></td></tr>
<tr class="codeline" data-linenumber="142"><td class="num" id="LN142">142</td><td class="line">                             <span class='comment'>* When dict referential is copied into active context (i.e. not attached),</span></td></tr>
<tr class="codeline" data-linenumber="143"><td class="num" id="LN143">143</td><td class="line">                             <span class='comment'>* loadedDictEnd == dictSize, since referential starts from zero.</span></td></tr>
<tr class="codeline" data-linenumber="144"><td class="num" id="LN144">144</td><td class="line">                             <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="145"><td class="num" id="LN145">145</td><td class="line">    U32 nextToUpdate;       <span class='comment'>/* index from which to continue table update */</span></td></tr>
<tr class="codeline" data-linenumber="146"><td class="num" id="LN146">146</td><td class="line">    U32 hashLog3;           <span class='comment'>/* dispatch table for matches of len==3 : larger == faster, more memory */</span></td></tr>
<tr class="codeline" data-linenumber="147"><td class="num" id="LN147">147</td><td class="line">    U32* hashTable;</td></tr>
<tr class="codeline" data-linenumber="148"><td class="num" id="LN148">148</td><td class="line">    U32* hashTable3;</td></tr>
<tr class="codeline" data-linenumber="149"><td class="num" id="LN149">149</td><td class="line">    U32* chainTable;</td></tr>
<tr class="codeline" data-linenumber="150"><td class="num" id="LN150">150</td><td class="line">    optState_t opt;         <span class='comment'>/* optimal parser state */</span></td></tr>
<tr class="codeline" data-linenumber="151"><td class="num" id="LN151">151</td><td class="line">    <span class='keyword'>const</span> ZSTD_matchState_t* dictMatchState;</td></tr>
<tr class="codeline" data-linenumber="152"><td class="num" id="LN152">152</td><td class="line">    ZSTD_compressionParameters cParams;</td></tr>
<tr class="codeline" data-linenumber="153"><td class="num" id="LN153">153</td><td class="line">};</td></tr>
<tr class="codeline" data-linenumber="154"><td class="num" id="LN154">154</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="155"><td class="num" id="LN155">155</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> {</td></tr>
<tr class="codeline" data-linenumber="156"><td class="num" id="LN156">156</td><td class="line">    ZSTD_compressedBlockState_t* prevCBlock;</td></tr>
<tr class="codeline" data-linenumber="157"><td class="num" id="LN157">157</td><td class="line">    ZSTD_compressedBlockState_t* nextCBlock;</td></tr>
<tr class="codeline" data-linenumber="158"><td class="num" id="LN158">158</td><td class="line">    ZSTD_matchState_t matchState;</td></tr>
<tr class="codeline" data-linenumber="159"><td class="num" id="LN159">159</td><td class="line">} ZSTD_blockState_t;</td></tr>
<tr class="codeline" data-linenumber="160"><td class="num" id="LN160">160</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="161"><td class="num" id="LN161">161</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> {</td></tr>
<tr class="codeline" data-linenumber="162"><td class="num" id="LN162">162</td><td class="line">    U32 offset;</td></tr>
<tr class="codeline" data-linenumber="163"><td class="num" id="LN163">163</td><td class="line">    U32 checksum;</td></tr>
<tr class="codeline" data-linenumber="164"><td class="num" id="LN164">164</td><td class="line">} ldmEntry_t;</td></tr>
<tr class="codeline" data-linenumber="165"><td class="num" id="LN165">165</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="166"><td class="num" id="LN166">166</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> {</td></tr>
<tr class="codeline" data-linenumber="167"><td class="num" id="LN167">167</td><td class="line">    ZSTD_window_t window;   <span class='comment'>/* State for the window round buffer management */</span></td></tr>
<tr class="codeline" data-linenumber="168"><td class="num" id="LN168">168</td><td class="line">    ldmEntry_t* hashTable;</td></tr>
<tr class="codeline" data-linenumber="169"><td class="num" id="LN169">169</td><td class="line">    U32 loadedDictEnd;</td></tr>
<tr class="codeline" data-linenumber="170"><td class="num" id="LN170">170</td><td class="line">    BYTE* bucketOffsets;    <span class='comment'>/* Next position in bucket to insert entry */</span></td></tr>
<tr class="codeline" data-linenumber="171"><td class="num" id="LN171">171</td><td class="line">    U64 hashPower;          <span class='comment'>/* Used to compute the rolling hash.</span></td></tr>
<tr class="codeline" data-linenumber="172"><td class="num" id="LN172">172</td><td class="line">                             <span class='comment'>* Depends on ldmParams.minMatchLength */</span></td></tr>
<tr class="codeline" data-linenumber="173"><td class="num" id="LN173">173</td><td class="line">} ldmState_t;</td></tr>
<tr class="codeline" data-linenumber="174"><td class="num" id="LN174">174</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="175"><td class="num" id="LN175">175</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> {</td></tr>
<tr class="codeline" data-linenumber="176"><td class="num" id="LN176">176</td><td class="line">    U32 enableLdm;          <span class='comment'>/* 1 if enable long distance matching */</span></td></tr>
<tr class="codeline" data-linenumber="177"><td class="num" id="LN177">177</td><td class="line">    U32 hashLog;            <span class='comment'>/* Log size of hashTable */</span></td></tr>
<tr class="codeline" data-linenumber="178"><td class="num" id="LN178">178</td><td class="line">    U32 bucketSizeLog;      <span class='comment'>/* Log bucket size for collision resolution, at most 8 */</span></td></tr>
<tr class="codeline" data-linenumber="179"><td class="num" id="LN179">179</td><td class="line">    U32 minMatchLength;     <span class='comment'>/* Minimum match length */</span></td></tr>
<tr class="codeline" data-linenumber="180"><td class="num" id="LN180">180</td><td class="line">    U32 hashRateLog;       <span class='comment'>/* Log number of entries to skip */</span></td></tr>
<tr class="codeline" data-linenumber="181"><td class="num" id="LN181">181</td><td class="line">    U32 windowLog;          <span class='comment'>/* Window log for the LDM */</span></td></tr>
<tr class="codeline" data-linenumber="182"><td class="num" id="LN182">182</td><td class="line">} ldmParams_t;</td></tr>
<tr class="codeline" data-linenumber="183"><td class="num" id="LN183">183</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="184"><td class="num" id="LN184">184</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> {</td></tr>
<tr class="codeline" data-linenumber="185"><td class="num" id="LN185">185</td><td class="line">    U32 offset;</td></tr>
<tr class="codeline" data-linenumber="186"><td class="num" id="LN186">186</td><td class="line">    U32 litLength;</td></tr>
<tr class="codeline" data-linenumber="187"><td class="num" id="LN187">187</td><td class="line">    U32 matchLength;</td></tr>
<tr class="codeline" data-linenumber="188"><td class="num" id="LN188">188</td><td class="line">} rawSeq;</td></tr>
<tr class="codeline" data-linenumber="189"><td class="num" id="LN189">189</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="190"><td class="num" id="LN190">190</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> {</td></tr>
<tr class="codeline" data-linenumber="191"><td class="num" id="LN191">191</td><td class="line">  rawSeq* seq;     <span class='comment'>/* The start of the sequences */</span></td></tr>
<tr class="codeline" data-linenumber="192"><td class="num" id="LN192">192</td><td class="line">  size_t pos;      <span class='comment'>/* The position where reading stopped. &lt;= size. */</span></td></tr>
<tr class="codeline" data-linenumber="193"><td class="num" id="LN193">193</td><td class="line">  size_t size;     <span class='comment'>/* The number of sequences. &lt;= capacity. */</span></td></tr>
<tr class="codeline" data-linenumber="194"><td class="num" id="LN194">194</td><td class="line">  size_t capacity; <span class='comment'>/* The capacity starting from `seq` pointer */</span></td></tr>
<tr class="codeline" data-linenumber="195"><td class="num" id="LN195">195</td><td class="line">} rawSeqStore_t;</td></tr>
<tr class="codeline" data-linenumber="196"><td class="num" id="LN196">196</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="197"><td class="num" id="LN197">197</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> {</td></tr>
<tr class="codeline" data-linenumber="198"><td class="num" id="LN198">198</td><td class="line">    <span class='keyword'>int</span> collectSequences;</td></tr>
<tr class="codeline" data-linenumber="199"><td class="num" id="LN199">199</td><td class="line">    ZSTD_Sequence* seqStart;</td></tr>
<tr class="codeline" data-linenumber="200"><td class="num" id="LN200">200</td><td class="line">    size_t seqIndex;</td></tr>
<tr class="codeline" data-linenumber="201"><td class="num" id="LN201">201</td><td class="line">    size_t maxSequences;</td></tr>
<tr class="codeline" data-linenumber="202"><td class="num" id="LN202">202</td><td class="line">} SeqCollector;</td></tr>
<tr class="codeline" data-linenumber="203"><td class="num" id="LN203">203</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="204"><td class="num" id="LN204">204</td><td class="line"><span class='keyword'>struct</span> ZSTD_CCtx_params_s {</td></tr>
<tr class="codeline" data-linenumber="205"><td class="num" id="LN205">205</td><td class="line">    ZSTD_format_e format;</td></tr>
<tr class="codeline" data-linenumber="206"><td class="num" id="LN206">206</td><td class="line">    ZSTD_compressionParameters cParams;</td></tr>
<tr class="codeline" data-linenumber="207"><td class="num" id="LN207">207</td><td class="line">    ZSTD_frameParameters fParams;</td></tr>
<tr class="codeline" data-linenumber="208"><td class="num" id="LN208">208</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="209"><td class="num" id="LN209">209</td><td class="line">    <span class='keyword'>int</span> compressionLevel;</td></tr>
<tr class="codeline" data-linenumber="210"><td class="num" id="LN210">210</td><td class="line">    <span class='keyword'>int</span> forceWindow;           <span class='comment'>/* force back-references to respect limit of</span></td></tr>
<tr class="codeline" data-linenumber="211"><td class="num" id="LN211">211</td><td class="line">                                <span class='comment'>* 1&lt;&lt;wLog, even for dictionary */</span></td></tr>
<tr class="codeline" data-linenumber="212"><td class="num" id="LN212">212</td><td class="line">    size_t targetCBlockSize;   <span class='comment'>/* Tries to fit compressed block size to be around targetCBlockSize.</span></td></tr>
<tr class="codeline" data-linenumber="213"><td class="num" id="LN213">213</td><td class="line">                                <span class='comment'>* No target when targetCBlockSize == 0.</span></td></tr>
<tr class="codeline" data-linenumber="214"><td class="num" id="LN214">214</td><td class="line">                                <span class='comment'>* There is no guarantee on compressed block size */</span></td></tr>
<tr class="codeline" data-linenumber="215"><td class="num" id="LN215">215</td><td class="line">    <span class='keyword'>int</span> srcSizeHint;           <span class='comment'>/* User's best guess of source size.</span></td></tr>
<tr class="codeline" data-linenumber="216"><td class="num" id="LN216">216</td><td class="line">                                <span class='comment'>* Hint is not valid when srcSizeHint == 0.</span></td></tr>
<tr class="codeline" data-linenumber="217"><td class="num" id="LN217">217</td><td class="line">                                <span class='comment'>* There is no guarantee that hint is close to actual source size */</span></td></tr>
<tr class="codeline" data-linenumber="218"><td class="num" id="LN218">218</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="219"><td class="num" id="LN219">219</td><td class="line">    ZSTD_dictAttachPref_e attachDictPref;</td></tr>
<tr class="codeline" data-linenumber="220"><td class="num" id="LN220">220</td><td class="line">    ZSTD_literalCompressionMode_e literalCompressionMode;</td></tr>
<tr class="codeline" data-linenumber="221"><td class="num" id="LN221">221</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="222"><td class="num" id="LN222">222</td><td class="line">    <span class='comment'>/* Multithreading: used to pass parameters to mtctx */</span></td></tr>
<tr class="codeline" data-linenumber="223"><td class="num" id="LN223">223</td><td class="line">    <span class='keyword'>int</span> nbWorkers;</td></tr>
<tr class="codeline" data-linenumber="224"><td class="num" id="LN224">224</td><td class="line">    size_t jobSize;</td></tr>
<tr class="codeline" data-linenumber="225"><td class="num" id="LN225">225</td><td class="line">    <span class='keyword'>int</span> overlapLog;</td></tr>
<tr class="codeline" data-linenumber="226"><td class="num" id="LN226">226</td><td class="line">    <span class='keyword'>int</span> rsyncable;</td></tr>
<tr class="codeline" data-linenumber="227"><td class="num" id="LN227">227</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="228"><td class="num" id="LN228">228</td><td class="line">    <span class='comment'>/* Long distance matching parameters */</span></td></tr>
<tr class="codeline" data-linenumber="229"><td class="num" id="LN229">229</td><td class="line">    ldmParams_t ldmParams;</td></tr>
<tr class="codeline" data-linenumber="230"><td class="num" id="LN230">230</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="231"><td class="num" id="LN231">231</td><td class="line">    <span class='comment'>/* Internal use, for createCCtxParams() and freeCCtxParams() only */</span></td></tr>
<tr class="codeline" data-linenumber="232"><td class="num" id="LN232">232</td><td class="line">    ZSTD_customMem customMem;</td></tr>
<tr class="codeline" data-linenumber="233"><td class="num" id="LN233">233</td><td class="line">};  <span class='comment'>/* typedef'd to ZSTD_CCtx_params within "zstd.h" */</span></td></tr>
<tr class="codeline" data-linenumber="234"><td class="num" id="LN234">234</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="235"><td class="num" id="LN235">235</td><td class="line"><span class='keyword'>struct</span> ZSTD_CCtx_s {</td></tr>
<tr class="codeline" data-linenumber="236"><td class="num" id="LN236">236</td><td class="line">    ZSTD_compressionStage_e stage;</td></tr>
<tr class="codeline" data-linenumber="237"><td class="num" id="LN237">237</td><td class="line">    <span class='keyword'>int</span> cParamsChanged;                  <span class='comment'>/* == 1 if cParams(except wlog) or compression level are changed in requestedParams. Triggers transmission of new params to ZSTDMT (if available) then reset to 0. */</span></td></tr>
<tr class="codeline" data-linenumber="238"><td class="num" id="LN238">238</td><td class="line">    <span class='keyword'>int</span> bmi2;                            <span class='comment'>/* == 1 if the CPU supports BMI2 and 0 otherwise. CPU support is determined dynamically once per context lifetime. */</span></td></tr>
<tr class="codeline" data-linenumber="239"><td class="num" id="LN239">239</td><td class="line">    ZSTD_CCtx_params requestedParams;</td></tr>
<tr class="codeline" data-linenumber="240"><td class="num" id="LN240">240</td><td class="line">    ZSTD_CCtx_params appliedParams;</td></tr>
<tr class="codeline" data-linenumber="241"><td class="num" id="LN241">241</td><td class="line">    U32   dictID;</td></tr>
<tr class="codeline" data-linenumber="242"><td class="num" id="LN242">242</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="243"><td class="num" id="LN243">243</td><td class="line">    ZSTD_cwksp workspace; <span class='comment'>/* manages buffer for dynamic allocations */</span></td></tr>
<tr class="codeline" data-linenumber="244"><td class="num" id="LN244">244</td><td class="line">    size_t blockSize;</td></tr>
<tr class="codeline" data-linenumber="245"><td class="num" id="LN245">245</td><td class="line">    <span class='keyword'>unsigned</span> <span class='keyword'>long</span> <span class='keyword'>long</span> pledgedSrcSizePlusOne;  <span class='comment'>/* this way, 0 (default) == unknown */</span></td></tr>
<tr class="codeline" data-linenumber="246"><td class="num" id="LN246">246</td><td class="line">    <span class='keyword'>unsigned</span> <span class='keyword'>long</span> <span class='keyword'>long</span> consumedSrcSize;</td></tr>
<tr class="codeline" data-linenumber="247"><td class="num" id="LN247">247</td><td class="line">    <span class='keyword'>unsigned</span> <span class='keyword'>long</span> <span class='keyword'>long</span> producedCSize;</td></tr>
<tr class="codeline" data-linenumber="248"><td class="num" id="LN248">248</td><td class="line">    XXH64_state_t xxhState;</td></tr>
<tr class="codeline" data-linenumber="249"><td class="num" id="LN249">249</td><td class="line">    ZSTD_customMem customMem;</td></tr>
<tr class="codeline" data-linenumber="250"><td class="num" id="LN250">250</td><td class="line">    size_t staticSize;</td></tr>
<tr class="codeline" data-linenumber="251"><td class="num" id="LN251">251</td><td class="line">    SeqCollector seqCollector;</td></tr>
<tr class="codeline" data-linenumber="252"><td class="num" id="LN252">252</td><td class="line">    <span class='keyword'>int</span> isFirstBlock;</td></tr>
<tr class="codeline" data-linenumber="253"><td class="num" id="LN253">253</td><td class="line">    <span class='keyword'>int</span> initialized;</td></tr>
<tr class="codeline" data-linenumber="254"><td class="num" id="LN254">254</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="255"><td class="num" id="LN255">255</td><td class="line">    seqStore_t seqStore;      <span class='comment'>/* sequences storage ptrs */</span></td></tr>
<tr class="codeline" data-linenumber="256"><td class="num" id="LN256">256</td><td class="line">    ldmState_t ldmState;      <span class='comment'>/* long distance matching state */</span></td></tr>
<tr class="codeline" data-linenumber="257"><td class="num" id="LN257">257</td><td class="line">    rawSeq* ldmSequences;     <span class='comment'>/* Storage for the ldm output sequences */</span></td></tr>
<tr class="codeline" data-linenumber="258"><td class="num" id="LN258">258</td><td class="line">    size_t maxNbLdmSequences;</td></tr>
<tr class="codeline" data-linenumber="259"><td class="num" id="LN259">259</td><td class="line">    rawSeqStore_t externSeqStore; <span class='comment'>/* Mutable reference to external sequences */</span></td></tr>
<tr class="codeline" data-linenumber="260"><td class="num" id="LN260">260</td><td class="line">    ZSTD_blockState_t blockState;</td></tr>
<tr class="codeline" data-linenumber="261"><td class="num" id="LN261">261</td><td class="line">    U32* entropyWorkspace;  <span class='comment'>/* entropy workspace of HUF_WORKSPACE_SIZE bytes */</span></td></tr>
<tr class="codeline" data-linenumber="262"><td class="num" id="LN262">262</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="263"><td class="num" id="LN263">263</td><td class="line">    <span class='comment'>/* streaming */</span></td></tr>
<tr class="codeline" data-linenumber="264"><td class="num" id="LN264">264</td><td class="line">    <span class='keyword'>char</span>*  inBuff;</td></tr>
<tr class="codeline" data-linenumber="265"><td class="num" id="LN265">265</td><td class="line">    size_t inBuffSize;</td></tr>
<tr class="codeline" data-linenumber="266"><td class="num" id="LN266">266</td><td class="line">    size_t inToCompress;</td></tr>
<tr class="codeline" data-linenumber="267"><td class="num" id="LN267">267</td><td class="line">    size_t inBuffPos;</td></tr>
<tr class="codeline" data-linenumber="268"><td class="num" id="LN268">268</td><td class="line">    size_t inBuffTarget;</td></tr>
<tr class="codeline" data-linenumber="269"><td class="num" id="LN269">269</td><td class="line">    <span class='keyword'>char</span>*  outBuff;</td></tr>
<tr class="codeline" data-linenumber="270"><td class="num" id="LN270">270</td><td class="line">    size_t outBuffSize;</td></tr>
<tr class="codeline" data-linenumber="271"><td class="num" id="LN271">271</td><td class="line">    size_t outBuffContentSize;</td></tr>
<tr class="codeline" data-linenumber="272"><td class="num" id="LN272">272</td><td class="line">    size_t outBuffFlushedSize;</td></tr>
<tr class="codeline" data-linenumber="273"><td class="num" id="LN273">273</td><td class="line">    ZSTD_cStreamStage streamStage;</td></tr>
<tr class="codeline" data-linenumber="274"><td class="num" id="LN274">274</td><td class="line">    U32    frameEnded;</td></tr>
<tr class="codeline" data-linenumber="275"><td class="num" id="LN275">275</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="276"><td class="num" id="LN276">276</td><td class="line">    <span class='comment'>/* Dictionary */</span></td></tr>
<tr class="codeline" data-linenumber="277"><td class="num" id="LN277">277</td><td class="line">    ZSTD_localDict localDict;</td></tr>
<tr class="codeline" data-linenumber="278"><td class="num" id="LN278">278</td><td class="line">    <span class='keyword'>const</span> ZSTD_CDict* cdict;</td></tr>
<tr class="codeline" data-linenumber="279"><td class="num" id="LN279">279</td><td class="line">    ZSTD_prefixDict prefixDict;   <span class='comment'>/* single-usage dictionary */</span></td></tr>
<tr class="codeline" data-linenumber="280"><td class="num" id="LN280">280</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="281"><td class="num" id="LN281">281</td><td class="line">    <span class='comment'>/* Multi-threading */</span></td></tr>
<tr class="codeline" data-linenumber="282"><td class="num" id="LN282">282</td><td class="line"><span class='directive'>#ifdef <span class='macro'>ZSTD_MULTITHREAD<span class='macro_popup'>1</span></span></span></td></tr>
<tr class="codeline" data-linenumber="283"><td class="num" id="LN283">283</td><td class="line">    ZSTDMT_CCtx* mtctx;</td></tr>
<tr class="codeline" data-linenumber="284"><td class="num" id="LN284">284</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="285"><td class="num" id="LN285">285</td><td class="line">};</td></tr>
<tr class="codeline" data-linenumber="286"><td class="num" id="LN286">286</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="287"><td class="num" id="LN287">287</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>enum</span> { ZSTD_dtlm_fast, ZSTD_dtlm_full } ZSTD_dictTableLoadMethod_e;</td></tr>
<tr class="codeline" data-linenumber="288"><td class="num" id="LN288">288</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="289"><td class="num" id="LN289">289</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>enum</span> { ZSTD_noDict = 0, ZSTD_extDict = 1, ZSTD_dictMatchState = 2 } ZSTD_dictMode_e;</td></tr>
<tr class="codeline" data-linenumber="290"><td class="num" id="LN290">290</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="291"><td class="num" id="LN291">291</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="292"><td class="num" id="LN292">292</td><td class="line"><span class='keyword'>typedef</span> size_t (*ZSTD_blockCompressor) (</td></tr>
<tr class="codeline" data-linenumber="293"><td class="num" id="LN293">293</td><td class="line">        ZSTD_matchState_t* bs, seqStore_t* seqStore, U32 rep[<span class='macro'>ZSTD_REP_NUM<span class='macro_popup'>3</span></span>],</td></tr>
<tr class="codeline" data-linenumber="294"><td class="num" id="LN294">294</td><td class="line">        <span class='keyword'>void</span> <span class='keyword'>const</span>* src, size_t srcSize);</td></tr>
<tr class="codeline" data-linenumber="295"><td class="num" id="LN295">295</td><td class="line">ZSTD_blockCompressor ZSTD_selectBlockCompressor(ZSTD_strategy strat, ZSTD_dictMode_e dictMode);</td></tr>
<tr class="codeline" data-linenumber="296"><td class="num" id="LN296">296</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="297"><td class="num" id="LN297">297</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="298"><td class="num" id="LN298">298</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> U32 ZSTD_LLcode(U32 litLength)</td></tr>
<tr class="codeline" data-linenumber="299"><td class="num" id="LN299">299</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="300"><td class="num" id="LN300">300</td><td class="line">    <span class='keyword'>static</span> <span class='keyword'>const</span> BYTE LL_Code[64] = {  0,  1,  2,  3,  4,  5,  6,  7,</td></tr>
<tr class="codeline" data-linenumber="301"><td class="num" id="LN301">301</td><td class="line">                                       8,  9, 10, 11, 12, 13, 14, 15,</td></tr>
<tr class="codeline" data-linenumber="302"><td class="num" id="LN302">302</td><td class="line">                                      16, 16, 17, 17, 18, 18, 19, 19,</td></tr>
<tr class="codeline" data-linenumber="303"><td class="num" id="LN303">303</td><td class="line">                                      20, 20, 20, 20, 21, 21, 21, 21,</td></tr>
<tr class="codeline" data-linenumber="304"><td class="num" id="LN304">304</td><td class="line">                                      22, 22, 22, 22, 22, 22, 22, 22,</td></tr>
<tr class="codeline" data-linenumber="305"><td class="num" id="LN305">305</td><td class="line">                                      23, 23, 23, 23, 23, 23, 23, 23,</td></tr>
<tr class="codeline" data-linenumber="306"><td class="num" id="LN306">306</td><td class="line">                                      24, 24, 24, 24, 24, 24, 24, 24,</td></tr>
<tr class="codeline" data-linenumber="307"><td class="num" id="LN307">307</td><td class="line">                                      24, 24, 24, 24, 24, 24, 24, 24 };</td></tr>
<tr class="codeline" data-linenumber="308"><td class="num" id="LN308">308</td><td class="line">    <span class='keyword'>static</span> <span class='keyword'>const</span> U32 LL_deltaCode = 19;</td></tr>
<tr class="codeline" data-linenumber="309"><td class="num" id="LN309">309</td><td class="line">    <span class='keyword'>return</span> (litLength &gt; 63) ? ZSTD_highbit32(litLength) + LL_deltaCode : LL_Code[litLength];</td></tr>
<tr class="codeline" data-linenumber="310"><td class="num" id="LN310">310</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="311"><td class="num" id="LN311">311</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="312"><td class="num" id="LN312">312</td><td class="line"><span class='comment'>/* ZSTD_MLcode() :</span></td></tr>
<tr class="codeline" data-linenumber="313"><td class="num" id="LN313">313</td><td class="line"> <span class='comment'>* note : mlBase = matchLength - MINMATCH;</span></td></tr>
<tr class="codeline" data-linenumber="314"><td class="num" id="LN314">314</td><td class="line"> <span class='comment'>*        because it's the format it's stored in seqStore-&gt;sequences */</span></td></tr>
<tr class="codeline" data-linenumber="315"><td class="num" id="LN315">315</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> U32 ZSTD_MLcode(U32 mlBase)</td></tr>
<tr class="codeline" data-linenumber="316"><td class="num" id="LN316">316</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="317"><td class="num" id="LN317">317</td><td class="line">    <span class='keyword'>static</span> <span class='keyword'>const</span> BYTE ML_Code[128] = { 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,</td></tr>
<tr class="codeline" data-linenumber="318"><td class="num" id="LN318">318</td><td class="line">                                      16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,</td></tr>
<tr class="codeline" data-linenumber="319"><td class="num" id="LN319">319</td><td class="line">                                      32, 32, 33, 33, 34, 34, 35, 35, 36, 36, 36, 36, 37, 37, 37, 37,</td></tr>
<tr class="codeline" data-linenumber="320"><td class="num" id="LN320">320</td><td class="line">                                      38, 38, 38, 38, 38, 38, 38, 38, 39, 39, 39, 39, 39, 39, 39, 39,</td></tr>
<tr class="codeline" data-linenumber="321"><td class="num" id="LN321">321</td><td class="line">                                      40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,</td></tr>
<tr class="codeline" data-linenumber="322"><td class="num" id="LN322">322</td><td class="line">                                      41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41,</td></tr>
<tr class="codeline" data-linenumber="323"><td class="num" id="LN323">323</td><td class="line">                                      42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,</td></tr>
<tr class="codeline" data-linenumber="324"><td class="num" id="LN324">324</td><td class="line">                                      42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42 };</td></tr>
<tr class="codeline" data-linenumber="325"><td class="num" id="LN325">325</td><td class="line">    <span class='keyword'>static</span> <span class='keyword'>const</span> U32 ML_deltaCode = 36;</td></tr>
<tr class="codeline" data-linenumber="326"><td class="num" id="LN326">326</td><td class="line">    <span class='keyword'>return</span> (mlBase &gt; 127) ? ZSTD_highbit32(mlBase) + ML_deltaCode : ML_Code[mlBase];</td></tr>
<tr class="codeline" data-linenumber="327"><td class="num" id="LN327">327</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="328"><td class="num" id="LN328">328</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="329"><td class="num" id="LN329">329</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> repcodes_s {</td></tr>
<tr class="codeline" data-linenumber="330"><td class="num" id="LN330">330</td><td class="line">    U32 rep[3];</td></tr>
<tr class="codeline" data-linenumber="331"><td class="num" id="LN331">331</td><td class="line">} repcodes_t;</td></tr>
<tr class="codeline" data-linenumber="332"><td class="num" id="LN332">332</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="333"><td class="num" id="LN333">333</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> repcodes_t ZSTD_updateRep(U32 <span class='keyword'>const</span> rep[3], U32 <span class='keyword'>const</span> offset, U32 <span class='keyword'>const</span> ll0)</td></tr>
<tr class="codeline" data-linenumber="334"><td class="num" id="LN334">334</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="335"><td class="num" id="LN335">335</td><td class="line">    repcodes_t newReps;</td></tr>
<tr class="codeline" data-linenumber="336"><td class="num" id="LN336">336</td><td class="line">    <span class='keyword'>if</span> (offset &gt;= <span class='macro'>ZSTD_REP_NUM<span class='macro_popup'>3</span></span>) {  <span class='comment'>/* full offset */</span></td></tr>
<tr class="codeline" data-linenumber="337"><td class="num" id="LN337">337</td><td class="line">        newReps.rep[2] = rep[1];</td></tr>
<tr class="codeline" data-linenumber="338"><td class="num" id="LN338">338</td><td class="line">        newReps.rep[1] = rep[0];</td></tr>
<tr class="codeline" data-linenumber="339"><td class="num" id="LN339">339</td><td class="line">        newReps.rep[0] = offset - <span class='macro'>ZSTD_REP_MOVE<span class='macro_popup'>(3 -1)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="340"><td class="num" id="LN340">340</td><td class="line">    } <span class='keyword'>else</span> {   <span class='comment'>/* repcode */</span></td></tr>
<tr class="codeline" data-linenumber="341"><td class="num" id="LN341">341</td><td class="line">        U32 <span class='keyword'>const</span> repCode = offset + ll0;</td></tr>
<tr class="codeline" data-linenumber="342"><td class="num" id="LN342">342</td><td class="line">        <span class='keyword'>if</span> (repCode &gt; 0) {  <span class='comment'>/* note : if repCode==0, no change */</span></td></tr>
<tr class="codeline" data-linenumber="343"><td class="num" id="LN343">343</td><td class="line">            U32 <span class='keyword'>const</span> currentOffset = (repCode==<span class='macro'>ZSTD_REP_NUM<span class='macro_popup'>3</span></span>) ? (rep[0] - 1) : rep[repCode];</td></tr>
<tr class="codeline" data-linenumber="344"><td class="num" id="LN344">344</td><td class="line">            newReps.rep[2] = (repCode &gt;= 2) ? rep[1] : rep[2];</td></tr>
<tr class="codeline" data-linenumber="345"><td class="num" id="LN345">345</td><td class="line">            newReps.rep[1] = rep[0];</td></tr>
<tr class="codeline" data-linenumber="346"><td class="num" id="LN346">346</td><td class="line">            newReps.rep[0] = currentOffset;</td></tr>
<tr class="codeline" data-linenumber="347"><td class="num" id="LN347">347</td><td class="line">        } <span class='keyword'>else</span> {   <span class='comment'>/* repCode == 0 */</span></td></tr>
<tr class="codeline" data-linenumber="348"><td class="num" id="LN348">348</td><td class="line">            <span class="mrange">memcpy</span>(&amp;newReps, rep, <span class='keyword'>sizeof</span>(newReps));</td></tr>
<tr><td class="num"></td><td class="line"><div id="EndPath" class="msg msgEvent" style="margin-left:13ex; max-width:58em">Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11</div></td></tr>
<tr class="codeline" data-linenumber="349"><td class="num" id="LN349">349</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="350"><td class="num" id="LN350">350</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="351"><td class="num" id="LN351">351</td><td class="line">    <span class='keyword'>return</span> newReps;</td></tr>
<tr class="codeline" data-linenumber="352"><td class="num" id="LN352">352</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="353"><td class="num" id="LN353">353</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="354"><td class="num" id="LN354">354</td><td class="line"><span class='comment'>/* ZSTD_cParam_withinBounds:</span></td></tr>
<tr class="codeline" data-linenumber="355"><td class="num" id="LN355">355</td><td class="line"> <span class='comment'>* @return 1 if value is within cParam bounds,</span></td></tr>
<tr class="codeline" data-linenumber="356"><td class="num" id="LN356">356</td><td class="line"> <span class='comment'>* 0 otherwise */</span></td></tr>
<tr class="codeline" data-linenumber="357"><td class="num" id="LN357">357</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> <span class='keyword'>int</span> ZSTD_cParam_withinBounds(ZSTD_cParameter cParam, <span class='keyword'>int</span> value)</td></tr>
<tr class="codeline" data-linenumber="358"><td class="num" id="LN358">358</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="359"><td class="num" id="LN359">359</td><td class="line">    ZSTD_bounds <span class='keyword'>const</span> bounds = ZSTD_cParam_getBounds(cParam);</td></tr>
<tr class="codeline" data-linenumber="360"><td class="num" id="LN360">360</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>ZSTD_isError<span class='macro_popup'>ERR_isError</span></span>(bounds.error)) <span class='keyword'>return</span> 0;</td></tr>
<tr class="codeline" data-linenumber="361"><td class="num" id="LN361">361</td><td class="line">    <span class='keyword'>if</span> (value &lt; bounds.lowerBound) <span class='keyword'>return</span> 0;</td></tr>
<tr class="codeline" data-linenumber="362"><td class="num" id="LN362">362</td><td class="line">    <span class='keyword'>if</span> (value &gt; bounds.upperBound) <span class='keyword'>return</span> 0;</td></tr>
<tr class="codeline" data-linenumber="363"><td class="num" id="LN363">363</td><td class="line">    <span class='keyword'>return</span> 1;</td></tr>
<tr class="codeline" data-linenumber="364"><td class="num" id="LN364">364</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="365"><td class="num" id="LN365">365</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="366"><td class="num" id="LN366">366</td><td class="line"><span class='comment'>/* ZSTD_noCompressBlock() :</span></td></tr>
<tr class="codeline" data-linenumber="367"><td class="num" id="LN367">367</td><td class="line"> <span class='comment'>* Writes uncompressed block to dst buffer from given src.</span></td></tr>
<tr class="codeline" data-linenumber="368"><td class="num" id="LN368">368</td><td class="line"> <span class='comment'>* Returns the size of the block */</span></td></tr>
<tr class="codeline" data-linenumber="369"><td class="num" id="LN369">369</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> size_t ZSTD_noCompressBlock (<span class='keyword'>void</span>* dst, size_t dstCapacity, <span class='keyword'>const</span> <span class='keyword'>void</span>* src, size_t srcSize, U32 lastBlock)</td></tr>
<tr class="codeline" data-linenumber="370"><td class="num" id="LN370">370</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="371"><td class="num" id="LN371">371</td><td class="line">    U32 <span class='keyword'>const</span> cBlockHeader24 = lastBlock + (((U32)bt_raw)&lt;&lt;1) + (U32)(srcSize &lt;&lt; 3);</td></tr>
<tr class="codeline" data-linenumber="372"><td class="num" id="LN372">372</td><td class="line">    <span class='macro'>RETURN_ERROR_IF(srcSize + ZSTD_blockHeaderSize &gt; dstCapacity,<span class='macro_popup'>if (srcSize + ZSTD_blockHeaderSize &gt; dstCapacity) { {}; if<br> (0) { _force_has_format_string("dst buf too small for uncompressed block"<br>); }; {}; {}; return ((size_t)-ZSTD_error_dstSize_tooSmall); }</span></span></td></tr>
<tr class="codeline" data-linenumber="373"><td class="num" id="LN373">373</td><td class="line">                    <span class='macro'>dstSize_tooSmall, <span class='string_literal'>"dst buf too small for uncompressed block"</span>)<span class='macro_popup'>if (srcSize + ZSTD_blockHeaderSize &gt; dstCapacity) { {}; if<br> (0) { _force_has_format_string("dst buf too small for uncompressed block"<br>); }; {}; {}; return ((size_t)-ZSTD_error_dstSize_tooSmall); }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="374"><td class="num" id="LN374">374</td><td class="line">    MEM_writeLE24(dst, cBlockHeader24);</td></tr>
<tr class="codeline" data-linenumber="375"><td class="num" id="LN375">375</td><td class="line">    memcpy((BYTE*)dst + ZSTD_blockHeaderSize, src, srcSize);</td></tr>
<tr class="codeline" data-linenumber="376"><td class="num" id="LN376">376</td><td class="line">    <span class='keyword'>return</span> ZSTD_blockHeaderSize + srcSize;</td></tr>
<tr class="codeline" data-linenumber="377"><td class="num" id="LN377">377</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="378"><td class="num" id="LN378">378</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="379"><td class="num" id="LN379">379</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> size_t ZSTD_rleCompressBlock (<span class='keyword'>void</span>* dst, size_t dstCapacity, BYTE src, size_t srcSize, U32 lastBlock)</td></tr>
<tr class="codeline" data-linenumber="380"><td class="num" id="LN380">380</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="381"><td class="num" id="LN381">381</td><td class="line">    BYTE* <span class='keyword'>const</span> op = (BYTE*)dst;</td></tr>
<tr class="codeline" data-linenumber="382"><td class="num" id="LN382">382</td><td class="line">    U32 <span class='keyword'>const</span> cBlockHeader = lastBlock + (((U32)bt_rle)&lt;&lt;1) + (U32)(srcSize &lt;&lt; 3);</td></tr>
<tr class="codeline" data-linenumber="383"><td class="num" id="LN383">383</td><td class="line">    <span class='macro'>RETURN_ERROR_IF(dstCapacity &lt; 4, dstSize_tooSmall, <span class='string_literal'>""</span>)<span class='macro_popup'>if (dstCapacity &lt; 4) { {}; if (0) { _force_has_format_string<br>(""); }; {}; {}; return ((size_t)-ZSTD_error_dstSize_tooSmall<br>); }</span></span>;</td></tr>
<tr class="codeline" data-linenumber="384"><td class="num" id="LN384">384</td><td class="line">    MEM_writeLE24(op, cBlockHeader);</td></tr>
<tr class="codeline" data-linenumber="385"><td class="num" id="LN385">385</td><td class="line">    op[3] = src;</td></tr>
<tr class="codeline" data-linenumber="386"><td class="num" id="LN386">386</td><td class="line">    <span class='keyword'>return</span> 4;</td></tr>
<tr class="codeline" data-linenumber="387"><td class="num" id="LN387">387</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="388"><td class="num" id="LN388">388</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="389"><td class="num" id="LN389">389</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="390"><td class="num" id="LN390">390</td><td class="line"><span class='comment'>/* ZSTD_minGain() :</span></td></tr>
<tr class="codeline" data-linenumber="391"><td class="num" id="LN391">391</td><td class="line"> <span class='comment'>* minimum compression required</span></td></tr>
<tr class="codeline" data-linenumber="392"><td class="num" id="LN392">392</td><td class="line"> <span class='comment'>* to generate a compress block or a compressed literals section.</span></td></tr>
<tr class="codeline" data-linenumber="393"><td class="num" id="LN393">393</td><td class="line"> <span class='comment'>* note : use same formula for both situations */</span></td></tr>
<tr class="codeline" data-linenumber="394"><td class="num" id="LN394">394</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> size_t ZSTD_minGain(size_t srcSize, ZSTD_strategy strat)</td></tr>
<tr class="codeline" data-linenumber="395"><td class="num" id="LN395">395</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="396"><td class="num" id="LN396">396</td><td class="line">    U32 <span class='keyword'>const</span> minlog = (strat&gt;=ZSTD_btultra) ? (U32)(strat) - 1 : 6;</td></tr>
<tr class="codeline" data-linenumber="397"><td class="num" id="LN397">397</td><td class="line">    <span class='macro'>ZSTD_STATIC_ASSERT(ZSTD_btultra == 8)<span class='macro_popup'>(void)sizeof(char[(ZSTD_btultra == 8) ? 1 : -1])</span></span>;</td></tr>
<tr class="codeline" data-linenumber="398"><td class="num" id="LN398">398</td><td class="line">    <span class='macro'>assert(ZSTD_cParam_withinBounds(ZSTD_c_strategy, strat))<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="399"><td class="num" id="LN399">399</td><td class="line">    <span class='keyword'>return</span> (srcSize &gt;&gt; minlog) + 2;</td></tr>
<tr class="codeline" data-linenumber="400"><td class="num" id="LN400">400</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="401"><td class="num" id="LN401">401</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="402"><td class="num" id="LN402">402</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> <span class='keyword'>int</span> ZSTD_disableLiteralsCompression(<span class='keyword'>const</span> ZSTD_CCtx_params* cctxParams)</td></tr>
<tr class="codeline" data-linenumber="403"><td class="num" id="LN403">403</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="404"><td class="num" id="LN404">404</td><td class="line">    <span class='keyword'>switch</span> (cctxParams-&gt;literalCompressionMode) {</td></tr>
<tr class="codeline" data-linenumber="405"><td class="num" id="LN405">405</td><td class="line">    <span class='keyword'>case</span> ZSTD_lcm_huffman:</td></tr>
<tr class="codeline" data-linenumber="406"><td class="num" id="LN406">406</td><td class="line">        <span class='keyword'>return</span> 0;</td></tr>
<tr class="codeline" data-linenumber="407"><td class="num" id="LN407">407</td><td class="line">    <span class='keyword'>case</span> ZSTD_lcm_uncompressed:</td></tr>
<tr class="codeline" data-linenumber="408"><td class="num" id="LN408">408</td><td class="line">        <span class='keyword'>return</span> 1;</td></tr>
<tr class="codeline" data-linenumber="409"><td class="num" id="LN409">409</td><td class="line">    <span class='keyword'>default</span>:</td></tr>
<tr class="codeline" data-linenumber="410"><td class="num" id="LN410">410</td><td class="line">        <span class='macro'>assert(0 <span class='comment'>/* impossible: pre-validated */</span>)<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="411"><td class="num" id="LN411">411</td><td class="line">        <span class='comment'>/* fall-through */</span></td></tr>
<tr class="codeline" data-linenumber="412"><td class="num" id="LN412">412</td><td class="line">    <span class='keyword'>case</span> ZSTD_lcm_auto:</td></tr>
<tr class="codeline" data-linenumber="413"><td class="num" id="LN413">413</td><td class="line">        <span class='keyword'>return</span> (cctxParams-&gt;cParams.strategy == ZSTD_fast) &amp;&amp; (cctxParams-&gt;cParams.targetLength &gt; 0);</td></tr>
<tr class="codeline" data-linenumber="414"><td class="num" id="LN414">414</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="415"><td class="num" id="LN415">415</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="416"><td class="num" id="LN416">416</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="417"><td class="num" id="LN417">417</td><td class="line"><span class='comment'>/*! ZSTD_safecopyLiterals() :</span></td></tr>
<tr class="codeline" data-linenumber="418"><td class="num" id="LN418">418</td><td class="line"> <span class='comment'>*  memcpy() function that won't read beyond more than WILDCOPY_OVERLENGTH bytes past ilimit_w.</span></td></tr>
<tr class="codeline" data-linenumber="419"><td class="num" id="LN419">419</td><td class="line"> <span class='comment'>*  Only called when the sequence ends past ilimit_w, so it only needs to be optimized for single</span></td></tr>
<tr class="codeline" data-linenumber="420"><td class="num" id="LN420">420</td><td class="line"> <span class='comment'>*  large copies.</span></td></tr>
<tr class="codeline" data-linenumber="421"><td class="num" id="LN421">421</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="422"><td class="num" id="LN422">422</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> ZSTD_safecopyLiterals(BYTE* op, BYTE <span class='keyword'>const</span>* ip, BYTE <span class='keyword'>const</span>* <span class='keyword'>const</span> iend, BYTE <span class='keyword'>const</span>* ilimit_w) {</td></tr>
<tr class="codeline" data-linenumber="423"><td class="num" id="LN423">423</td><td class="line">    <span class='macro'>assert(iend &gt; ilimit_w)<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="424"><td class="num" id="LN424">424</td><td class="line">    <span class='keyword'>if</span> (ip &lt;= ilimit_w) {</td></tr>
<tr class="codeline" data-linenumber="425"><td class="num" id="LN425">425</td><td class="line">        ZSTD_wildcopy(op, ip, ilimit_w - ip, ZSTD_no_overlap);</td></tr>
<tr class="codeline" data-linenumber="426"><td class="num" id="LN426">426</td><td class="line">        op += ilimit_w - ip;</td></tr>
<tr class="codeline" data-linenumber="427"><td class="num" id="LN427">427</td><td class="line">        ip = ilimit_w;</td></tr>
<tr class="codeline" data-linenumber="428"><td class="num" id="LN428">428</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="429"><td class="num" id="LN429">429</td><td class="line">    <span class='keyword'>while</span> (ip &lt; iend) *op++ = *ip++;</td></tr>
<tr class="codeline" data-linenumber="430"><td class="num" id="LN430">430</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="431"><td class="num" id="LN431">431</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="432"><td class="num" id="LN432">432</td><td class="line"><span class='comment'>/*! ZSTD_storeSeq() :</span></td></tr>
<tr class="codeline" data-linenumber="433"><td class="num" id="LN433">433</td><td class="line"> <span class='comment'>*  Store a sequence (litlen, litPtr, offCode and mlBase) into seqStore_t.</span></td></tr>
<tr class="codeline" data-linenumber="434"><td class="num" id="LN434">434</td><td class="line"> <span class='comment'>*  `offCode` : distance to match + ZSTD_REP_MOVE (values &lt;= ZSTD_REP_MOVE are repCodes).</span></td></tr>
<tr class="codeline" data-linenumber="435"><td class="num" id="LN435">435</td><td class="line"> <span class='comment'>*  `mlBase` : matchLength - MINMATCH</span></td></tr>
<tr class="codeline" data-linenumber="436"><td class="num" id="LN436">436</td><td class="line"> <span class='comment'>*  Allowed to overread literals up to litLimit.</span></td></tr>
<tr class="codeline" data-linenumber="437"><td class="num" id="LN437">437</td><td class="line"><span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="438"><td class="num" id="LN438">438</td><td class="line"><span class='macro'>HINT_INLINE<span class='macro_popup'>static inline __attribute__((always_inline))</span></span> <span class='macro'>UNUSED_ATTR<span class='macro_popup'>__attribute__((unused))</span></span></td></tr>
<tr class="codeline" data-linenumber="439"><td class="num" id="LN439">439</td><td class="line"><span class='keyword'>void</span> ZSTD_storeSeq(seqStore_t* seqStorePtr, size_t litLength, <span class='keyword'>const</span> BYTE* literals, <span class='keyword'>const</span> BYTE* litLimit, U32 offCode, size_t mlBase)</td></tr>
<tr class="codeline" data-linenumber="440"><td class="num" id="LN440">440</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="441"><td class="num" id="LN441">441</td><td class="line">    BYTE <span class='keyword'>const</span>* <span class='keyword'>const</span> litLimit_w = litLimit - <span class='macro'>WILDCOPY_OVERLENGTH<span class='macro_popup'>32</span></span>;</td></tr>
<tr class="codeline" data-linenumber="442"><td class="num" id="LN442">442</td><td class="line">    BYTE <span class='keyword'>const</span>* <span class='keyword'>const</span> litEnd = literals + litLength;</td></tr>
<tr class="codeline" data-linenumber="443"><td class="num" id="LN443">443</td><td class="line"><span class='directive'>#if defined(<span class='macro'>DEBUGLEVEL<span class='macro_popup'>0</span></span>) &amp;&amp; (<span class='macro'>DEBUGLEVEL<span class='macro_popup'>0</span></span> &gt;= 6)</span></td></tr>
<tr class="codeline" data-linenumber="444"><td class="num" id="LN444">444</td><td class="line">    <span class='keyword'>static</span> <span class='keyword'>const</span> BYTE* g_start = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="445"><td class="num" id="LN445">445</td><td class="line">    <span class='keyword'>if</span> (g_start==<span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>) g_start = (<span class='keyword'>const</span> BYTE*)literals;  <span class='comment'>/* note : index only works for compression within a single segment */</span></td></tr>
<tr class="codeline" data-linenumber="446"><td class="num" id="LN446">446</td><td class="line">    {   U32 <span class='keyword'>const</span> pos = (U32)((<span class='keyword'>const</span> BYTE*)literals - g_start);</td></tr>
<tr class="codeline" data-linenumber="447"><td class="num" id="LN447">447</td><td class="line">        <span class='macro'>DEBUGLOG(6, <span class='string_literal'>"Cpos%7u :%3u literals, match%4u bytes at offCode%7u"</span>,<span class='macro_popup'>{}</span></span></td></tr>
<tr class="codeline" data-linenumber="448"><td class="num" id="LN448">448</td><td class="line">               <span class='macro'>pos, (U32)litLength, (U32)mlBase+MINMATCH, (U32)offCode)<span class='macro_popup'>{}</span></span>;</td></tr>
<tr class="codeline" data-linenumber="449"><td class="num" id="LN449">449</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="450"><td class="num" id="LN450">450</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="451"><td class="num" id="LN451">451</td><td class="line">    <span class='macro'>assert((size_t)(seqStorePtr-&gt;sequences - seqStorePtr-&gt;sequencesStart) &lt; seqStorePtr-&gt;maxNbSeq)<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="452"><td class="num" id="LN452">452</td><td class="line">    <span class='comment'>/* copy Literals */</span></td></tr>
<tr class="codeline" data-linenumber="453"><td class="num" id="LN453">453</td><td class="line">    <span class='macro'>assert(seqStorePtr-&gt;maxNbLit &lt;= 128 KB)<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="454"><td class="num" id="LN454">454</td><td class="line">    <span class='macro'>assert(seqStorePtr-&gt;lit + litLength &lt;= seqStorePtr-&gt;litStart + seqStorePtr-&gt;maxNbLit)<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="455"><td class="num" id="LN455">455</td><td class="line">    <span class='macro'>assert(literals + litLength &lt;= litLimit)<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="456"><td class="num" id="LN456">456</td><td class="line">    <span class='keyword'>if</span> (litEnd &lt;= litLimit_w) {</td></tr>
<tr class="codeline" data-linenumber="457"><td class="num" id="LN457">457</td><td class="line">        <span class='comment'>/* Common case we can use wildcopy.</span></td></tr>
<tr class="codeline" data-linenumber="458"><td class="num" id="LN458">458</td><td class="line">	 <span class='comment'>* First copy 16 bytes, because literals are likely short.</span></td></tr>
<tr class="codeline" data-linenumber="459"><td class="num" id="LN459">459</td><td class="line">	 <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="460"><td class="num" id="LN460">460</td><td class="line">        <span class='macro'>assert(WILDCOPY_OVERLENGTH &gt;= 16)<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="461"><td class="num" id="LN461">461</td><td class="line">        ZSTD_copy16(seqStorePtr-&gt;lit, literals);</td></tr>
<tr class="codeline" data-linenumber="462"><td class="num" id="LN462">462</td><td class="line">        <span class='keyword'>if</span> (litLength &gt; 16) {</td></tr>
<tr class="codeline" data-linenumber="463"><td class="num" id="LN463">463</td><td class="line">            ZSTD_wildcopy(seqStorePtr-&gt;lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);</td></tr>
<tr class="codeline" data-linenumber="464"><td class="num" id="LN464">464</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="465"><td class="num" id="LN465">465</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="466"><td class="num" id="LN466">466</td><td class="line">        ZSTD_safecopyLiterals(seqStorePtr-&gt;lit, literals, litEnd, litLimit_w);</td></tr>
<tr class="codeline" data-linenumber="467"><td class="num" id="LN467">467</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="468"><td class="num" id="LN468">468</td><td class="line">    seqStorePtr-&gt;lit += litLength;</td></tr>
<tr class="codeline" data-linenumber="469"><td class="num" id="LN469">469</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="470"><td class="num" id="LN470">470</td><td class="line">    <span class='comment'>/* literal Length */</span></td></tr>
<tr class="codeline" data-linenumber="471"><td class="num" id="LN471">471</td><td class="line">    <span class='keyword'>if</span> (litLength&gt;0xFFFF) {</td></tr>
<tr class="codeline" data-linenumber="472"><td class="num" id="LN472">472</td><td class="line">        <span class='macro'>assert(seqStorePtr-&gt;longLengthID == 0)<span class='macro_popup'>((void)0)</span></span>; <span class='comment'>/* there can only be a single long length */</span></td></tr>
<tr class="codeline" data-linenumber="473"><td class="num" id="LN473">473</td><td class="line">        seqStorePtr-&gt;longLengthID = 1;</td></tr>
<tr class="codeline" data-linenumber="474"><td class="num" id="LN474">474</td><td class="line">        seqStorePtr-&gt;longLengthPos = (U32)(seqStorePtr-&gt;sequences - seqStorePtr-&gt;sequencesStart);</td></tr>
<tr class="codeline" data-linenumber="475"><td class="num" id="LN475">475</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="476"><td class="num" id="LN476">476</td><td class="line">    seqStorePtr-&gt;sequences[0].litLength = (U16)litLength;</td></tr>
<tr class="codeline" data-linenumber="477"><td class="num" id="LN477">477</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="478"><td class="num" id="LN478">478</td><td class="line">    <span class='comment'>/* match offset */</span></td></tr>
<tr class="codeline" data-linenumber="479"><td class="num" id="LN479">479</td><td class="line">    seqStorePtr-&gt;sequences[0].offset = offCode + 1;</td></tr>
<tr class="codeline" data-linenumber="480"><td class="num" id="LN480">480</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="481"><td class="num" id="LN481">481</td><td class="line">    <span class='comment'>/* match Length */</span></td></tr>
<tr class="codeline" data-linenumber="482"><td class="num" id="LN482">482</td><td class="line">    <span class='keyword'>if</span> (mlBase&gt;0xFFFF) {</td></tr>
<tr class="codeline" data-linenumber="483"><td class="num" id="LN483">483</td><td class="line">        <span class='macro'>assert(seqStorePtr-&gt;longLengthID == 0)<span class='macro_popup'>((void)0)</span></span>; <span class='comment'>/* there can only be a single long length */</span></td></tr>
<tr class="codeline" data-linenumber="484"><td class="num" id="LN484">484</td><td class="line">        seqStorePtr-&gt;longLengthID = 2;</td></tr>
<tr class="codeline" data-linenumber="485"><td class="num" id="LN485">485</td><td class="line">        seqStorePtr-&gt;longLengthPos = (U32)(seqStorePtr-&gt;sequences - seqStorePtr-&gt;sequencesStart);</td></tr>
<tr class="codeline" data-linenumber="486"><td class="num" id="LN486">486</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="487"><td class="num" id="LN487">487</td><td class="line">    seqStorePtr-&gt;sequences[0].matchLength = (U16)mlBase;</td></tr>
<tr class="codeline" data-linenumber="488"><td class="num" id="LN488">488</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="489"><td class="num" id="LN489">489</td><td class="line">    seqStorePtr-&gt;sequences++;</td></tr>
<tr class="codeline" data-linenumber="490"><td class="num" id="LN490">490</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="491"><td class="num" id="LN491">491</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="492"><td class="num" id="LN492">492</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="493"><td class="num" id="LN493">493</td><td class="line"><span class='comment'>/*-*************************************</span></td></tr>
<tr class="codeline" data-linenumber="494"><td class="num" id="LN494">494</td><td class="line"><span class='comment'>*  Match length counter</span></td></tr>
<tr class="codeline" data-linenumber="495"><td class="num" id="LN495">495</td><td class="line"><span class='comment'>***************************************/</span></td></tr>
<tr class="codeline" data-linenumber="496"><td class="num" id="LN496">496</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>unsigned</span> ZSTD_NbCommonBytes (size_t val)</td></tr>
<tr class="codeline" data-linenumber="497"><td class="num" id="LN497">497</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="498"><td class="num" id="LN498">498</td><td class="line">    <span class='keyword'>if</span> (MEM_isLittleEndian()) {</td></tr>
<tr class="codeline" data-linenumber="499"><td class="num" id="LN499">499</td><td class="line">        <span class='keyword'>if</span> (MEM_64bits()) {</td></tr>
<tr class="codeline" data-linenumber="500"><td class="num" id="LN500">500</td><td class="line"><span class='directive'>#       if defined(_MSC_VER) &amp;&amp; defined(_WIN64)</span></td></tr>
<tr class="codeline" data-linenumber="501"><td class="num" id="LN501">501</td><td class="line">            <span class='keyword'>unsigned</span> <span class='keyword'>long</span> r = 0;</td></tr>
<tr class="codeline" data-linenumber="502"><td class="num" id="LN502">502</td><td class="line">            <span class='keyword'>return</span> _BitScanForward64( &amp;r, (U64)val ) ? (<span class='keyword'>unsigned</span>)(r &gt;&gt; 3) : 0;</td></tr>
<tr class="codeline" data-linenumber="503"><td class="num" id="LN503">503</td><td class="line"><span class='directive'>#       elif defined(<span class='macro'>__GNUC__<span class='macro_popup'>4</span></span>) &amp;&amp; (<span class='macro'>__GNUC__<span class='macro_popup'>4</span></span> &gt;= 4)</span></td></tr>
<tr class="codeline" data-linenumber="504"><td class="num" id="LN504">504</td><td class="line">            <span class='keyword'>return</span> (__builtin_ctzll((U64)val) &gt;&gt; 3);</td></tr>
<tr class="codeline" data-linenumber="505"><td class="num" id="LN505">505</td><td class="line"><span class='directive'>#       else</span></td></tr>
<tr class="codeline" data-linenumber="506"><td class="num" id="LN506">506</td><td class="line">            <span class='keyword'>static</span> <span class='keyword'>const</span> <span class='keyword'>int</span> DeBruijnBytePos[64] = { 0, 0, 0, 0, 0, 1, 1, 2,</td></tr>
<tr class="codeline" data-linenumber="507"><td class="num" id="LN507">507</td><td class="line">                                                     0, 3, 1, 3, 1, 4, 2, 7,</td></tr>
<tr class="codeline" data-linenumber="508"><td class="num" id="LN508">508</td><td class="line">                                                     0, 2, 3, 6, 1, 5, 3, 5,</td></tr>
<tr class="codeline" data-linenumber="509"><td class="num" id="LN509">509</td><td class="line">                                                     1, 3, 4, 4, 2, 5, 6, 7,</td></tr>
<tr class="codeline" data-linenumber="510"><td class="num" id="LN510">510</td><td class="line">                                                     7, 0, 1, 2, 3, 3, 4, 6,</td></tr>
<tr class="codeline" data-linenumber="511"><td class="num" id="LN511">511</td><td class="line">                                                     2, 6, 5, 5, 3, 4, 5, 6,</td></tr>
<tr class="codeline" data-linenumber="512"><td class="num" id="LN512">512</td><td class="line">                                                     7, 1, 2, 4, 6, 4, 4, 5,</td></tr>
<tr class="codeline" data-linenumber="513"><td class="num" id="LN513">513</td><td class="line">                                                     7, 2, 6, 5, 7, 6, 7, 7 };</td></tr>
<tr class="codeline" data-linenumber="514"><td class="num" id="LN514">514</td><td class="line">            <span class='keyword'>return</span> DeBruijnBytePos[((U64)((val &amp; -(<span class='keyword'>long</span> <span class='keyword'>long</span>)val) * 0x0218A392CDABBD3FULL)) &gt;&gt; 58];</td></tr>
<tr class="codeline" data-linenumber="515"><td class="num" id="LN515">515</td><td class="line"><span class='directive'>#       endif</span></td></tr>
<tr class="codeline" data-linenumber="516"><td class="num" id="LN516">516</td><td class="line">        } <span class='keyword'>else</span> { <span class='comment'>/* 32 bits */</span></td></tr>
<tr class="codeline" data-linenumber="517"><td class="num" id="LN517">517</td><td class="line"><span class='directive'>#       if defined(_MSC_VER)</span></td></tr>
<tr class="codeline" data-linenumber="518"><td class="num" id="LN518">518</td><td class="line">            <span class='keyword'>unsigned</span> <span class='keyword'>long</span> r=0;</td></tr>
<tr class="codeline" data-linenumber="519"><td class="num" id="LN519">519</td><td class="line">            <span class='keyword'>return</span> _BitScanForward( &amp;r, (U32)val ) ? (<span class='keyword'>unsigned</span>)(r &gt;&gt; 3) : 0;</td></tr>
<tr class="codeline" data-linenumber="520"><td class="num" id="LN520">520</td><td class="line"><span class='directive'>#       elif defined(<span class='macro'>__GNUC__<span class='macro_popup'>4</span></span>) &amp;&amp; (<span class='macro'>__GNUC__<span class='macro_popup'>4</span></span> &gt;= 3)</span></td></tr>
<tr class="codeline" data-linenumber="521"><td class="num" id="LN521">521</td><td class="line">            <span class='keyword'>return</span> (__builtin_ctz((U32)val) &gt;&gt; 3);</td></tr>
<tr class="codeline" data-linenumber="522"><td class="num" id="LN522">522</td><td class="line"><span class='directive'>#       else</span></td></tr>
<tr class="codeline" data-linenumber="523"><td class="num" id="LN523">523</td><td class="line">            <span class='keyword'>static</span> <span class='keyword'>const</span> <span class='keyword'>int</span> DeBruijnBytePos[32] = { 0, 0, 3, 0, 3, 1, 3, 0,</td></tr>
<tr class="codeline" data-linenumber="524"><td class="num" id="LN524">524</td><td class="line">                                                     3, 2, 2, 1, 3, 2, 0, 1,</td></tr>
<tr class="codeline" data-linenumber="525"><td class="num" id="LN525">525</td><td class="line">                                                     3, 3, 1, 2, 2, 2, 2, 0,</td></tr>
<tr class="codeline" data-linenumber="526"><td class="num" id="LN526">526</td><td class="line">                                                     3, 1, 2, 0, 1, 0, 1, 1 };</td></tr>
<tr class="codeline" data-linenumber="527"><td class="num" id="LN527">527</td><td class="line">            <span class='keyword'>return</span> DeBruijnBytePos[((U32)((val &amp; -(S32)val) * 0x077CB531U)) &gt;&gt; 27];</td></tr>
<tr class="codeline" data-linenumber="528"><td class="num" id="LN528">528</td><td class="line"><span class='directive'>#       endif</span></td></tr>
<tr class="codeline" data-linenumber="529"><td class="num" id="LN529">529</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="530"><td class="num" id="LN530">530</td><td class="line">    } <span class='keyword'>else</span> {  <span class='comment'>/* Big Endian CPU */</span></td></tr>
<tr class="codeline" data-linenumber="531"><td class="num" id="LN531">531</td><td class="line">        <span class='keyword'>if</span> (MEM_64bits()) {</td></tr>
<tr class="codeline" data-linenumber="532"><td class="num" id="LN532">532</td><td class="line"><span class='directive'>#       if defined(_MSC_VER) &amp;&amp; defined(_WIN64)</span></td></tr>
<tr class="codeline" data-linenumber="533"><td class="num" id="LN533">533</td><td class="line">            <span class='keyword'>unsigned</span> <span class='keyword'>long</span> r = 0;</td></tr>
<tr class="codeline" data-linenumber="534"><td class="num" id="LN534">534</td><td class="line">            <span class='keyword'>return</span> _BitScanReverse64( &amp;r, val ) ? (<span class='keyword'>unsigned</span>)(r &gt;&gt; 3) : 0;</td></tr>
<tr class="codeline" data-linenumber="535"><td class="num" id="LN535">535</td><td class="line"><span class='directive'>#       elif defined(<span class='macro'>__GNUC__<span class='macro_popup'>4</span></span>) &amp;&amp; (<span class='macro'>__GNUC__<span class='macro_popup'>4</span></span> &gt;= 4)</span></td></tr>
<tr class="codeline" data-linenumber="536"><td class="num" id="LN536">536</td><td class="line">            <span class='keyword'>return</span> (__builtin_clzll(val) &gt;&gt; 3);</td></tr>
<tr class="codeline" data-linenumber="537"><td class="num" id="LN537">537</td><td class="line"><span class='directive'>#       else</span></td></tr>
<tr class="codeline" data-linenumber="538"><td class="num" id="LN538">538</td><td class="line">            <span class='keyword'>unsigned</span> r;</td></tr>
<tr class="codeline" data-linenumber="539"><td class="num" id="LN539">539</td><td class="line">            <span class='keyword'>const</span> <span class='keyword'>unsigned</span> n32 = <span class='keyword'>sizeof</span>(size_t)*4;   <span class='comment'>/* calculate this way due to compiler complaining in 32-bits mode */</span></td></tr>
<tr class="codeline" data-linenumber="540"><td class="num" id="LN540">540</td><td class="line">            <span class='keyword'>if</span> (!(val&gt;&gt;n32)) { r=4; } <span class='keyword'>else</span> { r=0; val&gt;&gt;=n32; }</td></tr>
<tr class="codeline" data-linenumber="541"><td class="num" id="LN541">541</td><td class="line">            <span class='keyword'>if</span> (!(val&gt;&gt;16)) { r+=2; val&gt;&gt;=8; } <span class='keyword'>else</span> { val&gt;&gt;=24; }</td></tr>
<tr class="codeline" data-linenumber="542"><td class="num" id="LN542">542</td><td class="line">            r += (!val);</td></tr>
<tr class="codeline" data-linenumber="543"><td class="num" id="LN543">543</td><td class="line">            <span class='keyword'>return</span> r;</td></tr>
<tr class="codeline" data-linenumber="544"><td class="num" id="LN544">544</td><td class="line"><span class='directive'>#       endif</span></td></tr>
<tr class="codeline" data-linenumber="545"><td class="num" id="LN545">545</td><td class="line">        } <span class='keyword'>else</span> { <span class='comment'>/* 32 bits */</span></td></tr>
<tr class="codeline" data-linenumber="546"><td class="num" id="LN546">546</td><td class="line"><span class='directive'>#       if defined(_MSC_VER)</span></td></tr>
<tr class="codeline" data-linenumber="547"><td class="num" id="LN547">547</td><td class="line">            <span class='keyword'>unsigned</span> <span class='keyword'>long</span> r = 0;</td></tr>
<tr class="codeline" data-linenumber="548"><td class="num" id="LN548">548</td><td class="line">            <span class='keyword'>return</span> _BitScanReverse( &amp;r, (<span class='keyword'>unsigned</span> <span class='keyword'>long</span>)val ) ? (<span class='keyword'>unsigned</span>)(r &gt;&gt; 3) : 0;</td></tr>
<tr class="codeline" data-linenumber="549"><td class="num" id="LN549">549</td><td class="line"><span class='directive'>#       elif defined(<span class='macro'>__GNUC__<span class='macro_popup'>4</span></span>) &amp;&amp; (<span class='macro'>__GNUC__<span class='macro_popup'>4</span></span> &gt;= 3)</span></td></tr>
<tr class="codeline" data-linenumber="550"><td class="num" id="LN550">550</td><td class="line">            <span class='keyword'>return</span> (__builtin_clz((U32)val) &gt;&gt; 3);</td></tr>
<tr class="codeline" data-linenumber="551"><td class="num" id="LN551">551</td><td class="line"><span class='directive'>#       else</span></td></tr>
<tr class="codeline" data-linenumber="552"><td class="num" id="LN552">552</td><td class="line">            <span class='keyword'>unsigned</span> r;</td></tr>
<tr class="codeline" data-linenumber="553"><td class="num" id="LN553">553</td><td class="line">            <span class='keyword'>if</span> (!(val&gt;&gt;16)) { r=2; val&gt;&gt;=8; } <span class='keyword'>else</span> { r=0; val&gt;&gt;=24; }</td></tr>
<tr class="codeline" data-linenumber="554"><td class="num" id="LN554">554</td><td class="line">            r += (!val);</td></tr>
<tr class="codeline" data-linenumber="555"><td class="num" id="LN555">555</td><td class="line">            <span class='keyword'>return</span> r;</td></tr>
<tr class="codeline" data-linenumber="556"><td class="num" id="LN556">556</td><td class="line"><span class='directive'>#       endif</span></td></tr>
<tr class="codeline" data-linenumber="557"><td class="num" id="LN557">557</td><td class="line">    }   }</td></tr>
<tr class="codeline" data-linenumber="558"><td class="num" id="LN558">558</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="559"><td class="num" id="LN559">559</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="560"><td class="num" id="LN560">560</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="561"><td class="num" id="LN561">561</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> size_t ZSTD_count(<span class='keyword'>const</span> BYTE* pIn, <span class='keyword'>const</span> BYTE* pMatch, <span class='keyword'>const</span> BYTE* <span class='keyword'>const</span> pInLimit)</td></tr>
<tr class="codeline" data-linenumber="562"><td class="num" id="LN562">562</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="563"><td class="num" id="LN563">563</td><td class="line">    <span class='keyword'>const</span> BYTE* <span class='keyword'>const</span> pStart = pIn;</td></tr>
<tr class="codeline" data-linenumber="564"><td class="num" id="LN564">564</td><td class="line">    <span class='keyword'>const</span> BYTE* <span class='keyword'>const</span> pInLoopLimit = pInLimit - (<span class='keyword'>sizeof</span>(size_t)-1);</td></tr>
<tr class="codeline" data-linenumber="565"><td class="num" id="LN565">565</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="566"><td class="num" id="LN566">566</td><td class="line">    <span class='keyword'>if</span> (pIn &lt; pInLoopLimit) {</td></tr>
<tr class="codeline" data-linenumber="567"><td class="num" id="LN567">567</td><td class="line">        { size_t <span class='keyword'>const</span> diff = MEM_readST(pMatch) ^ MEM_readST(pIn);</td></tr>
<tr class="codeline" data-linenumber="568"><td class="num" id="LN568">568</td><td class="line">          <span class='keyword'>if</span> (diff) <span class='keyword'>return</span> ZSTD_NbCommonBytes(diff); }</td></tr>
<tr class="codeline" data-linenumber="569"><td class="num" id="LN569">569</td><td class="line">        pIn+=<span class='keyword'>sizeof</span>(size_t); pMatch+=<span class='keyword'>sizeof</span>(size_t);</td></tr>
<tr class="codeline" data-linenumber="570"><td class="num" id="LN570">570</td><td class="line">        <span class='keyword'>while</span> (pIn &lt; pInLoopLimit) {</td></tr>
<tr class="codeline" data-linenumber="571"><td class="num" id="LN571">571</td><td class="line">            size_t <span class='keyword'>const</span> diff = MEM_readST(pMatch) ^ MEM_readST(pIn);</td></tr>
<tr class="codeline" data-linenumber="572"><td class="num" id="LN572">572</td><td class="line">            <span class='keyword'>if</span> (!diff) { pIn+=<span class='keyword'>sizeof</span>(size_t); pMatch+=<span class='keyword'>sizeof</span>(size_t); <span class='keyword'>continue</span>; }</td></tr>
<tr class="codeline" data-linenumber="573"><td class="num" id="LN573">573</td><td class="line">            pIn += ZSTD_NbCommonBytes(diff);</td></tr>
<tr class="codeline" data-linenumber="574"><td class="num" id="LN574">574</td><td class="line">            <span class='keyword'>return</span> (size_t)(pIn - pStart);</td></tr>
<tr class="codeline" data-linenumber="575"><td class="num" id="LN575">575</td><td class="line">    }   }</td></tr>
<tr class="codeline" data-linenumber="576"><td class="num" id="LN576">576</td><td class="line">    <span class='keyword'>if</span> (MEM_64bits() &amp;&amp; (pIn&lt;(pInLimit-3)) &amp;&amp; (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }</td></tr>
<tr class="codeline" data-linenumber="577"><td class="num" id="LN577">577</td><td class="line">    <span class='keyword'>if</span> ((pIn&lt;(pInLimit-1)) &amp;&amp; (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }</td></tr>
<tr class="codeline" data-linenumber="578"><td class="num" id="LN578">578</td><td class="line">    <span class='keyword'>if</span> ((pIn&lt;pInLimit) &amp;&amp; (*pMatch == *pIn)) pIn++;</td></tr>
<tr class="codeline" data-linenumber="579"><td class="num" id="LN579">579</td><td class="line">    <span class='keyword'>return</span> (size_t)(pIn - pStart);</td></tr>
<tr class="codeline" data-linenumber="580"><td class="num" id="LN580">580</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="581"><td class="num" id="LN581">581</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="582"><td class="num" id="LN582">582</td><td class="line"><span class='comment'>/** ZSTD_count_2segments() :</span></td></tr>
<tr class="codeline" data-linenumber="583"><td class="num" id="LN583">583</td><td class="line"> <span class='comment'>*  can count match length with `ip` &amp; `match` in 2 different segments.</span></td></tr>
<tr class="codeline" data-linenumber="584"><td class="num" id="LN584">584</td><td class="line"> <span class='comment'>*  convention : on reaching mEnd, match count continue starting from iStart</span></td></tr>
<tr class="codeline" data-linenumber="585"><td class="num" id="LN585">585</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="586"><td class="num" id="LN586">586</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> size_t</td></tr>
<tr class="codeline" data-linenumber="587"><td class="num" id="LN587">587</td><td class="line">ZSTD_count_2segments(<span class='keyword'>const</span> BYTE* ip, <span class='keyword'>const</span> BYTE* match,</td></tr>
<tr class="codeline" data-linenumber="588"><td class="num" id="LN588">588</td><td class="line">                     <span class='keyword'>const</span> BYTE* iEnd, <span class='keyword'>const</span> BYTE* mEnd, <span class='keyword'>const</span> BYTE* iStart)</td></tr>
<tr class="codeline" data-linenumber="589"><td class="num" id="LN589">589</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="590"><td class="num" id="LN590">590</td><td class="line">    <span class='keyword'>const</span> BYTE* <span class='keyword'>const</span> vEnd = <span class='macro'>MIN( ip + (mEnd - match), iEnd)<span class='macro_popup'>((ip + (mEnd - match))&lt;(iEnd) ? (ip + (mEnd - match)) : (iEnd<br>))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="591"><td class="num" id="LN591">591</td><td class="line">    size_t <span class='keyword'>const</span> matchLength = ZSTD_count(ip, match, vEnd);</td></tr>
<tr class="codeline" data-linenumber="592"><td class="num" id="LN592">592</td><td class="line">    <span class='keyword'>if</span> (match + matchLength != mEnd) <span class='keyword'>return</span> matchLength;</td></tr>
<tr class="codeline" data-linenumber="593"><td class="num" id="LN593">593</td><td class="line">    <span class='macro'>DEBUGLOG(7, <span class='string_literal'>"ZSTD_count_2segments: found a 2-parts match (current length==%zu)"</span>, matchLength)<span class='macro_popup'>{}</span></span>;</td></tr>
<tr class="codeline" data-linenumber="594"><td class="num" id="LN594">594</td><td class="line">    <span class='macro'>DEBUGLOG(7, <span class='string_literal'>"distance from match beginning to end dictionary = %zi"</span>, mEnd - match)<span class='macro_popup'>{}</span></span>;</td></tr>
<tr class="codeline" data-linenumber="595"><td class="num" id="LN595">595</td><td class="line">    <span class='macro'>DEBUGLOG(7, <span class='string_literal'>"distance from current pos to end buffer = %zi"</span>, iEnd - ip)<span class='macro_popup'>{}</span></span>;</td></tr>
<tr class="codeline" data-linenumber="596"><td class="num" id="LN596">596</td><td class="line">    <span class='macro'>DEBUGLOG(7, <span class='string_literal'>"next byte : ip==%02X, istart==%02X"</span>, ip[matchLength], *iStart)<span class='macro_popup'>{}</span></span>;</td></tr>
<tr class="codeline" data-linenumber="597"><td class="num" id="LN597">597</td><td class="line">    <span class='macro'>DEBUGLOG(7, <span class='string_literal'>"final match length = %zu"</span>, matchLength + ZSTD_count(ip+matchLength, iStart, iEnd))<span class='macro_popup'>{}</span></span>;</td></tr>
<tr class="codeline" data-linenumber="598"><td class="num" id="LN598">598</td><td class="line">    <span class='keyword'>return</span> matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);</td></tr>
<tr class="codeline" data-linenumber="599"><td class="num" id="LN599">599</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="600"><td class="num" id="LN600">600</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="601"><td class="num" id="LN601">601</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="602"><td class="num" id="LN602">602</td><td class="line"><span class='comment'>/*-*************************************</span></td></tr>
<tr class="codeline" data-linenumber="603"><td class="num" id="LN603">603</td><td class="line"> <span class='comment'>*  Hashes</span></td></tr>
<tr class="codeline" data-linenumber="604"><td class="num" id="LN604">604</td><td class="line"> <span class='comment'>***************************************/</span></td></tr>
<tr class="codeline" data-linenumber="605"><td class="num" id="LN605">605</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>const</span> U32 prime3bytes = 506832829U;</td></tr>
<tr class="codeline" data-linenumber="606"><td class="num" id="LN606">606</td><td class="line"><span class='keyword'>static</span> U32    ZSTD_hash3(U32 u, U32 h) { <span class='keyword'>return</span> ((u &lt;&lt; (32-24)) * prime3bytes)  &gt;&gt; (32-h) ; }</td></tr>
<tr class="codeline" data-linenumber="607"><td class="num" id="LN607">607</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> size_t ZSTD_hash3Ptr(<span class='keyword'>const</span> <span class='keyword'>void</span>* ptr, U32 h) { <span class='keyword'>return</span> ZSTD_hash3(MEM_readLE32(ptr), h); } <span class='comment'>/* only in zstd_opt.h */</span></td></tr>
<tr class="codeline" data-linenumber="608"><td class="num" id="LN608">608</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="609"><td class="num" id="LN609">609</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>const</span> U32 prime4bytes = 2654435761U;</td></tr>
<tr class="codeline" data-linenumber="610"><td class="num" id="LN610">610</td><td class="line"><span class='keyword'>static</span> U32    ZSTD_hash4(U32 u, U32 h) { <span class='keyword'>return</span> (u * prime4bytes) &gt;&gt; (32-h) ; }</td></tr>
<tr class="codeline" data-linenumber="611"><td class="num" id="LN611">611</td><td class="line"><span class='keyword'>static</span> size_t ZSTD_hash4Ptr(<span class='keyword'>const</span> <span class='keyword'>void</span>* ptr, U32 h) { <span class='keyword'>return</span> ZSTD_hash4(MEM_read32(ptr), h); }</td></tr>
<tr class="codeline" data-linenumber="612"><td class="num" id="LN612">612</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="613"><td class="num" id="LN613">613</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>const</span> U64 prime5bytes = 889523592379ULL;</td></tr>
<tr class="codeline" data-linenumber="614"><td class="num" id="LN614">614</td><td class="line"><span class='keyword'>static</span> size_t ZSTD_hash5(U64 u, U32 h) { <span class='keyword'>return</span> (size_t)(((u  &lt;&lt; (64-40)) * prime5bytes) &gt;&gt; (64-h)) ; }</td></tr>
<tr class="codeline" data-linenumber="615"><td class="num" id="LN615">615</td><td class="line"><span class='keyword'>static</span> size_t ZSTD_hash5Ptr(<span class='keyword'>const</span> <span class='keyword'>void</span>* p, U32 h) { <span class='keyword'>return</span> ZSTD_hash5(MEM_readLE64(p), h); }</td></tr>
<tr class="codeline" data-linenumber="616"><td class="num" id="LN616">616</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="617"><td class="num" id="LN617">617</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>const</span> U64 prime6bytes = 227718039650203ULL;</td></tr>
<tr class="codeline" data-linenumber="618"><td class="num" id="LN618">618</td><td class="line"><span class='keyword'>static</span> size_t ZSTD_hash6(U64 u, U32 h) { <span class='keyword'>return</span> (size_t)(((u  &lt;&lt; (64-48)) * prime6bytes) &gt;&gt; (64-h)) ; }</td></tr>
<tr class="codeline" data-linenumber="619"><td class="num" id="LN619">619</td><td class="line"><span class='keyword'>static</span> size_t ZSTD_hash6Ptr(<span class='keyword'>const</span> <span class='keyword'>void</span>* p, U32 h) { <span class='keyword'>return</span> ZSTD_hash6(MEM_readLE64(p), h); }</td></tr>
<tr class="codeline" data-linenumber="620"><td class="num" id="LN620">620</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="621"><td class="num" id="LN621">621</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>const</span> U64 prime7bytes = 58295818150454627ULL;</td></tr>
<tr class="codeline" data-linenumber="622"><td class="num" id="LN622">622</td><td class="line"><span class='keyword'>static</span> size_t ZSTD_hash7(U64 u, U32 h) { <span class='keyword'>return</span> (size_t)(((u  &lt;&lt; (64-56)) * prime7bytes) &gt;&gt; (64-h)) ; }</td></tr>
<tr class="codeline" data-linenumber="623"><td class="num" id="LN623">623</td><td class="line"><span class='keyword'>static</span> size_t ZSTD_hash7Ptr(<span class='keyword'>const</span> <span class='keyword'>void</span>* p, U32 h) { <span class='keyword'>return</span> ZSTD_hash7(MEM_readLE64(p), h); }</td></tr>
<tr class="codeline" data-linenumber="624"><td class="num" id="LN624">624</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="625"><td class="num" id="LN625">625</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>const</span> U64 prime8bytes = 0xCF1BBCDCB7A56463ULL;</td></tr>
<tr class="codeline" data-linenumber="626"><td class="num" id="LN626">626</td><td class="line"><span class='keyword'>static</span> size_t ZSTD_hash8(U64 u, U32 h) { <span class='keyword'>return</span> (size_t)(((u) * prime8bytes) &gt;&gt; (64-h)) ; }</td></tr>
<tr class="codeline" data-linenumber="627"><td class="num" id="LN627">627</td><td class="line"><span class='keyword'>static</span> size_t ZSTD_hash8Ptr(<span class='keyword'>const</span> <span class='keyword'>void</span>* p, U32 h) { <span class='keyword'>return</span> ZSTD_hash8(MEM_readLE64(p), h); }</td></tr>
<tr class="codeline" data-linenumber="628"><td class="num" id="LN628">628</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="629"><td class="num" id="LN629">629</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> size_t ZSTD_hashPtr(<span class='keyword'>const</span> <span class='keyword'>void</span>* p, U32 hBits, U32 mls)</td></tr>
<tr class="codeline" data-linenumber="630"><td class="num" id="LN630">630</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="631"><td class="num" id="LN631">631</td><td class="line">    <span class='keyword'>switch</span>(mls)</td></tr>
<tr class="codeline" data-linenumber="632"><td class="num" id="LN632">632</td><td class="line">    {</td></tr>
<tr class="codeline" data-linenumber="633"><td class="num" id="LN633">633</td><td class="line">    <span class='keyword'>default</span>:</td></tr>
<tr class="codeline" data-linenumber="634"><td class="num" id="LN634">634</td><td class="line">    <span class='keyword'>case</span> 4: <span class='keyword'>return</span> ZSTD_hash4Ptr(p, hBits);</td></tr>
<tr class="codeline" data-linenumber="635"><td class="num" id="LN635">635</td><td class="line">    <span class='keyword'>case</span> 5: <span class='keyword'>return</span> ZSTD_hash5Ptr(p, hBits);</td></tr>
<tr class="codeline" data-linenumber="636"><td class="num" id="LN636">636</td><td class="line">    <span class='keyword'>case</span> 6: <span class='keyword'>return</span> ZSTD_hash6Ptr(p, hBits);</td></tr>
<tr class="codeline" data-linenumber="637"><td class="num" id="LN637">637</td><td class="line">    <span class='keyword'>case</span> 7: <span class='keyword'>return</span> ZSTD_hash7Ptr(p, hBits);</td></tr>
<tr class="codeline" data-linenumber="638"><td class="num" id="LN638">638</td><td class="line">    <span class='keyword'>case</span> 8: <span class='keyword'>return</span> ZSTD_hash8Ptr(p, hBits);</td></tr>
<tr class="codeline" data-linenumber="639"><td class="num" id="LN639">639</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="640"><td class="num" id="LN640">640</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="641"><td class="num" id="LN641">641</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="642"><td class="num" id="LN642">642</td><td class="line"><span class='comment'>/** ZSTD_ipow() :</span></td></tr>
<tr class="codeline" data-linenumber="643"><td class="num" id="LN643">643</td><td class="line"> <span class='comment'>* Return base^exponent.</span></td></tr>
<tr class="codeline" data-linenumber="644"><td class="num" id="LN644">644</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="645"><td class="num" id="LN645">645</td><td class="line"><span class='keyword'>static</span> U64 ZSTD_ipow(U64 base, U64 exponent)</td></tr>
<tr class="codeline" data-linenumber="646"><td class="num" id="LN646">646</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="647"><td class="num" id="LN647">647</td><td class="line">    U64 power = 1;</td></tr>
<tr class="codeline" data-linenumber="648"><td class="num" id="LN648">648</td><td class="line">    <span class='keyword'>while</span> (exponent) {</td></tr>
<tr class="codeline" data-linenumber="649"><td class="num" id="LN649">649</td><td class="line">      <span class='keyword'>if</span> (exponent &amp; 1) power *= base;</td></tr>
<tr class="codeline" data-linenumber="650"><td class="num" id="LN650">650</td><td class="line">      exponent &gt;&gt;= 1;</td></tr>
<tr class="codeline" data-linenumber="651"><td class="num" id="LN651">651</td><td class="line">      base *= base;</td></tr>
<tr class="codeline" data-linenumber="652"><td class="num" id="LN652">652</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="653"><td class="num" id="LN653">653</td><td class="line">    <span class='keyword'>return</span> power;</td></tr>
<tr class="codeline" data-linenumber="654"><td class="num" id="LN654">654</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="655"><td class="num" id="LN655">655</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="656"><td class="num" id="LN656">656</td><td class="line"><span class='directive'>#define <span class='macro'>ZSTD_ROLL_HASH_CHAR_OFFSET<span class='macro_popup'>10</span></span> 10</span></td></tr>
<tr class="codeline" data-linenumber="657"><td class="num" id="LN657">657</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="658"><td class="num" id="LN658">658</td><td class="line"><span class='comment'>/** ZSTD_rollingHash_append() :</span></td></tr>
<tr class="codeline" data-linenumber="659"><td class="num" id="LN659">659</td><td class="line"> <span class='comment'>* Add the buffer to the hash value.</span></td></tr>
<tr class="codeline" data-linenumber="660"><td class="num" id="LN660">660</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="661"><td class="num" id="LN661">661</td><td class="line"><span class='keyword'>static</span> U64 ZSTD_rollingHash_append(U64 hash, <span class='keyword'>void</span> <span class='keyword'>const</span>* buf, size_t size)</td></tr>
<tr class="codeline" data-linenumber="662"><td class="num" id="LN662">662</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="663"><td class="num" id="LN663">663</td><td class="line">    BYTE <span class='keyword'>const</span>* istart = (BYTE <span class='keyword'>const</span>*)buf;</td></tr>
<tr class="codeline" data-linenumber="664"><td class="num" id="LN664">664</td><td class="line">    size_t pos;</td></tr>
<tr class="codeline" data-linenumber="665"><td class="num" id="LN665">665</td><td class="line">    <span class='keyword'>for</span> (pos = 0; pos &lt; size; ++pos) {</td></tr>
<tr class="codeline" data-linenumber="666"><td class="num" id="LN666">666</td><td class="line">        hash *= prime8bytes;</td></tr>
<tr class="codeline" data-linenumber="667"><td class="num" id="LN667">667</td><td class="line">        hash += istart[pos] + <span class='macro'>ZSTD_ROLL_HASH_CHAR_OFFSET<span class='macro_popup'>10</span></span>;</td></tr>
<tr class="codeline" data-linenumber="668"><td class="num" id="LN668">668</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="669"><td class="num" id="LN669">669</td><td class="line">    <span class='keyword'>return</span> hash;</td></tr>
<tr class="codeline" data-linenumber="670"><td class="num" id="LN670">670</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="671"><td class="num" id="LN671">671</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="672"><td class="num" id="LN672">672</td><td class="line"><span class='comment'>/** ZSTD_rollingHash_compute() :</span></td></tr>
<tr class="codeline" data-linenumber="673"><td class="num" id="LN673">673</td><td class="line"> <span class='comment'>* Compute the rolling hash value of the buffer.</span></td></tr>
<tr class="codeline" data-linenumber="674"><td class="num" id="LN674">674</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="675"><td class="num" id="LN675">675</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> U64 ZSTD_rollingHash_compute(<span class='keyword'>void</span> <span class='keyword'>const</span>* buf, size_t size)</td></tr>
<tr class="codeline" data-linenumber="676"><td class="num" id="LN676">676</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="677"><td class="num" id="LN677">677</td><td class="line">    <span class='keyword'>return</span> ZSTD_rollingHash_append(0, buf, size);</td></tr>
<tr class="codeline" data-linenumber="678"><td class="num" id="LN678">678</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="679"><td class="num" id="LN679">679</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="680"><td class="num" id="LN680">680</td><td class="line"><span class='comment'>/** ZSTD_rollingHash_primePower() :</span></td></tr>
<tr class="codeline" data-linenumber="681"><td class="num" id="LN681">681</td><td class="line"> <span class='comment'>* Compute the primePower to be passed to ZSTD_rollingHash_rotate() for a hash</span></td></tr>
<tr class="codeline" data-linenumber="682"><td class="num" id="LN682">682</td><td class="line"> <span class='comment'>* over a window of length bytes.</span></td></tr>
<tr class="codeline" data-linenumber="683"><td class="num" id="LN683">683</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="684"><td class="num" id="LN684">684</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> U64 ZSTD_rollingHash_primePower(U32 length)</td></tr>
<tr class="codeline" data-linenumber="685"><td class="num" id="LN685">685</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="686"><td class="num" id="LN686">686</td><td class="line">    <span class='keyword'>return</span> ZSTD_ipow(prime8bytes, length - 1);</td></tr>
<tr class="codeline" data-linenumber="687"><td class="num" id="LN687">687</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="688"><td class="num" id="LN688">688</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="689"><td class="num" id="LN689">689</td><td class="line"><span class='comment'>/** ZSTD_rollingHash_rotate() :</span></td></tr>
<tr class="codeline" data-linenumber="690"><td class="num" id="LN690">690</td><td class="line"> <span class='comment'>* Rotate the rolling hash by one byte.</span></td></tr>
<tr class="codeline" data-linenumber="691"><td class="num" id="LN691">691</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="692"><td class="num" id="LN692">692</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> U64 ZSTD_rollingHash_rotate(U64 hash, BYTE toRemove, BYTE toAdd, U64 primePower)</td></tr>
<tr class="codeline" data-linenumber="693"><td class="num" id="LN693">693</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="694"><td class="num" id="LN694">694</td><td class="line">    hash -= (toRemove + <span class='macro'>ZSTD_ROLL_HASH_CHAR_OFFSET<span class='macro_popup'>10</span></span>) * primePower;</td></tr>
<tr class="codeline" data-linenumber="695"><td class="num" id="LN695">695</td><td class="line">    hash *= prime8bytes;</td></tr>
<tr class="codeline" data-linenumber="696"><td class="num" id="LN696">696</td><td class="line">    hash += toAdd + <span class='macro'>ZSTD_ROLL_HASH_CHAR_OFFSET<span class='macro_popup'>10</span></span>;</td></tr>
<tr class="codeline" data-linenumber="697"><td class="num" id="LN697">697</td><td class="line">    <span class='keyword'>return</span> hash;</td></tr>
<tr class="codeline" data-linenumber="698"><td class="num" id="LN698">698</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="699"><td class="num" id="LN699">699</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="700"><td class="num" id="LN700">700</td><td class="line"><span class='comment'>/*-*************************************</span></td></tr>
<tr class="codeline" data-linenumber="701"><td class="num" id="LN701">701</td><td class="line"><span class='comment'>*  Round buffer management</span></td></tr>
<tr class="codeline" data-linenumber="702"><td class="num" id="LN702">702</td><td class="line"><span class='comment'>***************************************/</span></td></tr>
<tr class="codeline" data-linenumber="703"><td class="num" id="LN703">703</td><td class="line"><span class='directive'>#if (<span class='macro'>ZSTD_WINDOWLOG_MAX_64<span class='macro_popup'>31</span></span> &gt; 31)</span></td></tr>
<tr class="codeline" data-linenumber="704"><td class="num" id="LN704">704</td><td class="line"><span class='directive'># error "ZSTD_WINDOWLOG_MAX is too large : would overflow ZSTD_CURRENT_MAX"</span></td></tr>
<tr class="codeline" data-linenumber="705"><td class="num" id="LN705">705</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="706"><td class="num" id="LN706">706</td><td class="line"><span class='comment'>/* Max current allowed */</span></td></tr>
<tr class="codeline" data-linenumber="707"><td class="num" id="LN707">707</td><td class="line"><span class='directive'>#define <span class='macro'>ZSTD_CURRENT_MAX<span class='macro_popup'>((3U &lt;&lt; 29) + (1U &lt;&lt; ((int)(sizeof(size_t) == 4 ?<br> 30 : 31))))</span></span> ((3U &lt;&lt; 29) + (1U &lt;&lt; <span class='macro'>ZSTD_WINDOWLOG_MAX<span class='macro_popup'>((int)(sizeof(size_t) == 4 ? 30 : 31))</span></span>))</span></td></tr>
<tr class="codeline" data-linenumber="708"><td class="num" id="LN708">708</td><td class="line"><span class='comment'>/* Maximum chunk size before overflow correction needs to be called again */</span></td></tr>
<tr class="codeline" data-linenumber="709"><td class="num" id="LN709">709</td><td class="line"><span class='directive'>#define <span class='macro'>ZSTD_CHUNKSIZE_MAX<span class='macro_popup'>( ((U32)-1) - ((3U &lt;&lt; 29) + (1U &lt;&lt; ((int)(sizeof(<br>size_t) == 4 ? 30 : 31)))))</span></span>                                                     \</span></td></tr>
<tr class="codeline" data-linenumber="710"><td class="num" id="LN710">710</td><td class="line">    <span class='directive'>( ((U32)-1)                  /* Maximum ending current index */            \</span></td></tr>
<tr class="codeline" data-linenumber="711"><td class="num" id="LN711">711</td><td class="line">    <span class='directive'>- <span class='macro'>ZSTD_CURRENT_MAX<span class='macro_popup'>((3U &lt;&lt; 29) + (1U &lt;&lt; ((int)(sizeof(size_t) == 4 ?<br> 30 : 31))))</span></span>)          /* Maximum beginning lowLimit */</span></td></tr>
<tr class="codeline" data-linenumber="712"><td class="num" id="LN712">712</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="713"><td class="num" id="LN713">713</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="714"><td class="num" id="LN714">714</td><td class="line"> <span class='comment'>* ZSTD_window_clear():</span></td></tr>
<tr class="codeline" data-linenumber="715"><td class="num" id="LN715">715</td><td class="line"> <span class='comment'>* Clears the window containing the history by simply setting it to empty.</span></td></tr>
<tr class="codeline" data-linenumber="716"><td class="num" id="LN716">716</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="717"><td class="num" id="LN717">717</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> <span class='keyword'>void</span> ZSTD_window_clear(ZSTD_window_t* window)</td></tr>
<tr class="codeline" data-linenumber="718"><td class="num" id="LN718">718</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="719"><td class="num" id="LN719">719</td><td class="line">    size_t <span class='keyword'>const</span> endT = (size_t)(window-&gt;nextSrc - window-&gt;base);</td></tr>
<tr class="codeline" data-linenumber="720"><td class="num" id="LN720">720</td><td class="line">    U32 <span class='keyword'>const</span> end = (U32)endT;</td></tr>
<tr class="codeline" data-linenumber="721"><td class="num" id="LN721">721</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="722"><td class="num" id="LN722">722</td><td class="line">    window-&gt;lowLimit = end;</td></tr>
<tr class="codeline" data-linenumber="723"><td class="num" id="LN723">723</td><td class="line">    window-&gt;dictLimit = end;</td></tr>
<tr class="codeline" data-linenumber="724"><td class="num" id="LN724">724</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="725"><td class="num" id="LN725">725</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="726"><td class="num" id="LN726">726</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="727"><td class="num" id="LN727">727</td><td class="line"> <span class='comment'>* ZSTD_window_hasExtDict():</span></td></tr>
<tr class="codeline" data-linenumber="728"><td class="num" id="LN728">728</td><td class="line"> <span class='comment'>* Returns non-zero if the window has a non-empty extDict.</span></td></tr>
<tr class="codeline" data-linenumber="729"><td class="num" id="LN729">729</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="730"><td class="num" id="LN730">730</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> U32 ZSTD_window_hasExtDict(ZSTD_window_t <span class='keyword'>const</span> window)</td></tr>
<tr class="codeline" data-linenumber="731"><td class="num" id="LN731">731</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="732"><td class="num" id="LN732">732</td><td class="line">    <span class='keyword'>return</span> window.lowLimit &lt; window.dictLimit;</td></tr>
<tr class="codeline" data-linenumber="733"><td class="num" id="LN733">733</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="734"><td class="num" id="LN734">734</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="735"><td class="num" id="LN735">735</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="736"><td class="num" id="LN736">736</td><td class="line"> <span class='comment'>* ZSTD_matchState_dictMode():</span></td></tr>
<tr class="codeline" data-linenumber="737"><td class="num" id="LN737">737</td><td class="line"> <span class='comment'>* Inspects the provided matchState and figures out what dictMode should be</span></td></tr>
<tr class="codeline" data-linenumber="738"><td class="num" id="LN738">738</td><td class="line"> <span class='comment'>* passed to the compressor.</span></td></tr>
<tr class="codeline" data-linenumber="739"><td class="num" id="LN739">739</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="740"><td class="num" id="LN740">740</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> ZSTD_dictMode_e ZSTD_matchState_dictMode(<span class='keyword'>const</span> ZSTD_matchState_t *ms)</td></tr>
<tr class="codeline" data-linenumber="741"><td class="num" id="LN741">741</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="742"><td class="num" id="LN742">742</td><td class="line">    <span class='keyword'>return</span> ZSTD_window_hasExtDict(ms-&gt;window) ?</td></tr>
<tr class="codeline" data-linenumber="743"><td class="num" id="LN743">743</td><td class="line">        ZSTD_extDict :</td></tr>
<tr class="codeline" data-linenumber="744"><td class="num" id="LN744">744</td><td class="line">        ms-&gt;dictMatchState != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span> ?</td></tr>
<tr class="codeline" data-linenumber="745"><td class="num" id="LN745">745</td><td class="line">            ZSTD_dictMatchState :</td></tr>
<tr class="codeline" data-linenumber="746"><td class="num" id="LN746">746</td><td class="line">            ZSTD_noDict;</td></tr>
<tr class="codeline" data-linenumber="747"><td class="num" id="LN747">747</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="748"><td class="num" id="LN748">748</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="749"><td class="num" id="LN749">749</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="750"><td class="num" id="LN750">750</td><td class="line"> <span class='comment'>* ZSTD_window_needOverflowCorrection():</span></td></tr>
<tr class="codeline" data-linenumber="751"><td class="num" id="LN751">751</td><td class="line"> <span class='comment'>* Returns non-zero if the indices are getting too large and need overflow</span></td></tr>
<tr class="codeline" data-linenumber="752"><td class="num" id="LN752">752</td><td class="line"> <span class='comment'>* protection.</span></td></tr>
<tr class="codeline" data-linenumber="753"><td class="num" id="LN753">753</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="754"><td class="num" id="LN754">754</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> U32 ZSTD_window_needOverflowCorrection(ZSTD_window_t <span class='keyword'>const</span> window,</td></tr>
<tr class="codeline" data-linenumber="755"><td class="num" id="LN755">755</td><td class="line">                                                  <span class='keyword'>void</span> <span class='keyword'>const</span>* srcEnd)</td></tr>
<tr class="codeline" data-linenumber="756"><td class="num" id="LN756">756</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="757"><td class="num" id="LN757">757</td><td class="line">    U32 <span class='keyword'>const</span> current = (U32)((BYTE <span class='keyword'>const</span>*)srcEnd - window.base);</td></tr>
<tr class="codeline" data-linenumber="758"><td class="num" id="LN758">758</td><td class="line">    <span class='keyword'>return</span> current &gt; <span class='macro'>ZSTD_CURRENT_MAX<span class='macro_popup'>((3U &lt;&lt; 29) + (1U &lt;&lt; ((int)(sizeof(size_t) == 4 ?<br> 30 : 31))))</span></span>;</td></tr>
<tr class="codeline" data-linenumber="759"><td class="num" id="LN759">759</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="760"><td class="num" id="LN760">760</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="761"><td class="num" id="LN761">761</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="762"><td class="num" id="LN762">762</td><td class="line"> <span class='comment'>* ZSTD_window_correctOverflow():</span></td></tr>
<tr class="codeline" data-linenumber="763"><td class="num" id="LN763">763</td><td class="line"> <span class='comment'>* Reduces the indices to protect from index overflow.</span></td></tr>
<tr class="codeline" data-linenumber="764"><td class="num" id="LN764">764</td><td class="line"> <span class='comment'>* Returns the correction made to the indices, which must be applied to every</span></td></tr>
<tr class="codeline" data-linenumber="765"><td class="num" id="LN765">765</td><td class="line"> <span class='comment'>* stored index.</span></td></tr>
<tr class="codeline" data-linenumber="766"><td class="num" id="LN766">766</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="767"><td class="num" id="LN767">767</td><td class="line"> <span class='comment'>* The least significant cycleLog bits of the indices must remain the same,</span></td></tr>
<tr class="codeline" data-linenumber="768"><td class="num" id="LN768">768</td><td class="line"> <span class='comment'>* which may be 0. Every index up to maxDist in the past must be valid.</span></td></tr>
<tr class="codeline" data-linenumber="769"><td class="num" id="LN769">769</td><td class="line"> <span class='comment'>* NOTE: (maxDist &amp; cycleMask) must be zero.</span></td></tr>
<tr class="codeline" data-linenumber="770"><td class="num" id="LN770">770</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="771"><td class="num" id="LN771">771</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> U32 ZSTD_window_correctOverflow(ZSTD_window_t* window, U32 cycleLog,</td></tr>
<tr class="codeline" data-linenumber="772"><td class="num" id="LN772">772</td><td class="line">                                           U32 maxDist, <span class='keyword'>void</span> <span class='keyword'>const</span>* src)</td></tr>
<tr class="codeline" data-linenumber="773"><td class="num" id="LN773">773</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="774"><td class="num" id="LN774">774</td><td class="line">    <span class='comment'>/* preemptive overflow correction:</span></td></tr>
<tr class="codeline" data-linenumber="775"><td class="num" id="LN775">775</td><td class="line">     <span class='comment'>* 1. correction is large enough:</span></td></tr>
<tr class="codeline" data-linenumber="776"><td class="num" id="LN776">776</td><td class="line">     <span class='comment'>*    lowLimit &gt; (3&lt;&lt;29) ==&gt; current &gt; 3&lt;&lt;29 + 1&lt;&lt;windowLog</span></td></tr>
<tr class="codeline" data-linenumber="777"><td class="num" id="LN777">777</td><td class="line">     <span class='comment'>*    1&lt;&lt;windowLog &lt;= newCurrent &lt; 1&lt;&lt;chainLog + 1&lt;&lt;windowLog</span></td></tr>
<tr class="codeline" data-linenumber="778"><td class="num" id="LN778">778</td><td class="line">     <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="779"><td class="num" id="LN779">779</td><td class="line">     <span class='comment'>*    current - newCurrent</span></td></tr>
<tr class="codeline" data-linenumber="780"><td class="num" id="LN780">780</td><td class="line">     <span class='comment'>*    &gt; (3&lt;&lt;29 + 1&lt;&lt;windowLog) - (1&lt;&lt;windowLog + 1&lt;&lt;chainLog)</span></td></tr>
<tr class="codeline" data-linenumber="781"><td class="num" id="LN781">781</td><td class="line">     <span class='comment'>*    &gt; (3&lt;&lt;29) - (1&lt;&lt;chainLog)</span></td></tr>
<tr class="codeline" data-linenumber="782"><td class="num" id="LN782">782</td><td class="line">     <span class='comment'>*    &gt; (3&lt;&lt;29) - (1&lt;&lt;30)             (NOTE: chainLog &lt;= 30)</span></td></tr>
<tr class="codeline" data-linenumber="783"><td class="num" id="LN783">783</td><td class="line">     <span class='comment'>*    &gt; 1&lt;&lt;29</span></td></tr>
<tr class="codeline" data-linenumber="784"><td class="num" id="LN784">784</td><td class="line">     <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="785"><td class="num" id="LN785">785</td><td class="line">     <span class='comment'>* 2. (ip+ZSTD_CHUNKSIZE_MAX - cctx-&gt;base) doesn't overflow:</span></td></tr>
<tr class="codeline" data-linenumber="786"><td class="num" id="LN786">786</td><td class="line">     <span class='comment'>*    After correction, current is less than (1&lt;&lt;chainLog + 1&lt;&lt;windowLog).</span></td></tr>
<tr class="codeline" data-linenumber="787"><td class="num" id="LN787">787</td><td class="line">     <span class='comment'>*    In 64-bit mode we are safe, because we have 64-bit ptrdiff_t.</span></td></tr>
<tr class="codeline" data-linenumber="788"><td class="num" id="LN788">788</td><td class="line">     <span class='comment'>*    In 32-bit mode we are safe, because (chainLog &lt;= 29), so</span></td></tr>
<tr class="codeline" data-linenumber="789"><td class="num" id="LN789">789</td><td class="line">     <span class='comment'>*    ip+ZSTD_CHUNKSIZE_MAX - cctx-&gt;base &lt; 1&lt;&lt;32.</span></td></tr>
<tr class="codeline" data-linenumber="790"><td class="num" id="LN790">790</td><td class="line">     <span class='comment'>* 3. (cctx-&gt;lowLimit + 1&lt;&lt;windowLog) &lt; 1&lt;&lt;32:</span></td></tr>
<tr class="codeline" data-linenumber="791"><td class="num" id="LN791">791</td><td class="line">     <span class='comment'>*    windowLog &lt;= 31 ==&gt; 3&lt;&lt;29 + 1&lt;&lt;windowLog &lt; 7&lt;&lt;29 &lt; 1&lt;&lt;32.</span></td></tr>
<tr class="codeline" data-linenumber="792"><td class="num" id="LN792">792</td><td class="line">     <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="793"><td class="num" id="LN793">793</td><td class="line">    U32 <span class='keyword'>const</span> cycleMask = (1U &lt;&lt; cycleLog) - 1;</td></tr>
<tr class="codeline" data-linenumber="794"><td class="num" id="LN794">794</td><td class="line">    U32 <span class='keyword'>const</span> current = (U32)((BYTE <span class='keyword'>const</span>*)src - window-&gt;base);</td></tr>
<tr class="codeline" data-linenumber="795"><td class="num" id="LN795">795</td><td class="line">    U32 <span class='keyword'>const</span> currentCycle0 = current &amp; cycleMask;</td></tr>
<tr class="codeline" data-linenumber="796"><td class="num" id="LN796">796</td><td class="line">    <span class='comment'>/* Exclude zero so that newCurrent - maxDist &gt;= 1. */</span></td></tr>
<tr class="codeline" data-linenumber="797"><td class="num" id="LN797">797</td><td class="line">    U32 <span class='keyword'>const</span> currentCycle1 = currentCycle0 == 0 ? (1U &lt;&lt; cycleLog) : currentCycle0;</td></tr>
<tr class="codeline" data-linenumber="798"><td class="num" id="LN798">798</td><td class="line">    U32 <span class='keyword'>const</span> newCurrent = currentCycle1 + maxDist;</td></tr>
<tr class="codeline" data-linenumber="799"><td class="num" id="LN799">799</td><td class="line">    U32 <span class='keyword'>const</span> correction = current - newCurrent;</td></tr>
<tr class="codeline" data-linenumber="800"><td class="num" id="LN800">800</td><td class="line">    <span class='macro'>assert((maxDist &amp; cycleMask) == 0)<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="801"><td class="num" id="LN801">801</td><td class="line">    <span class='macro'>assert(current &gt; newCurrent)<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="802"><td class="num" id="LN802">802</td><td class="line">    <span class='comment'>/* Loose bound, should be around 1&lt;&lt;29 (see above) */</span></td></tr>
<tr class="codeline" data-linenumber="803"><td class="num" id="LN803">803</td><td class="line">    <span class='macro'>assert(correction &gt; 1&lt;&lt;28)<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="804"><td class="num" id="LN804">804</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="805"><td class="num" id="LN805">805</td><td class="line">    window-&gt;base += correction;</td></tr>
<tr class="codeline" data-linenumber="806"><td class="num" id="LN806">806</td><td class="line">    window-&gt;dictBase += correction;</td></tr>
<tr class="codeline" data-linenumber="807"><td class="num" id="LN807">807</td><td class="line">    <span class='keyword'>if</span> (window-&gt;lowLimit &lt;= correction) window-&gt;lowLimit = 1;</td></tr>
<tr class="codeline" data-linenumber="808"><td class="num" id="LN808">808</td><td class="line">    <span class='keyword'>else</span> window-&gt;lowLimit -= correction;</td></tr>
<tr class="codeline" data-linenumber="809"><td class="num" id="LN809">809</td><td class="line">    <span class='keyword'>if</span> (window-&gt;dictLimit &lt;= correction) window-&gt;dictLimit = 1;</td></tr>
<tr class="codeline" data-linenumber="810"><td class="num" id="LN810">810</td><td class="line">    <span class='keyword'>else</span> window-&gt;dictLimit -= correction;</td></tr>
<tr class="codeline" data-linenumber="811"><td class="num" id="LN811">811</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="812"><td class="num" id="LN812">812</td><td class="line">    <span class='comment'>/* Ensure we can still reference the full window. */</span></td></tr>
<tr class="codeline" data-linenumber="813"><td class="num" id="LN813">813</td><td class="line">    <span class='macro'>assert(newCurrent &gt;= maxDist)<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="814"><td class="num" id="LN814">814</td><td class="line">    <span class='macro'>assert(newCurrent - maxDist &gt;= 1)<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="815"><td class="num" id="LN815">815</td><td class="line">    <span class='comment'>/* Ensure that lowLimit and dictLimit didn't underflow. */</span></td></tr>
<tr class="codeline" data-linenumber="816"><td class="num" id="LN816">816</td><td class="line">    <span class='macro'>assert(window-&gt;lowLimit &lt;= newCurrent)<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="817"><td class="num" id="LN817">817</td><td class="line">    <span class='macro'>assert(window-&gt;dictLimit &lt;= newCurrent)<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="818"><td class="num" id="LN818">818</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="819"><td class="num" id="LN819">819</td><td class="line">    <span class='macro'>DEBUGLOG(4, <span class='string_literal'>"Correction of 0x%x bytes to lowLimit=0x%x"</span>, correction,<span class='macro_popup'>{}</span></span></td></tr>
<tr class="codeline" data-linenumber="820"><td class="num" id="LN820">820</td><td class="line">             <span class='macro'>window-&gt;lowLimit)<span class='macro_popup'>{}</span></span>;</td></tr>
<tr class="codeline" data-linenumber="821"><td class="num" id="LN821">821</td><td class="line">    <span class='keyword'>return</span> correction;</td></tr>
<tr class="codeline" data-linenumber="822"><td class="num" id="LN822">822</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="823"><td class="num" id="LN823">823</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="824"><td class="num" id="LN824">824</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="825"><td class="num" id="LN825">825</td><td class="line"> <span class='comment'>* ZSTD_window_enforceMaxDist():</span></td></tr>
<tr class="codeline" data-linenumber="826"><td class="num" id="LN826">826</td><td class="line"> <span class='comment'>* Updates lowLimit so that:</span></td></tr>
<tr class="codeline" data-linenumber="827"><td class="num" id="LN827">827</td><td class="line"> <span class='comment'>*    (srcEnd - base) - lowLimit == maxDist + loadedDictEnd</span></td></tr>
<tr class="codeline" data-linenumber="828"><td class="num" id="LN828">828</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="829"><td class="num" id="LN829">829</td><td class="line"> <span class='comment'>* It ensures index is valid as long as index &gt;= lowLimit.</span></td></tr>
<tr class="codeline" data-linenumber="830"><td class="num" id="LN830">830</td><td class="line"> <span class='comment'>* This must be called before a block compression call.</span></td></tr>
<tr class="codeline" data-linenumber="831"><td class="num" id="LN831">831</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="832"><td class="num" id="LN832">832</td><td class="line"> <span class='comment'>* loadedDictEnd is only defined if a dictionary is in use for current compression.</span></td></tr>
<tr class="codeline" data-linenumber="833"><td class="num" id="LN833">833</td><td class="line"> <span class='comment'>* As the name implies, loadedDictEnd represents the index at end of dictionary.</span></td></tr>
<tr class="codeline" data-linenumber="834"><td class="num" id="LN834">834</td><td class="line"> <span class='comment'>* The value lies within context's referential, it can be directly compared to blockEndIdx.</span></td></tr>
<tr class="codeline" data-linenumber="835"><td class="num" id="LN835">835</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="836"><td class="num" id="LN836">836</td><td class="line"> <span class='comment'>* If loadedDictEndPtr is NULL, no dictionary is in use, and we use loadedDictEnd == 0.</span></td></tr>
<tr class="codeline" data-linenumber="837"><td class="num" id="LN837">837</td><td class="line"> <span class='comment'>* If loadedDictEndPtr is not NULL, we set it to zero after updating lowLimit.</span></td></tr>
<tr class="codeline" data-linenumber="838"><td class="num" id="LN838">838</td><td class="line"> <span class='comment'>* This is because dictionaries are allowed to be referenced fully</span></td></tr>
<tr class="codeline" data-linenumber="839"><td class="num" id="LN839">839</td><td class="line"> <span class='comment'>* as long as the last byte of the dictionary is in the window.</span></td></tr>
<tr class="codeline" data-linenumber="840"><td class="num" id="LN840">840</td><td class="line"> <span class='comment'>* Once input has progressed beyond window size, dictionary cannot be referenced anymore.</span></td></tr>
<tr class="codeline" data-linenumber="841"><td class="num" id="LN841">841</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr class="codeline" data-linenumber="842"><td class="num" id="LN842">842</td><td class="line"> <span class='comment'>* In normal dict mode, the dictionary lies between lowLimit and dictLimit.</span></td></tr>
<tr class="codeline" data-linenumber="843"><td class="num" id="LN843">843</td><td class="line"> <span class='comment'>* In dictMatchState mode, lowLimit and dictLimit are the same,</span></td></tr>
<tr class="codeline" data-linenumber="844"><td class="num" id="LN844">844</td><td class="line"> <span class='comment'>* and the dictionary is below them.</span></td></tr>
<tr class="codeline" data-linenumber="845"><td class="num" id="LN845">845</td><td class="line"> <span class='comment'>* forceWindow and dictMatchState are therefore incompatible.</span></td></tr>
<tr class="codeline" data-linenumber="846"><td class="num" id="LN846">846</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="847"><td class="num" id="LN847">847</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="848"><td class="num" id="LN848">848</td><td class="line">ZSTD_window_enforceMaxDist(ZSTD_window_t* window,</td></tr>
<tr class="codeline" data-linenumber="849"><td class="num" id="LN849">849</td><td class="line">                     <span class='keyword'>const</span> <span class='keyword'>void</span>* blockEnd,</td></tr>
<tr class="codeline" data-linenumber="850"><td class="num" id="LN850">850</td><td class="line">                           U32   maxDist,</td></tr>
<tr class="codeline" data-linenumber="851"><td class="num" id="LN851">851</td><td class="line">                           U32*  loadedDictEndPtr,</td></tr>
<tr class="codeline" data-linenumber="852"><td class="num" id="LN852">852</td><td class="line">                     <span class='keyword'>const</span> ZSTD_matchState_t** dictMatchStatePtr)</td></tr>
<tr class="codeline" data-linenumber="853"><td class="num" id="LN853">853</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="854"><td class="num" id="LN854">854</td><td class="line">    U32 <span class='keyword'>const</span> blockEndIdx = (U32)((BYTE <span class='keyword'>const</span>*)blockEnd - window-&gt;base);</td></tr>
<tr class="codeline" data-linenumber="855"><td class="num" id="LN855">855</td><td class="line">    U32 <span class='keyword'>const</span> loadedDictEnd = (loadedDictEndPtr != <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>) ? *loadedDictEndPtr : 0;</td></tr>
<tr class="codeline" data-linenumber="856"><td class="num" id="LN856">856</td><td class="line">    <span class='macro'>DEBUGLOG(5, <span class='string_literal'>"ZSTD_window_enforceMaxDist: blockEndIdx=%u, maxDist=%u, loadedDictEnd=%u"</span>,<span class='macro_popup'>{}</span></span></td></tr>
<tr class="codeline" data-linenumber="857"><td class="num" id="LN857">857</td><td class="line">                <span class='macro'>(<span class='keyword'>unsigned</span>)blockEndIdx, (<span class='keyword'>unsigned</span>)maxDist, (<span class='keyword'>unsigned</span>)loadedDictEnd)<span class='macro_popup'>{}</span></span>;</td></tr>
<tr class="codeline" data-linenumber="858"><td class="num" id="LN858">858</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="859"><td class="num" id="LN859">859</td><td class="line">    <span class='comment'>/* - When there is no dictionary : loadedDictEnd == 0.</span></td></tr>
<tr class="codeline" data-linenumber="860"><td class="num" id="LN860">860</td><td class="line">         <span class='comment'>In which case, the test (blockEndIdx &gt; maxDist) is merely to avoid</span></td></tr>
<tr class="codeline" data-linenumber="861"><td class="num" id="LN861">861</td><td class="line">         <span class='comment'>overflowing next operation `newLowLimit = blockEndIdx - maxDist`.</span></td></tr>
<tr class="codeline" data-linenumber="862"><td class="num" id="LN862">862</td><td class="line">       <span class='comment'>- When there is a standard dictionary :</span></td></tr>
<tr class="codeline" data-linenumber="863"><td class="num" id="LN863">863</td><td class="line">         <span class='comment'>Index referential is copied from the dictionary,</span></td></tr>
<tr class="codeline" data-linenumber="864"><td class="num" id="LN864">864</td><td class="line">         <span class='comment'>which means it starts from 0.</span></td></tr>
<tr class="codeline" data-linenumber="865"><td class="num" id="LN865">865</td><td class="line">         <span class='comment'>In which case, loadedDictEnd == dictSize,</span></td></tr>
<tr class="codeline" data-linenumber="866"><td class="num" id="LN866">866</td><td class="line">         <span class='comment'>and it makes sense to compare `blockEndIdx &gt; maxDist + dictSize`</span></td></tr>
<tr class="codeline" data-linenumber="867"><td class="num" id="LN867">867</td><td class="line">         <span class='comment'>since `blockEndIdx` also starts from zero.</span></td></tr>
<tr class="codeline" data-linenumber="868"><td class="num" id="LN868">868</td><td class="line">       <span class='comment'>- When there is an attached dictionary :</span></td></tr>
<tr class="codeline" data-linenumber="869"><td class="num" id="LN869">869</td><td class="line">         <span class='comment'>loadedDictEnd is expressed within the referential of the context,</span></td></tr>
<tr class="codeline" data-linenumber="870"><td class="num" id="LN870">870</td><td class="line">         <span class='comment'>so it can be directly compared against blockEndIdx.</span></td></tr>
<tr class="codeline" data-linenumber="871"><td class="num" id="LN871">871</td><td class="line">    <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="872"><td class="num" id="LN872">872</td><td class="line">    <span class='keyword'>if</span> (blockEndIdx &gt; maxDist + loadedDictEnd) {</td></tr>
<tr class="codeline" data-linenumber="873"><td class="num" id="LN873">873</td><td class="line">        U32 <span class='keyword'>const</span> newLowLimit = blockEndIdx - maxDist;</td></tr>
<tr class="codeline" data-linenumber="874"><td class="num" id="LN874">874</td><td class="line">        <span class='keyword'>if</span> (window-&gt;lowLimit &lt; newLowLimit) window-&gt;lowLimit = newLowLimit;</td></tr>
<tr class="codeline" data-linenumber="875"><td class="num" id="LN875">875</td><td class="line">        <span class='keyword'>if</span> (window-&gt;dictLimit &lt; window-&gt;lowLimit) {</td></tr>
<tr class="codeline" data-linenumber="876"><td class="num" id="LN876">876</td><td class="line">            <span class='macro'>DEBUGLOG(5, <span class='string_literal'>"Update dictLimit to match lowLimit, from %u to %u"</span>,<span class='macro_popup'>{}</span></span></td></tr>
<tr class="codeline" data-linenumber="877"><td class="num" id="LN877">877</td><td class="line">                        <span class='macro'>(<span class='keyword'>unsigned</span>)window-&gt;dictLimit, (<span class='keyword'>unsigned</span>)window-&gt;lowLimit)<span class='macro_popup'>{}</span></span>;</td></tr>
<tr class="codeline" data-linenumber="878"><td class="num" id="LN878">878</td><td class="line">            window-&gt;dictLimit = window-&gt;lowLimit;</td></tr>
<tr class="codeline" data-linenumber="879"><td class="num" id="LN879">879</td><td class="line">        }</td></tr>
<tr class="codeline" data-linenumber="880"><td class="num" id="LN880">880</td><td class="line">        <span class='comment'>/* On reaching window size, dictionaries are invalidated */</span></td></tr>
<tr class="codeline" data-linenumber="881"><td class="num" id="LN881">881</td><td class="line">        <span class='keyword'>if</span> (loadedDictEndPtr) *loadedDictEndPtr = 0;</td></tr>
<tr class="codeline" data-linenumber="882"><td class="num" id="LN882">882</td><td class="line">        <span class='keyword'>if</span> (dictMatchStatePtr) *dictMatchStatePtr = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="883"><td class="num" id="LN883">883</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="884"><td class="num" id="LN884">884</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="885"><td class="num" id="LN885">885</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="886"><td class="num" id="LN886">886</td><td class="line"><span class='comment'>/* Similar to ZSTD_window_enforceMaxDist(),</span></td></tr>
<tr class="codeline" data-linenumber="887"><td class="num" id="LN887">887</td><td class="line"> <span class='comment'>* but only invalidates dictionary</span></td></tr>
<tr class="codeline" data-linenumber="888"><td class="num" id="LN888">888</td><td class="line"> <span class='comment'>* when input progresses beyond window size.</span></td></tr>
<tr class="codeline" data-linenumber="889"><td class="num" id="LN889">889</td><td class="line"> <span class='comment'>* assumption : loadedDictEndPtr and dictMatchStatePtr are valid (non NULL)</span></td></tr>
<tr class="codeline" data-linenumber="890"><td class="num" id="LN890">890</td><td class="line"> <span class='comment'>*              loadedDictEnd uses same referential as window-&gt;base</span></td></tr>
<tr class="codeline" data-linenumber="891"><td class="num" id="LN891">891</td><td class="line"> <span class='comment'>*              maxDist is the window size */</span></td></tr>
<tr class="codeline" data-linenumber="892"><td class="num" id="LN892">892</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> <span class='keyword'>void</span></td></tr>
<tr class="codeline" data-linenumber="893"><td class="num" id="LN893">893</td><td class="line">ZSTD_checkDictValidity(<span class='keyword'>const</span> ZSTD_window_t* window,</td></tr>
<tr class="codeline" data-linenumber="894"><td class="num" id="LN894">894</td><td class="line">                       <span class='keyword'>const</span> <span class='keyword'>void</span>* blockEnd,</td></tr>
<tr class="codeline" data-linenumber="895"><td class="num" id="LN895">895</td><td class="line">                             U32   maxDist,</td></tr>
<tr class="codeline" data-linenumber="896"><td class="num" id="LN896">896</td><td class="line">                             U32*  loadedDictEndPtr,</td></tr>
<tr class="codeline" data-linenumber="897"><td class="num" id="LN897">897</td><td class="line">                       <span class='keyword'>const</span> ZSTD_matchState_t** dictMatchStatePtr)</td></tr>
<tr class="codeline" data-linenumber="898"><td class="num" id="LN898">898</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="899"><td class="num" id="LN899">899</td><td class="line">    <span class='macro'>assert(loadedDictEndPtr != NULL)<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="900"><td class="num" id="LN900">900</td><td class="line">    <span class='macro'>assert(dictMatchStatePtr != NULL)<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="901"><td class="num" id="LN901">901</td><td class="line">    {   U32 <span class='keyword'>const</span> blockEndIdx = (U32)((BYTE <span class='keyword'>const</span>*)blockEnd - window-&gt;base);</td></tr>
<tr class="codeline" data-linenumber="902"><td class="num" id="LN902">902</td><td class="line">        U32 <span class='keyword'>const</span> loadedDictEnd = *loadedDictEndPtr;</td></tr>
<tr class="codeline" data-linenumber="903"><td class="num" id="LN903">903</td><td class="line">        <span class='macro'>DEBUGLOG(5, <span class='string_literal'>"ZSTD_checkDictValidity: blockEndIdx=%u, maxDist=%u, loadedDictEnd=%u"</span>,<span class='macro_popup'>{}</span></span></td></tr>
<tr class="codeline" data-linenumber="904"><td class="num" id="LN904">904</td><td class="line">                    <span class='macro'>(<span class='keyword'>unsigned</span>)blockEndIdx, (<span class='keyword'>unsigned</span>)maxDist, (<span class='keyword'>unsigned</span>)loadedDictEnd)<span class='macro_popup'>{}</span></span>;</td></tr>
<tr class="codeline" data-linenumber="905"><td class="num" id="LN905">905</td><td class="line">        <span class='macro'>assert(blockEndIdx &gt;= loadedDictEnd)<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="906"><td class="num" id="LN906">906</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="907"><td class="num" id="LN907">907</td><td class="line">        <span class='keyword'>if</span> (blockEndIdx &gt; loadedDictEnd + maxDist) {</td></tr>
<tr class="codeline" data-linenumber="908"><td class="num" id="LN908">908</td><td class="line">            <span class='comment'>/* On reaching window size, dictionaries are invalidated.</span></td></tr>
<tr class="codeline" data-linenumber="909"><td class="num" id="LN909">909</td><td class="line">             <span class='comment'>* For simplification, if window size is reached anywhere within next block,</span></td></tr>
<tr class="codeline" data-linenumber="910"><td class="num" id="LN910">910</td><td class="line">             <span class='comment'>* the dictionary is invalidated for the full block.</span></td></tr>
<tr class="codeline" data-linenumber="911"><td class="num" id="LN911">911</td><td class="line">             <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="912"><td class="num" id="LN912">912</td><td class="line">            <span class='macro'>DEBUGLOG(6, <span class='string_literal'>"invalidating dictionary for current block (distance &gt; windowSize)"</span>)<span class='macro_popup'>{}</span></span>;</td></tr>
<tr class="codeline" data-linenumber="913"><td class="num" id="LN913">913</td><td class="line">            *loadedDictEndPtr = 0;</td></tr>
<tr class="codeline" data-linenumber="914"><td class="num" id="LN914">914</td><td class="line">            *dictMatchStatePtr = <span class='macro'>NULL<span class='macro_popup'>((void*)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="915"><td class="num" id="LN915">915</td><td class="line">        } <span class='keyword'>else</span> {</td></tr>
<tr class="codeline" data-linenumber="916"><td class="num" id="LN916">916</td><td class="line">            <span class='keyword'>if</span> (*loadedDictEndPtr != 0) {</td></tr>
<tr class="codeline" data-linenumber="917"><td class="num" id="LN917">917</td><td class="line">                <span class='macro'>DEBUGLOG(6, <span class='string_literal'>"dictionary considered valid for current block"</span>)<span class='macro_popup'>{}</span></span>;</td></tr>
<tr class="codeline" data-linenumber="918"><td class="num" id="LN918">918</td><td class="line">    }   }   }</td></tr>
<tr class="codeline" data-linenumber="919"><td class="num" id="LN919">919</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="920"><td class="num" id="LN920">920</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="921"><td class="num" id="LN921">921</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> <span class='keyword'>void</span> ZSTD_window_init(ZSTD_window_t* window) {</td></tr>
<tr class="codeline" data-linenumber="922"><td class="num" id="LN922">922</td><td class="line">    memset(window, 0, <span class='keyword'>sizeof</span>(*window));</td></tr>
<tr class="codeline" data-linenumber="923"><td class="num" id="LN923">923</td><td class="line">    window-&gt;base = (BYTE <span class='keyword'>const</span>*)<span class='string_literal'>""</span>;</td></tr>
<tr class="codeline" data-linenumber="924"><td class="num" id="LN924">924</td><td class="line">    window-&gt;dictBase = (BYTE <span class='keyword'>const</span>*)<span class='string_literal'>""</span>;</td></tr>
<tr class="codeline" data-linenumber="925"><td class="num" id="LN925">925</td><td class="line">    window-&gt;dictLimit = 1;    <span class='comment'>/* start from 1, so that 1st position is valid */</span></td></tr>
<tr class="codeline" data-linenumber="926"><td class="num" id="LN926">926</td><td class="line">    window-&gt;lowLimit = 1;     <span class='comment'>/* it ensures first and later CCtx usages compress the same */</span></td></tr>
<tr class="codeline" data-linenumber="927"><td class="num" id="LN927">927</td><td class="line">    window-&gt;nextSrc = window-&gt;base + 1;   <span class='comment'>/* see issue #1241 */</span></td></tr>
<tr class="codeline" data-linenumber="928"><td class="num" id="LN928">928</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="929"><td class="num" id="LN929">929</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="930"><td class="num" id="LN930">930</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="931"><td class="num" id="LN931">931</td><td class="line"> <span class='comment'>* ZSTD_window_update():</span></td></tr>
<tr class="codeline" data-linenumber="932"><td class="num" id="LN932">932</td><td class="line"> <span class='comment'>* Updates the window by appending [src, src + srcSize) to the window.</span></td></tr>
<tr class="codeline" data-linenumber="933"><td class="num" id="LN933">933</td><td class="line"> <span class='comment'>* If it is not contiguous, the current prefix becomes the extDict, and we</span></td></tr>
<tr class="codeline" data-linenumber="934"><td class="num" id="LN934">934</td><td class="line"> <span class='comment'>* forget about the extDict. Handles overlap of the prefix and extDict.</span></td></tr>
<tr class="codeline" data-linenumber="935"><td class="num" id="LN935">935</td><td class="line"> <span class='comment'>* Returns non-zero if the segment is contiguous.</span></td></tr>
<tr class="codeline" data-linenumber="936"><td class="num" id="LN936">936</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="937"><td class="num" id="LN937">937</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> U32 ZSTD_window_update(ZSTD_window_t* window,</td></tr>
<tr class="codeline" data-linenumber="938"><td class="num" id="LN938">938</td><td class="line">                                  <span class='keyword'>void</span> <span class='keyword'>const</span>* src, size_t srcSize)</td></tr>
<tr class="codeline" data-linenumber="939"><td class="num" id="LN939">939</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="940"><td class="num" id="LN940">940</td><td class="line">    BYTE <span class='keyword'>const</span>* <span class='keyword'>const</span> ip = (BYTE <span class='keyword'>const</span>*)src;</td></tr>
<tr class="codeline" data-linenumber="941"><td class="num" id="LN941">941</td><td class="line">    U32 contiguous = 1;</td></tr>
<tr class="codeline" data-linenumber="942"><td class="num" id="LN942">942</td><td class="line">    <span class='macro'>DEBUGLOG(5, <span class='string_literal'>"ZSTD_window_update"</span>)<span class='macro_popup'>{}</span></span>;</td></tr>
<tr class="codeline" data-linenumber="943"><td class="num" id="LN943">943</td><td class="line">    <span class='keyword'>if</span> (srcSize == 0)</td></tr>
<tr class="codeline" data-linenumber="944"><td class="num" id="LN944">944</td><td class="line">        <span class='keyword'>return</span> contiguous;</td></tr>
<tr class="codeline" data-linenumber="945"><td class="num" id="LN945">945</td><td class="line">    <span class='macro'>assert(window-&gt;base != NULL)<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="946"><td class="num" id="LN946">946</td><td class="line">    <span class='macro'>assert(window-&gt;dictBase != NULL)<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="947"><td class="num" id="LN947">947</td><td class="line">    <span class='comment'>/* Check if blocks follow each other */</span></td></tr>
<tr class="codeline" data-linenumber="948"><td class="num" id="LN948">948</td><td class="line">    <span class='keyword'>if</span> (src != window-&gt;nextSrc) {</td></tr>
<tr class="codeline" data-linenumber="949"><td class="num" id="LN949">949</td><td class="line">        <span class='comment'>/* not contiguous */</span></td></tr>
<tr class="codeline" data-linenumber="950"><td class="num" id="LN950">950</td><td class="line">        size_t <span class='keyword'>const</span> distanceFromBase = (size_t)(window-&gt;nextSrc - window-&gt;base);</td></tr>
<tr class="codeline" data-linenumber="951"><td class="num" id="LN951">951</td><td class="line">        <span class='macro'>DEBUGLOG(5, <span class='string_literal'>"Non contiguous blocks, new segment starts at %u"</span>, window-&gt;dictLimit)<span class='macro_popup'>{}</span></span>;</td></tr>
<tr class="codeline" data-linenumber="952"><td class="num" id="LN952">952</td><td class="line">        window-&gt;lowLimit = window-&gt;dictLimit;</td></tr>
<tr class="codeline" data-linenumber="953"><td class="num" id="LN953">953</td><td class="line">        <span class='macro'>assert(distanceFromBase == (size_t)(U32)distanceFromBase)<span class='macro_popup'>((void)0)</span></span>;  <span class='comment'>/* should never overflow */</span></td></tr>
<tr class="codeline" data-linenumber="954"><td class="num" id="LN954">954</td><td class="line">        window-&gt;dictLimit = (U32)distanceFromBase;</td></tr>
<tr class="codeline" data-linenumber="955"><td class="num" id="LN955">955</td><td class="line">        window-&gt;dictBase = window-&gt;base;</td></tr>
<tr class="codeline" data-linenumber="956"><td class="num" id="LN956">956</td><td class="line">        window-&gt;base = ip - distanceFromBase;</td></tr>
<tr class="codeline" data-linenumber="957"><td class="num" id="LN957">957</td><td class="line">        <span class='comment'>/* ms-&gt;nextToUpdate = window-&gt;dictLimit; */</span></td></tr>
<tr class="codeline" data-linenumber="958"><td class="num" id="LN958">958</td><td class="line">        <span class='keyword'>if</span> (window-&gt;dictLimit - window-&gt;lowLimit &lt; <span class='macro'>HASH_READ_SIZE<span class='macro_popup'>8</span></span>) window-&gt;lowLimit = window-&gt;dictLimit;   <span class='comment'>/* too small extDict */</span></td></tr>
<tr class="codeline" data-linenumber="959"><td class="num" id="LN959">959</td><td class="line">        contiguous = 0;</td></tr>
<tr class="codeline" data-linenumber="960"><td class="num" id="LN960">960</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="961"><td class="num" id="LN961">961</td><td class="line">    window-&gt;nextSrc = ip + srcSize;</td></tr>
<tr class="codeline" data-linenumber="962"><td class="num" id="LN962">962</td><td class="line">    <span class='comment'>/* if input and dictionary overlap : reduce dictionary (area presumed modified by input) */</span></td></tr>
<tr class="codeline" data-linenumber="963"><td class="num" id="LN963">963</td><td class="line">    <span class='keyword'>if</span> ( (ip+srcSize &gt; window-&gt;dictBase + window-&gt;lowLimit)</td></tr>
<tr class="codeline" data-linenumber="964"><td class="num" id="LN964">964</td><td class="line">       &amp; (ip &lt; window-&gt;dictBase + window-&gt;dictLimit)) {</td></tr>
<tr class="codeline" data-linenumber="965"><td class="num" id="LN965">965</td><td class="line">        ptrdiff_t <span class='keyword'>const</span> highInputIdx = (ip + srcSize) - window-&gt;dictBase;</td></tr>
<tr class="codeline" data-linenumber="966"><td class="num" id="LN966">966</td><td class="line">        U32 <span class='keyword'>const</span> lowLimitMax = (highInputIdx &gt; (ptrdiff_t)window-&gt;dictLimit) ? window-&gt;dictLimit : (U32)highInputIdx;</td></tr>
<tr class="codeline" data-linenumber="967"><td class="num" id="LN967">967</td><td class="line">        window-&gt;lowLimit = lowLimitMax;</td></tr>
<tr class="codeline" data-linenumber="968"><td class="num" id="LN968">968</td><td class="line">        <span class='macro'>DEBUGLOG(5, <span class='string_literal'>"Overlapping extDict and input : new lowLimit = %u"</span>, window-&gt;lowLimit)<span class='macro_popup'>{}</span></span>;</td></tr>
<tr class="codeline" data-linenumber="969"><td class="num" id="LN969">969</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="970"><td class="num" id="LN970">970</td><td class="line">    <span class='keyword'>return</span> contiguous;</td></tr>
<tr class="codeline" data-linenumber="971"><td class="num" id="LN971">971</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="972"><td class="num" id="LN972">972</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="973"><td class="num" id="LN973">973</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="974"><td class="num" id="LN974">974</td><td class="line"> <span class='comment'>* Returns the lowest allowed match index. It may either be in the ext-dict or the prefix.</span></td></tr>
<tr class="codeline" data-linenumber="975"><td class="num" id="LN975">975</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="976"><td class="num" id="LN976">976</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> U32 ZSTD_getLowestMatchIndex(<span class='keyword'>const</span> ZSTD_matchState_t* ms, U32 current, <span class='keyword'>unsigned</span> windowLog)</td></tr>
<tr class="codeline" data-linenumber="977"><td class="num" id="LN977">977</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="978"><td class="num" id="LN978">978</td><td class="line">    U32    <span class='keyword'>const</span> maxDistance = 1U &lt;&lt; windowLog;</td></tr>
<tr class="codeline" data-linenumber="979"><td class="num" id="LN979">979</td><td class="line">    U32    <span class='keyword'>const</span> lowestValid = ms-&gt;window.lowLimit;</td></tr>
<tr class="codeline" data-linenumber="980"><td class="num" id="LN980">980</td><td class="line">    U32    <span class='keyword'>const</span> withinWindow = (current - lowestValid &gt; maxDistance) ? current - maxDistance : lowestValid;</td></tr>
<tr class="codeline" data-linenumber="981"><td class="num" id="LN981">981</td><td class="line">    U32    <span class='keyword'>const</span> isDictionary = (ms-&gt;loadedDictEnd != 0);</td></tr>
<tr class="codeline" data-linenumber="982"><td class="num" id="LN982">982</td><td class="line">    U32    <span class='keyword'>const</span> matchLowest = isDictionary ? lowestValid : withinWindow;</td></tr>
<tr class="codeline" data-linenumber="983"><td class="num" id="LN983">983</td><td class="line">    <span class='keyword'>return</span> matchLowest;</td></tr>
<tr class="codeline" data-linenumber="984"><td class="num" id="LN984">984</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="985"><td class="num" id="LN985">985</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="986"><td class="num" id="LN986">986</td><td class="line"><span class='comment'>/**</span></td></tr>
<tr class="codeline" data-linenumber="987"><td class="num" id="LN987">987</td><td class="line"> <span class='comment'>* Returns the lowest allowed match index in the prefix.</span></td></tr>
<tr class="codeline" data-linenumber="988"><td class="num" id="LN988">988</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="989"><td class="num" id="LN989">989</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> U32 ZSTD_getLowestPrefixIndex(<span class='keyword'>const</span> ZSTD_matchState_t* ms, U32 current, <span class='keyword'>unsigned</span> windowLog)</td></tr>
<tr class="codeline" data-linenumber="990"><td class="num" id="LN990">990</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="991"><td class="num" id="LN991">991</td><td class="line">    U32    <span class='keyword'>const</span> maxDistance = 1U &lt;&lt; windowLog;</td></tr>
<tr class="codeline" data-linenumber="992"><td class="num" id="LN992">992</td><td class="line">    U32    <span class='keyword'>const</span> lowestValid = ms-&gt;window.dictLimit;</td></tr>
<tr class="codeline" data-linenumber="993"><td class="num" id="LN993">993</td><td class="line">    U32    <span class='keyword'>const</span> withinWindow = (current - lowestValid &gt; maxDistance) ? current - maxDistance : lowestValid;</td></tr>
<tr class="codeline" data-linenumber="994"><td class="num" id="LN994">994</td><td class="line">    U32    <span class='keyword'>const</span> isDictionary = (ms-&gt;loadedDictEnd != 0);</td></tr>
<tr class="codeline" data-linenumber="995"><td class="num" id="LN995">995</td><td class="line">    U32    <span class='keyword'>const</span> matchLowest = isDictionary ? lowestValid : withinWindow;</td></tr>
<tr class="codeline" data-linenumber="996"><td class="num" id="LN996">996</td><td class="line">    <span class='keyword'>return</span> matchLowest;</td></tr>
<tr class="codeline" data-linenumber="997"><td class="num" id="LN997">997</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="998"><td class="num" id="LN998">998</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="999"><td class="num" id="LN999">999</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1000"><td class="num" id="LN1000">1000</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1001"><td class="num" id="LN1001">1001</td><td class="line"><span class='comment'>/* debug functions */</span></td></tr>
<tr class="codeline" data-linenumber="1002"><td class="num" id="LN1002">1002</td><td class="line"><span class='directive'>#if (<span class='macro'>DEBUGLEVEL<span class='macro_popup'>0</span></span>&gt;=2)</span></td></tr>
<tr class="codeline" data-linenumber="1003"><td class="num" id="LN1003">1003</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1004"><td class="num" id="LN1004">1004</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> <span class='keyword'>double</span> ZSTD_fWeight(U32 rawStat)</td></tr>
<tr class="codeline" data-linenumber="1005"><td class="num" id="LN1005">1005</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="1006"><td class="num" id="LN1006">1006</td><td class="line">    U32 <span class='keyword'>const</span> fp_accuracy = 8;</td></tr>
<tr class="codeline" data-linenumber="1007"><td class="num" id="LN1007">1007</td><td class="line">    U32 <span class='keyword'>const</span> fp_multiplier = (1 &lt;&lt; fp_accuracy);</td></tr>
<tr class="codeline" data-linenumber="1008"><td class="num" id="LN1008">1008</td><td class="line">    U32 <span class='keyword'>const</span> newStat = rawStat + 1;</td></tr>
<tr class="codeline" data-linenumber="1009"><td class="num" id="LN1009">1009</td><td class="line">    U32 <span class='keyword'>const</span> hb = ZSTD_highbit32(newStat);</td></tr>
<tr class="codeline" data-linenumber="1010"><td class="num" id="LN1010">1010</td><td class="line">    U32 <span class='keyword'>const</span> BWeight = hb * fp_multiplier;</td></tr>
<tr class="codeline" data-linenumber="1011"><td class="num" id="LN1011">1011</td><td class="line">    U32 <span class='keyword'>const</span> FWeight = (newStat &lt;&lt; fp_accuracy) &gt;&gt; hb;</td></tr>
<tr class="codeline" data-linenumber="1012"><td class="num" id="LN1012">1012</td><td class="line">    U32 <span class='keyword'>const</span> weight = BWeight + FWeight;</td></tr>
<tr class="codeline" data-linenumber="1013"><td class="num" id="LN1013">1013</td><td class="line">    <span class='macro'>assert(hb + fp_accuracy &lt; 31)<span class='macro_popup'>((void)0)</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1014"><td class="num" id="LN1014">1014</td><td class="line">    <span class='keyword'>return</span> (<span class='keyword'>double</span>)weight / fp_multiplier;</td></tr>
<tr class="codeline" data-linenumber="1015"><td class="num" id="LN1015">1015</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1016"><td class="num" id="LN1016">1016</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1017"><td class="num" id="LN1017">1017</td><td class="line"><span class='comment'>/* display a table content,</span></td></tr>
<tr class="codeline" data-linenumber="1018"><td class="num" id="LN1018">1018</td><td class="line"> <span class='comment'>* listing each element, its frequency, and its predicted bit cost */</span></td></tr>
<tr class="codeline" data-linenumber="1019"><td class="num" id="LN1019">1019</td><td class="line"><span class='macro'>MEM_STATIC<span class='macro_popup'>static __inline __attribute__((unused))</span></span> <span class='keyword'>void</span> ZSTD_debugTable(<span class='keyword'>const</span> U32* table, U32 max)</td></tr>
<tr class="codeline" data-linenumber="1020"><td class="num" id="LN1020">1020</td><td class="line">{</td></tr>
<tr class="codeline" data-linenumber="1021"><td class="num" id="LN1021">1021</td><td class="line">    <span class='keyword'>unsigned</span> u, sum;</td></tr>
<tr class="codeline" data-linenumber="1022"><td class="num" id="LN1022">1022</td><td class="line">    <span class='keyword'>for</span> (u=0, sum=0; u&lt;=max; u++) sum += table[u];</td></tr>
<tr class="codeline" data-linenumber="1023"><td class="num" id="LN1023">1023</td><td class="line">    <span class='macro'>DEBUGLOG(2, <span class='string_literal'>"total nb elts: %u"</span>, sum)<span class='macro_popup'>{}</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1024"><td class="num" id="LN1024">1024</td><td class="line">    <span class='keyword'>for</span> (u=0; u&lt;=max; u++) {</td></tr>
<tr class="codeline" data-linenumber="1025"><td class="num" id="LN1025">1025</td><td class="line">        <span class='macro'>DEBUGLOG(2, <span class='string_literal'>"%2u: %5u  (%.2f)"</span>,<span class='macro_popup'>{}</span></span></td></tr>
<tr class="codeline" data-linenumber="1026"><td class="num" id="LN1026">1026</td><td class="line">                <span class='macro'>u, table[u], ZSTD_fWeight(sum) - ZSTD_fWeight(table[u]) )<span class='macro_popup'>{}</span></span>;</td></tr>
<tr class="codeline" data-linenumber="1027"><td class="num" id="LN1027">1027</td><td class="line">    }</td></tr>
<tr class="codeline" data-linenumber="1028"><td class="num" id="LN1028">1028</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1029"><td class="num" id="LN1029">1029</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1030"><td class="num" id="LN1030">1030</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="1031"><td class="num" id="LN1031">1031</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1032"><td class="num" id="LN1032">1032</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1033"><td class="num" id="LN1033">1033</td><td class="line"><span class='directive'>#if defined (__cplusplus)</span></td></tr>
<tr class="codeline" data-linenumber="1034"><td class="num" id="LN1034">1034</td><td class="line">}</td></tr>
<tr class="codeline" data-linenumber="1035"><td class="num" id="LN1035">1035</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr class="codeline" data-linenumber="1036"><td class="num" id="LN1036">1036</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1037"><td class="num" id="LN1037">1037</td><td class="line"><span class='comment'>/* ===============================================================</span></td></tr>
<tr class="codeline" data-linenumber="1038"><td class="num" id="LN1038">1038</td><td class="line"> <span class='comment'>* Shared internal declarations</span></td></tr>
<tr class="codeline" data-linenumber="1039"><td class="num" id="LN1039">1039</td><td class="line"> <span class='comment'>* These prototypes may be called from sources not in lib/compress</span></td></tr>
<tr class="codeline" data-linenumber="1040"><td class="num" id="LN1040">1040</td><td class="line"> <span class='comment'>* =============================================================== */</span></td></tr>
<tr class="codeline" data-linenumber="1041"><td class="num" id="LN1041">1041</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1042"><td class="num" id="LN1042">1042</td><td class="line"><span class='comment'>/* ZSTD_loadCEntropy() :</span></td></tr>
<tr class="codeline" data-linenumber="1043"><td class="num" id="LN1043">1043</td><td class="line"> <span class='comment'>* dict : must point at beginning of a valid zstd dictionary.</span></td></tr>
<tr class="codeline" data-linenumber="1044"><td class="num" id="LN1044">1044</td><td class="line"> <span class='comment'>* return : size of dictionary header (size of magic number + dict ID + entropy tables)</span></td></tr>
<tr class="codeline" data-linenumber="1045"><td class="num" id="LN1045">1045</td><td class="line"> <span class='comment'>* assumptions : magic number supposed already checked</span></td></tr>
<tr class="codeline" data-linenumber="1046"><td class="num" id="LN1046">1046</td><td class="line"> <span class='comment'>*               and dictSize &gt;= 8 */</span></td></tr>
<tr class="codeline" data-linenumber="1047"><td class="num" id="LN1047">1047</td><td class="line">size_t ZSTD_loadCEntropy(ZSTD_compressedBlockState_t* bs, <span class='keyword'>void</span>* workspace,</td></tr>
<tr class="codeline" data-linenumber="1048"><td class="num" id="LN1048">1048</td><td class="line">                         <span class='keyword'>short</span>* offcodeNCount, <span class='keyword'>unsigned</span>* offcodeMaxValue,</td></tr>
<tr class="codeline" data-linenumber="1049"><td class="num" id="LN1049">1049</td><td class="line">                         <span class='keyword'>const</span> <span class='keyword'>void</span>* <span class='keyword'>const</span> dict, size_t dictSize);</td></tr>
<tr class="codeline" data-linenumber="1050"><td class="num" id="LN1050">1050</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1051"><td class="num" id="LN1051">1051</td><td class="line"><span class='keyword'>void</span> ZSTD_reset_compressedBlockState(ZSTD_compressedBlockState_t* bs);</td></tr>
<tr class="codeline" data-linenumber="1052"><td class="num" id="LN1052">1052</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1053"><td class="num" id="LN1053">1053</td><td class="line"><span class='comment'>/* ==============================================================</span></td></tr>
<tr class="codeline" data-linenumber="1054"><td class="num" id="LN1054">1054</td><td class="line"> <span class='comment'>* Private declarations</span></td></tr>
<tr class="codeline" data-linenumber="1055"><td class="num" id="LN1055">1055</td><td class="line"> <span class='comment'>* These prototypes shall only be called from within lib/compress</span></td></tr>
<tr class="codeline" data-linenumber="1056"><td class="num" id="LN1056">1056</td><td class="line"> <span class='comment'>* ============================================================== */</span></td></tr>
<tr class="codeline" data-linenumber="1057"><td class="num" id="LN1057">1057</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1058"><td class="num" id="LN1058">1058</td><td class="line"><span class='comment'>/* ZSTD_getCParamsFromCCtxParams() :</span></td></tr>
<tr class="codeline" data-linenumber="1059"><td class="num" id="LN1059">1059</td><td class="line"> <span class='comment'>* cParams are built depending on compressionLevel, src size hints,</span></td></tr>
<tr class="codeline" data-linenumber="1060"><td class="num" id="LN1060">1060</td><td class="line"> <span class='comment'>* LDM and manually set compression parameters.</span></td></tr>
<tr class="codeline" data-linenumber="1061"><td class="num" id="LN1061">1061</td><td class="line"> <span class='comment'>* Note: srcSizeHint == 0 means 0!</span></td></tr>
<tr class="codeline" data-linenumber="1062"><td class="num" id="LN1062">1062</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1063"><td class="num" id="LN1063">1063</td><td class="line">ZSTD_compressionParameters ZSTD_getCParamsFromCCtxParams(</td></tr>
<tr class="codeline" data-linenumber="1064"><td class="num" id="LN1064">1064</td><td class="line">        <span class='keyword'>const</span> ZSTD_CCtx_params* CCtxParams, U64 srcSizeHint, size_t dictSize);</td></tr>
<tr class="codeline" data-linenumber="1065"><td class="num" id="LN1065">1065</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1066"><td class="num" id="LN1066">1066</td><td class="line"><span class='comment'>/*! ZSTD_initCStream_internal() :</span></td></tr>
<tr class="codeline" data-linenumber="1067"><td class="num" id="LN1067">1067</td><td class="line"> <span class='comment'>*  Private use only. Init streaming operation.</span></td></tr>
<tr class="codeline" data-linenumber="1068"><td class="num" id="LN1068">1068</td><td class="line"> <span class='comment'>*  expects params to be valid.</span></td></tr>
<tr class="codeline" data-linenumber="1069"><td class="num" id="LN1069">1069</td><td class="line"> <span class='comment'>*  must receive dict, or cdict, or none, but not both.</span></td></tr>
<tr class="codeline" data-linenumber="1070"><td class="num" id="LN1070">1070</td><td class="line"> <span class='comment'>*  @return : 0, or an error code */</span></td></tr>
<tr class="codeline" data-linenumber="1071"><td class="num" id="LN1071">1071</td><td class="line">size_t ZSTD_initCStream_internal(ZSTD_CStream* zcs,</td></tr>
<tr class="codeline" data-linenumber="1072"><td class="num" id="LN1072">1072</td><td class="line">                     <span class='keyword'>const</span> <span class='keyword'>void</span>* dict, size_t dictSize,</td></tr>
<tr class="codeline" data-linenumber="1073"><td class="num" id="LN1073">1073</td><td class="line">                     <span class='keyword'>const</span> ZSTD_CDict* cdict,</td></tr>
<tr class="codeline" data-linenumber="1074"><td class="num" id="LN1074">1074</td><td class="line">                     <span class='keyword'>const</span> ZSTD_CCtx_params* params, <span class='keyword'>unsigned</span> <span class='keyword'>long</span> <span class='keyword'>long</span> pledgedSrcSize);</td></tr>
<tr class="codeline" data-linenumber="1075"><td class="num" id="LN1075">1075</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1076"><td class="num" id="LN1076">1076</td><td class="line"><span class='keyword'>void</span> ZSTD_resetSeqStore(seqStore_t* ssPtr);</td></tr>
<tr class="codeline" data-linenumber="1077"><td class="num" id="LN1077">1077</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1078"><td class="num" id="LN1078">1078</td><td class="line"><span class='comment'>/*! ZSTD_getCParamsFromCDict() :</span></td></tr>
<tr class="codeline" data-linenumber="1079"><td class="num" id="LN1079">1079</td><td class="line"> <span class='comment'>*  as the name implies */</span></td></tr>
<tr class="codeline" data-linenumber="1080"><td class="num" id="LN1080">1080</td><td class="line">ZSTD_compressionParameters ZSTD_getCParamsFromCDict(<span class='keyword'>const</span> ZSTD_CDict* cdict);</td></tr>
<tr class="codeline" data-linenumber="1081"><td class="num" id="LN1081">1081</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1082"><td class="num" id="LN1082">1082</td><td class="line"><span class='comment'>/* ZSTD_compressBegin_advanced_internal() :</span></td></tr>
<tr class="codeline" data-linenumber="1083"><td class="num" id="LN1083">1083</td><td class="line"> <span class='comment'>* Private use only. To be called from zstdmt_compress.c. */</span></td></tr>
<tr class="codeline" data-linenumber="1084"><td class="num" id="LN1084">1084</td><td class="line">size_t ZSTD_compressBegin_advanced_internal(ZSTD_CCtx* cctx,</td></tr>
<tr class="codeline" data-linenumber="1085"><td class="num" id="LN1085">1085</td><td class="line">                                    <span class='keyword'>const</span> <span class='keyword'>void</span>* dict, size_t dictSize,</td></tr>
<tr class="codeline" data-linenumber="1086"><td class="num" id="LN1086">1086</td><td class="line">                                    ZSTD_dictContentType_e dictContentType,</td></tr>
<tr class="codeline" data-linenumber="1087"><td class="num" id="LN1087">1087</td><td class="line">                                    ZSTD_dictTableLoadMethod_e dtlm,</td></tr>
<tr class="codeline" data-linenumber="1088"><td class="num" id="LN1088">1088</td><td class="line">                                    <span class='keyword'>const</span> ZSTD_CDict* cdict,</td></tr>
<tr class="codeline" data-linenumber="1089"><td class="num" id="LN1089">1089</td><td class="line">                                    <span class='keyword'>const</span> ZSTD_CCtx_params* params,</td></tr>
<tr class="codeline" data-linenumber="1090"><td class="num" id="LN1090">1090</td><td class="line">                                    <span class='keyword'>unsigned</span> <span class='keyword'>long</span> <span class='keyword'>long</span> pledgedSrcSize);</td></tr>
<tr class="codeline" data-linenumber="1091"><td class="num" id="LN1091">1091</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1092"><td class="num" id="LN1092">1092</td><td class="line"><span class='comment'>/* ZSTD_compress_advanced_internal() :</span></td></tr>
<tr class="codeline" data-linenumber="1093"><td class="num" id="LN1093">1093</td><td class="line"> <span class='comment'>* Private use only. To be called from zstdmt_compress.c. */</span></td></tr>
<tr class="codeline" data-linenumber="1094"><td class="num" id="LN1094">1094</td><td class="line">size_t ZSTD_compress_advanced_internal(ZSTD_CCtx* cctx,</td></tr>
<tr class="codeline" data-linenumber="1095"><td class="num" id="LN1095">1095</td><td class="line">                                       <span class='keyword'>void</span>* dst, size_t dstCapacity,</td></tr>
<tr class="codeline" data-linenumber="1096"><td class="num" id="LN1096">1096</td><td class="line">                                 <span class='keyword'>const</span> <span class='keyword'>void</span>* src, size_t srcSize,</td></tr>
<tr class="codeline" data-linenumber="1097"><td class="num" id="LN1097">1097</td><td class="line">                                 <span class='keyword'>const</span> <span class='keyword'>void</span>* dict,size_t dictSize,</td></tr>
<tr class="codeline" data-linenumber="1098"><td class="num" id="LN1098">1098</td><td class="line">                                 <span class='keyword'>const</span> ZSTD_CCtx_params* params);</td></tr>
<tr class="codeline" data-linenumber="1099"><td class="num" id="LN1099">1099</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1100"><td class="num" id="LN1100">1100</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1101"><td class="num" id="LN1101">1101</td><td class="line"><span class='comment'>/* ZSTD_writeLastEmptyBlock() :</span></td></tr>
<tr class="codeline" data-linenumber="1102"><td class="num" id="LN1102">1102</td><td class="line"> <span class='comment'>* output an empty Block with end-of-frame mark to complete a frame</span></td></tr>
<tr class="codeline" data-linenumber="1103"><td class="num" id="LN1103">1103</td><td class="line"> <span class='comment'>* @return : size of data written into `dst` (== ZSTD_blockHeaderSize (defined in zstd_internal.h))</span></td></tr>
<tr class="codeline" data-linenumber="1104"><td class="num" id="LN1104">1104</td><td class="line"> <span class='comment'>*           or an error code if `dstCapacity` is too small (&lt;ZSTD_blockHeaderSize)</span></td></tr>
<tr class="codeline" data-linenumber="1105"><td class="num" id="LN1105">1105</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1106"><td class="num" id="LN1106">1106</td><td class="line">size_t ZSTD_writeLastEmptyBlock(<span class='keyword'>void</span>* dst, size_t dstCapacity);</td></tr>
<tr class="codeline" data-linenumber="1107"><td class="num" id="LN1107">1107</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1108"><td class="num" id="LN1108">1108</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1109"><td class="num" id="LN1109">1109</td><td class="line"><span class='comment'>/* ZSTD_referenceExternalSequences() :</span></td></tr>
<tr class="codeline" data-linenumber="1110"><td class="num" id="LN1110">1110</td><td class="line"> <span class='comment'>* Must be called before starting a compression operation.</span></td></tr>
<tr class="codeline" data-linenumber="1111"><td class="num" id="LN1111">1111</td><td class="line"> <span class='comment'>* seqs must parse a prefix of the source.</span></td></tr>
<tr class="codeline" data-linenumber="1112"><td class="num" id="LN1112">1112</td><td class="line"> <span class='comment'>* This cannot be used when long range matching is enabled.</span></td></tr>
<tr class="codeline" data-linenumber="1113"><td class="num" id="LN1113">1113</td><td class="line"> <span class='comment'>* Zstd will use these sequences, and pass the literals to a secondary block</span></td></tr>
<tr class="codeline" data-linenumber="1114"><td class="num" id="LN1114">1114</td><td class="line"> <span class='comment'>* compressor.</span></td></tr>
<tr class="codeline" data-linenumber="1115"><td class="num" id="LN1115">1115</td><td class="line"> <span class='comment'>* @return : An error code on failure.</span></td></tr>
<tr class="codeline" data-linenumber="1116"><td class="num" id="LN1116">1116</td><td class="line"> <span class='comment'>* NOTE: seqs are not verified! Invalid sequences can cause out-of-bounds memory</span></td></tr>
<tr class="codeline" data-linenumber="1117"><td class="num" id="LN1117">1117</td><td class="line"> <span class='comment'>* access and data corruption.</span></td></tr>
<tr class="codeline" data-linenumber="1118"><td class="num" id="LN1118">1118</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr class="codeline" data-linenumber="1119"><td class="num" id="LN1119">1119</td><td class="line">size_t ZSTD_referenceExternalSequences(ZSTD_CCtx* cctx, rawSeq* seq, size_t nbSeq);</td></tr>
<tr class="codeline" data-linenumber="1120"><td class="num" id="LN1120">1120</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1121"><td class="num" id="LN1121">1121</td><td class="line"><span class='comment'>/** ZSTD_cycleLog() :</span></td></tr>
<tr class="codeline" data-linenumber="1122"><td class="num" id="LN1122">1122</td><td class="line"> <span class='comment'>*  condition for correct operation : hashLog &gt; 1 */</span></td></tr>
<tr class="codeline" data-linenumber="1123"><td class="num" id="LN1123">1123</td><td class="line">U32 ZSTD_cycleLog(U32 hashLog, ZSTD_strategy strat);</td></tr>
<tr class="codeline" data-linenumber="1124"><td class="num" id="LN1124">1124</td><td class="line"> </td></tr>
<tr class="codeline" data-linenumber="1125"><td class="num" id="LN1125">1125</td><td class="line"><span class='directive'>#endif /* ZSTD_COMPRESS_H */</span></td></tr>
</table></body></html>
